{
    "version": "https://jsonfeed.org/version/1",
    "title": "",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2024/05/20/AI/week1/",
            "url": "http://example.com/2024/05/20/AI/week1/",
            "title": "Week1",
            "date_published": "2024-05-19T16:00:00.000Z",
            "content_html": "<blockquote>\n<p>2025-2026春夏人工智能课程笔记</p>\n</blockquote>\n<h1 id=\"Ch1-绪论\"><a href=\"#Ch1-绪论\" class=\"headerlink\" title=\"Ch1 绪论\"></a>Ch1 绪论</h1><ul>\n<li>人工智能求解：<ul>\n<li>以符号主义为核心的逻辑推理：将概念（如命题等）符号化，从若干判断（前提）出发得到新判断（结论）</li>\n<li>以问题求解为核心的探寻搜索:探寻搜索依据已有信息来寻找满足约束条件的待求解问题的答案</li>\n<li>以数据驱动为核心的机器学习:从数据中发现数据所承载语义（如概念）的内在模式</li>\n<li>以行为主义为核心的强化学习:根据环境所提供的奖罚反馈来学习所处状态可施加的最佳行动，在“探索（未知空间）-利用（已有经验）（exploration vs. exploitation）”之间寻找平衡，完成某个序列化任务，具备自我学习能力</li>\n<li>以博弈对抗为核心的群体智能:从“数据拟合”优化解的求取向“均衡解”的求取迈进</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "人工智能"
            ]
        },
        {
            "id": "http://example.com/2024/05/20/AI/week2/",
            "url": "http://example.com/2024/05/20/AI/week2/",
            "title": "Week2",
            "date_published": "2024-05-19T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch2-知识表达与推理\"><a href=\"#Ch2-知识表达与推理\" class=\"headerlink\" title=\"Ch2 知识表达与推理\"></a>Ch2 知识表达与推理</h1><h2 id=\"命题逻辑\"><a href=\"#命题逻辑\" class=\"headerlink\" title=\"命题逻辑\"></a>命题逻辑</h2><p><img data-src=\"/img1.png\"><br>真值表：<br><img data-src=\"/img2.png\"></p>\n<blockquote>\n<p>“条件”命题联结词中前提为假时命题结论永远为真，bi-conditional只有两个都是true或者都是false才是true<br>逻辑等价：给定命题p和命题q，如果&#x3D;&#x3D;p和q在所有情况下都具有同样真假结果&#x3D;&#x3D;，那么p和q在逻辑上等价，一般用 $\\equiv$ 来表示，即p $\\equiv$ q。<br>判断逻辑等价：画真值表<br>逻辑等价式：<br><img data-src=\"/img3.jpg\"><br><img data-src=\"/img4.png\"></p>\n</blockquote>\n<ul>\n<li>normal form<ul>\n<li>有限个简单合取式构成的析取式称为析取(or)范式</li>\n<li>由有限个简单析取式构成的合取式称为合取(and)范式</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"谓词逻辑\"><a href=\"#谓词逻辑\" class=\"headerlink\" title=\"谓词逻辑\"></a>谓词逻辑</h2><ul>\n<li>全称量词与存在量词</li>\n<li>约束变元、自由变元<br>:::info<br>在约束变元相同的情况下，量词的运算满足分配律：全称量词对析取没有分配律、存在量词对合取没有分配律<br>:::<br>$$\\begin{aligned}<br>(\\forall x)(A(x) \\lor B(x)) \\equiv (\\forall x)A(x) \\lor (\\forall x)B(x) 不成立<br>\\end{aligned}$$</li>\n</ul>\n<p>$$\\begin{aligned}<br>(\\forall x)(A(x) \\land B(x)) \\equiv (\\forall x)A(x) \\land (\\forall x)B(x) 成立<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>(\\exists x)(A(x) \\lor B(x)) \\equiv (\\exists x)A(x) \\lor (\\exists x)B(x) 成立<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>(\\exists x)(A(x) \\land B(x)) \\equiv (\\exists x)A(x) \\land (\\exists x)B(x) 不成立<br>\\end{aligned}$$<br>:::info<br>当公式中存在多个量词时，若多个量词都是全称量词或者都是存在量词，则量词的位置可以互换；若多个量词中既有全称量词又有存在量词，则量词的位置不可以随意互换<br>:::<br>$$\\begin{aligned}<br>(\\forall x)(\\forall y)A(x, y) \\equiv (\\forall y)(\\forall x)A(x, y)<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>(\\exists x)(\\exists y)A(x, y) \\equiv (\\exists y)(\\exists x)A(x, y)<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>(\\forall x)(\\forall y)A(x, y) \\equiv (\\exists y)(\\forall x)A(x, y)<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>(\\forall x)(\\forall y)A(x, y) \\equiv (\\exists x)(\\forall y)A(x, y)<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>(\\exists y)(\\forall x)A(x, y) \\equiv (\\forall x)(\\exists y)A(x, y)<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>(\\exists x)(\\forall y)A(x, y) \\equiv (\\forall y)(\\exists x)A(x, y)<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>(\\forall x)(\\exists y)A(x, y) \\equiv (\\exists y)(\\exists x)A(x, y)<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>(\\forall y)(\\exists x)A(x, y) \\equiv (\\exists x)(\\exists y)A(x, y)<br>\\end{aligned}$$</p>\n",
            "tags": [
                "人工智能"
            ]
        },
        {
            "id": "http://example.com/2024/05/14/computer-science/computer-organization/ch2/",
            "url": "http://example.com/2024/05/14/computer-science/computer-organization/ch2/",
            "title": "Ch2",
            "date_published": "2024-05-13T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch2-数据的表示和运算\"><a href=\"#Ch2-数据的表示和运算\" class=\"headerlink\" title=\"Ch2 数据的表示和运算\"></a>Ch2 数据的表示和运算</h1><h2 id=\"2-1-进位计数制及其相互转换\"><a href=\"#2-1-进位计数制及其相互转换\" class=\"headerlink\" title=\"2.1 进位计数制及其相互转换\"></a>2.1 进位计数制及其相互转换</h2><h3 id=\"2-1-1\"><a href=\"#2-1-1\" class=\"headerlink\" title=\"2.1.1\"></a>2.1.1</h3><ul>\n<li>十进制二进制八进制十六进制转换<ul>\n<li>略</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-1-2-定点数的编码表示\"><a href=\"#2-1-2-定点数的编码表示\" class=\"headerlink\" title=\"2.1.2 定点数的编码表示\"></a>2.1.2 定点数的编码表示</h3><ul>\n<li>定点百世一般表示定点小数和定点整数，小数是符号位.xxx，整数是符号位xxxx.0</li>\n<li><blockquote>\n<p>感觉不是什么重要的东西，浮点数表示比较重要</p>\n</blockquote>\n</li>\n<li>原码，反码，补码<ul>\n<li>正数的原码反码补码相同</li>\n<li>原码表示的范围为 $-2^n+1 ~ 2^n-1$</li>\n<li>补码表示的范围为 $-2^n ~ 2^n-1$</li>\n<li>负数的原码是1+绝对值，反码是1+绝对值取反，补码是反码+1</li>\n</ul>\n</li>\n<li>移码：用来表示浮点数的阶码，只能表示整数<ul>\n<li>一般用移码表示浮点数的阶码，用补码表示定点整数<br>$$ [x]_移 &#x3D; 2^n + x $$<br>移码就是在真值x前面加一个offset，比如取offset为2^7，就在补码的第8位加上1</li>\n<li>比如正数10101，移码是10010101，负数-10101的补码是11101011，所以移码是01101011</li>\n<li>移码的作用是&#x3D;&#x3D;保持数据原有的大小顺序&#x3D;&#x3D;，移码大真值大，移码小真值小，所以可以直观地进行比较<br>:::warning<br>相同位数的补码和移码表示具有相同的数据表示范围，区别只是表示方法不同<br>补码与移码只差一个符号位。同一个数的补码和移码表示，其数值部分相同，而符号位相反。<br>:::</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-1-3-整数表示\"><a href=\"#2-1-3-整数表示\" class=\"headerlink\" title=\"2.1.3 整数表示\"></a>2.1.3 整数表示</h3><p>略</p>\n<h3 id=\"2-1-4\"><a href=\"#2-1-4\" class=\"headerlink\" title=\"2.1.4\"></a>2.1.4</h3><p>c中的强制转换<br>short转成unsigned short直接把二进制看成unsigned short，比如-1变成65535<br>int变成short直接截断<br>小字长转大字长不会改变值，如果是unsigned就会在前面补0，如果是有符号数就在前面补符号位<br>short转unsigned int，先对short进行符号扩展到int，再把它当做unsigned int，如果是unsigned short转int，就进行零扩展再看成int……</p>\n<p>一些题目<br>+++info example<br>;;;id3 t1<br>若$[x]_补 &#x3D; 1,x_1x_2x_3x_4x_5x_6$,其中$x_i$取0或1，若要x&gt;-32，应当满足：<br>C. $x_1$为1，$x_2…x_6$中至少有一位为1<br>1100000是-32，要比-32大所以绝对值要小，所以数值部分要大，所以$x_1$必须是1,后面随便有个1就行<br>;;;<br>;;;id3 t2<br>设x为正数，$[x]_补 &#x3D; 1,x_1x_2x_3x_4x_5$,若要x&lt;-16，应当满足：<br>C. $x_1$必须为0，其它任意<br>110000是-16，要小于-16所以数值部分绝对值要小，所以只要$x_1$为0就比-16小<br>;;;<br>;;;id3 t3<br>一个8位的二进制整数由2个“0”和6个“1”组成，采用补码或者移码表示，则<br>若采用移码表示，偏置值为127，则此整数最小为-64（偏置为127需要在补码加上1111111，&#x3D;&#x3D;要让数值最小，应该把1放低位&#x3D;&#x3D;，所以移码是00111111，补码是10111111是-64）</p>\n<blockquote>\n<p>：前面说过，移码大真值大，移码小真值小，所以要让数值最小把1放低位就行了</p>\n</blockquote>\n<p>若采用补码表示，则此整数最小为-97（10011111&#x3D;-97）<br>;;;<br>;;;id3 比较大小的方法<br>对于无符号数，数值大的数就大<br>对于有符号数的原码和反码比较大小：先看正负然后看数值，反码数值转成原码再比<br>对于补码比较大小，正数正常比较，负数数值部分越小，绝对值越大（前面1更多的数的绝对值越小，所以11111111是-1）<br>;;;<br>+++</p>\n<h2 id=\"2-2-运算方法和运算电路\"><a href=\"#2-2-运算方法和运算电路\" class=\"headerlink\" title=\"2.2 运算方法和运算电路\"></a>2.2 运算方法和运算电路</h2><h3 id=\"2-2-1-基本运算部件\"><a href=\"#2-2-1-基本运算部件\" class=\"headerlink\" title=\"2.2.1 基本运算部件\"></a>2.2.1 基本运算部件</h3><h4 id=\"一位全加器\"><a href=\"#一位全加器\" class=\"headerlink\" title=\"一位全加器\"></a>一位全加器</h4><ul>\n<li>用真值表实现的：进位C，和S<table>\n<thead>\n<tr>\n<th align=\"center\">A</th>\n<th align=\"center\">B</th>\n<th align=\"center\">Cin</th>\n<th align=\"center\">Cout</th>\n<th align=\"center\">S</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n</tr>\n</tbody></table>\n<ul>\n<li>可以用卡诺图或者直接理解(王道不写还好我本来就会，差点忘了。。。)<br><img data-src=\"/img2.jpg\"><br>$$<br>\\begin{aligned}<br>S &amp;&#x3D; \\overline{A} , \\overline{B} , C_i + \\overline{A} , B , \\overline{C_i} + A , \\overline{B} , \\overline{C_i} + A , B , C_i \\<br>&amp;&#x3D; A \\oplus B \\oplus C_i<br>\\end{aligned}<br>$$<br>$$<br>\\begin{aligned}<br>Co &amp;&#x3D; AB + A \\overline{B} C_i + \\overline{A} B C_i \\<br>&amp;&#x3D; AB + (A \\oplus B) \\cdot C_i<br>\\end{aligned}<br>$$</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"串行进位加法器\"><a href=\"#串行进位加法器\" class=\"headerlink\" title=\"串行进位加法器\"></a>串行进位加法器</h4><ul>\n<li>把n个一位全加器连起来<br><img data-src=\"/img3.png\"><br>Carry Propagation &amp; Delay</li>\n</ul>\n<h4 id=\"并行进位加法器\"><a href=\"#并行进位加法器\" class=\"headerlink\" title=\"并行进位加法器\"></a>并行进位加法器</h4><p>对Cin进行look ahead</p>\n<p><img data-src=\"/img4.png\"></p>\n<p>前面提到：<br>$$<br>\\begin{aligned}<br>Co &amp;&#x3D; AB + A \\overline{B} C_i + \\overline{A} B C_i \\<br>   &amp;&#x3D; AB + (A \\oplus B) \\cdot C_i<br>\\end{aligned}<br>$$<br>下一位的Cin等于上一位的Cout，所以可以进行look ahead，这里让<br>$$<br>\\begin{aligned}<br>G_i &amp;&#x3D; A_iB_i<br>\\end{aligned}<br>$$<br>$$<br>\\begin{aligned}<br>P_i &amp;&#x3D; A_i \\oplus B_i<br>\\end{aligned}<br>$$<br>所以<br>$$<br>\\begin{aligned}<br>C_{i+1} &amp;&#x3D; G_i + P_iC_i<br>\\end{aligned}<br>$$<br>$$<br>\\begin{aligned}<br>S_i &amp;&#x3D; P_i \\oplus C_i<br>\\end{aligned}<br>$$<br>就能得到超前进位的效果</p>\n<h4 id=\"带标志加法器\"><a href=\"#带标志加法器\" class=\"headerlink\" title=\"带标志加法器\"></a>带标志加法器</h4><p><img data-src=\"/img5.jpg\"></p>\n<ul>\n<li>溢出标志 $OF &amp;&#x3D; C_n  \\oplus C_{n-1}$，只能判断有符号数是否溢出<br>-两个正数加起来变成负数或者两个负数加起来变成正数，就会溢出<table>\n<thead>\n<tr>\n<th align=\"center\">A</th>\n<th align=\"center\">B</th>\n<th align=\"center\">$C_{n-1}$</th>\n<th align=\"center\">F</th>\n<th align=\"center\">$C_n$</th>\n<th align=\"center\">OF</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<blockquote>\n<p>第二行A&#x3D;0, B&#x3D;0, F&#x3D;1，正+正&#x3D;负<br>  第七行A&#x3D;0, B&#x3D;1, F&#x3D;0，负+负&#x3D;正<br>  所以OF&#x3D;1，表示有溢出<br>  观察发现$OF &#x3D; C_{n-1}  \\oplus C_n$</p>\n</blockquote>\n<ul>\n<li>符号标志 $$SF &#x3D; F_{n-1}$$，输出的最高位决定有符号数的正负</li>\n<li>进位&#x2F;借位标志：用于判断无符号数的加减运算是否溢出<ul>\n<li>$CF &#x3D; Cin \\oplus Cout$</li>\n<li>此处的Cin和Cout表示最开始的输入和最后的输出，还没理解</li>\n</ul>\n</li>\n<li>零标志 当且仅当所有F&#x3D;0时为1，否则为0（把所有F作或非）</li>\n</ul>\n<h4 id=\"ALU\"><a href=\"#ALU\" class=\"headerlink\" title=\"ALU\"></a>ALU</h4><p>略</p>\n<h3 id=\"2-2-2-定点数的移位运算\"><a href=\"#2-2-2-定点数的移位运算\" class=\"headerlink\" title=\"2.2.2 定点数的移位运算\"></a>2.2.2 定点数的移位运算</h3><ul>\n<li>左移一位*2，右移一位&#x2F;2</li>\n<li>逻辑移位：移完直接补0</li>\n<li>算数移位：右移时，补符号位，左移如果高位和符号位不同，则发生overflow</li>\n</ul>\n<h3 id=\"定点数的加减运算\"><a href=\"#定点数的加减运算\" class=\"headerlink\" title=\"定点数的加减运算\"></a>定点数的加减运算</h3><p>补码相加减，略<br>主要是溢出判断：符号相同的数相加或者符号相异的数相减会发生溢出</p>\n<ul>\n<li>一位符号位（参考前面OF）</li>\n<li>双符号位（模4补码）<ul>\n<li>符号位左边那一位表示正确的符号，0为正，1为负；右边那一位如果和左边的相同，如 “00”表示正且无溢出，”11”表示负且无溢出。如果右边那一位与左边那一位不一样，则表示有溢出</li>\n<li>溢出逻辑判断：若V为0则无溢出，V为1则溢出<br>$$<br>V &#x3D; S_{s1} \\oplus S_{s2}<br>$$<br>例子看这篇写的挺清楚：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1bl9ib3lfYm95X3N1bi9hcnRpY2xlL2RldGFpbHMvODc5MTcwMjA=\">https://blog.csdn.net/sun_boy_boy_sun/article/details/87917020</span><br>总之两位不同则有溢出</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"定点数的乘除运算\"><a href=\"#定点数的乘除运算\" class=\"headerlink\" title=\"定点数的乘除运算\"></a>定点数的乘除运算</h3><p>略，列竖式即可</p>\n",
            "tags": [
                "数据的表示与运算"
            ]
        },
        {
            "id": "http://example.com/2024/05/13/computer-science/computer-organization/ch1/",
            "url": "http://example.com/2024/05/13/computer-science/computer-organization/ch1/",
            "title": "Ch1",
            "date_published": "2024-05-12T16:00:00.000Z",
            "content_html": "<blockquote>\n<p>王道计组考研复习笔记<br>怕学完忘了写个笔记保留一下顺便加深印象x<br>王道书写得好烂、、</p>\n</blockquote>\n<h1 id=\"Ch1-计算机系统概述\"><a href=\"#Ch1-计算机系统概述\" class=\"headerlink\" title=\"Ch1 计算机系统概述\"></a>Ch1 计算机系统概述</h1><h2 id=\"1-1-计算机发展历程\"><a href=\"#1-1-计算机发展历程\" class=\"headerlink\" title=\"1.1 计算机发展历程\"></a>1.1 计算机发展历程</h2><ul>\n<li>四代计算机：电子管-&gt;晶体管-&gt;集成电路-&gt;超大规模集成电路</li>\n<li>摩尔定律：集成电路上可以容纳的晶体管数目在大约每经过18个月到24个月便会增加一倍</li>\n</ul>\n<h2 id=\"1-2-计算机系统层次结构\"><a href=\"#1-2-计算机系统层次结构\" class=\"headerlink\" title=\"1.2 计算机系统层次结构\"></a>1.2 计算机系统层次结构</h2><ul>\n<li>计算机系统：硬件+软件</li>\n<li>对于某一功能，既能用软件实现又能用硬件实现，称为软、硬件在逻辑功能上是等价的</li>\n</ul>\n<h3 id=\"1-2-2-硬件\"><a href=\"#1-2-2-硬件\" class=\"headerlink\" title=\"1.2.2 硬件\"></a>1.2.2 硬件</h3><ul>\n<li>冯·诺依曼机的特点：<ul>\n<li>采用“存储程序”的工作方式</li>\n<li>冯·诺依曼计算机由五大部件组成：运算器、控制器、存储器、输入设备和输出设备</li>\n<li>指令和数据以同等地位存储在存储器中</li>\n<li>指令和数据均用二进制代码表示</li>\n<li>指令由操作码和地址码组成</li>\n<li><img data-src=\"/img1.png\"></li>\n</ul>\n</li>\n<li>计算机的功能部件：<ul>\n<li>输入设备</li>\n<li>输出设备</li>\n<li>存储器：主存+外存<ul>\n<li>CPU能直接访问的是主存</li>\n<li><img data-src=\"/img2.jpg\"></li>\n<li>MAR位10位则最多有$2^{10}$个存储单元</li>\n<li>在现代计算机中MAR和MDR存在CPU中</li>\n</ul>\n</li>\n<li>运算器：进行算术运算和逻辑运算<ul>\n<li>核心是ALU：通用寄存器有&#x3D;&#x3D;累加器(ACC)，乘商寄存器(MQ)，操作数寄存器(X)&#x3D;&#x3D;，变址寄存器(IX)，基址寄存器(BR)等，前三个必备</li>\n<li>程序状态寄存器(PSW)</li>\n<li><img data-src=\"/img3.jpg\"></li>\n</ul>\n</li>\n<li>控制器：由PC, IR和control unit组成<ul>\n<li>: RISCV控制器</li>\n<li><img data-src=\"/img4.png\"></li>\n</ul>\n</li>\n<li>CPU由运算器、控制器和cache组成</li>\n<li>总线有地址总线、数据总线、控制总线</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-2-3-软件\"><a href=\"#1-2-3-软件\" class=\"headerlink\" title=\"1.2.3 软件\"></a>1.2.3 软件</h3><ul>\n<li>组成：系统软件(OS, DBMS, 编译器, …)+应用软件</li>\n<li>语言：汇编语言、机器语言、高级语言<ul>\n<li>汇编器：把汇编语言翻译成机器语言</li>\n<li>编译器：把高级语言翻译成汇编语言或机器语言</li>\n<li>解释器：把高级语言翻译成&#x3D;&#x3D;机器语言&#x3D;&#x3D;(比如python)<br>  +++info example<br>  ;;;id3 题目<br>  :chestnut:<br>  将高级语言源程序转换为机器级目标代码文件的程序是 []。<br>  A. 汇编程序<br>  B. 链接程序<br>  C. 编译程序<br>  D. 解释程序<br>  ;;;<br>  ;;;id3 答案<br>  C. 编译程序<br>  因为解释程序不生成目标代码，编译器可以把高级语言翻译成汇编语言或者直接翻译成机器语言<br>  ;;;<br>  +++</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-2-4-计算机系统的层次结构\"><a href=\"#1-2-4-计算机系统的层次结构\" class=\"headerlink\" title=\"1.2.4 计算机系统的层次结构\"></a>1.2.4 计算机系统的层次结构</h3><ul>\n<li>看看就好</li>\n<li><img data-src=\"/img5.png\"></li>\n</ul>\n<h3 id=\"1-2-5-计算机系统的工作原理\"><a href=\"#1-2-5-计算机系统的工作原理\" class=\"headerlink\" title=\"1.2.5 计算机系统的工作原理\"></a>1.2.5 计算机系统的工作原理</h3><ul>\n<li>程序执行前，需要把所含的指令和数据一起放入主存中</li>\n<li>五个阶段：IF-ID-EX-MEM-WB</li>\n<li>c程序怎么变成可执行文件的：直接看图<ul>\n<li><img data-src=\"/img6.png\"></li>\n<li>汇编器把指令打包成可重定位目标代码文件：使用相对地址和符号引用来表示各个代码段之间的关系（代码段、数据段、符号表、重定位表…）使得代码或数据能在内存中任意位置加载或运行</li>\n</ul>\n</li>\n<li>指令执行过程：后面几章会具体讲</li>\n</ul>\n<h2 id=\"1-3-计算机的性能指标\"><a href=\"#1-3-计算机的性能指标\" class=\"headerlink\" title=\"1.3 计算机的性能指标\"></a>1.3 计算机的性能指标</h2><h3 id=\"1-3-1-主要性能指标\"><a href=\"#1-3-1-主要性能指标\" class=\"headerlink\" title=\"1.3.1 主要性能指标\"></a>1.3.1 主要性能指标</h3><ul>\n<li>字长：一次整数运算所能处理的二进制数据的位数<br> :::info<br> 机器字长、指令字长和存储字长<br> :::</li>\n<li>带宽<code>bandwidth</code>：总线一次能并行传送信息的位数</li>\n<li>主存容量</li>\n<li>运算速度<ul>\n<li>吞吐量<code>throughput</code>：一次输入数据所对应的输出数据个数</li>\n<li>响应时间<code>Response (Execution) time</code></li>\n<li>主频</li>\n<li>clock cycle time( &#x3D; 1&#x2F;CPU frequency)</li>\n<li>MIPS: million instructions per second</li>\n<li>FLOPS: floating-point operations per second<blockquote>\n<p>CPI: clock cycles per instruction(IPC: CPI的倒数)</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<p>$$ \\begin{aligned}<br>    \\text{CPU execution time} &amp;&#x3D; \\text{CPU clock cycles} \\times \\text{Clock cycle time} \\<br>    &amp;&#x3D; \\frac{\\text{CPU clock cycles}}{\\text{Clock rate}}<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>    \\text{CPU clock cycles} &amp;&#x3D; \\text{Instructions count} \\times \\text{Average cycles per instruction}<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>    \\text{CPU execution time} &amp;&#x3D; \\text{CPU clock cycles} \\times \\text{Clock cycle time} \\<br>    &amp;&#x3D; \\frac{\\text{CPU clock cycles}}{\\text{Clock rate}}<br>\\end{aligned} $$</p>\n<p>$$ \\begin{aligned}<br>     \\text{performance} &amp;&#x3D; \\frac{1}{\\text{CPU execution time}}<br>\\end{aligned}$$</p>\n<p>“Processor X is n times fast than Y” is<br>$$ \\begin{aligned}<br>    \\text{n} &amp;&#x3D; \\frac{\\text{CPU execution time of Y}}{\\text{CPU execution time of X}}<br>\\end{aligned}$$</p>\n<p>IPS: instructions per second<br>$$ \\begin{aligned}<br>    \\text{IPS} &amp;&#x3D; \\frac{\\text{CPU frequency}}{\\text{CPI}}<br>        &amp;&#x3D; \\frac{1}{\\text{CPU clock cycles} \\times \\text{CPU execution time}}<br>\\end{aligned}$$</p>\n<ul>\n<li>其他公式，，，用到再说吧</li>\n<li>兼容：软件或硬件的通用性</li>\n</ul>\n<blockquote>\n<p>在用于科学计算的计算机中，标志系统性能最有用的参数是浮点数运算相关的</p>\n<ul>\n<li>MFLOPS 10^6</li>\n<li>GFLOPS 10^9</li>\n<li>TFLOPS 10^12</li>\n<li>PFLOPS 10^15</li>\n<li>EFLOPS 10^18</li>\n<li>ZFLOPS 10^21</li>\n</ul>\n</blockquote>\n",
            "tags": [
                "计算机组成"
            ]
        },
        {
            "id": "http://example.com/2024/05/13/computer-science/computer-network/ch1/",
            "url": "http://example.com/2024/05/13/computer-science/computer-network/ch1/",
            "title": "Ch1",
            "date_published": "2024-05-12T16:00:00.000Z",
            "content_html": "",
            "tags": [
                "计算机网络"
            ]
        },
        {
            "id": "http://example.com/2024/03/29/computer-science/compile-principles/ch4/",
            "url": "http://example.com/2024/03/29/computer-science/compile-principles/ch4/",
            "title": "Ch4",
            "date_published": "2024-03-28T16:00:00.000Z",
            "content_html": "",
            "tags": [
                "抽象语法"
            ]
        },
        {
            "id": "http://example.com/2024/03/23/computer-science/compile-principles/ch3/",
            "url": "http://example.com/2024/03/23/computer-science/compile-principles/ch3/",
            "title": "Ch3",
            "date_published": "2024-03-22T16:00:00.000Z",
            "content_html": "<h1 id=\"语法分析\"><a href=\"#语法分析\" class=\"headerlink\" title=\"语法分析\"></a>语法分析</h1><h2 id=\"CFG\"><a href=\"#CFG\" class=\"headerlink\" title=\"CFG\"></a>CFG</h2><p>见计算理论<br>Parse tree</p>\n<h3 id=\"Ambiguous-grammars\"><a href=\"#Ambiguous-grammars\" class=\"headerlink\" title=\"Ambiguous grammars\"></a>Ambiguous grammars</h3><h2 id><a href=\"#\" class=\"headerlink\" title></a></h2>",
            "tags": [
                "语法分析"
            ]
        },
        {
            "id": "http://example.com/2024/03/22/computer-science/compile-principles/ch2/",
            "url": "http://example.com/2024/03/22/computer-science/compile-principles/ch2/",
            "title": "Ch2",
            "date_published": "2024-03-21T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch2-词法分析\"><a href=\"#Ch2-词法分析\" class=\"headerlink\" title=\"Ch2 词法分析\"></a>Ch2 词法分析</h1><blockquote>\n<p>把input分解成一个个token</p>\n</blockquote>\n<h2 id=\"Regular-Expression\"><a href=\"#Regular-Expression\" class=\"headerlink\" title=\"Regular Expression\"></a>Regular Expression</h2><ul>\n<li>Language: a set of strings</li>\n<li>String: a finite sequence of characters<blockquote>\n<p>Regular Experssion Notations:<br><img data-src=\"/image-1.png\"></p>\n</blockquote>\n</li>\n</ul>\n<p>:::info<br>DFA, NFA相关 见计算理论<br>:::</p>\n<h2 id=\"RE转NFA\"><a href=\"#RE转NFA\" class=\"headerlink\" title=\"RE转NFA\"></a>RE转NFA</h2><p>:::info 方法：</p>\n<ol>\n<li>画出初始态和终态</li>\n<li>分裂规则：<br><img data-src=\"/image-2.jpg\"><br>:::</li>\n</ol>\n<h2 id=\"NFA转DFA\"><a href=\"#NFA转DFA\" class=\"headerlink\" title=\"NFA转DFA\"></a>NFA转DFA</h2><p>从初始状态的闭包开始，每次根据\\epsilon和当前状态的闭包，得到下一个状态的闭包，直到得到终态的闭包。</p>\n<p>+++info example<br>;;;id3 题目<br>:chestnut:<br>把这个NFA转成等价的DFA<br><img data-src=\"/image-3.png\"><br>;;;<br>;;;id3 答案<br>初态的闭包是1、2、6，1、2、6经过a可以转移到3、7，因为有\\epsilon转移，所以3、7的闭包是3、4、7、8，同理3、4、7、8经过b可以到5、8，由于8是终态，把所有包含8的圆圈画成终态的环。<br><img data-src=\"/image-4.png\"><br>;;;<br>+++</p>\n<h2 id=\"最小化DFA\"><a href=\"#最小化DFA\" class=\"headerlink\" title=\"最小化DFA\"></a>最小化DFA</h2><p>含义：</p>\n<ol>\n<li>没有多余状态：</li>\n</ol>\n<ul>\n<li>从这个状态没有通路到达终态</li>\n<li>从开始状态出发，任何输入串也不能到达的那个状态</li>\n</ul>\n<ol start=\"2\">\n<li>没有两个状态相互等价<br>:::info 方法：</li>\n<li>多余状态直接删除<br><img data-src=\"/image-5.png\"></li>\n<li>合并等价状态</li>\n</ol>\n<ul>\n<li>将状态分为终态和非终态两个集合</li>\n<li>遍历每个集合，如果经过转换到达的状态都在当前集合里，则不用分，否则划分子集，直到划分不了为止</li>\n<li>:chestnut: 例子</li>\n<li><img data-src=\"/image-6.png\"><br>:::</li>\n</ul>\n",
            "tags": [
                "词法分析"
            ]
        },
        {
            "id": "http://example.com/2024/03/21/computer-science/compile-principles/ch1/",
            "url": "http://example.com/2024/03/21/computer-science/compile-principles/ch1/",
            "title": "Ch1",
            "date_published": "2024-03-20T16:00:00.000Z",
            "content_html": "<blockquote>\n<p>ZJU 2025春夏编译原理 学习笔记</p>\n<p>主要基于虎书（<em>Modern Compiler Implementation in C</em>, Andrew W. Appel）</p>\n</blockquote>\n<h1 id=\"CH1-Introduction\"><a href=\"#CH1-Introduction\" class=\"headerlink\" title=\"CH1 Introduction\"></a>CH1 Introduction</h1><ul>\n<li>Two Important Concepts<ul>\n<li>Phases（阶段）</li>\n<li>Interfaces（接口）</li>\n</ul>\n</li>\n</ul>\n<p>方框里的是phase，中间的是interface<br><img data-src=\"/image.png\"><br>各个阶段的描述<br><img data-src=\"/image-1.png\"><img data-src=\"/image-2.png\"></p>\n",
            "tags": [
                "编译原理"
            ]
        },
        {
            "id": "http://example.com/2024/03/21/computer-science/compile-principles/ch5/",
            "url": "http://example.com/2024/03/21/computer-science/compile-principles/ch5/",
            "title": "Ch5",
            "date_published": "2024-03-20T16:00:00.000Z",
            "content_html": "<h1 id=\"语义分析\"><a href=\"#语义分析\" class=\"headerlink\" title=\"语义分析\"></a>语义分析</h1><blockquote>\n<p>绑定，类型检查</p>\n</blockquote>\n<h2 id=\"symbol-table\"><a href=\"#symbol-table\" class=\"headerlink\" title=\"symbol table\"></a>symbol table</h2><ul>\n<li>Functional style: 函数式风格<ul>\n<li>To keep $\\sigma_1$ in pristine condition while creating create $\\sigma_2$ and $\\sigma_3$</li>\n</ul>\n</li>\n<li>Imperative style: 命令式风格<ul>\n<li>Modify $\\sigma_1$ until it becomes $\\sigma_2$. </li>\n<li>While $\\sigma_2$ exists, we cannot look things up in $\\sigma_1$. </li>\n<li>When done with $\\sigma_2$, can undo the modification to get $\\sigma_1$ back again.<br>:::info 方法：<br>Hashing<br>:::</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "语义分析"
            ]
        }
    ]
}