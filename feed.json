{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/12/11/note/20251211/",
            "url": "http://example.com/2025/12/11/note/20251211/",
            "title": "杂项",
            "date_published": "2025-12-10T16:00:00.000Z",
            "content_html": "<h1 id=\"默认构造、拷贝构造、移动构造以及赋值运算符重载\"><a href=\"#默认构造、拷贝构造、移动构造以及赋值运算符重载\" class=\"headerlink\" title=\"默认构造、拷贝构造、移动构造以及赋值运算符重载\"></a>默认构造、拷贝构造、移动构造以及赋值运算符重载</h1><figure class=\"highlight c++\"><figcaption><span>构造函数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span>* data;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>(): <span class=\"built_in\">data</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">MyClass</span>() &#123; <span class=\"keyword\">delete</span> data; &#125;</span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>(<span class=\"type\">const</span> MyClass&amp; other): <span class=\"built_in\">data</span>(<span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (other.data != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>(*other.data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>(MyClass&amp;&amp; other) <span class=\"keyword\">noexcept</span>: <span class=\"built_in\">data</span>(<span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        data = other.data;</span><br><span class=\"line\">        other.data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 拷贝赋值运算符</span></span><br><span class=\"line\">    MyClass&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> MyClass&amp; other) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == &amp;other) &#123;      <span class=\"comment\">// 自赋值检查</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> data;              <span class=\"comment\">// 释放当前资源</span></span><br><span class=\"line\">        data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (other.data != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>(*other.data); <span class=\"comment\">// 深拷贝</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 移动赋值运算符</span></span><br><span class=\"line\">    MyClass&amp; <span class=\"keyword\">operator</span>=(MyClass&amp;&amp; other) <span class=\"keyword\">noexcept</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == &amp;other) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> data;               <span class=\"comment\">// 释放当前资源</span></span><br><span class=\"line\">        data = other.data;         <span class=\"comment\">// 接管</span></span><br><span class=\"line\">        other.data = <span class=\"literal\">nullptr</span>;      <span class=\"comment\">// 置空</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>下面用动态数组示例补全拷贝&#x2F;移动语义（遵循 Rule of Five）：</p>\n<figure class=\"highlight c++\"><figcaption><span>数组</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyArray</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span>* data;</span><br><span class=\"line\">    <span class=\"type\">int</span> size;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MyArray</span>(): <span class=\"built_in\">data</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">size</span>(<span class=\"number\">0</span>) &#123;&#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">MyArray</span>()&#123; <span class=\"keyword\">delete</span>[] data; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">MyArray</span>(<span class=\"type\">int</span> sz): <span class=\"built_in\">data</span>(sz ? <span class=\"keyword\">new</span> <span class=\"type\">int</span>[sz] : <span class=\"literal\">nullptr</span>), <span class=\"built_in\">size</span>(sz) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 拷贝构造：深拷贝</span></span><br><span class=\"line\">    <span class=\"built_in\">MyArray</span>(<span class=\"type\">const</span> MyArray&amp; other): <span class=\"built_in\">data</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">size</span>(other.size) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (other.data &amp;&amp; other.size &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[other.size];</span><br><span class=\"line\">            <span class=\"built_in\">copy</span>(other.data, other.data + other.size, data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 移动构造：接管资源</span></span><br><span class=\"line\">    <span class=\"built_in\">MyArray</span>(MyArray&amp;&amp; other) <span class=\"keyword\">noexcept</span>: <span class=\"built_in\">data</span>(other.data), <span class=\"built_in\">size</span>(other.size) &#123;</span><br><span class=\"line\">        other.data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        other.size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 拷贝赋值：先复制再交换（异常安全）</span></span><br><span class=\"line\">    MyArray&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> MyArray&amp; other) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == &amp;other) <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span>* newData = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (other.size &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            newData = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[other.size];</span><br><span class=\"line\">            <span class=\"built_in\">copy</span>(other.data, other.data + other.size, newData);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] data;</span><br><span class=\"line\">        data = newData;</span><br><span class=\"line\">        size = other.size;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 移动赋值：释放当前资源并接管</span></span><br><span class=\"line\">    MyArray&amp; <span class=\"keyword\">operator</span>=(MyArray&amp;&amp; other) <span class=\"keyword\">noexcept</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == &amp;other) <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] data;</span><br><span class=\"line\">        data = other.data;</span><br><span class=\"line\">        size = other.size;</span><br><span class=\"line\">        other.data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        other.size = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getSize</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> size; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span>* <span class=\"title\">getData</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> data; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>要点：</p>\n<ul>\n<li>对于拥有动态资源的类型，建议同时实现析构、拷贝构造、移动构造、拷贝赋值、移动赋值（Rule of Five）。</li>\n<li>拷贝要做深拷贝，移动要尽可能接管资源并置空原对象以避免双重释放。</li>\n<li>拷贝赋值实现中可以先分配新资源，再释放旧资源以提高异常安全性。</li>\n</ul>\n<h1 id=\"智能指针怎么用\"><a href=\"#智能指针怎么用\" class=\"headerlink\" title=\"智能指针怎么用\"></a>智能指针怎么用</h1><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xOTIxNTc5ODE0Mjg1OTc1Njcw\">https://zhuanlan.zhihu.com/p/1921579814285975670</span></p>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用std::make_shared</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> ptr1 = std::<span class=\"built_in\">make_shared</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用std::shared_ptr(new T(args...))</span></span><br><span class=\"line\"><span class=\"function\">std::shared_ptr&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">ptr2</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"type\">int</span>(<span class=\"number\">10</span>))</span></span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::shared_ptr&lt;<span class=\"type\">int</span>&gt; shared_ptr1 = std::<span class=\"built_in\">make_shared</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">10</span>); </span><br><span class=\"line\">std::weak_ptr&lt;<span class=\"type\">int</span>&gt; weak_ptr1 = shared_ptr1; </span><br><span class=\"line\"><span class=\"keyword\">auto</span> shared_ptr2 = weak_ptr<span class=\"number\">1.l</span>ock(); </span><br><span class=\"line\"><span class=\"keyword\">if</span> (shared_ptr2) &#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Object is still alive: &quot;</span> &lt;&lt; *shared_ptr2 &lt;&lt; std::endl; </span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Object has been destroyed&quot;</span> &lt;&lt; std::endl; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>多个 shared_ptr 对象可以共享同一个动态分配的对象，并通过一个&#x3D;&#x3D;共享的控制块&#x3D;&#x3D;（control block）来维护引用计数，当最后一个 shared_ptr 被销毁或重置时，自动释放所管理的对象。</p>\n<h3 id=\"1-控制块（Control-Block）\"><a href=\"#1-控制块（Control-Block）\" class=\"headerlink\" title=\"1. 控制块（Control Block）\"></a>1. 控制块（Control Block）</h3><p>每个被 <code>shared_ptr</code> 管理的对象都会关联一个 <strong>控制块（control block）</strong>，这个控制块通常包含以下信息：</p>\n<ul>\n<li><strong>强引用计数（strong reference count）</strong>：即有多少个 <code>shared_ptr</code> 正在共享该对象。</li>\n<li><strong>弱引用计数（weak reference count）</strong>：即有多少个 <code>weak_ptr</code> 指向该控制块（用于支持 <code>weak_ptr</code>）。</li>\n<li><strong>被管理对象的指针</strong>（有时直接内嵌对象，如通过 <code>make_shared</code>）。</li>\n<li><strong>删除器（deleter）</strong>：可自定义的函数对象，用于释放资源（默认是 <code>delete</code>）。</li>\n<li><strong>分配器（allocator）</strong>：如果使用了自定义内存分配策略。</li>\n</ul>\n<blockquote>\n<p>注意：控制块本身是堆上分配的（除非使用 <code>make_shared</code>，此时对象和控制块可能分配在同一块内存中以提高效率）。</p>\n</blockquote>\n<h3 id=\"2-引用计数的增减\"><a href=\"#2-引用计数的增减\" class=\"headerlink\" title=\"2. 引用计数的增减\"></a>2. 引用计数的增减</h3><ul>\n<li><strong>构造&#x2F;拷贝&#x2F;赋值</strong>：<ul>\n<li>当一个新的 <code>shared_ptr</code> 通过拷贝构造、移动构造或赋值操作指向同一对象时，<strong>强引用计数加 1</strong>。</li>\n</ul>\n</li>\n<li><strong>析构&#x2F;重置（reset）</strong>：<ul>\n<li>当一个 <code>shared_ptr</code> 被销毁或调用 <code>reset()</code> 时，<strong>强引用计数减 1</strong>。</li>\n<li>如果强引用计数变为 0，则：<ul>\n<li>调用删除器（deleter）释放被管理的对象；</li>\n<li><strong>但控制块不会立即释放</strong>，因为可能还有 <code>weak_ptr</code> 存在（需等待弱引用计数也为 0 才释放控制块）。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-线程安全性\"><a href=\"#3-线程安全性\" class=\"headerlink\" title=\"3. 线程安全性\"></a>3. 线程安全性</h3><ul>\n<li><strong>引用计数的操作是原子的</strong>（通常使用 <code>std::atomic</code> 实现），因此多个线程同时拷贝或销毁 <code>shared_ptr</code> 是线程安全的。</li>\n<li>但注意：<strong>对被管理对象本身的访问不是线程安全的</strong>，需要用户自己加锁。</li>\n</ul>\n<h1 id=\"shared-ptr什么时候-1什么时候-1\"><a href=\"#shared-ptr什么时候-1什么时候-1\" class=\"headerlink\" title=\"shared_ptr什么时候+1什么时候-1\"></a>shared_ptr什么时候+1什么时候-1</h1><h2 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"+1\"></a>+1</h2><ol>\n<li>拷贝构造</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::shared_ptr&lt;<span class=\"type\">int</span>&gt; p1 = std::<span class=\"built_in\">make_shared</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">42</span>);</span><br><span class=\"line\"><span class=\"function\">std::shared_ptr&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">p2</span><span class=\"params\">(p1)</span></span>;  <span class=\"comment\">// +1 → 强引用计数变为 2</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>拷贝赋值</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::shared_ptr&lt;<span class=\"type\">int</span>&gt; p3;</span><br><span class=\"line\">p3 = p1;  <span class=\"comment\">// p3 原来为空，现在共享 p1 的对象 → +1</span></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>函数传参</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">foo</span><span class=\"params\">(std::shared_ptr&lt;<span class=\"type\">int</span>&gt; p)</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\"><span class=\"built_in\">foo</span>(p1);  <span class=\"comment\">// 进入函数时拷贝 → +1；函数返回时析构 → -1</span></span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>作为返回值返回</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::shared_ptr&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">getPtr</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p1;  <span class=\"comment\">// 返回时可能触发拷贝或移动（见下文）</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> p4 = <span class=\"built_in\">getPtr</span>();  <span class=\"comment\">// 若发生拷贝 → +1；若被优化为移动 → 不变</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>现代编译器通常会进行 返回值优化（RVO） 或使用 移动语义，避免不必要的 +1&#x2F;-1</p>\n<ol start=\"5\">\n<li>放入容器（如 vector、list）</li>\n</ol>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::vector&lt;std::shared_ptr&lt;<span class=\"type\">int</span>&gt;&gt; vec;</span><br><span class=\"line\">vec.<span class=\"built_in\">push_back</span>(p1);  <span class=\"comment\">// 拷贝进容器 → +1</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-1\"><a href=\"#1-1\" class=\"headerlink\" title=\"-1\"></a>-1</h2><ol>\n<li>析构</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    std::shared_ptr&lt;<span class=\"type\">int</span>&gt; p = p1;  <span class=\"comment\">// +1</span></span><br><span class=\"line\">&#125; <span class=\"comment\">// p 析构 → -1</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>调用reset</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p<span class=\"number\">1.</span><span class=\"built_in\">reset</span>();        <span class=\"comment\">// 放弃当前对象 → -1</span></span><br><span class=\"line\">p<span class=\"number\">1.</span><span class=\"built_in\">reset</span>(<span class=\"literal\">nullptr</span>); <span class=\"comment\">// 同上</span></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>被赋予新值</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::shared_ptr&lt;<span class=\"type\">int</span>&gt; p2 = std::<span class=\"built_in\">make_shared</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">100</span>);</span><br><span class=\"line\">p1 = p2;  </span><br><span class=\"line\"><span class=\"comment\">// 先对 p1 原来的对象 -1，</span></span><br><span class=\"line\"><span class=\"comment\">// 再对 p2 的对象 +1（因为 p1 现在共享 p2 的对象）</span></span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>被赋予nullptr或空</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p1 = <span class=\"literal\">nullptr</span>;  <span class=\"comment\">// 相当于 reset() → -1</span></span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>从容器中移除或clear</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec.<span class=\"built_in\">clear</span>();  <span class=\"comment\">// 容器中每个 shared_ptr 析构 → 各自管理的对象引用计数 -1</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"vector底层\"><a href=\"#vector底层\" class=\"headerlink\" title=\"vector底层\"></a>vector底层</h1><p>连续内存存储 + 动态扩容</p>\n<h2 id=\"一、基本结构\"><a href=\"#一、基本结构\" class=\"headerlink\" title=\"一、基本结构\"></a>一、基本结构</h2><p><code>std::vector&lt;T&gt;</code> 内部通常维护三个关键指针（或等效的成员）：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> Allocator = std::allocator&lt;T&gt;&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> vector &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    T* begin_;     <span class=\"comment\">// 指向首元素</span></span><br><span class=\"line\">    T* end_;       <span class=\"comment\">// 指向最后一个元素的下一个位置（即 size 的边界）</span></span><br><span class=\"line\">    T* capacity_;  <span class=\"comment\">// 指向已分配内存的末尾（即 capacity 的边界）</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong><code>size()</code></strong> &#x3D; <code>end_ - begin_</code></li>\n<li><strong><code>capacity()</code></strong> &#x3D; <code>capacity_ - begin_</code></li>\n<li>所有元素在 <code>[begin_, end_)</code> 范围内，内存连续。</li>\n</ul>\n<blockquote>\n<p>实际标准库实现（如 libstdc++、libc++）可能用一个指针 + 两个整数（size&#x2F;capacity），但逻辑等价。</p>\n</blockquote>\n<h2 id=\"二、内存分配与释放\"><a href=\"#二、内存分配与释放\" class=\"headerlink\" title=\"二、内存分配与释放\"></a>二、内存分配与释放</h2><ul>\n<li>使用 <strong>分配器（Allocator）</strong> 管理内存，默认是 <code>std::allocator&lt;T&gt;</code>。</li>\n<li>初始时 <code>capacity() == 0</code>，不分配内存（除非显式 <code>reserve</code> 或插入元素）。</li>\n<li>当需要更多空间时，<strong>重新分配一块更大的连续内存</strong>，将旧元素<strong>移动或拷贝</strong>过去，再释放旧内存。</li>\n</ul>\n<h2 id=\"三、动态扩容机制（关键！）\"><a href=\"#三、动态扩容机制（关键！）\" class=\"headerlink\" title=\"三、动态扩容机制（关键！）\"></a>三、动态扩容机制（关键！）</h2><h3 id=\"1-何时扩容？\"><a href=\"#1-何时扩容？\" class=\"headerlink\" title=\"1. 何时扩容？\"></a>1. <strong>何时扩容？</strong></h3><p>当 <code>size() == capacity()</code> 且尝试插入新元素（如 <code>push_back</code>、<code>insert</code>）时，触发扩容。</p>\n<h3 id=\"2-扩容策略\"><a href=\"#2-扩容策略\" class=\"headerlink\" title=\"2. 扩容策略\"></a>2. <strong>扩容策略</strong></h3><ul>\n<li><strong>不是每次只加 1 个元素</strong>（那样效率极低）。</li>\n<li>通常采用 <strong>倍增策略（geometric growth）</strong>：<ul>\n<li>GCC (libstdc++)：<strong>容量 × 2</strong></li>\n<li>MSVC：<strong>容量 × 1.5</strong></li>\n<li>目的：保证 <strong>摊还时间复杂度 O(1)</strong> 的 <code>push_back</code></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>例如：初始容量 1 → 2 → 4 → 8 → 16 …</p>\n</blockquote>\n<h3 id=\"3-扩容过程\"><a href=\"#3-扩容过程\" class=\"headerlink\" title=\"3. 扩容过程\"></a>3. <strong>扩容过程</strong></h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_back</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">size</span>() == <span class=\"built_in\">capacity</span>()) &#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> new_cap = (<span class=\"built_in\">capacity</span>() == <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : <span class=\"built_in\">capacity</span>() * <span class=\"number\">2</span>;</span><br><span class=\"line\">        T* new_mem = allocator.<span class=\"built_in\">allocate</span>(new_cap);           <span class=\"comment\">// 分配新内存</span></span><br><span class=\"line\">        <span class=\"built_in\">uninitialized_move</span>(begin_, end_, new_mem);          <span class=\"comment\">// 移动旧元素</span></span><br><span class=\"line\">        allocator.<span class=\"built_in\">deallocate</span>(begin_, <span class=\"built_in\">capacity</span>());           <span class=\"comment\">// 释放旧内存</span></span><br><span class=\"line\">        begin_ = new_mem;</span><br><span class=\"line\">        end_ = new_mem + <span class=\"built_in\">size</span>();</span><br><span class=\"line\">        capacity_ = new_mem + new_cap;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">construct</span>(end_, value);  <span class=\"comment\">// 在 end_ 处构造新元素</span></span><br><span class=\"line\">    ++end_;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：C++11 起优先使用 <strong>移动语义</strong>（move）而非拷贝，提升性能。</p>\n</blockquote>\n<h2 id=\"四、关键操作的时间复杂度\"><a href=\"#四、关键操作的时间复杂度\" class=\"headerlink\" title=\"四、关键操作的时间复杂度\"></a>四、关键操作的时间复杂度</h2><table>\n<thead>\n<tr>\n<th>操作</th>\n<th>时间复杂度</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>operator[]</code>, <code>at()</code></td>\n<td>O(1)</td>\n<td>随机访问</td>\n</tr>\n<tr>\n<td><code>push_back()</code></td>\n<td><strong>O(1) 摊还</strong></td>\n<td>偶尔 O(n) 扩容</td>\n</tr>\n<tr>\n<td><code>pop_back()</code></td>\n<td>O(1)</td>\n<td>仅析构最后一个元素，不释放内存</td>\n</tr>\n<tr>\n<td><code>insert(pos, val)</code></td>\n<td>O(n)</td>\n<td>需移动 pos 后所有元素</td>\n</tr>\n<tr>\n<td><code>erase(pos)</code></td>\n<td>O(n)</td>\n<td>同上</td>\n</tr>\n<tr>\n<td><code>clear()</code></td>\n<td>O(n)</td>\n<td>析构所有元素，但 <strong>不释放内存</strong>（capacity 不变）</td>\n</tr>\n<tr>\n<td><code>shrink_to_fit()</code></td>\n<td>O(n)</td>\n<td>请求释放多余内存（非强制，依赖实现）</td>\n</tr>\n</tbody></table>\n<h2 id=\"五、内存管理特性\"><a href=\"#五、内存管理特性\" class=\"headerlink\" title=\"五、内存管理特性\"></a>五、内存管理特性</h2><ul>\n<li><strong>内存连续</strong>：支持与 C 数组互操作（如 <code>&amp;vec[0]</code> 或 <code>vec.data()</code>）。</li>\n<li><strong>不自动缩容</strong>：<code>pop_back</code> 或 <code>erase</code> 后 <code>capacity()</code> 不变，避免频繁 realloc。</li>\n<li><strong>异常安全</strong>：现代实现通常提供 <strong>强异常安全保证</strong>（如 copy-and-swap 技术）。</li>\n</ul>\n",
            "tags": [
                "杂项"
            ]
        },
        {
            "id": "http://example.com/2025/12/09/AI/agent/",
            "url": "http://example.com/2025/12/09/AI/agent/",
            "title": "agent相关",
            "date_published": "2025-12-08T16:00:00.000Z",
            "content_html": "<h1 id=\"python回顾\"><a href=\"#python回顾\" class=\"headerlink\" title=\"python回顾\"></a>python回顾</h1><p>参考：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saWFveHVlZmVuZy5jb20vYm9va3MvcHl0aG9uL2Jhc2ljL2RhdGEtdHlwZXMvaW5kZXguaHRtbA==\">廖雪峰</span></p>\n",
            "tags": [
                "人工智能"
            ]
        },
        {
            "id": "http://example.com/2025/12/07/computer-science/computer-network/note/",
            "url": "http://example.com/2025/12/07/computer-science/computer-network/note/",
            "title": "计网八股",
            "date_published": "2025-12-06T16:00:00.000Z",
            "content_html": "<ol>\n<li>网络模型</li>\n</ol>\n<ul>\n<li>OSI七层模型：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层</li>\n<li>TCP&#x2F;IP四层模型：网络接口层，网际层，传输层，应用层</li>\n</ul>\n",
            "tags": [
                "计算机网络"
            ]
        },
        {
            "id": "http://example.com/2025/11/23/note/20251123/",
            "url": "http://example.com/2025/11/23/note/20251123/",
            "title": "20251123面经回忆",
            "date_published": "2025-11-22T16:00:00.000Z",
            "content_html": "<ol>\n<li>pdd二面，手撕开放地址法哈希，实现Get, Set, Delete操作</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>Hashing</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> key;</span><br><span class=\"line\">    <span class=\"type\">int</span> value;</span><br><span class=\"line\">    <span class=\"built_in\">Node</span>(): <span class=\"built_in\">key</span>(<span class=\"number\">-1</span>), <span class=\"built_in\">value</span>(<span class=\"number\">-1</span>)&#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">Node</span>(<span class=\"type\">int</span> key, <span class=\"type\">int</span> value) : <span class=\"built_in\">key</span>(key), <span class=\"built_in\">value</span>(value) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">HashTable</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> size;</span><br><span class=\"line\">    vector&lt;Node&gt; table;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> EMPTY = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> DELETED = <span class=\"number\">-2</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span>: </span><br><span class=\"line\">    <span class=\"built_in\">HashTable</span>(<span class=\"type\">int</span> size): <span class=\"built_in\">size</span>(size), <span class=\"built_in\">table</span>(size)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i)&#123;</span><br><span class=\"line\">            table[i].key = EMPTY;</span><br><span class=\"line\">            table[i].value = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Get</span><span class=\"params\">(<span class=\"type\">int</span> key)</span></span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> h = key % size;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h &lt; <span class=\"number\">0</span>) h += size;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> idx = (h + i) % size;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (table[idx].key == EMPTY) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; <span class=\"comment\">// not found</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (table[idx].key == key) <span class=\"keyword\">return</span> table[idx].value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Set</span><span class=\"params\">(<span class=\"type\">int</span> key, <span class=\"type\">int</span> value)</span></span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> h = key % size;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h &lt; <span class=\"number\">0</span>) h += size;</span><br><span class=\"line\">        <span class=\"type\">int</span> firstDeleted = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> idx = (h + i) % size;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (table[idx].key == key)&#123;</span><br><span class=\"line\">                table[idx].value = value; <span class=\"comment\">// update existing</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (firstDeleted == <span class=\"number\">-1</span> &amp;&amp; table[idx].key == DELETED)&#123;</span><br><span class=\"line\">                firstDeleted = idx;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (table[idx].key == EMPTY)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (firstDeleted != <span class=\"number\">-1</span>) idx = firstDeleted;</span><br><span class=\"line\">                table[idx].key = key;</span><br><span class=\"line\">                table[idx].value = value;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (firstDeleted != <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            table[firstDeleted].key = key;</span><br><span class=\"line\">            table[firstDeleted].value = value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; <span class=\"comment\">// table full</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Delete</span><span class=\"params\">(<span class=\"type\">int</span> key)</span></span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> h = key % size;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h &lt; <span class=\"number\">0</span>) h += size;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> idx = (h + i) % size;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (table[idx].key == EMPTY) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; <span class=\"comment\">// not found</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (table[idx].key == key)&#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> value = table[idx].value;</span><br><span class=\"line\">                table[idx].key = DELETED; <span class=\"comment\">// tombstone</span></span><br><span class=\"line\">                table[idx].value = <span class=\"number\">-1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>网易<br>找到n个数里面第k大的，除了排序有没有别的方法<br>问了一堆基础知识，static&#x2F;inline等等</p>\n</li>\n<li><p>华为<br>一面双指针，二面贪心</p>\n</li>\n<li><p>忘了</p>\n</li>\n</ol>\n",
            "tags": [
                "面经"
            ]
        },
        {
            "id": "http://example.com/2025/11/20/note/20251130/",
            "url": "http://example.com/2025/11/20/note/20251130/",
            "title": "杂项",
            "date_published": "2025-11-19T16:00:00.000Z",
            "content_html": "<h1 id=\"杂项\"><a href=\"#杂项\" class=\"headerlink\" title=\"杂项\"></a>杂项</h1><ol>\n<li>explicit<br>构造函数默认是隐式转换的，如果想要禁止隐式转换，可以使用explicit关键字修饰构造函数。<br>比如</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>explicit</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">FileSize</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 构造函数：接受字节数</span></span><br><span class=\"line\">    <span class=\"built_in\">FileSize</span>(<span class=\"type\">long</span> <span class=\"type\">long</span> bytes) : <span class=\"built_in\">bytes_</span>(bytes) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">long</span> <span class=\"type\">long</span> <span class=\"title\">getBytes</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> bytes_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"type\">long</span> bytes_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">deleteFileLargerThan</span><span class=\"params\">(<span class=\"type\">const</span> FileSize&amp; maxSize)</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Deleting files larger than &quot;</span> &lt;&lt; maxSize.<span class=\"built_in\">getBytes</span>() &lt;&lt; <span class=\"string\">&quot; bytes.\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 实际逻辑省略...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">deleteFileLargerThan</span>(<span class=\"string\">&quot;100MB&quot;</span>);  <span class=\"comment\">// 打错了！本想传字符串配置，但函数不接受 string</span></span><br><span class=\"line\">    <span class=\"comment\">// &quot;100MB&quot;  →  const char*  →  bool(true)  →  long long(1)   →  FileSize(1)</span></span><br><span class=\"line\">    <span class=\"comment\">// 变成：Deleting files larger than 1 bytes. 严重错误</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>回调函数<br>回调函数是一种函数指针，它允许在运行时指定一个函数，并在某个事件发生时调用该函数。<br>人话：一个被作为参数传递给另一个函数，并在“合适的时候”被调用的函数。</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>callback</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">std::function&lt;R(Args...)&gt; cb;</span><br><span class=\"line\"><span class=\"comment\">// R: 返回类型</span></span><br><span class=\"line\"><span class=\"comment\">// Args...: 参数列表</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>std::function 能装什么？</p>\n</blockquote>\n<ul>\n<li>普通函数</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>callback</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">greet</span><span class=\"params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"string\">&quot;Hello!\\n&quot;</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">std::function&lt;<span class=\"type\">void</span>()&gt; cb = greet;</span><br><span class=\"line\"><span class=\"built_in\">cb</span>(); <span class=\"comment\">// 输出 Hello!</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>Lambda表达式</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>callback</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> x = <span class=\"number\">42</span>;</span><br><span class=\"line\">std::function&lt;<span class=\"type\">void</span>()&gt; cb = [x]() &#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Captured x = &quot;</span> &lt;&lt; x &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">cb</span>(); <span class=\"comment\">// 输出 Captured x = 42</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>函数对象</li>\n<li>成员函数</li>\n</ul>\n<ol start=\"3\">\n<li><p><code>mutable std::mutex mtx_;</code><br><code>mutable</code> 关键字表示变量可以在常量函数中修改。<br>如果没有 mutable，mtx_ 是普通成员变量，在 const 函数中，所有成员都被视为 const，调用 mtx_.lock() 会报错</p>\n</li>\n<li><p>std::unique_lock<span class=\"exturl\" data-url=\"c3RkOjptdXRleA==\">std::mutex</span> lock(mtx_)<br>进入时自动调用 mtx_.lock()（当前线程获得锁），当 lock 变量离开作用域（比如函数返回、出 {}），会自动调用 mtx_.unlock()</p>\n</li>\n<li><p>lambda<br>有点抽象，有空继续研究<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jLmJpYW5jaGVuZy5uZXQvdmlldy9ibDF5dnd5Lmh0bWw=\">https://c.biancheng.net/view/bl1yvwy.html</span></p>\n</li>\n</ol>\n<ul>\n<li>作为函数对象（Functor）替代手写类</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>lambda</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">IsEven</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> x % <span class=\"number\">2</span> == <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">std::vector&lt;<span class=\"type\">int</span>&gt; v = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> it = std::<span class=\"built_in\">find_if</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), IsEven&#123;&#125;);</span><br><span class=\"line\"><span class=\"comment\">// lambda写法</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> it = std::<span class=\"built_in\">find_if</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), [](<span class=\"type\">int</span> x) &#123; <span class=\"keyword\">return</span> x % <span class=\"number\">2</span> == <span class=\"number\">0</span>; &#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>STL 算法的自定义谓词（最常用！）</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>lambda</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::vector&lt;Person&gt; people = &#123;...&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 按年龄降序</span></span><br><span class=\"line\">std::<span class=\"built_in\">sort</span>(people.<span class=\"built_in\">begin</span>(), people.<span class=\"built_in\">end</span>(),</span><br><span class=\"line\">          [](<span class=\"type\">const</span> Person&amp; a, <span class=\"type\">const</span> Person&amp; b) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> a.age &gt; b.age;</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除所有空字符串</span></span><br><span class=\"line\">vec.<span class=\"built_in\">erase</span>(</span><br><span class=\"line\">    std::<span class=\"built_in\">remove_if</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">end</span>(),</span><br><span class=\"line\">                   [](<span class=\"type\">const</span> std::string&amp; s) &#123; <span class=\"keyword\">return</span> s.<span class=\"built_in\">empty</span>(); &#125;),</span><br><span class=\"line\">    vec.<span class=\"built_in\">end</span>()</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 找第一个大于 10 的数</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> it = std::<span class=\"built_in\">find_if</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), [](<span class=\"type\">int</span> x) &#123; <span class=\"keyword\">return</span> x &gt; <span class=\"number\">10</span>; &#125;);</span><br></pre></td></tr></table></figure>\n\n\n<ol start=\"6\">\n<li>condition_variable<br>不希望 FSM 的 worker 线程这样:</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>轮询</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (queue 空)</span><br><span class=\"line\">        一直查（忙等）</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>condition_variable 的作用：</p>\n<ul>\n<li>队列空 → 工作线程睡觉</li>\n<li>有事件 → 唤醒工作线程<br>写法：</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>condition_variable</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cv.<span class=\"built_in\">wait</span>(lock, []&#123; <span class=\"keyword\">return</span> !queue.<span class=\"built_in\">empty</span>(); &#125;);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li><p>atomic库<br><code>atomic&lt;bool&gt;</code> 原子变量，线程安全的 bool</p>\n</li>\n<li><p>匿名函数</p>\n</li>\n<li><p>workerThread + 队列 + 状态机</p>\n</li>\n</ol>\n",
            "tags": [
                "杂项"
            ]
        },
        {
            "id": "http://example.com/2025/11/20/note/20251201/",
            "url": "http://example.com/2025/11/20/note/20251201/",
            "title": "测试相关",
            "date_published": "2025-11-19T16:00:00.000Z",
            "content_html": "<h1 id=\"gtest\"><a href=\"#gtest\" class=\"headerlink\" title=\"gtest\"></a>gtest</h1><p>Google开源的c++单元测试框架<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2dvb2dsZXRlc3Qv\">https://google.github.io/googletest/</span></p>\n<h1 id=\"查看代码覆盖率\"><a href=\"#查看代码覆盖率\" class=\"headerlink\" title=\"查看代码覆盖率\"></a>查看代码覆盖率</h1><ul>\n<li>GCC + gcov(cmake一般带了) + lcov</li>\n</ul>\n<ol>\n<li>修改CMakeLists.txt</li>\n</ol>\n<figure class=\"highlight cmake\"><figcaption><span>lcov</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启用调试信息和覆盖率支持（仅在需要时开启）</span></span><br><span class=\"line\"><span class=\"keyword\">option</span>(ENABLE_COVERAGE <span class=\"string\">&quot;Enable coverage build&quot;</span> <span class=\"keyword\">OFF</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(ENABLE_COVERAGE)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(CMAKE_CXX_COMPILER_ID <span class=\"keyword\">MATCHES</span> <span class=\"string\">&quot;GNU|Clang&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">target_compile_options</span>(your_library_or_source_files PRIVATE</span><br><span class=\"line\">            -O0          <span class=\"comment\"># 禁用优化（否则行号可能不准）</span></span><br><span class=\"line\">            -g           <span class=\"comment\"># 调试信息</span></span><br><span class=\"line\">            --coverage   <span class=\"comment\"># 等价于 -fprofile-arcs -ftest-coverage</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">        <span class=\"keyword\">target_link_options</span>(your_library_or_source_files PRIVATE --coverage)</span><br><span class=\"line\">    <span class=\"keyword\">endif</span>()</span><br><span class=\"line\"><span class=\"keyword\">endif</span>()</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>构建并运行测试<br>…<br>cmake .. -DENABLE_COVERAGE&#x3D;ON<br>…</li>\n<li>生成可视化覆盖率报告（HTML）</li>\n</ol>\n<figure class=\"highlight bash\"><figcaption><span>lcov</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 初始化覆盖率数据</span></span><br><span class=\"line\">lcov --capture --initial --directory . --output-file coverage_base.info</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 收集实际运行后的覆盖率</span></span><br><span class=\"line\">lcov --capture --directory . --output-file coverage_test.info</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 合并（可选，但推荐）</span></span><br><span class=\"line\">lcov --add-tracefile coverage_base.info --add-tracefile coverage_test.info --output-file coverage_total.info</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># （可选）过滤掉第三方代码（如 googletest）</span></span><br><span class=\"line\">lcov --remove coverage_total.info <span class=\"string\">&#x27;/usr/*&#x27;</span> <span class=\"string\">&#x27;*/thirdpart/*&#x27;</span> <span class=\"string\">&#x27;*/googletest*&#x27;</span> --output-file coverage_final.info</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生成 HTML 报告</span></span><br><span class=\"line\">genhtml coverage_final.info --output-directory coverage_report</span><br></pre></td></tr></table></figure>\n<p>或者直接</p>\n<figure class=\"highlight bash\"><figcaption><span>lcov</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make coverage</span><br></pre></td></tr></table></figure>\n<p>然后再build目录下的coverage_html目录下查看index.html，可以点开具体文件查看哪些行没有覆盖到</p>\n<h1 id=\"如何提高单元测试的覆盖率\"><a href=\"#如何提高单元测试的覆盖率\" class=\"headerlink\" title=\"如何提高单元测试的覆盖率\"></a>如何提高单元测试的覆盖率</h1><p>分析当前覆盖率报告，找出未执行的代码路径，然后编写新的测试用例来触发这些路径。</p>\n",
            "tags": [
                "ctest",
                "gtest",
                "test coverage"
            ]
        },
        {
            "id": "http://example.com/2025/10/26/oop/note/",
            "url": "http://example.com/2025/10/26/oop/note/",
            "title": "C++相关",
            "date_published": "2025-10-25T16:00:00.000Z",
            "content_html": "<ol>\n<li><p>面向对象 vs 面向过程<br>面向对象三大特性：封装、继承、多态<br>c++不是完全面向对象的语言<br>封装：把数据和方法打包成一个类，隐藏实现细节，只提供接口<br>继承：子类继承父类的属性和方法，子类可以扩展父类的功能，实现代码复用<br>多态：在运行时，根据对象的实际类型，调用对应的函数。主要通过虚函数和继承实现</p>\n</li>\n<li><p>C++编译过程<br>预处理-&gt;编译-&gt;汇编-&gt;链接<br>预处理：预处理指令、宏定义、包含文件(处理 #include, #define, 条件编译等)<br>编译：把源代码编译成汇编代码(将 .cpp 转为 .s )<br>汇编：把汇编代码编译成机器码<br>链接：把多个对象文件链接成可执行文件(将多个目标文件和库合并成可执行文件)<br>&#x3D;&#x3D;第三方库就是在第 4 步 —— 链接（Linking）阶段加入的&#x3D;&#x3D;<br>在 链接阶段，通过 -lxxx（如 -lcurl）告诉链接器：“我要用这个库”，然后链接器去找到对应的 静态库（.a 或 .lib）或动态库（.so 或 .dll）<br>静态库在在编译过程中（链接阶段）被载入可执行程序，生成的可执行文件体积较大<br>动态库是在运行时才载入内存，但更新库后需要重新编译。&#x3D;&#x3D;动态库是运行时库&#x3D;&#x3D;</p>\n</li>\n<li><p>静态链接和动态链接<br>静态链接：把所有用到的库文件都链接到可执行文件中，编译速度慢，但运行速度快<br>动态链接：把所有用到的库文件都放到一个单独的文件中，运行时再加载，编译速度快，但运行速度慢</p>\n</li>\n<li><p>静态多态（编译时多态） 和 动态多态（运行时多态）</p>\n</li>\n</ol>\n<ul>\n<li><p>动态多态（Dynamic Polymorphism）—— 运行时多态<br>这是通过 继承 + 虚函数（virtual function） 实现的。动态多态是通过虚函数重写实现的，是在运行期间确定的多态，是一种&#x3D;&#x3D;晚绑定&#x3D;&#x3D;机制（或&#x3D;&#x3D;动态绑定&#x3D;&#x3D;），在运行期间才能确定调用哪一个函数</p>\n<blockquote>\n<p>基类中的虚函数：使用 virtual 关键字声明。<br>派生类重写（override）虚函数。<br>通过基类指针或引用调用虚函数。<br>必须通过 基类指针或引用 调用虚函数，涉及虚函数表（<code>vtable</code>）和虚指针（<code>vptr</code>）<br>:::info<br>虚函数如何实现晚绑定？<br>每个有虚函数的类有一个 虚函数表（vtable），存函数指针。（编译时候产生的，放在静态存储区中）<br>每个对象构造时会有一个 虚指针（vptr），指向自己的 vtable。<br>调用虚函数时：<br>程序运行时，通过对象的 vptr 找到 vtable<br>在 vtable 中查找对应函数地址<br>调用该函数<br>这个过程在运行时完成，所以是晚绑定。<br>:::</p>\n</blockquote>\n</li>\n<li><p>静态多态（Static Polymorphism）—— 编译时多态<br>在编译期就确定了调用哪个函数，不涉及运行时开销，属于“&#x3D;&#x3D;早绑定&#x3D;&#x3D;（Early Binding）”</p>\n<blockquote>\n<p>函数重载（Function Overloading）<br>运算符重载（Operator Overloading）<br>函数模板（Function Templates）</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>例子</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1. 函数重载</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Integer: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">double</span> x)</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Double: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; s)</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;String: &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&gt; 符号表如何支持函数重载？</span><br><span class=\"line\">在支持重载的语言（如 C++）中，符号表不会把同名函数合并成一个条目，而是为每个不同的函数签名单独存储一条记录，并将它们组织成一个“重载集合”，用的时候根据实参的类型和数量等样进行匹配，找到最匹配的函数调用。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 函数模板（泛型）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printGeneric</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; value)</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Generic: &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 运算符重载</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> x, y;</span><br><span class=\"line\">    <span class=\"built_in\">Point</span>(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y) : <span class=\"built_in\">x</span>(x), <span class=\"built_in\">y</span>(y) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Point <span class=\"keyword\">operator</span>+(<span class=\"type\">const</span> Point&amp; other) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Point</span>(x + other.x, y + other.y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"number\">42</span>);           <span class=\"comment\">// 调用 print(int)</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"number\">3.14</span>);         <span class=\"comment\">// 调用 print(double)</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hello&quot;</span>);      <span class=\"comment\">// 调用 print(string)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printGeneric</span>(<span class=\"number\">100</span>);   <span class=\"comment\">// 编译时生成 printGeneric&lt;int&gt;</span></span><br><span class=\"line\">    <span class=\"built_in\">printGeneric</span>(<span class=\"number\">2.5</span>);   <span class=\"comment\">// 生成 printGeneric&lt;double&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Point <span class=\"title\">p1</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span>, <span class=\"title\">p2</span><span class=\"params\">(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span></span>;</span><br><span class=\"line\">    Point p3 = p1 + p2;  <span class=\"comment\">// 使用重载的 +</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Point: (&quot;</span> &lt;&lt; p<span class=\"number\">3.</span>x &lt;&lt; <span class=\"string\">&quot;, &quot;</span> &lt;&lt; p<span class=\"number\">3.</span>y &lt;&lt; <span class=\"string\">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ol>\n<li>参数推导; 2. 实例化具体函数(在符号表中对应不同的条目); 3. 编译链接</li>\n</ol>\n</blockquote>\n<ol start=\"5\">\n<li>必须通过指针或引用调用 才能触发多态。如果直接用对象调用，会是静态绑定。<br>想用多态，必须用基类指针或基类引用去操作派生类对象</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>例子</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Animal speaks&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> : <span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Dog barks: 汪汪！&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过指针调用 → 触发多态（动态绑定）</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>1</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Dog dog;</span><br><span class=\"line\">    Animal* ptr = &amp;dog;  <span class=\"comment\">// 基类指针指向派生类对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ptr-&gt;<span class=\"built_in\">speak</span>();  <span class=\"comment\">// 输出 Dog barks: 汪汪！</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过引用调用 → 也触发多态</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>2</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">makeAnimalSpeak</span><span class=\"params\">(Animal&amp; animal)</span> </span>&#123;</span><br><span class=\"line\">    animal.<span class=\"built_in\">speak</span>();  <span class=\"comment\">// 动态绑定</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Dog dog;</span><br><span class=\"line\">    <span class=\"built_in\">makeAnimalSpeak</span>(dog);  <span class=\"comment\">// 输出：Dog barks: 汪汪！</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>直接对对象调用，静态绑定</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>3</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Dog dog;</span><br><span class=\"line\">    Animal a = dog;  <span class=\"comment\">// 把 Dog 对象赋值给 Animal 对象（会发生“对象切片”）</span></span><br><span class=\"line\"></span><br><span class=\"line\">    a.<span class=\"built_in\">speak</span>();  <span class=\"comment\">// 输出 Animal speaks</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>指针 vs 引用<br>引用是别名，指针是表示地址的变量<br>引用的特性：<blockquote>\n<p>必须初始化，引用定义时必须绑定到一个变量<br>不能重新绑定，一旦绑定，就不能再指向其他变量<br>操作即原变量，对引用的所有操作都作用于原变量</p>\n</blockquote>\n</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>引用</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>&amp; ref;     <span class=\"comment\">// 错误！未初始化</span></span><br><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">5</span>, b = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span>&amp; ref = a;</span><br><span class=\"line\">ref = b;      <span class=\"comment\">// 注意：这是赋值！不是重新绑定！a 变成 10，ref 仍绑定 a，此时a 和 ref 都是 10</span></span><br></pre></td></tr></table></figure>\n<p>引用的常见用法：</p>\n<blockquote>\n<p>函数参数传递：传递大对象（如 string、vector）<br>函数返回值（返回对象本身，支持链式调用）</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>引用</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyInt</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> value;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MyInt</span>(<span class=\"type\">int</span> v) : <span class=\"built_in\">value</span>(v) &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 返回引用，支持链式赋值</span></span><br><span class=\"line\">    MyInt&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> MyInt&amp; other) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != &amp;other) &#123;  <span class=\"comment\">// 自赋值检查</span></span><br><span class=\"line\">            value = other.value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;  <span class=\"comment\">// 返回当前对象的引用</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">MyInt <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">1</span>)</span>, <span class=\"title\">b</span><span class=\"params\">(<span class=\"number\">2</span>)</span>, <span class=\"title\">c</span><span class=\"params\">(<span class=\"number\">3</span>)</span></span>;</span><br><span class=\"line\">a = b = c;  <span class=\"comment\">// 链式赋值：b=c 返回 b 的引用，再赋给 a</span></span><br></pre></td></tr></table></figure>\n<p>:::danger<br>不能返回局部变量的引用<br>:::</p>\n<figure class=\"highlight c++\"><figcaption><span>错误</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span>&amp; <span class=\"title\">getRef</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;  <span class=\"comment\">// 错误！x 是局部变量，函数结束后销毁</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>遍历容器（避免拷贝元素）</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>遍历容器</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;string&gt; names = &#123;<span class=\"string\">&quot;Alice&quot;</span>, <span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Charlie&quot;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用引用遍历，避免拷贝字符串</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">const</span> string&amp; name : names) &#123;</span><br><span class=\"line\">    cout &lt;&lt; name &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或使用 auto&amp;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; name : names) &#123;</span><br><span class=\"line\">    name += <span class=\"string\">&quot; (modified)&quot;</span>;  <span class=\"comment\">// 如果想修改原元素</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>作为输出参数（替代指针）</p>\n</blockquote>\n<ol start=\"7\">\n<li>const引用<br>引用是别名，const引用是常量别名，不能修改别名指向的变量</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>const引用</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span>&amp; cref = x;  <span class=\"comment\">// cref 是 x 的常引用</span></span><br><span class=\"line\">cref = <span class=\"number\">20</span>;            <span class=\"comment\">// 错误！不能通过 cref 修改 x</span></span><br></pre></td></tr></table></figure>\n<p>可以用来绑定临时对象（延长生命周期）</p>\n<figure class=\"highlight c++\"><figcaption><span>常引用</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">3.14</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">double</span>&amp; r = <span class=\"built_in\">getValue</span>();  <span class=\"comment\">// 合法！临时对象生命周期延长到 r 结束</span></span><br><span class=\"line\">cout &lt;&lt; r;  <span class=\"comment\">// 输出 3.14</span></span><br></pre></td></tr></table></figure>\n<p>getValue()的值在表达式结束就应该销毁了，但是当一个 const 引用绑定到临时对象时，这个临时对象的生命周期会被“延长”，直到引用 r 结束为止。<br>用法：</p>\n<blockquote>\n<p>避免不必要的拷贝</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>引用</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> string&amp; s = <span class=\"string\">&quot;hello&quot;</span>;  <span class=\"comment\">// 不拷贝字符串</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>支持函数链式调用</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>引用</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> string&amp; result = <span class=\"built_in\">getPrefix</span>() + <span class=\"built_in\">getName</span>() + <span class=\"built_in\">getSuffix</span>();</span><br><span class=\"line\"><span class=\"comment\">// 临时 string 对象被 const 引用延长生命周期</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>STL中使用</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>STL</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; item : vec) &#123; ... &#125;  <span class=\"comment\">// 避免拷贝，安全高效</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"8\">\n<li>左值引用 vs 右值引用<br>左值：有名字、能取地址的变量，可以放在赋值号左边，生命周期较长<br>右值：临时变量，不能取地址，生命周期较短，通常在表达式中“用完就扔”</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>右值</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10</span>;                <span class=\"comment\">// 字面量，右值</span></span><br><span class=\"line\">x + <span class=\"number\">1</span>;             <span class=\"comment\">// 表达式结果，右值</span></span><br><span class=\"line\"><span class=\"built_in\">string</span>(<span class=\"string\">&quot;hello&quot;</span>);   <span class=\"comment\">// 临时 string 对象，右值</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>右值引用（T&amp;&amp;）就是一种可以绑定到右值（临时对象）的引用。</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>右值引用</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//类型&amp;&amp; 右值引用名 = 右值;</span></span><br><span class=\"line\"><span class=\"type\">int</span>&amp;&amp; rref = <span class=\"number\">10</span>;           <span class=\"comment\">// 10 是右值，rref 是它的右值引用</span></span><br><span class=\"line\"><span class=\"type\">int</span>&amp;&amp; rref2 = <span class=\"number\">5</span> + <span class=\"number\">3</span>;       <span class=\"comment\">// 表达式结果是右值</span></span><br><span class=\"line\">string&amp;&amp; sref = <span class=\"built_in\">string</span>(<span class=\"string\">&quot;临时字符串&quot;</span>);  <span class=\"comment\">// 绑定临时 string 对象</span></span><br></pre></td></tr></table></figure>\n<p>用法：对临时变量移动构造，避免深拷贝</p>\n<figure class=\"highlight c++\"><figcaption><span>移动构造</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// std:move(x) 将左值转换为右值引用，触发移动语义</span></span><br><span class=\"line\"><span class=\"function\">MyString <span class=\"title\">s1</span><span class=\"params\">(<span class=\"string\">&quot;hello&quot;</span>)</span></span>;</span><br><span class=\"line\">MyString s2 = std::<span class=\"built_in\">move</span>(s1);  <span class=\"comment\">// 告诉编译器：“s1 可以被移动了”</span></span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; s<span class=\"number\">1.</span>data;  <span class=\"comment\">// 可能是 nullptr！s1 处于“有效但不可用”状态</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"9\">\n<li>继承</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>继承</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    string name;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Animal</span>(string n) : <span class=\"built_in\">name</span>(n) &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span> </span>&#123; cout &lt;&lt; name &lt;&lt; <span class=\"string\">&quot; 在吃东西&quot;</span> &lt;&lt; endl; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Dog 继承 Animal，继承方式为 public</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> : <span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Dog</span>(string n) : <span class=\"built_in\">Animal</span>(n) &#123;&#125;  <span class=\"comment\">// 调用基类构造函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bark</span><span class=\"params\">()</span> </span>&#123; cout &lt;&lt; name &lt;&lt; <span class=\"string\">&quot; 汪汪叫！&quot;</span> &lt;&lt; endl; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Dog <span class=\"title\">d</span><span class=\"params\">(<span class=\"string\">&quot;小黄&quot;</span>)</span></span>;</span><br><span class=\"line\">    d.<span class=\"built_in\">eat</span>();   <span class=\"comment\">// 继承自 Animal</span></span><br><span class=\"line\">    d.<span class=\"built_in\">bark</span>();  <span class=\"comment\">// Dog 自己的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>继承方式</th>\n<th>基类 public 成员</th>\n<th>基类 protected 成员</th>\n<th>基类 private 成员</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public</td>\n<td>在派生类中仍是 public</td>\n<td>在派生类中是 protected</td>\n<td>不可访问</td>\n</tr>\n<tr>\n<td>protected</td>\n<td>在派生类中是 protected</td>\n<td>在派生类中是 protected</td>\n<td>不可访问</td>\n</tr>\n<tr>\n<td>private</td>\n<td>在派生类中是 private</td>\n<td>在派生类中是 private</td>\n<td>不可访问</td>\n</tr>\n</tbody></table>\n<p>继承中的构造与析构顺序</p>\n<blockquote>\n<p>构造顺序：<br>基类构造函数<br>成员对象构造函数（按声明顺序）<br>派生类构造函数<br>析构顺序：与构造相反<br>派生类析构函数<br>成员对象析构函数（按声明逆序）<br>基类析构函数</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>继承中的构造与析构顺序</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Base</span>() &#123; cout &lt;&lt; <span class=\"string\">&quot;Base 构造\\n&quot;</span>; &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">Base</span>() &#123; cout &lt;&lt; <span class=\"string\">&quot;Base 析构\\n&quot;</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Member</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Member</span>() &#123; cout &lt;&lt; <span class=\"string\">&quot;Member 构造\\n&quot;</span>; &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">Member</span>() &#123; cout &lt;&lt; <span class=\"string\">&quot;Member 析构\\n&quot;</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\">    Member m;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Derived</span>() &#123; cout &lt;&lt; <span class=\"string\">&quot;Derived 构造\\n&quot;</span>; &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">Derived</span>() &#123; cout &lt;&lt; <span class=\"string\">&quot;Derived 析构\\n&quot;</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Derived d;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：<br>Base 构造<br>Member 构造<br>Derived 构造<br>Derived 析构<br>Member 析构<br>Base 析构</p>\n<p>继承是实现 <code>动态多态</code> 的基础。<br>条件：</p>\n<ul>\n<li>基类有 <code>virtual</code> 函数</li>\n<li>派生类 <code>override</code> 它</li>\n<li>通过 <code>基类指针或引用</code> 调用</li>\n</ul>\n<blockquote>\n<p>继承类不能访问基类的私有成员<br>构造函数不能继承，C++11 起支持 <code>using Base::Base;</code> 继承构造函数<br>析构函数应为虚函数：如果类可能被继承，析构函数必须是 <code>virtual</code>，否则 <code>delete基类指针</code>会只调用基类析构，导致派生类资源泄漏</p>\n</blockquote>\n<p>:::info<br>多重继承<br>:::</p>\n<p>&#x3D;&#x3D;如果一个类可能被继承（作为基类），那么它的析构函数就应该声明为 <code>virtual</code>&#x3D;&#x3D;<br>否则，当用基类指针（或引用）删除派生类对象时，派生类的析构函数不会被调用，造成资源泄漏<br>原因：virtual让析构函数变成动态绑定，delete时，程序会通过虚函数表（vtable）找到实际对象的类型</p>\n<ol start=\"10\">\n<li>为什么构造函数不能是虚函数？<br>虚函数依赖对象的 vptr<br>构造函数执行时，对象还没完全构造，vptr 还没初始化<br>每个有虚函数的类，编译器会生成一个 虚函数表（vtable），里面存着虚函数的地址。<br>每个对象内部有一个虚指针（vptr），指向自己的 vtable。<br>调用虚函数时：<br>对象 -&gt; vptr -&gt; vtable -&gt; 找到函数地址 -&gt; 调用</li>\n</ol>\n<ul>\n<li>构造函数执行时：</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>例子</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"string\">&quot;Animal sound\\n&quot;</span>; &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Animal</span>() &#123;  <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">        <span class=\"comment\">// 在这里，vptr 被设置为指向 Animal 的 vtable</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> : <span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123; cout &lt;&lt; <span class=\"string\">&quot;汪汪！\\n&quot;</span>; &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Dog</span>() &#123;  <span class=\"comment\">// Dog 的构造函数</span></span><br><span class=\"line\">        <span class=\"comment\">// 在这里，vptr 被更新为指向 Dog 的 vtable</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>调用 Dog dog;<br>先调用 Animal 的构造函数<br>此时，dog 对象的 vptr 被初始化为指向 Animal 的 vtable<br>再调用 Dog 的构造函数<br>vptr 被更新为指向 Dog 的 vtable</p>\n<p>:::danger<br>虚拟构造函数（后面在学）<br>:::</p>\n<ol start=\"11\">\n<li>重载（Overload）、重写（Override）、隐藏（Hiding）<br>Overload: 同一个作用域（通常是同一个类），函数名相同，参数列表不同（类型、个数、顺序），返回类型可以不同（但不能仅靠返回类型区分）<br>Override: 发生在继承关系中，基类函数必须是 virtual，函数名、参数列表、返回类型（或协变）完全相同，派生类中使用 override<br>Hiding: 两种情况① 函数名相同，参数不同；② 函数名相同，但基类函数不是 virtual</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>隐藏</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Animal speak&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">(string msg)</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Animal says: &quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> : <span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123;  <span class=\"comment\">// ✅ 重写 speak()</span></span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Dog barks&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 注意：speak(string) 被隐藏了！</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Dog d;</span><br><span class=\"line\">d.<span class=\"built_in\">speak</span>();           <span class=\"comment\">// 输出：Dog barks</span></span><br><span class=\"line\"><span class=\"comment\">// d.speak(&quot;hello&quot;); // 编译错误！speak(string) 被隐藏</span></span><br></pre></td></tr></table></figure>\n<p>解除隐藏：添加 <code>using Base::speak;</code></p>\n<ol start=\"12\">\n<li>深拷贝浅拷贝<br>深拷贝复制相同大小的内容到堆区，浅拷贝把源对象的指针赋给目标对象，多个对象的指针会指向同一块内存，容易导致双重释放</li>\n</ol>\n<p>类里面有动态分配的资源比如<code>int*</code>, <code>char*</code>必须进行深拷贝：</p>\n<ul>\n<li>析构函数</li>\n<li>构造函数和拷贝构造需要手动实现深拷贝（比如strcpy）</li>\n<li>&#x3D;&#x3D;重载赋值运算符&#x3D;&#x3D;</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>深拷贝</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyString</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">char</span>* data;  <span class=\"comment\">// 指向堆上的字符串</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 1️⃣ 构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">MyString</span>(<span class=\"type\">const</span> <span class=\"type\">char</span>* str = <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (str == <span class=\"literal\">nullptr</span> || str[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;\\0&#x27;</span>) &#123;</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"type\">char</span>[<span class=\"number\">1</span>];</span><br><span class=\"line\">            data[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"type\">char</span>[<span class=\"built_in\">strlen</span>(str) + <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(data, str);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2️⃣ 析构函数：释放资源</span></span><br><span class=\"line\">    ~<span class=\"built_in\">MyString</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] data;  <span class=\"comment\">// 释放堆内存</span></span><br><span class=\"line\">        data = <span class=\"literal\">nullptr</span>; <span class=\"comment\">// 防止悬空（可选）</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3️⃣ 拷贝构造函数：深拷贝</span></span><br><span class=\"line\">    <span class=\"built_in\">MyString</span>(<span class=\"type\">const</span> MyString&amp; other) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (other.data == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"type\">char</span>[<span class=\"built_in\">strlen</span>(other.data) + <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(data, other.data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 4️⃣ 拷贝赋值运算符：深拷贝赋值</span></span><br><span class=\"line\">    MyString&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> MyString&amp; other) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 自我赋值检查</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == &amp;other) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 先释放旧资源</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] data;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 分配新内存，深拷贝</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (other.data == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"type\">char</span>[<span class=\"built_in\">strlen</span>(other.data) + <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(data, other.data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 辅助函数：打印</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; (data ? data : <span class=\"string\">&quot;null&quot;</span>) &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<ol start=\"13\">\n<li><p>拷贝构造参数不是引用行吗？<br>拷贝构造的参数不是引用会导致无限递归，加const是为了避免通过形参修改实参</p>\n</li>\n<li><p>堆和栈的区别？<br>堆是由程序员手动申请和释放的，可以使用new和malloc申请，释放使用delete和free。内存空间较大，从低地址到高地址，访问速度较慢，有碎片问题，适合用于大对象、动态数组等<br>栈由编译器自动分配和释放，内存空间较小，从高地址到低地址，访问速度快，无碎片问题，适合用于局部变量、函数参数、返回地址</p>\n</li>\n</ol>\n<ul>\n<li>为什么栈快，堆慢？<br>栈：内存分配只是移动栈指针（esp），是 CPU 指令级操作，极快。<br>堆：需要调用操作系统 API，查找合适的内存块，维护空闲链表，效率较低。</li>\n</ul>\n<ol start=\"15\">\n<li>内联函数<br>请求编译器将函数体直接插入到调用处的机制，避免函数调用的开销<br>但是只是对编译器的建议，编译器不一定会实现<br>一般来说递归函数不适合内联，因为递归调用会生成临时变量，这些变量在函数退出时会被销毁，内联函数的临时变量会一直存在，导致内存泄漏；虚函数也不适合内联，内联函数在编译的时候确定代码，但虚函数是运行时多态</li>\n</ol>\n<ul>\n<li>使用<code>inline</code>关键字</li>\n<li>类内定义函数自动内联<br>内联函数比宏定义安全：</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>宏定义vs内联函数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAX(a,b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class=\"line\"><span class=\"type\">int</span> x = <span class=\"built_in\">MAX</span>(i++, j++);  <span class=\"comment\">// i 和 j 可能被 ++ 两次！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123; <span class=\"keyword\">return</span> a &gt; b ? a : b; &#125;</span><br><span class=\"line\"><span class=\"type\">int</span> x = <span class=\"built_in\">max</span>(i++, j++);  <span class=\"comment\">// 安全，参数只计算一次</span></span><br></pre></td></tr></table></figure>\n\n<p>定义写在类内不需要显式写inline关键字，定义在类外需要</p>\n<ol start=\"16\">\n<li>友元<br>允许某个函数或类“突破封装”，访问另一个类的私有（private）和保护（protected）成员。</li>\n</ol>\n<ul>\n<li>将非成员函数声明为友元函数：非成员函数可以直接访问<code>private</code>和<code>protected</code>成员</li>\n<li>将其他类的成员函数声明为友元函数：其他类成员函数可以直接访问<code>private</code>和<code>protected</code>成员</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>友元</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"type\">void</span> <span class=\"title\">Student::show</span><span class=\"params\">(Address *addr)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>友元类：一个类声明为另一个类的友元类，则该类中的所有成员函数都可以访问该类的<code>private</code>和<code>protected</code>成员</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>友元类</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Address</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"> <span class=\"built_in\">Address</span>(<span class=\"type\">char</span> *province, <span class=\"type\">char</span> *city, <span class=\"type\">char</span> *district);</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"> <span class=\"comment\">//将Student类声明为Address类的友元类，Student类中的所有成员函数都可以访问Address类的private成员</span></span><br><span class=\"line\"> <span class=\"keyword\">friend</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Student</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\"> <span class=\"type\">char</span> *m_province; <span class=\"comment\">//省份</span></span><br><span class=\"line\"> <span class=\"type\">char</span> *m_city; <span class=\"comment\">//城市</span></span><br><span class=\"line\"> <span class=\"type\">char</span> *m_district; <span class=\"comment\">//区（市区）</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"17\">\n<li>智能指针<br>new了没有delete —— 内存泄漏<br>delete之后没有置为nullptr&#x2F;指针指向的对象生命周期结束 —— 野指针<br>多个指针指向同一块内存 —— 悬空指针<br>&#x3D;&#x3D;智能指针本质是封装指针的类模板&#x3D;&#x3D;<br>RAII（Resource Acquisition Is Initialization）原则：资源在构造时获取，在析构时释放。</li>\n</ol>\n<ul>\n<li><code>unique_ptr</code>：独占指针，只能有一个指针指向一块内存，不能拷贝，不能赋值，析构时会自动释放内存。赋值只能用<code>std::move()</code>转移所有权，此时<code>u1</code>的所有权被转移给<code>u3</code>，<code>u1</code>变成空指针。<br><code>unique_ptr</code>支持管理数组，它会使用<code>delete[]</code>来释放数组内存（区别于<code>auto_ptr</code>，它使用<code>delete</code>来释放内存）</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>unique_ptr</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::unique_ptr&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">u1</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"type\">int</span>(<span class=\"number\">10</span>))</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// std::unique_ptr&lt;int&gt; u2 = u1;  // 编译错误，不允许拷贝</span></span><br><span class=\"line\">std::unique_ptr&lt;<span class=\"type\">int</span>&gt; u3 = std::<span class=\"built_in\">move</span>(u1);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>shared_ptr</code>：共享指针，多个指针可以指向一块内存，通过引用计数机制来管理对象的生命周期 。当一个<code>shared_ptr</code>指向对象时，引用计数加 1；当<code>shared_ptr</code>离开作用域或被重新赋值时，引用计数减 1，当引用计数为 0 时，对象会被自动释放<br><code>shared_ptr</code>在多线程环境中使用时，需要注意线程安全问题，因为引用计数的修改不是原子操作，可能会导致数据竞争 。为了解决这个问题，可以使用<code>std::atomic</code>来实现原子操作，或者使用互斥锁来保护引用计数的修改</li>\n<li><code>weak_ptr</code>：不能访问指针指向的对象，不控制对象的生命周期，只能判断指针是否为空，不能赋值，析构时会自动释放内存。主要是用来解决两个<code>shared_ptr</code>对象之间形成循环引用的问题（循环引用计数永远不会归零，导致这两个对象永远无法被销毁），当一个<code>shared_ptr</code>对象被另一个<code>shared_ptr</code>对象所引用时，两个对象之间形成循环引用，导致内存泄漏。<code>weak_ptr</code>对象用来监视<code>shared_ptr</code>中管理的资源是否存在，可以判断指针是否为空，也可以获取指针指向的对象，但无法访问对象。<code>weak_ptr</code>对象可以通过<code>lock()</code>方法获取对应的<code>shared_ptr</code>对象，如果对象仍然存在，则返回对应的<code>shared_ptr</code>对象，否则返回一个空的<code>shared_ptr</code>对象。<br>使用<code>weak_ptr</code>时，需要通过<code>lock</code>函数将其提升为<code>shared_ptr</code>，才能访问对象 。如果对象已经被释放，<code>lock</code>函数会返回一个空的<code>shared_ptr</code></li>\n</ul>\n<ol start=\"18\">\n<li>模板<br>允许你写一份代码，编译器根据不同的类型自动生成对应的函数或类<br>比如<code>swap</code>：</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>模板</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">swap</span><span class=\"params\">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class=\"line\">    T temp = a;</span><br><span class=\"line\">    a = b;</span><br><span class=\"line\">    b = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>基本语法：</p>\n<figure class=\"highlight c++\"><figcaption><span>函数模板</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> U&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">add</span><span class=\"params\">(T a, U b)</span> -&gt; <span class=\"title\">decltype</span><span class=\"params\">(a + b)</span> </span>&#123; <span class=\"comment\">// auto表示返回值在后面指定，编译器会根据a+b的结果自动推导返回类型</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><figcaption><span>类模板</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// template &lt;typename T1, typename T2, ...&gt;</span></span><br><span class=\"line\"><span class=\"comment\">// class ClassName &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     // 使用 T1, T2 等作为类型</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;;</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"type\">int</span> N&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Array</span> &#123;</span><br><span class=\"line\">    T data[N];</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    T&amp; <span class=\"keyword\">operator</span>[](<span class=\"type\">int</span> index) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> N; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>模板的实现（函数体）必须和声明放在同一个头文件中，STL就是模板</p>\n<ol start=\"19\">\n<li>volatile<br>原因：多处理器访问变量，缓存和主存可能存在不一致的问题<br>volatile让变量的读写都从主存中读写，而不是从缓存中读写</li>\n</ol>\n<ul>\n<li>易变性（可见性）: …可能不一致</li>\n<li>不可优化的: 编译器不要做优化</li>\n</ul>\n<figure class=\"highlight c\"><figcaption><span>volatile</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"type\">int</span> a;</span><br><span class=\"line\">a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(%d, a);  </span><br></pre></td></tr></table></figure>\n<p>不加<code>volatile</code>的话编译器可能会优化成&#96;printf(%d, 1);</p>\n<ul>\n<li>顺序执行的: 编译器会对无关的语句进行优化，可能会把<code>printf</code>放到<code>a = 1</code>的前面执行</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> j = <span class=\"number\">1</span></span><br><span class=\"line\">i += <span class=\"number\">1</span>;</span><br><span class=\"line\">j += <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>实际上执行顺序可能不是这样的（原因详见编译原理），写了<code>volatile</code>之后，编译器就不会改变顺序</p>\n<ul>\n<li>使用场景: 多线程共享字段（标志位）且经常被修改；中断服务程序和硬件设备访问相关的情况（指针可以是<code>volatile</code>）</li>\n<li>误区：<code>volatile</code>修饰的变量不能保证原子性，原子性需要通过原子操作或者锁来实现</li>\n</ul>\n<ol start=\"20\">\n<li>static<br>c语言中：</li>\n</ol>\n<ul>\n<li>用于局部变量（函数内部）<ul>\n<li>作用：使局部变量具有静态存储期（即程序运行期间一直存在），但作用域仍限于当前括号之内。</li>\n<li>初始化：只在第一次进入函数时初始化一次。</li>\n<li>默认值：未显式初始化则为 0。</li>\n</ul>\n</li>\n<li>用于全局变量或函数<ul>\n<li>作用：将变量或函数的链接属性（linkage）设为内部链接（internal linkage），即仅在当前源文件中可见，其他文件无法访问。</li>\n<li>目的：实现封装，避免命名冲突。<br>c++中：<br><code>C++</code>继承了<code>C</code>中<code>static</code>的所有用法，还增加了面向对象场景下的新用途</li>\n</ul>\n</li>\n<li>静态成员变量：<ul>\n<li>属于类本身，而不是类的某个对象。</li>\n<li>所有对象共享同一个静态成员。</li>\n<li>必须在类外定义（C++17 前），C++17 起可用 inline static 在类内定义。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>static</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">int</span> count;       <span class=\"comment\">// 声明</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> MyClass::count = <span class=\"number\">0</span>;     <span class=\"comment\">// 定义（C++17 前必需）</span></span><br><span class=\"line\"><span class=\"comment\">// 或 C++17 起：</span></span><br><span class=\"line\"><span class=\"comment\">// inline static int count = 0;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>静态成员函数：<ul>\n<li>不属于任何对象，不能访问非静态成员（因为没有 this 指针）。</li>\n<li>可直接通过类名调用。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>static</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不能访问非静态成员</span></span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Static function\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">MyClass::<span class=\"built_in\">print</span>(); <span class=\"comment\">// 无需对象</span></span><br></pre></td></tr></table></figure>\n<p>C++11 起，static 局部变量的初始化自动线程安全，c语言没有这种保证</p>\n<ol start=\"21\">\n<li>c语言保证线程安全<br>C 语言标准库本身（C89&#x2F;C99&#x2F;C11 等）在早期版本中并不直接提供线程或锁操作，但 C11 标准（ISO&#x2F;IEC 9899:2011）引入了多线程支持，包括锁（mutex）等同步原语。<br>C11 引入了 &lt;threads.h&gt; 头文件，提供了类似 POSIX 的线程和锁接口。</li>\n</ol>\n<figure class=\"highlight c\"><figcaption><span>mutex</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;threads.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 互斥锁类型</span></span><br><span class=\"line\"><span class=\"type\">mtx_t</span> mutex;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化锁</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">mtx_init</span><span class=\"params\">(<span class=\"type\">mtx_t</span> *mtx, <span class=\"type\">int</span> type)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加锁（阻塞）</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">mtx_lock</span><span class=\"params\">(<span class=\"type\">mtx_t</span> *mtx)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 尝试加锁（非阻塞）</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">mtx_trylock</span><span class=\"params\">(<span class=\"type\">mtx_t</span> *mtx)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解锁</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">mtx_unlock</span><span class=\"params\">(<span class=\"type\">mtx_t</span> *mtx)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 销毁锁</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">mtx_destroy</span><span class=\"params\">(<span class=\"type\">mtx_t</span> *mtx)</span>;</span><br></pre></td></tr></table></figure>\n<p>比如线程安全计数器</p>\n<figure class=\"highlight c\"><figcaption><span>mutex</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;threads.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> counter = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">mtx_t</span> mutex;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">increment</span><span class=\"params\">(<span class=\"type\">void</span>* arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++) &#123;</span><br><span class=\"line\">        mtx_lock(&amp;mutex);</span><br><span class=\"line\">        counter++;</span><br><span class=\"line\">        mtx_unlock(&amp;mutex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    mtx_init(&amp;mutex, mtx_plain);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">thrd_t</span> t1, t2;</span><br><span class=\"line\">    thrd_create(&amp;t1, increment, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    thrd_create(&amp;t2, increment, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    thrd_join(t1, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    thrd_join(t2, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Counter = %d\\n&quot;</span>, counter); <span class=\"comment\">// 应为 200000</span></span><br><span class=\"line\">    mtx_destroy(&amp;mutex);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实际上用得多的可能是pthreads</p>\n<figure class=\"highlight c\"><figcaption><span>pthreads</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或动态初始化</span></span><br><span class=\"line\">pthread_mutex_init(&amp;mutex, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加锁</span></span><br><span class=\"line\">pthread_mutex_lock(&amp;mutex);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 尝试加锁</span></span><br><span class=\"line\">pthread_mutex_trylock(&amp;mutex);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解锁</span></span><br><span class=\"line\">pthread_mutex_unlock(&amp;mutex);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 销毁</span></span><br><span class=\"line\">pthread_mutex_destroy(&amp;mutex);</span><br></pre></td></tr></table></figure>\n<p>示例</p>\n<figure class=\"highlight c\"><figcaption><span>pthreads</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> counter = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span>* <span class=\"title function_\">increment</span><span class=\"params\">(<span class=\"type\">void</span>* arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++) &#123;</span><br><span class=\"line\">        pthread_mutex_lock(&amp;mutex);</span><br><span class=\"line\">        counter++;</span><br><span class=\"line\">        pthread_mutex_unlock(&amp;mutex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">pthread_t</span> t1, t2;</span><br><span class=\"line\">    pthread_create(&amp;t1, <span class=\"literal\">NULL</span>, increment, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    pthread_create(&amp;t2, <span class=\"literal\">NULL</span>, increment, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    pthread_join(t1, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    pthread_join(t2, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Counter = %d\\n&quot;</span>, counter);</span><br><span class=\"line\">    pthread_mutex_destroy(&amp;mutex);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"22\">\n<li>typedef 和 define</li>\n</ol>\n<p>#define 是“文本替换”，像 Word 的“查找替换”，预处理的时候替换；<br>typedef 是“类型定义”的关键字，是编译器理解的真正类型别名。typedef 可以定义新的类型，也可以定义新的类型别名，但不能定义常量&#x2F;宏函数，在编译的时候处理</p>\n<ol start=\"23\">\n<li>数组指针和指针数组<br>数组指针：<br>指向数组的指针</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>array pointer</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> *p[<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> b[<span class=\"number\">12</span>] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>, <span class=\"number\">12</span>&#125;;</span><br><span class=\"line\">p = b;</span><br></pre></td></tr></table></figure>\n<p>指针数组：<br>数组的元素是指针</p>\n<figure class=\"highlight c++\"><figcaption><span>pointer array</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>* p[<span class=\"number\">4</span>];</span><br></pre></td></tr></table></figure>\n\n<ol start=\"24\">\n<li>函数指针<br>函数指针：<br>指向函数的指针</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>function pointer</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> (*p)(<span class=\"type\">int</span>, <span class=\"type\">int</span>); <span class=\"comment\">// 括号不能省略</span></span><br><span class=\"line\">p = add;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123; <span class=\"keyword\">return</span> a + b; &#125;</span><br><span class=\"line\"><span class=\"type\">int</span> result = <span class=\"built_in\">p</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, result); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>函数指针没有自增和自减运算</p>\n<blockquote>\n<p>区分 int *p 和 int (*p)<br>前者是一个指向 int 类型的指针，后者有可能是一个数组指针或是返回 int 类型的函数指针</p>\n</blockquote>\n<ol start=\"25\">\n<li>如何保证线程安全？</li>\n</ol>\n<ul>\n<li>锁</li>\n<li>原子操作</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>atomic</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;atomic&gt;</span></span></span><br><span class=\"line\">std::atomic&lt;<span class=\"type\">int</span>&gt; counter;</span><br><span class=\"line\">counter.<span class=\"built_in\">fetch_add</span>(<span class=\"number\">1</span>);   <span class=\"comment\">// fetch_sub(), fetch_and(), fetch_or()...</span></span><br><span class=\"line\">counter.<span class=\"built_in\">load</span>();</span><br><span class=\"line\">counter.<span class=\"built_in\">store</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">counter.<span class=\"built_in\">exchange</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">counter.<span class=\"built_in\">compare_exchange_strong</span>(old_value, new_value);  <span class=\"comment\">// 如果old_value == counter，则将 counter 设为 new_value</span></span><br><span class=\"line\">counter.<span class=\"built_in\">compare_exchange_weak</span>(old_value, new_value);    <span class=\"comment\">// 区别：weak 版本允许虚假失败，需要循环</span></span><br><span class=\"line\">counter.<span class=\"built_in\">is_lock_free</span>();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>线程同步原语</li>\n</ul>\n<ol start=\"26\">\n<li><code>const</code>用法</li>\n</ol>\n<ul>\n<li>常量变量<br>必须在定义时初始化</li>\n<li>常量指针 vs 指针常量：见上</li>\n<li>引用与 const：见上<code>const 引用</code></li>\n<li>类中的 const:<ul>\n<li>const成员函数：不能修改对象成员变量，不能调用非 const 成员函数</li>\n<li>const对象：const 对象只能调用 const 成员函数</li>\n</ul>\n</li>\n</ul>\n<ol start=\"27\">\n<li><p>多线程<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucnVub29iLmNvbS9jcGx1c3BsdXMvY3BwLW11bHRpdGhyZWFkaW5nLmh0bWw=\">https://www.runoob.com/cplusplus/cpp-multithreading.html</span></p>\n</li>\n<li><p>协程</p>\n</li>\n</ol>\n",
            "tags": [
                "C++"
            ]
        },
        {
            "id": "http://example.com/2025/10/15/note/20251015/",
            "url": "http://example.com/2025/10/15/note/20251015/",
            "title": "20251015力扣刷题笔记",
            "date_published": "2025-10-14T16:00:00.000Z",
            "content_html": "<h2 id=\"一、C-常用容器总览\"><a href=\"#一、C-常用容器总览\" class=\"headerlink\" title=\"一、C++ 常用容器总览\"></a>一、C++ 常用容器总览</h2><table>\n<thead>\n<tr>\n<th>容器</th>\n<th>类型</th>\n<th>底层结构</th>\n<th>是否有序</th>\n<th>是否去重</th>\n<th>主要用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>vector</code></td>\n<td>序列容器</td>\n<td>动态数组</td>\n<td>否</td>\n<td>否</td>\n<td>动态数组，随机访问</td>\n</tr>\n<tr>\n<td><code>deque</code></td>\n<td>序列容器</td>\n<td>双端队列（分段连续）</td>\n<td>否</td>\n<td>否</td>\n<td>首尾高效插入</td>\n</tr>\n<tr>\n<td><code>list</code></td>\n<td>序列容器</td>\n<td>双向链表</td>\n<td>否</td>\n<td>否</td>\n<td>频繁中间插入&#x2F;删除</td>\n</tr>\n<tr>\n<td><code>forward_list</code></td>\n<td>序列容器</td>\n<td>单向链表</td>\n<td>否</td>\n<td>否</td>\n<td>节省内存的链表</td>\n</tr>\n<tr>\n<td><code>array</code></td>\n<td>序列容器</td>\n<td>静态数组</td>\n<td>否</td>\n<td>否</td>\n<td>固定大小数组</td>\n</tr>\n<tr>\n<td><code>stack</code></td>\n<td>容器适配器</td>\n<td><code>deque</code>（默认）</td>\n<td>否</td>\n<td>否</td>\n<td>栈（LIFO）</td>\n</tr>\n<tr>\n<td><code>queue</code></td>\n<td>容器适配器</td>\n<td><code>deque</code>（默认）</td>\n<td>否</td>\n<td>否</td>\n<td>队列（FIFO）</td>\n</tr>\n<tr>\n<td><code>priority_queue</code></td>\n<td>容器适配器</td>\n<td><code>vector</code>（默认）</td>\n<td>是（堆序）</td>\n<td>否</td>\n<td>优先队列</td>\n</tr>\n<tr>\n<td><code>set</code></td>\n<td>关联容器</td>\n<td>红黑树</td>\n<td>是（升序）</td>\n<td>是</td>\n<td>有序唯一集合</td>\n</tr>\n<tr>\n<td><code>multiset</code></td>\n<td>关联容器</td>\n<td>红黑树</td>\n<td>是</td>\n<td>否</td>\n<td>有序可重复集合</td>\n</tr>\n<tr>\n<td><code>map</code></td>\n<td>关联容器</td>\n<td>红黑树</td>\n<td>是</td>\n<td>是（按键）</td>\n<td>有序键值对</td>\n</tr>\n<tr>\n<td><code>multimap</code></td>\n<td>关联容器</td>\n<td>红黑树</td>\n<td>是</td>\n<td>否</td>\n<td>有序可重复键值对</td>\n</tr>\n<tr>\n<td><code>unordered_set</code></td>\n<td>无序关联容器</td>\n<td>哈希表</td>\n<td>否</td>\n<td>是</td>\n<td>无序唯一集合</td>\n</tr>\n<tr>\n<td><code>unordered_multiset</code></td>\n<td>无序关联容器</td>\n<td>哈希表</td>\n<td>否</td>\n<td>否</td>\n<td>无序可重复集合</td>\n</tr>\n<tr>\n<td><code>unordered_map</code></td>\n<td>无序关联容器</td>\n<td>哈希表</td>\n<td>否</td>\n<td>是（按键）</td>\n<td>无序键值对</td>\n</tr>\n<tr>\n<td><code>unordered_multimap</code></td>\n<td>无序关联容器</td>\n<td>哈希表</td>\n<td>否</td>\n<td>否</td>\n<td>无序可重复键值对</td>\n</tr>\n</tbody></table>\n<h2 id=\"二、各容器操作复杂度对比\"><a href=\"#二、各容器操作复杂度对比\" class=\"headerlink\" title=\"二、各容器操作复杂度对比\"></a>二、各容器操作复杂度对比</h2><h3 id=\"1-vector\"><a href=\"#1-vector\" class=\"headerlink\" title=\"1. vector&lt;T&gt;\"></a>1. <code>vector&lt;T&gt;</code></h3><ul>\n<li><strong>底层</strong>：动态数组（连续内存）</li>\n<li><strong>特点</strong>：支持随机访问，尾部操作快，中间插入慢。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>复杂度</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>push_back()</code></td>\n<td>平均 O(1)，最坏 O(n)</td>\n<td>扩容时复制</td>\n</tr>\n<tr>\n<td><code>pop_back()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>insert(it, x)</code></td>\n<td>O(n)</td>\n<td>中间插入需移动</td>\n</tr>\n<tr>\n<td><code>erase(it)</code></td>\n<td>O(n)</td>\n<td>删除后需移动</td>\n</tr>\n<tr>\n<td><code>operator[]</code> &#x2F; <code>at()</code></td>\n<td>O(1)</td>\n<td>随机访问</td>\n</tr>\n<tr>\n<td><code>size()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>begin()</code> &#x2F; <code>end()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>适合：频繁随机访问、尾部增删<br>不适合：频繁中间插入&#x2F;删除</p>\n</blockquote>\n<hr>\n<h3 id=\"2-deque（双端队列）\"><a href=\"#2-deque（双端队列）\" class=\"headerlink\" title=\"2. deque&lt;T&gt;（双端队列）\"></a>2. <code>deque&lt;T&gt;</code>（双端队列）</h3><ul>\n<li><strong>底层</strong>：分段连续数组（多个小数组）</li>\n<li><strong>特点</strong>：首尾操作都快，支持随机访问。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>复杂度</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>push_front()</code> &#x2F; <code>push_back()</code></td>\n<td>O(1)</td>\n<td>首尾插入都快</td>\n</tr>\n<tr>\n<td><code>pop_front()</code> &#x2F; <code>pop_back()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>insert()</code> &#x2F; <code>erase()</code>（中间）</td>\n<td>O(n)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>operator[]</code> &#x2F; <code>at()</code></td>\n<td>O(1)</td>\n<td>支持随机访问</td>\n</tr>\n<tr>\n<td><code>size()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>适合：需要首尾高效插入的场景（如滑动窗口）<br>注意：迭代器失效规则比 <code>vector</code> 复杂</p>\n</blockquote>\n<hr>\n<h3 id=\"3-list（双向链表）\"><a href=\"#3-list（双向链表）\" class=\"headerlink\" title=\"3. list&lt;T&gt;（双向链表）\"></a>3. <code>list&lt;T&gt;</code>（双向链表）</h3><ul>\n<li><strong>底层</strong>：双向链表</li>\n<li><strong>特点</strong>：任意位置插入&#x2F;删除 O(1)，但不支持随机访问。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>复杂度</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>push_front()</code> &#x2F; <code>push_back()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>insert(it, x)</code></td>\n<td>O(1)</td>\n<td>已知位置</td>\n</tr>\n<tr>\n<td><code>erase(it)</code></td>\n<td>O(1)</td>\n<td>已知位置</td>\n</tr>\n<tr>\n<td><code>operator[]</code></td>\n<td>不支持</td>\n<td></td>\n</tr>\n<tr>\n<td><code>find()</code></td>\n<td>O(n)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>size()</code></td>\n<td>C++11 起 O(1)，之前 O(n)</td>\n<td></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>适合：频繁中间插入&#x2F;删除<br>不适合：随机访问、缓存不友好</p>\n</blockquote>\n<hr>\n<h3 id=\"4-forward-list（单向链表）\"><a href=\"#4-forward-list（单向链表）\" class=\"headerlink\" title=\"4. forward_list&lt;T&gt;（单向链表）\"></a>4. <code>forward_list&lt;T&gt;</code>（单向链表）</h3><ul>\n<li><strong>底层</strong>：单向链表</li>\n<li><strong>特点</strong>：比 <code>list</code> 更省内存，但只能单向遍历。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>复杂度</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>push_front()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>insert_after()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>erase_after()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td>不支持 <code>push_back()</code></td>\n<td>—</td>\n<td></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>适合：内存敏感、只需前向遍历的场景</p>\n</blockquote>\n<hr>\n<h3 id=\"5-array\"><a href=\"#5-array\" class=\"headerlink\" title=\"5. array&lt;T, N&gt;\"></a>5. <code>array&lt;T, N&gt;</code></h3><ul>\n<li><strong>底层</strong>：静态数组（栈上内存）</li>\n<li><strong>特点</strong>：大小固定，性能极高。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>复杂度</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>operator[]</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>at()</code></td>\n<td>O(1)</td>\n<td>带边界检查</td>\n</tr>\n<tr>\n<td><code>size()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td>所有操作</td>\n<td>O(1)</td>\n<td>固定大小</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>适合：小数据、固定大小、高性能场景</p>\n</blockquote>\n<hr>\n<h3 id=\"6-set-map\"><a href=\"#6-set-map\" class=\"headerlink\" title=\"6. set&lt;T&gt; &#x2F; map&lt;K,V&gt;\"></a>6. <code>set&lt;T&gt;</code> &#x2F; <code>map&lt;K,V&gt;</code></h3><ul>\n<li><strong>底层</strong>：<strong>红黑树</strong>（自平衡二叉搜索树）</li>\n<li><strong>特点</strong>：自动排序、自动去重（<code>set</code> 和 <code>map</code> 键唯一）</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>复杂度</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>insert()</code></td>\n<td>O(log n)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>find()</code></td>\n<td>O(log n)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>erase()</code></td>\n<td>O(log n)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>size()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td>遍历</td>\n<td>O(n)</td>\n<td>有序输出</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>适合：需要有序、去重、查找的场景</p>\n</blockquote>\n<hr>\n<h3 id=\"7-unordered-set-unordered-map\"><a href=\"#7-unordered-set-unordered-map\" class=\"headerlink\" title=\"7. unordered_set&lt;T&gt; &#x2F; unordered_map&lt;K,V&gt;\"></a>7. <code>unordered_set&lt;T&gt;</code> &#x2F; <code>unordered_map&lt;K,V&gt;</code></h3><ul>\n<li><strong>底层</strong>：<strong>哈希表</strong>（开链法或开放寻址）</li>\n<li><strong>特点</strong>：平均极快，但无序，最坏 O(n)</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>复杂度</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>insert()</code></td>\n<td>平均 O(1)，最坏 O(n)</td>\n<td>哈希冲突时退化</td>\n</tr>\n<tr>\n<td><code>find()</code></td>\n<td>平均 O(1)，最坏 O(n)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>erase()</code></td>\n<td>平均 O(1)，最坏 O(n)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>size()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td>负载因子</td>\n<td>影响性能</td>\n<td>可调 <code>max_load_factor()</code></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>适合：大数据、高频查找、不在乎顺序<br>不适合：需要有序输出</p>\n</blockquote>\n<h3 id=\"8-容器适配器（stack-queue-priority-queue）\"><a href=\"#8-容器适配器（stack-queue-priority-queue）\" class=\"headerlink\" title=\"8. 容器适配器（stack, queue, priority_queue）\"></a>8. 容器适配器（<code>stack</code>, <code>queue</code>, <code>priority_queue</code>）</h3><table>\n<thead>\n<tr>\n<th>容器</th>\n<th>默认底层</th>\n<th>特点</th>\n<th>操作复杂度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>stack&lt;T&gt;</code></td>\n<td><code>deque</code></td>\n<td>后进先出（LIFO）</td>\n<td><code>push</code>&#x2F;<code>pop</code>&#x2F;<code>top</code>: O(1)</td>\n</tr>\n<tr>\n<td><code>queue&lt;T&gt;</code></td>\n<td><code>deque</code></td>\n<td>先进先出（FIFO）</td>\n<td><code>push</code>&#x2F;<code>pop</code>&#x2F;<code>front</code>: O(1)</td>\n</tr>\n<tr>\n<td><code>priority_queue&lt;T&gt;</code></td>\n<td><code>vector</code> + 堆</td>\n<td>最大&#x2F;最小元素在顶</td>\n<td><code>push</code>: O(log n), <code>top</code>: O(1), <code>pop</code>: O(log n)</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>它们<strong>不是真正容器</strong>，而是基于其他容器的封装，接口受限。</p>\n</blockquote>\n<h2 id=\"选择\"><a href=\"#选择\" class=\"headerlink\" title=\"选择\"></a>选择</h2><table>\n<thead>\n<tr>\n<th>需求</th>\n<th>推荐容器</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>动态数组，随机访问</td>\n<td><code>vector</code></td>\n</tr>\n<tr>\n<td>首尾都能高效插入</td>\n<td><code>deque</code></td>\n</tr>\n<tr>\n<td>频繁中间插入&#x2F;删除</td>\n<td><code>list</code></td>\n</tr>\n<tr>\n<td>固定大小数组</td>\n<td><code>array</code></td>\n</tr>\n<tr>\n<td>快速查找、去重（不在乎顺序）</td>\n<td><code>unordered_set</code> &#x2F; <code>unordered_map</code></td>\n</tr>\n<tr>\n<td>需要有序输出、去重</td>\n<td><code>set</code> &#x2F; <code>map</code></td>\n</tr>\n<tr>\n<td>栈操作</td>\n<td><code>stack</code></td>\n</tr>\n<tr>\n<td>队列操作</td>\n<td><code>queue</code></td>\n</tr>\n<tr>\n<td>找最大&#x2F;最小元素（堆）</td>\n<td><code>priority_queue</code></td>\n</tr>\n</tbody></table>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><table>\n<thead>\n<tr>\n<th>口诀</th>\n<th>对应容器</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>“要快用 unordered”</strong></td>\n<td><code>unordered_set/map</code>（平均 O(1)）</td>\n</tr>\n<tr>\n<td><strong>“要序用 set&#x2F;map”</strong></td>\n<td><code>set/map</code>（O(log n)，有序）</td>\n</tr>\n<tr>\n<td><strong>“通用选 vector”</strong></td>\n<td><code>vector</code>（最常用）</td>\n</tr>\n<tr>\n<td><strong>“首尾快用 deque”</strong></td>\n<td><code>deque</code>（双端高效）</td>\n</tr>\n<tr>\n<td><strong>“中间删用 list”</strong></td>\n<td><code>list</code>（任意位置 O(1) 删除）</td>\n</tr>\n<tr>\n<td><strong>“最大最小用堆”</strong></td>\n<td><code>priority_queue</code></td>\n</tr>\n</tbody></table>\n<p>LRU：</p>\n<figure class=\"highlight c++\"><figcaption><span>lru</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 哈希表+双向链表</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">DNode</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">DNode</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> key, value;</span><br><span class=\"line\">    DNode* pre;</span><br><span class=\"line\">    DNode* next;</span><br><span class=\"line\">    <span class=\"built_in\">DNode</span>(): <span class=\"built_in\">key</span>(<span class=\"number\">-1</span>), <span class=\"built_in\">value</span>(<span class=\"number\">-1</span>), <span class=\"built_in\">pre</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">next</span>(<span class=\"literal\">nullptr</span>)&#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">DNode</span>(<span class=\"type\">int</span> key, <span class=\"type\">int</span> val): <span class=\"built_in\">key</span>(key), <span class=\"built_in\">value</span>(val), <span class=\"built_in\">pre</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">next</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LRUCache</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">LRUCache</span>(<span class=\"type\">int</span> capacity) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;capacity = capacity;</span><br><span class=\"line\">        head = <span class=\"keyword\">new</span> <span class=\"built_in\">DNode</span>();</span><br><span class=\"line\">        tail = <span class=\"keyword\">new</span> <span class=\"built_in\">DNode</span>();</span><br><span class=\"line\">        head-&gt;next = tail;</span><br><span class=\"line\">        tail-&gt;pre = head;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mp.<span class=\"built_in\">find</span>(key) != mp.<span class=\"built_in\">end</span>())&#123;</span><br><span class=\"line\">            DNode* pre = mp[key]-&gt;pre;</span><br><span class=\"line\">            pre-&gt;next = mp[key]-&gt;next;</span><br><span class=\"line\">            mp[key]-&gt;next-&gt;pre = pre;</span><br><span class=\"line\">            DNode* next = head-&gt;next;</span><br><span class=\"line\">            head-&gt;next = mp[key];</span><br><span class=\"line\">            mp[key]-&gt;pre = head;</span><br><span class=\"line\">            mp[key]-&gt;next = next;</span><br><span class=\"line\">            next-&gt;pre = mp[key];</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mp[key]-&gt;value;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">put</span><span class=\"params\">(<span class=\"type\">int</span> key, <span class=\"type\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mp.<span class=\"built_in\">find</span>(key) != mp.<span class=\"built_in\">end</span>())&#123;</span><br><span class=\"line\">            mp[key]-&gt;value = value;</span><br><span class=\"line\">            DNode* pre = mp[key]-&gt;pre;</span><br><span class=\"line\">            pre-&gt;next = mp[key]-&gt;next;</span><br><span class=\"line\">            mp[key]-&gt;next-&gt;pre = pre;</span><br><span class=\"line\">            DNode* next = head-&gt;next;</span><br><span class=\"line\">            head-&gt;next = mp[key];</span><br><span class=\"line\">            mp[key]-&gt;pre = head;</span><br><span class=\"line\">            mp[key]-&gt;next = next;</span><br><span class=\"line\">            next-&gt;pre = mp[key];</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>-&gt;size &lt; <span class=\"keyword\">this</span>-&gt;capacity)&#123;</span><br><span class=\"line\">                DNode* p = head-&gt;next;</span><br><span class=\"line\">                DNode* newNode = <span class=\"keyword\">new</span> <span class=\"built_in\">DNode</span>(key, value);</span><br><span class=\"line\">                head-&gt;next = newNode;</span><br><span class=\"line\">                newNode-&gt;pre = head;</span><br><span class=\"line\">                newNode-&gt;next = p;</span><br><span class=\"line\">                p-&gt;pre = newNode;</span><br><span class=\"line\">                mp[key] = newNode;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>-&gt;size++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                DNode* remove = tail-&gt;pre;</span><br><span class=\"line\">                mp.<span class=\"built_in\">erase</span>(remove-&gt;key);</span><br><span class=\"line\">                remove-&gt;pre-&gt;next = tail;</span><br><span class=\"line\">                tail-&gt;pre = remove-&gt;pre;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> remove;</span><br><span class=\"line\">                DNode* newNode = <span class=\"keyword\">new</span> <span class=\"built_in\">DNode</span>(key, value);</span><br><span class=\"line\">                DNode* nxt = head-&gt;next;</span><br><span class=\"line\">                head-&gt;next = newNode;</span><br><span class=\"line\">                newNode-&gt;pre = head;</span><br><span class=\"line\">                newNode-&gt;next = nxt;</span><br><span class=\"line\">                nxt-&gt;pre = newNode;</span><br><span class=\"line\">                mp[key] = newNode;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> capacity;</span><br><span class=\"line\">    <span class=\"type\">int</span> size;</span><br><span class=\"line\">    unordered_map&lt;<span class=\"type\">int</span>, DNode*&gt; mp;</span><br><span class=\"line\">    DNode* head;</span><br><span class=\"line\">    DNode* tail;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>反转链表</p>\n<figure class=\"highlight c++\"><figcaption><span>reverse</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ListNode</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> val;</span><br><span class=\"line\">    ListNode *next;</span><br><span class=\"line\">    <span class=\"built_in\">ListNode</span>() : <span class=\"built_in\">val</span>(<span class=\"number\">0</span>), <span class=\"built_in\">next</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">ListNode</span>(<span class=\"type\">int</span> x) : <span class=\"built_in\">val</span>(x), <span class=\"built_in\">next</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">ListNode</span>(<span class=\"type\">int</span> x, ListNode *next) : <span class=\"built_in\">val</span>(x), <span class=\"built_in\">next</span>(next) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">reverseList</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">    ListNode* prev = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    ListNode* curr = head;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (curr != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        ListNode* next = curr-&gt;next; <span class=\"comment\">// 保存下一个节点</span></span><br><span class=\"line\">        curr-&gt;next = prev;           <span class=\"comment\">// 反转当前节点</span></span><br><span class=\"line\">        prev = curr;                 <span class=\"comment\">// prev 前进</span></span><br><span class=\"line\">        curr = next;                 <span class=\"comment\">// curr 前进</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> prev; <span class=\"comment\">// 新的头节点</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>",
            "tags": [
                "容器"
            ]
        },
        {
            "id": "http://example.com/2025/10/13/computer-science/DS/ch7/",
            "url": "http://example.com/2025/10/13/computer-science/DS/ch7/",
            "title": "ch7",
            "date_published": "2025-10-12T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch7\"><a href=\"#Ch7\" class=\"headerlink\" title=\"Ch7\"></a>Ch7</h1>",
            "tags": [
                "查找"
            ]
        },
        {
            "id": "http://example.com/2025/10/13/computer-science/DS/ch8/",
            "url": "http://example.com/2025/10/13/computer-science/DS/ch8/",
            "title": "ch8",
            "date_published": "2025-10-12T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch8\"><a href=\"#Ch8\" class=\"headerlink\" title=\"Ch8\"></a>Ch8</h1><h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p>直接看代码</p>\n<figure class=\"highlight c++\"><figcaption><span>bubbleSort</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(<span class=\"type\">int</span> a[], <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; n - i - <span class=\"number\">1</span>; j++) &#123;   <span class=\"comment\">// j从0开始到n-i-1，原因是每次遍历之后第i大的元素已经被放到后面了，从后往前的顺序是对的</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a[j] &gt; a[j + <span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                <span class=\"built_in\">swap</span>(a[j], a[j + <span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度$O(n^2)$，空间复杂度$O(1)$</p>\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><p>每次找最小的和循环的第一个元素交换</p>\n<figure class=\"highlight c++\"><figcaption><span>selectionSort</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">selectionSort</span><span class=\"params\">(<span class=\"type\">int</span> a[], <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0l</span> i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> min_index = i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = i; j &lt; n; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a[j] &lt; a[min_index])&#123;</span><br><span class=\"line\">                min_index = j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(a[i], a[min_index]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度$O(n^2)$，空间复杂度$O(1)$</p>\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p>将列表分为已排序部分和未排序部分。初始时，已排序部分只包含第一个元素，未排序部分包含剩余元素，从未排序部分中取出第一个元素，插入已排序部分合适位置。</p>\n<figure class=\"highlight c++\"><figcaption><span>insertionSort</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insertionSort</span><span class=\"params\">(<span class=\"type\">int</span> a[], <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> j = i;</span><br><span class=\"line\">        <span class=\"type\">int</span> key = a[i];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j &gt; <span class=\"number\">0</span> &amp;&amp; key &lt; a[j - <span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">            a[j] = a[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        a[j] = key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度$O(n^2)$，空间复杂度$O(1)$</p>\n<h2 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h2><p>将待排序的列表分成若干子列表，对每个子列表进行插入排序，逐步缩小子列表的间隔，常见的增量序列有希尔增量（n&#x2F;2, n&#x2F;4, …, 1）</p>\n<figure class=\"highlight c++\"><figcaption><span>shellSort</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shellSort</span><span class=\"params\">(<span class=\"type\">int</span> a[], <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> gap = n / <span class=\"number\">2</span>; gap &gt; <span class=\"number\">0</span>; gap /= <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = gap; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> j = i; </span><br><span class=\"line\">            <span class=\"type\">int</span> key = a[i];</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(j &gt;= gap &amp;&amp; key &lt; a[j - gap])&#123;</span><br><span class=\"line\">                a[j] = a[j - gap];</span><br><span class=\"line\">                j -= gap;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            a[j] = key;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>best time complexity$O(nlog_n)$, worst time complexity$O(n^2)$，空间复杂度$O(1)$</p>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><p>每次分成两半，像把两个有序链表合并成一个有序链表一样，将两个有序的子序列合并成一个有序的序列，然后递归处理每个子序列，直到处理完所有元素</p>\n<figure class=\"highlight c++\"><figcaption><span>mergeSort</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(<span class=\"type\">int</span> &amp;a[], <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度$O(nlog_n)$,空间复杂度$O(n)$</p>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><p>从列表中选择一个元素作为基准（pivot）。选择方式可以是第一个元素、最后一个元素、中间元素或随机元素,使得所有小于基准元素的元素都在基准的左侧，所有大于基准元素的元素都在基准的右侧</p>\n<ol>\n<li>选择pivot</li>\n<li>分割列表：把小于pivot的元素放在pivot的左侧，大于pivot的元素放在pivot的右侧，最终pivot的位置是正确的</li>\n<li>递归处理</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>quickSort</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(<span class=\"type\">int</span> a[], <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &gt;= right) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> pivot = a[(left + right) / <span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> i = left, j = right;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt;= j) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (a[i] &lt; pivot) i++;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (a[j] &gt; pivot) j--;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt;= j) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 交换</span></span><br><span class=\"line\">            <span class=\"type\">int</span> temp = a[i];</span><br><span class=\"line\">            a[i] = a[j];</span><br><span class=\"line\">            a[j] = temp;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">quickSort</span>(a, left, j);</span><br><span class=\"line\">    <span class=\"built_in\">quickSort</span>(a, i, right);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度$O(nlog_n)$,空间复杂度$O(log_n)$</p>\n<h2 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h2><p>建立一个堆，让它自己排序（shift_down和shift_up）<br>最大堆用于升序排序，最小堆用于降序排序</p>\n<figure class=\"highlight c++\"><figcaption><span>heapSort</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">heapSort</span><span class=\"params\">(<span class=\"type\">int</span> a[], <span class=\"type\">int</span> n)</span> </span>&#123;&#125;    <span class=\"comment\">// 有待补充</span></span><br></pre></td></tr></table></figure>\n<p>时间复杂度$O(nlog_n)$,空间复杂度$O(n)$</p>\n<h2 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h2><p>将数据分到若干个桶中，每个桶再进行排序，最后将各个桶的元素合并</p>\n<figure class=\"highlight c++\"><figcaption><span>bucketSort</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bucketSort</span><span class=\"params\">(<span class=\"type\">int</span> a[], <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度$O(n+k)$,空间复杂度$O(n+k)$</p>\n",
            "tags": [
                "排序"
            ]
        },
        {
            "id": "http://example.com/2025/10/11/computer-science/DS/ch6/",
            "url": "http://example.com/2025/10/11/computer-science/DS/ch6/",
            "title": "ch6",
            "date_published": "2025-10-10T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch6\"><a href=\"#Ch6\" class=\"headerlink\" title=\"Ch6\"></a>Ch6</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>$$<br>G &#x3D; (V, E)<br>$$<br>图的顶点至少要有一个，边可以没有<br>顶点数：$|V|$<br>边数：$|E|$</p>\n<ul>\n<li>有向图、无向图</li>\n<li>简单图（不存在重复边、不存在到自身的边）、多重图</li>\n<li>度、入度、出度<br>$$<br>TD(v) &#x3D; ID(v) + OD(v)<br>$$</li>\n<li>有向图所有顶点的入度和出度之和相等，且等于边数</li>\n<li>路径、路径长度、回路</li>\n<li>简单路径、简单回路（顶点不重复出现）</li>\n<li>距离（从u到v的最短路径的长度，若不存在路径则为无穷大）</li>\n<li>子图：由某几个顶点和某几条边组成的图</li>\n<li>连通、连通图和连通分量<br>&#x3D;&#x3D;无向图中&#x3D;&#x3D;从v到w有路径存在，则v和w是连通的<br>若图中任意两个顶点都连通，则该图是<code>连通图</code>，否则是非连通图<br>无向图中的极大连通子图称为<code>连通分量</code><blockquote>\n<p>有$n$个顶点的连通图中，至少存在$n-1$条边（边数小于$n-1$一定是非连通图）<br>$n$个顶点的非连通图，最多有$n-2$条边</p>\n</blockquote>\n</li>\n<li>强连通图、强连通分量<br>在&#x3D;&#x3D;有向图中&#x3D;&#x3D;，若有一对顶点v和w，从v到w有路径，从w到v有路径，则v和w是强连通的<br>若图中任意两个顶点都强连通，则该图是<code>强连通图</code>，否则是非强连通图<br>有向图中的极大强连通子图称为<code>强连通分量</code><blockquote>\n<p>一个有向图有$n$个顶点，如果它是强连通图，则至少有$n$条边（环路）</p>\n</blockquote>\n</li>\n<li>生成树、生成森林<br>连通图的生成树是包含所有顶点的极小连通子图（若有$n$个顶点则生成树有$n-1$条边）<blockquote>\n<p>极大连通子图vs极小连通子图<br>极大连通子图要求连通且包含尽可能多的顶点和边，极小联通子图要求保持连通且边数最少</p>\n</blockquote>\n</li>\n<li>边的权、网和带权路径长度<br>带权图中，边有权值。路径上所有边的权值之和称为带权路径长度</li>\n<li>完全图（也称简单完全图）<br>无向图，有$n$个顶点，有$n(n-1)&#x2F;2$条边的，称为完全（无向）图（顶点两两之间都有边）<br>有向图，有$n$个顶点，有$n(n-1)$条边的，称为完全（有向）图</li>\n<li>稠密图、稀疏图<br>当$|E| &lt; |V|log_2{|v|}$时，可以视为稀疏图</li>\n<li>有向树<br>一个顶点入度为0，其他顶点入度均为1的有向图，称为有向树</li>\n</ul>\n<h2 id=\"图的存储及基本操作\"><a href=\"#图的存储及基本操作\" class=\"headerlink\" title=\"图的存储及基本操作\"></a>图的存储及基本操作</h2><h3 id=\"邻接矩阵法\"><a href=\"#邻接矩阵法\" class=\"headerlink\" title=\"邻接矩阵法\"></a>邻接矩阵法</h3><p>$$<br>A[i][j] &#x3D;<br>\\begin{cases}<br>1, &amp; \\text{如果顶点 } i \\text{ 和顶点 } j \\text{ 之间有边} \\<br>0, &amp; \\text{否则}<br>\\end{cases}<br>$$<br>带权图：<br>$$<br>A[i][j] &#x3D;<br>\\begin{cases}<br>w_{ij}, &amp; \\text{如果顶点 } i \\text{ 和 } j \\text{ 之间有边，权重为 } w_{ij} \\<br>0 \\text{ 或 } \\infty, &amp; \\text{如果没有边}<br>\\end{cases}<br>$$</p>\n<figure class=\"highlight c++\"><figcaption><span>邻接矩阵</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxVertexNum 100</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">char</span> VertexType;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> EdgeType;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    VertexType vex[MaxVertexNum];   <span class=\"comment\">// 顶点表</span></span><br><span class=\"line\">    EdgeType edge[MaxVertexNum][MaxVertexNum];  <span class=\"comment\">// 邻接矩阵</span></span><br><span class=\"line\">    <span class=\"type\">int</span> vexnum, edgnum;</span><br><span class=\"line\">&#125;MGraph;</span><br></pre></td></tr></table></figure>\n<p>无向图的邻接矩阵一定是对称的，所以只需要存上三角（或下三角）就行</p>\n<blockquote>\n<p>对于无向图，邻接矩阵第$i$行非零元素的个数即为顶点$i$的度<br>对于有向图，邻接矩阵第$i$行非零元素的个数即为顶点$i$的出度，第$i$列非零元素的个数即为顶点$i$的入度<br>邻接矩阵适合稠密图</p>\n</blockquote>\n<h3 id=\"邻接表法\"><a href=\"#邻接表法\" class=\"headerlink\" title=\"邻接表法\"></a>邻接表法</h3><p>稀疏图适合用邻接表存储<br><img data-src=\"/f1.jpg\"></p>\n<figure class=\"highlight c++\"><figcaption><span>邻接表</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxVertexNum 100</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">ArcNode</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> adjvex;  <span class=\"comment\">// 邻接点</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">ArcNode</span> *nextarc;</span><br><span class=\"line\">&#125;ArcNode;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">VNode</span> &#123;</span><br><span class=\"line\">    VertexType data;</span><br><span class=\"line\">    ArcNode *firstarc;</span><br><span class=\"line\">&#125;VNode, AdjList[MaxVertexNum];</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    AdjList vertices;</span><br><span class=\"line\">    <span class=\"type\">int</span> vexnum, arcnum;</span><br><span class=\"line\">&#125;ALGraph;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>对于无向图，所需要的空间为$O(|V|+2|E|)$；若为有向图，空间为$O(|V|+|E|)$</p>\n</blockquote>\n<h3 id=\"十字链表\"><a href=\"#十字链表\" class=\"headerlink\" title=\"十字链表\"></a>十字链表</h3><p>&#x3D;&#x3D;有向图&#x3D;&#x3D;的一种链式存储结构<br>每条弧、顶点都用结点表示<br>顶点结点<br><code>firstIn</code>表示进入这个结点的第一个弧节点，<code>firstOut</code>表示出去这个结点的第一个弧节点<br><img data-src=\"/f2.png\"><br><img data-src=\"/f4.png\"><br>弧结点<br><code>tailVexh</code>和<code>headVex</code>存放弧尾和弧头在顶点数组的编号。<code>hLink</code>则表示指向弧头相同的下一条弧，<code>tLink</code>则表示指向弧尾相同的下一条弧<br><img data-src=\"/f3.png\"><br>:::danger<br>王道这里的弧头指的是箭头的头部，弧尾指的是箭头的尾部，王道这一部分不知道哪个天才写的，纯误导人，直接看英语就行了<br>:::</p>\n<p>+++primary 示例<br><img data-src=\"/f5.png\"><br><img data-src=\"/f6.png\"><br>+++</p>\n<h3 id=\"邻接多重表\"><a href=\"#邻接多重表\" class=\"headerlink\" title=\"邻接多重表\"></a>邻接多重表</h3><p>无向图的一种链式存储结构<br>边结点：<br>| ivex | ilink | jvex | jlink | (info) |<br>顶点结点：<br>| data | firstedge |<br>和十字链表差不多意思，只不过这个是无向图<br><img data-src=\"/f7.jpg\"></p>\n<h3 id=\"图的基本操作\"><a href=\"#图的基本操作\" class=\"headerlink\" title=\"图的基本操作\"></a>图的基本操作</h3><h2 id=\"图的遍历\"><a href=\"#图的遍历\" class=\"headerlink\" title=\"图的遍历\"></a>图的遍历</h2><ol>\n<li>BFS<br>用队列实现，入队的时候visit，出队的时候检查邻接点</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>BFS邻接表实现</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">BFS</span><span class=\"params\">(ALGraph G, <span class=\"type\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">visit</span>(i);</span><br><span class=\"line\">    visited[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"built_in\">EnQueue</span>(Q, i);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!<span class=\"built_in\">IsEmpty</span>(Q))&#123;</span><br><span class=\"line\">        <span class=\"built_in\">Dequeue</span>(Q, v);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> p=G.vertices[v].firstarc; p; p=p-&gt;nextarc)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!visited[p-&gt;adjvex])&#123;</span><br><span class=\"line\">                <span class=\"built_in\">visit</span>(p-&gt;adjvex);</span><br><span class=\"line\">                visited[p-&gt;adjvex] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"built_in\">EnQueue</span>(Q, p-&gt;adjvex);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度：$O(|V|+|E|)$</p>\n<figure class=\"highlight c++\"><figcaption><span>BFS邻接矩阵实现</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">DFS</span><span class=\"params\">(MGraph G, <span class=\"type\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">visit</span>(i);</span><br><span class=\"line\">    visited[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"built_in\">EnQueue</span>(Q, i);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!<span class=\"built_in\">IsEmpty</span>(Q))&#123;</span><br><span class=\"line\">        <span class=\"built_in\">Dequeue</span>(Q, v);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;G.vexnum; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(G.edge[v][j] &amp;&amp; !visited[j])&#123;</span><br><span class=\"line\">                <span class=\"built_in\">visit</span>(j);</span><br><span class=\"line\">                visited[j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"built_in\">EnQueue</span>(Q, j);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度：$O(|V|^2)$</p>\n<ul>\n<li>BFS求<code>u</code>到<code>v</code>的最短距离<br>在BFS基础上添加一个数组<code>d</code>，记录从<code>u</code>到<code>v</code>的最短距离；增加一个数组<code>pre</code>记录路径</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>BFS求最短路径</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">BFS_MIN_Distance</span><span class=\"params\">(ALGraph G, <span class=\"type\">int</span> u, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class=\"line\">        d[i] = INF;</span><br><span class=\"line\">        pre[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        visited[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">visit</span>(u);</span><br><span class=\"line\">    visited[u] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    d[u] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    pre[u] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">EnQueue</span>(Q, u);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!<span class=\"built_in\">IsEmpty</span>(Q)) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> v;</span><br><span class=\"line\">        <span class=\"built_in\">Dequeue</span>(Q, v);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (anto p = G.vertices[v].firstarc; p; p = p-&gt;nextarc) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> w = p-&gt;adjvex;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!visited[w]) &#123;</span><br><span class=\"line\">                visited[w] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"built_in\">visit</span>(w);</span><br><span class=\"line\">                d[w] = d[v] + <span class=\"number\">1</span>;  <span class=\"comment\">// 距离 = 前驱距离 + 1</span></span><br><span class=\"line\">                pre[w] = v;       <span class=\"comment\">// 记录前驱</span></span><br><span class=\"line\">                <span class=\"built_in\">EnQueue</span>(Q, w);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<ol start=\"2\">\n<li>DFS<br>用栈实现</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>DFS邻接表实现</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">DFS</span><span class=\"params\">(ALGraph G, <span class=\"type\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">visit</span>(i);</span><br><span class=\"line\">    visited[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> p=G.vertices[i].firstarc; p; p=p-&gt;nextarc)&#123;</span><br><span class=\"line\">        j = p-&gt;adjvex;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!visited[j])&#123;</span><br><span class=\"line\">            <span class=\"built_in\">DFS</span>(G, j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度：$O(|V|+|E|)$</p>\n<figure class=\"highlight c++\"><figcaption><span>DFS邻接矩阵实现</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">DFS</span><span class=\"params\">(MGraph G, <span class=\"type\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">visit</span>(i);</span><br><span class=\"line\">    visited[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;G.vexnum; j++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(G.edge[i][j] &amp;&amp; !visited[j])&#123;</span><br><span class=\"line\">            <span class=\"built_in\">DFS</span>(G, j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度：$O(|V|^2)$<br>如果是非连通图，则需要多次调用DFS（再扫描一次visit数组，找到未访问的顶点然后继续调用DFS）</p>\n<h2 id=\"图的应用\"><a href=\"#图的应用\" class=\"headerlink\" title=\"图的应用\"></a>图的应用</h2><h3 id=\"最小生成树-MST\"><a href=\"#最小生成树-MST\" class=\"headerlink\" title=\"最小生成树 MST\"></a>最小生成树 MST</h3><p>最小生成树：从连通无向图中找出一棵树（包含所有n个节点和n-1条边），同时边的权重之和要最小</p>\n<ol>\n<li>Prim算法<br>随便取一个根节点记作visited，不断寻找visited节点和unvisited节点之间权重最小的边<br>初始的时候只有一个结点，&#x3D;&#x3D;从顶点开始每次找到和已有的结点距离最小的边&#x3D;&#x3D;，加入树中，直到树中顶点数等于顶点数（每次要保证树是连通的且没有回路）<br>时间复杂度：$O(|V|^2)$，适用于求稠密图的最小生成树</li>\n<li>Kruskal算法<br>每次找到距离最短的边，加入树中，直到所有顶点都在一个连通分量上<br>1）创建一个队列，将边按权重排序，最小的在最上面；（2）从顶端不断dequeue，如果符合不在同一棵树里就接受那条边</li>\n</ol>\n<h3 id=\"最短路径\"><a href=\"#最短路径\" class=\"headerlink\" title=\"最短路径\"></a>最短路径</h3><ol>\n<li><p>Dijkstra算法<br>有权图的单源最短路算法<br>求从源点到其他点的最短路径：每次选距离最近的点，更新源点到其他点的最短距离<br>一开始和其他点的距离全都初始化为<code>INF</code>，和自己的距离为0，每次在unvisited的结点中找距离最小的visit，然后看这个结点的邻接点，新的距离比旧距离小则更新<br>画一个表，分别是是否visit、编号、距离和路径，每次取unvisited里最小的</p>\n</li>\n<li><p>Floyd算法<br>多源最短路算法，求所有顶点之间的最短路径<br>递归产生一个n阶方阵序列<br>直接看例子：<br><img data-src=\"/f9.jpg\"><br>路径就是加起来的两个值的路径</p>\n</li>\n</ol>\n<h3 id=\"有向无环图描述表达式\"><a href=\"#有向无环图描述表达式\" class=\"headerlink\" title=\"有向无环图描述表达式\"></a>有向无环图描述表达式</h3><p>有向图中不存在环，则称为有向无环图，DAG<br><img data-src=\"/f10.jpg\"><br>先用树表示，然后把能合并的合并到一起，得到一个有向无环图<br>+++primary<br><img data-src=\"/f11.png\"><br><img data-src=\"/f12.png\"><br><img data-src=\"/f13.png\"><br>+++</p>\n<h3 id=\"拓扑排序\"><a href=\"#拓扑排序\" class=\"headerlink\" title=\"拓扑排序\"></a>拓扑排序</h3><p>AOV图顶点表示活动，边表示活动间的依赖关系</p>\n<ul>\n<li>拓扑排序<br>当且仅当一个有向图为有向无环图（directed acyclic graph，或称DAG）时，才能得到对应于该图的拓扑排序。每一个有向无环图都至少存在一种拓扑排序。</li>\n</ul>\n<p>方法：不断寻找入度为0的节点pop出去，删除该节点和相关的边<br>采用邻接表时，时间复杂度为$O(|V|+|E|)$，采用邻接矩阵时，时间复杂度为$O(|V|^2)$<br>序列不唯一<br><img data-src=\"/f14.png\"></p>\n<ul>\n<li><p>逆拓扑排序<br><img data-src=\"/f15.png\"><br>每次删除出度为0的顶点，并把该顶点的邻接点出度减1<br>序列不唯一</p>\n</li>\n<li><p>用dfs实现拓扑排序<br><img data-src=\"/f16.jpg\"></p>\n</li>\n</ul>\n<h3 id=\"AOE网\"><a href=\"#AOE网\" class=\"headerlink\" title=\"AOE网\"></a>AOE网</h3><p>边表示活动，顶点表示事件</p>\n<ol>\n<li>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始;</li>\n<li>只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生（所以事件的最早开始时间要取最大的）</li>\n</ol>\n<blockquote>\n<p>求事件的最早开始时间和最晚完成时间<br><img data-src=\"/f17.png\"><br>V代表事件，a代表活动</p>\n</blockquote>\n<p>先求事件（V）：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>V1</th>\n<th>V2</th>\n<th>V3</th>\n<th>V4</th>\n<th>V5</th>\n<th>V6</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>最早开始时间</td>\n<td>0</td>\n<td>3</td>\n<td>2</td>\n<td>6</td>\n<td>6</td>\n<td>8</td>\n</tr>\n<tr>\n<td>最晚完成时间</td>\n<td>0</td>\n<td>4</td>\n<td>2</td>\n<td>6</td>\n<td>7</td>\n<td>8</td>\n</tr>\n</tbody></table>\n<p>最早开始时间&#x3D;&#x3D;从前往后取最大的&#x3D;&#x3D;（V1填0，V4有V1-&gt;V2-&gt;V4和V1-&gt;V3-&gt;V4两条，取大的是6）<br>最晚完成时间&#x3D;&#x3D;从后往前推(用最早开始时间 - a），取最小的&#x3D;&#x3D;（V6填8，V5&#x3D;V6-1，V3有V6-&gt;V3和V6-&gt;V4-&gt;V3两条，取最小的V4-4&#x3D;2）</p>\n<p>&#x3D;&#x3D;最早开始时间 &#x3D; 最晚完成时间 —— 关键路径&#x3D;&#x3D;</p>\n<p>活动（A）：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>a1</th>\n<th>a2</th>\n<th>a3</th>\n<th>a4</th>\n<th>a5</th>\n<th>a6</th>\n<th>a7</th>\n<th>a8</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>最早开始时间</td>\n<td>0</td>\n<td>0</td>\n<td>3</td>\n<td>3</td>\n<td>2</td>\n<td>2</td>\n<td>6</td>\n<td>6</td>\n</tr>\n<tr>\n<td>最晚完成时间</td>\n<td>1</td>\n<td>0</td>\n<td>4</td>\n<td>4</td>\n<td>2</td>\n<td>5</td>\n<td>6</td>\n<td>7</td>\n</tr>\n</tbody></table>\n<p>最早开始时间取箭头的出发点的最早开始时间，最晚完成时间取箭头指向的点的最晚完成时间 - a</p>\n<p>&#x3D;&#x3D;最早开始时间 &#x3D; 最晚完成时间 —— 关键活动&#x3D;&#x3D;</p>\n<h3 id=\"各种时间复杂度\"><a href=\"#各种时间复杂度\" class=\"headerlink\" title=\"各种时间复杂度\"></a>各种时间复杂度</h3><p><img data-src=\"/f18.jpg\"></p>\n",
            "tags": [
                "图论"
            ]
        },
        {
            "id": "http://example.com/2025/10/10/computer-science/DS/ch5/",
            "url": "http://example.com/2025/10/10/computer-science/DS/ch5/",
            "title": "ch5",
            "date_published": "2025-10-09T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch5\"><a href=\"#Ch5\" class=\"headerlink\" title=\"Ch5\"></a>Ch5</h1><h2 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h2><p>树的性质：</p>\n<ul>\n<li>$n$个节点的树有$n-1$条边</li>\n<li>结点数$n$等于所以结点的度数和+1</li>\n<li>度为$m$的树中第$i$层上之多有$m^{i-1}$个结点</li>\n<li>高度为$h$的$m$叉树中至多有$(m^h-1)&#x2F;(m-1)$个结点</li>\n<li>度为$m$，具有$n$个结点的树的最小高度$h$<br>$$<br>h_{\\min} &#x3D;<br>\\left\\lceil \\log_m \\left( (m - 1)n + 1 \\right) \\right\\rceil<br>$$</li>\n<li>度为$m$，具有$n$个结点的树的最大高度h为$n-m-1$</li>\n<li>高度为$h$，度为$m$的树至少有$h+m-1$个结点</li>\n</ul>\n<h2 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h2><p>二叉树：每个结点最多有两个子树，称为左子树和右子树<br>二叉树和度为2的有序树的区别：</p>\n<ol>\n<li>度为2的有序树至少有3个结点，二叉树可以为空</li>\n<li>二叉树不管有没有兄弟结点都需要区分是左子树还是右子树</li>\n</ol>\n<ul>\n<li>满二叉树：每层都满</li>\n<li>完全二叉树：除了最后一层外，其他层都是满二叉树，最后一层左边要是满的</li>\n<li>二叉排序树：每个结点都满足左子树小于该结点，右子树大于该结点</li>\n<li>平衡二叉树：任意结点的左右子树的高度差不超过1</li>\n<li>正则二叉树：树中每个分支结点都有两个子结点，树中只有度为0或2的结点</li>\n</ul>\n<p>性质：</p>\n<ol>\n<li>非空二叉树上的叶结点数等于度为2的结点数加1，$n_0 &#x3D; n_2 + 1$</li>\n<li>非空二叉树第k层最多有$2^{k-1}$个结点</li>\n<li>高度为h的二叉树最多有$2^h-1$个结点</li>\n<li>对完全二叉树按从上到下、从左到右的顺序依次编号，则<br>最后一个分支节点的编号为$\\left\\lfloor \\frac{n}{2} \\right\\rfloor$，如果$i$小于等于这个数就是分支节点，否则就是叶子结点<br>如果$n$为奇数，则每个分支节点都有左右孩子，如果是偶数就编号最大的分支只有左孩子<br>结点$i$的左孩子编号为$2i$，右孩子编号$2i+1$<br>结点i所在的depth为$\\left\\lceil \\log_2 i \\right\\rceil + 1$</li>\n<li>具有n个结点的完全二叉树的高度为$\\left\\lfloor \\log_2 n \\right\\rfloor + 1$或者$\\left\\lceil \\log_2 {n+1} \\right\\rceil$</li>\n</ol>\n<h3 id=\"二叉树的存储结构\"><a href=\"#二叉树的存储结构\" class=\"headerlink\" title=\"二叉树的存储结构\"></a>二叉树的存储结构</h3><ul>\n<li>完全二叉树可以存储在数组里，数组中第i个结点对应数组中的第i个元素，0为空，就可以利用下标找到parent&#x2F;left child&#x2F;right child</li>\n<li>普通的二叉树采用链式存储结构</li>\n</ul>\n<figure class=\"highlight c\"><figcaption><span>二叉树</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTNode</span>&#123;</span></span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTNode</span> *<span class=\"title\">lchild</span>, *<span class=\"title\">rchild</span>;</span></span><br><span class=\"line\">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二叉树的遍历和线索二叉树\"><a href=\"#二叉树的遍历和线索二叉树\" class=\"headerlink\" title=\"二叉树的遍历和线索二叉树\"></a>二叉树的遍历和线索二叉树</h3><ol>\n<li>PreOrder先（前）序遍历: 根左右</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>先序遍历</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">PreOrder</span><span class=\"params\">(BiTree T)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(T != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">Visit</span>(T);</span><br><span class=\"line\">        <span class=\"built_in\">PreOrder</span>(T-&gt;lchild);</span><br><span class=\"line\">        <span class=\"built_in\">PreOrder</span>(T-&gt;rchild);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>InOrder中序遍历: 左根右</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>中序遍历</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">InOrder</span><span class=\"params\">(BiTree T)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(T != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">InOrder</span>(T-&gt;lchild);</span><br><span class=\"line\">        <span class=\"built_in\">Visit</span>(T);</span><br><span class=\"line\">        <span class=\"built_in\">InOrder</span>(T-&gt;rchild);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>PostOrder后序遍历: 左右根</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>后序遍历</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">PostOrder</span><span class=\"params\">(BiTree T)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(T != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">PostOrder</span>(T-&gt;lchild);</span><br><span class=\"line\">        <span class=\"built_in\">PostOrder</span>(T-&gt;rchild);</span><br><span class=\"line\">        <span class=\"built_in\">Visit</span>(T);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>:::info<br>以上三种遍历方式都是递归方式，栈的深度就是树的高度，时间复杂度都是$O(n)$<br>最坏的情况下，二叉树是有n个结点且深度为n的单支树，此时空间复杂度为$O(n)$<br>:::<br>4. LevelOrder层序遍历: 从上到下从左到右<br>需要借助一个队列，其实就是bfs</p>\n<figure class=\"highlight c++\"><figcaption><span>层序遍历</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">LevelOrder</span><span class=\"params\">(BiTree T)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">initQueue</span>(Q);   <span class=\"comment\">//根节点入队</span></span><br><span class=\"line\">    BiTree p;</span><br><span class=\"line\">    <span class=\"built_in\">enQueue</span>(Q, T);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!<span class=\"built_in\">isEmpty</span>(Q))&#123; <span class=\"comment\">//若队列非空</span></span><br><span class=\"line\">        <span class=\"built_in\">DeQueue</span>(Q, p);  <span class=\"comment\">//出队</span></span><br><span class=\"line\">        <span class=\"built_in\">visit</span>(p);   <span class=\"comment\">//访问当前节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p-&gt;lchild != <span class=\"literal\">NULL</span>)   <span class=\"comment\">//左孩子入队</span></span><br><span class=\"line\">            <span class=\"built_in\">EnQueue</span>(Q, p-&gt;lchild);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p-&gt;rchild != <span class=\"literal\">NULL</span>)   <span class=\"comment\">//右孩子入队</span></span><br><span class=\"line\">            <span class=\"built_in\">EnQueue</span>(Q, p-&gt;rchild);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>由遍历序列构造二叉树<br>若已知InOrder，再给出PreOrder&#x2F;PostOrder&#x2F;LevelOrder都可以唯一的确定一棵二叉树</li>\n</ol>\n<ul>\n<li>前序 + 中序<br>用先序遍历得到根节点，在中序遍历中找，根节点把中序遍历分为左右两段分别是左子树和右子树，递归构造左右子树</li>\n<li>后序 + 中序<br>和前序同理</li>\n<li>层序 + 中序<br>层序的第一个是根节点，然后在层序找到左右子树的根节点（如果有左子树，根后面第一个就是左子树的根节点，如果有右子树，下一个就是右子树的根节点）<br>+++primary 例<br><img data-src=\"/f1.jpg\"><br><img data-src=\"/f2.jpg\"><br>+++</li>\n</ul>\n<h3 id=\"线索二叉树\"><a href=\"#线索二叉树\" class=\"headerlink\" title=\"线索二叉树\"></a>线索二叉树</h3><p>利用叶子结点和不满的结点的空指针存放指向其前驱或者后继的指针，若没有左子树，则lchild指向前驱结点，若没有右子树，则rchild指向后继结点。新增ltag和rtag，如果为0表示指向左&#x2F;右孩子，为1表示为线索指向前驱&#x2F;后继结点</p>\n<figure class=\"highlight c++\"><figcaption><span>线索二叉树</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">ThreadNode</span>&#123;</span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">ThreadNode</span> *lchild, *rchild;</span><br><span class=\"line\">    <span class=\"type\">int</span> ltag, rtag;</span><br><span class=\"line\">&#125;ThreadNode, *ThreadTree;</span><br></pre></td></tr></table></figure>\n\n<p>方法就是找出遍历的序列，然后对每个不满的节点建立线索</p>\n<h4 id=\"中序线索二叉树：\"><a href=\"#中序线索二叉树：\" class=\"headerlink\" title=\"中序线索二叉树：\"></a>中序线索二叉树：</h4><figure class=\"highlight c++\"><figcaption><span>中序线索二叉树</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">InThread</span><span class=\"params\">(ThreadTree &amp;p, ThreadTree &amp;pre)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">InThread</span>(p-&gt;lchild, pre);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p-&gt;lchild == <span class=\"literal\">NULL</span>)&#123; </span><br><span class=\"line\">            p-&gt;lchild = pre;</span><br><span class=\"line\">            p-&gt;ltag = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pre != <span class=\"literal\">NULL</span> &amp;&amp; pre-&gt;rchild == <span class=\"literal\">NULL</span>)&#123; </span><br><span class=\"line\">            pre-&gt;rchild = p;</span><br><span class=\"line\">            pre-&gt;rtag = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre = p;</span><br><span class=\"line\">        <span class=\"built_in\">InThread</span>(p-&gt;rchild, pre);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CreateInThread</span><span class=\"params\">(ThreadTree &amp;T)</span></span>&#123;</span><br><span class=\"line\">    ThreadTree pre = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(T != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">InThread</span>(T, pre);</span><br><span class=\"line\">    pre-&gt;rchild = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    pre-&gt;rtag = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了方便会增加一个head结点的lchild指向根节点，rchild指向中序遍历的最后一个结点，令中序遍历第一个节点的lchild和最后一个节点的rchild指向head</p>\n<figure class=\"highlight c++\"><figcaption><span>求中序线索二叉树中序序列下的第一个节点</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ThreadNode *<span class=\"title\">Firstnode</span><span class=\"params\">(ThreadNode *p)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p-&gt;ltag == <span class=\"number\">0</span>) p = p-&gt;lchild;  <span class=\"comment\">//找到最左下的节点但不一定是叶子</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>求节点p的后继结点</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ThreadNode *<span class=\"title\">Nextnode</span><span class=\"params\">(ThreadNode *p)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p-&gt;rtag == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">Firstnode</span>(p-&gt;rchild);   <span class=\"comment\">//如果有右孩子，则返回右孩子的最左下的节点</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> p-&gt;rchild;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>求中序线索二叉树的最后一个结点</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ThreadNode *<span class=\"title\">Lastnode</span><span class=\"params\">(ThreadNode *p)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p-&gt;rtag == <span class=\"number\">0</span>) p = p-&gt;rchild;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>求节点p的前驱结点</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ThreadNode *<span class=\"title\">Prevnode</span><span class=\"params\">(ThreadNode *p)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p-&gt;ltag == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">Lastnode</span>(p-&gt;lchild);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> p-&gt;lchild;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>不含头结点的中序线索二叉树的中序遍历</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">InOrder</span><span class=\"params\">(ThreadNode *T)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(ThreadNode *p = <span class=\"built_in\">Firstnode</span>(T); p != <span class=\"literal\">NULL</span>; p = <span class=\"built_in\">Nextnode</span>(p))</span><br><span class=\"line\">        <span class=\"built_in\">Visit</span>(p);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"先序线索二叉树\"><a href=\"#先序线索二叉树\" class=\"headerlink\" title=\"先序线索二叉树\"></a>先序线索二叉树</h4><h4 id=\"后序线索二叉树\"><a href=\"#后序线索二叉树\" class=\"headerlink\" title=\"后序线索二叉树\"></a>后序线索二叉树</h4><h2 id=\"树，森林\"><a href=\"#树，森林\" class=\"headerlink\" title=\"树，森林\"></a>树，森林</h2><h3 id=\"树的存储结构\"><a href=\"#树的存储结构\" class=\"headerlink\" title=\"树的存储结构\"></a>树的存储结构</h3><ol>\n<li>双亲表示法<br>用一个结构体数组来存，一个node包括数据域和parent域，parent域的值是父节点的数组下标。根节点的parent域为-1</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>双亲表示法</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAX_TREE_SIZE 100</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"type\">int</span> parent;</span><br><span class=\"line\">&#125;PTNode;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    PTNode nodes[MAX_TREE_SIZE];</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">&#125;PTree;</span><br></pre></td></tr></table></figure>\n<p>优点：可以很快找到parent，但求孩子需要遍历整个树<br>2. 孩子表示法<br>将每个结点的孩子视为一个线性表，以单链表作为存储结构<br>3. 孩子兄弟表示法<br>二叉树表示法，每个结点包括数据域，左孩子指针，右兄弟指针</p>\n<figure class=\"highlight c++\"><figcaption><span>孩子兄弟表示法</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">CSNode</span>&#123;</span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">CSNode</span> *firstchild, *nextsibling;</span><br><span class=\"line\">&#125;CSNode, *CSTree;</span><br></pre></td></tr></table></figure>\n<p>+++primary 图示<br><img data-src=\"/f3.jpg\"><br><img data-src=\"/f4.jpg\"><br>+++</p>\n<h3 id=\"树、森林和二叉树的转换\"><a href=\"#树、森林和二叉树的转换\" class=\"headerlink\" title=\"树、森林和二叉树的转换\"></a>树、森林和二叉树的转换</h3><ol>\n<li>树转二叉树<br>用孩子兄弟表示法（左孩子右兄弟）</li>\n<li>森林转二叉树<br>先讲森林中的每棵树转为二叉树，每棵树视为兄弟，将第二棵树对应的二叉树作为第一颗二叉树根的右子树……<br>+++primary 例<br><img data-src=\"/f5.jpg\"><br>+++</li>\n<li>二叉树转森林<br>把右子树分开，知道最后只剩一棵没有右子树的二叉树为止。和森林转二叉树相反</li>\n</ol>\n<h3 id=\"树和森林的遍历\"><a href=\"#树和森林的遍历\" class=\"headerlink\" title=\"树和森林的遍历\"></a>树和森林的遍历</h3><ol>\n<li>树的遍历</li>\n</ol>\n<ul>\n<li>先根后子树，遍历序列和这棵树对应的二叉树的先序序列相同</li>\n<li>先子树后根，遍历序列和这棵树对应的二叉树的中序序列相同</li>\n</ul>\n<ol start=\"2\">\n<li>森林的遍历</li>\n</ol>\n<ul>\n<li>先序遍历：从第一棵树开始，先根，再子树</li>\n<li>中序遍历：从第一棵树开始，先子树，再根</li>\n</ul>\n<h2 id=\"树与二叉树的应用\"><a href=\"#树与二叉树的应用\" class=\"headerlink\" title=\"树与二叉树的应用\"></a>树与二叉树的应用</h2><h3 id=\"哈夫曼树\"><a href=\"#哈夫曼树\" class=\"headerlink\" title=\"哈夫曼树\"></a>哈夫曼树</h3><h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>带权路径长度：根结点到该结点的路径长度<em>该结点的权值<br>树的带权路径长度<br>$$<br>WPL &#x3D; \\sum_{i&#x3D;1}^{n}w_i</em>l_i<br>$$<br>WPL最小的二叉树称为哈夫曼树，也称最优二叉树</p>\n<h4 id=\"构造\"><a href=\"#构造\" class=\"headerlink\" title=\"构造\"></a>构造</h4><ul>\n<li>构造方法：不断合并两个权值加起来最小的结点<br><img data-src=\"/f6.jpg\"></li>\n</ul>\n<h4 id=\"哈夫曼编码\"><a href=\"#哈夫曼编码\" class=\"headerlink\" title=\"哈夫曼编码\"></a>哈夫曼编码</h4><p>可变长度编码，让频率高的字符编码长度短，频率低的字符编码长度长<br>用哈夫曼树构建哈夫曼编码，是前缀编码，因此每个编码都可以唯一区分一个字符（没有字符的编码是其他编码的前缀）<br>构造的方法是权值为频率，左分支为0，右分支为1（左边1右边0也可以，主要是看长度）<br><img data-src=\"/f7.jpg\"><br>编码方式不唯一，因为长度相同的字符编码方式是可以互换的</p>\n<h3 id=\"并查集-Disjoint-Set\"><a href=\"#并查集-Disjoint-Set\" class=\"headerlink\" title=\"并查集 Disjoint Set\"></a>并查集 Disjoint Set</h3><p>主要用来求等价关系<br>基本操作：</p>\n<ul>\n<li>初始化：所有元素都是单元素集合</li>\n<li>Union(S, Root1, Root2):合并两个集合，把Root2的根节点连到Root1的根节点上</li>\n<li>Find(S, x): 查找x的根节点</li>\n</ul>\n<p>基本实现：</p>\n<figure class=\"highlight c++\"><figcaption><span>disjoint set</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SIZE 100</span></span><br><span class=\"line\"><span class=\"type\">int</span> UFSets[SIZE];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Initial</span><span class=\"params\">(<span class=\"type\">int</span> S[])</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; SIZE; i++)&#123;</span><br><span class=\"line\">        S[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"type\">int</span> S[], <span class=\"type\">int</span> x)</span></span>&#123;   <span class=\"comment\">//时间复杂度为O(d)，d为树的深度</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(S[x] &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        x = S[x];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Union</span><span class=\"params\">(<span class=\"type\">int</span> S[], <span class=\"type\">int</span> Root1, <span class=\"type\">int</span> Root2)</span></span>&#123;  <span class=\"comment\">//时间复杂度为O(1)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Root1 == Root2) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    S[Root2] = Root1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"并查集的优化\"><a href=\"#并查集的优化\" class=\"headerlink\" title=\"并查集的优化\"></a>并查集的优化</h4><ol>\n<li>按高度求并 Union-by-Height</li>\n</ol>\n<ul>\n<li>用根节点的绝对值表示树的结点总数（根节点的值是负数）</li>\n<li>把小树合并到大树，能够保证所有树的深度最多是$O(logn)$</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>Union-by-Height</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Union</span><span class=\"params\">(<span class=\"type\">int</span> S[], <span class=\"type\">int</span> Root1, <span class=\"type\">int</span> Root2)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Root1 == Root2) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(S[Root2] &gt; S[Root1])&#123;    <span class=\"comment\">//Root2的深度小于Root1</span></span><br><span class=\"line\">        S[Root1] += S[Root2];</span><br><span class=\"line\">        S[Root2] = Root1;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        S[Root2] += S[Root1];</span><br><span class=\"line\">        S[Root1] = Root2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>路径压缩<br>为了减少深度，在Find操作时将从根到元素x路径上的所有元素都变成根的孩子</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>路径压缩</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"type\">int</span> S[], <span class=\"type\">int</span> x)</span></span>&#123;   <span class=\"comment\">//先搜一次找到根，再搜一次把路径上所有节点的父节点都改成根</span></span><br><span class=\"line\">    <span class=\"type\">int</span> root = x;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(S[root] &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        root = S[root];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x != root)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> temp = S[x];</span><br><span class=\"line\">        S[x] = root;</span><br><span class=\"line\">        x = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n",
            "tags": [
                "树与二叉树"
            ]
        },
        {
            "id": "http://example.com/2025/10/09/computer-science/OS/ch2/",
            "url": "http://example.com/2025/10/09/computer-science/OS/ch2/",
            "title": "ch2",
            "date_published": "2025-10-08T16:00:00.000Z",
            "content_html": "",
            "tags": [
                "操作系统"
            ]
        },
        {
            "id": "http://example.com/2025/10/05/computer-science/DS/ch4/",
            "url": "http://example.com/2025/10/05/computer-science/DS/ch4/",
            "title": "ch4",
            "date_published": "2025-10-04T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch4\"><a href=\"#Ch4\" class=\"headerlink\" title=\"Ch4\"></a>Ch4</h1><h2 id=\"模式匹配\"><a href=\"#模式匹配\" class=\"headerlink\" title=\"模式匹配\"></a>模式匹配</h2><p>i: 主串当前待比较的字符位置<br>j: 模式串当前待比较的字符位置</p>\n<p>字符串模式匹配，在主串中找到与模式串相同的子串</p>\n<h3 id=\"暴力算法\"><a href=\"#暴力算法\" class=\"headerlink\" title=\"暴力算法\"></a>暴力算法</h3><p>遍历主串，从每个和第一个字符相同的位置开始，继续比较后继字符<br>时间复杂度：$O(mn)$（主串长度n，模式串长度m）</p>\n<h3 id=\"KMP算法\"><a href=\"#KMP算法\" class=\"headerlink\" title=\"KMP算法\"></a>KMP算法</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVBENHkxbzduZC8/c3BtX2lkX2Zyb209MzMzLjEzODcuaG9tZXBhZ2UudmlkZW9fY2FyZC5jbGljayZ2ZF9zb3VyY2U9MWE3ZDhmNTk2ZjNkZmU0MGZlZTM0Yzg1OGVkNDdlNzM=\">https://www.bilibili.com/video/BV1PD4y1o7nd/?spm_id_from=333.1387.homepage.video_card.click&amp;vd_source=1a7d8f596f3dfe40fee34c858ed47e73</span><br>这个讲得好<br>:::danger<br>KMP算法中i永远不递减<br>:::</p>\n<p>前缀：除了最后一个字符外所有的头部子串<br>后缀：除了第一个字符外所有的尾部子串</p>\n<ul>\n<li>PM数组<br>方法：算出所有前缀的前缀和后缀的最长公共子串的长度，并保存在数组中（PM，部分匹配值）<br>从头开始，右滑位数 &#x3D; 已匹配的字符数 - 对应的部分匹配值（最后一个匹配的字符的PM）<br>&#x3D;&#x3D;时间复杂度：$O(m+n)$&#x3D;&#x3D;</li>\n<li>next数组<br>next数组代表匹配的时候子串中可以跳过匹配的字符个数</li>\n</ul>\n<p>$$ next[j] &#x3D; PM[j-1] + 1 $$<br>将模式串的PM表右移一位并整体+1，左边空缺用0来填充，右边溢出舍去<br>:::info<br>在上面方法中，串的编号是从1开始的<br>:::<br>当模式串在位置 j 与主串不匹配时，模式串应该向右滑动的位数 &#x3D; j - next[j-1]</p>\n<ul>\n<li>next数组的一般公式</li>\n</ul>\n<ol>\n<li>第1个是0，第2个是1</li>\n<li>当前位置前面的串的相等的最长的前缀和后缀的长度+1</li>\n<li>前缀后缀都不相等，填1</li>\n</ol>\n<p>直接看代码</p>\n<figure class=\"highlight c++\"><figcaption><span>KMP</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">get_next</span><span class=\"params\">(SString T, <span class=\"type\">int</span> nexxt[])</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">1</span>, j = <span class=\"number\">0</span>;   <span class=\"comment\">//i指向当前要计算next[i]的位置，j表示上一个最长前后缀长度</span></span><br><span class=\"line\">    next[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt; T.length)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j == <span class=\"number\">0</span> || T.ch[i] == T.ch[j])&#123;</span><br><span class=\"line\">            ++i;</span><br><span class=\"line\">            ++j;</span><br><span class=\"line\">            next[i] = j;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            j = next[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>next[0]是不用的</p>\n<p>KMP匹配算法</p>\n<figure class=\"highlight c++\"><figcaption><span>KMP</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">index_KMP</span><span class=\"params\">(SString S, SString T, <span class=\"type\">int</span> next[])</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">1</span>, j = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt;= S.length &amp;&amp; j &lt;= T.length)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j == <span class=\"number\">0</span> || S.ch[i] == T.ch[j])&#123;   <span class=\"comment\">//表示模式串已经回退到不能再回退的位置,此时必须让主串指针i前进一步，模式串从第一个字符重新开始匹配</span></span><br><span class=\"line\">            ++i;</span><br><span class=\"line\">            ++j;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            j = next[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(j &gt; T.length) <span class=\"keyword\">return</span> i - T.length;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>nextval数组<br>如果$p_j$和$p_{next[j]}$相等，让next[j]的值等于next[next[j]]，一直递归下去<br>如果跳转后的位置字符和当前字符相同，那就直接跳到更前面的位置（即 nextval[j]），避免无效比较</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>nextval</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">get_nextval</span><span class=\"params\">(SString T, <span class=\"type\">int</span> nextval[])</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">1</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    nextval[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt; T.length)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j == <span class=\"number\">0</span> || T.ch[i] == T.ch[j])&#123;</span><br><span class=\"line\">            ++i;</span><br><span class=\"line\">            ++j;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(T.ch[i] != T.ch[j])</span><br><span class=\"line\">                nextval[i] = j;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> nextval[i] = nextval[j];</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            j = nextval[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "串"
            ]
        },
        {
            "id": "http://example.com/2025/10/04/computer-science/DS/ch3/",
            "url": "http://example.com/2025/10/04/computer-science/DS/ch3/",
            "title": "ch3",
            "date_published": "2025-10-03T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch3\"><a href=\"#Ch3\" class=\"headerlink\" title=\"Ch3\"></a>Ch3</h1><h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><p>LIFO</p>\n<h3 id=\"顺序栈的实现\"><a href=\"#顺序栈的实现\" class=\"headerlink\" title=\"顺序栈的实现\"></a>顺序栈的实现</h3><figure class=\"highlight c++\"><figcaption><span>定义</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 50</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    ElemType data[MaxSize];</span><br><span class=\"line\">    <span class=\"type\">int</span> top;</span><br><span class=\"line\">&#125;SqStack;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><figcaption><span>初始化</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">InitStack</span><span class=\"params\">(SqStack &amp;S)</span></span>&#123;</span><br><span class=\"line\">    S.top = <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>判断空</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">StackEmpty</span><span class=\"params\">(SqStack S)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(S.top == <span class=\"number\">-1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>push</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Push</span><span class=\"params\">(SqStack &amp;S,ElemType x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(S.top == MaxSize - <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    S.data[++S.top] = x;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>pop</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Pop</span><span class=\"params\">(SqStack &amp;S,ElemType &amp;x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(S.top == <span class=\"number\">-1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    x = S.data[S.top--];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>gettop</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">GetTop</span><span class=\"params\">(SqStack S,ElemType &amp;x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(S.top == <span class=\"number\">-1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    x = S.data[S.top];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"共享栈\"><a href=\"#共享栈\" class=\"headerlink\" title=\"共享栈\"></a>共享栈</h3><p>同时从两边向中间压栈</p>\n<h3 id=\"链栈\"><a href=\"#链栈\" class=\"headerlink\" title=\"链栈\"></a>链栈</h3><figure class=\"highlight c++\"><figcaption><span>定义</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">Linknode</span>&#123;</span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">Linknode</span> *next;</span><br><span class=\"line\">&#125;LiStack;</span><br></pre></td></tr></table></figure>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><p>FIFO</p>\n<h3 id=\"顺序存储\"><a href=\"#顺序存储\" class=\"headerlink\" title=\"顺序存储\"></a>顺序存储</h3><figure class=\"highlight c++\"><figcaption><span>队列的实现</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 50</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    ElemType data[MaxSize];</span><br><span class=\"line\">    <span class=\"type\">int</span> front,rear;</span><br><span class=\"line\">&#125;SqQueue;</span><br></pre></td></tr></table></figure>\n<p>初始状态：front &#x3D; rear &#x3D; 0</p>\n<figure class=\"highlight c++\"><figcaption><span>队列判空</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">QueueEmpty</span><span class=\"params\">(SqQueue Q)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.front == Q.rear)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"循环队列\"><a href=\"#循环队列\" class=\"headerlink\" title=\"循环队列\"></a>循环队列</h4><figure class=\"highlight c++\"><figcaption><span>初始化</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">InitQueue</span><span class=\"params\">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class=\"line\">    Q.front = Q.rear = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>队列判空</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">QueueEmpty</span><span class=\"params\">(SqQueue Q)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.front == Q.rear)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>队列判满</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">QueueFull</span><span class=\"params\">(SqQueue Q)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((Q.rear + <span class=\"number\">1</span>) % MaxSize == Q.front)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>入队</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">EnQueue</span><span class=\"params\">(SqQueue &amp;Q,ElemType x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">QueueFull</span>(Q))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    Q.data[Q.rear] = x;</span><br><span class=\"line\">    Q.rear = (Q.rear + <span class=\"number\">1</span>) % MaxSize;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>出队</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">DeQueue</span><span class=\"params\">(SqQueue &amp;Q,ElemType &amp;x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">QueueEmpty</span>(Q))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    x = Q.data[Q.front];</span><br><span class=\"line\">    Q.front = (Q.front + <span class=\"number\">1</span>) % MaxSize;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>求元素个数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">QueueLength</span><span class=\"params\">(SqQueue Q)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (Q.rear - Q.front + MaxSize) % MaxSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"链式存储\"><a href=\"#链式存储\" class=\"headerlink\" title=\"链式存储\"></a>链式存储</h3><figure class=\"highlight c++\"><figcaption><span>链队列的实现</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">Linknode</span>&#123;</span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">Linknode</span> *next;</span><br><span class=\"line\">&#125;LinkNode;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    LinkNode *front,*rear;</span><br><span class=\"line\">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>\n<p>一般设计成带头结点的链队列</p>\n<figure class=\"highlight c\"><figcaption><span>初始化</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitQueue</span><span class=\"params\">(LinkQueue &amp;Q)</span>&#123;</span><br><span class=\"line\">    Q.front = Q.rear = (LinkNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LinkNode));</span><br><span class=\"line\">    Q.front-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><figcaption><span>队列判空</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">QueueEmpty</span><span class=\"params\">(LinkQueue Q)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.front == Q.rear)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><figcaption><span>入队</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">EnQueue</span><span class=\"params\">(LinkQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class=\"line\">    LinkNode *s = (LinkNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LinkNode));</span><br><span class=\"line\">    s-&gt;data = x;</span><br><span class=\"line\">    s-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    Q.rear-&gt;next = s;</span><br><span class=\"line\">    Q.rear = s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><figcaption><span>出队</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">DeQueue</span><span class=\"params\">(LinkQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.front == Q.rear)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    LinkNode *p = Q.front-&gt;next;</span><br><span class=\"line\">    x = p-&gt;data;</span><br><span class=\"line\">    Q.front-&gt;next = p-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.rear == p)</span><br><span class=\"line\">        Q.rear = Q.front;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"双端队列\"><a href=\"#双端队列\" class=\"headerlink\" title=\"双端队列\"></a>双端队列</h3><ul>\n<li>输出受限的双端队列<br>允许在一端进行push&#x2F;pop操作，另一端只能push</li>\n<li>输入受限的双端队列<br>允许在一端进行push&#x2F;pop操作，另一端只能pop</li>\n</ul>\n<h2 id=\"栈和队列的应用\"><a href=\"#栈和队列的应用\" class=\"headerlink\" title=\"栈和队列的应用\"></a>栈和队列的应用</h2><h3 id=\"栈-1\"><a href=\"#栈-1\" class=\"headerlink\" title=\"栈\"></a>栈</h3><h4 id=\"表达式\"><a href=\"#表达式\" class=\"headerlink\" title=\"表达式\"></a>表达式</h4><ul>\n<li>括号匹配<br>左括号压栈，右括号出栈，判断是否匹配</li>\n<li>算术表达式<br>中缀表达式：左根右<br>前缀表达式：根左右<br>后缀表达式：左右根<blockquote>\n<p>中缀转后缀</p>\n<ol>\n<li>加括号</li>\n<li>把运算符移到当前层的括号后面</li>\n<li>去掉括号<br><strong>用栈实现中缀转后缀：</strong></li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<ol>\n<li>遇到操作数直接加入后缀表达式</li>\n<li>遇到括号，左括号入栈，右括号依次出栈加入后缀表达式直到遇到左括号位置，并删除左括号</li>\n<li>遇到运算符，判断优先级，如果栈为空或者栈顶为“（”或者栈顶运算符优先级低于当前运算符，则入栈，否则依次出栈加入后缀表达式，直到栈为空或者栈顶运算符优先级低于当前运算符（优先级相同的也要出栈），最后将当前运算符入栈<br>&#x3D;&#x3D;所以栈里面只存运算符和括号&#x3D;&#x3D;</li>\n</ol>\n<blockquote>\n<p>后缀表达式求值<br>从左到右扫描表达式，遇到操作数压栈，遇到操作符就弹出两个操作数，计算结果压入栈中</p>\n</blockquote>\n<h4 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h4><h3 id=\"队列-1\"><a href=\"#队列-1\" class=\"headerlink\" title=\"队列\"></a>队列</h3><h4 id=\"层次遍历\"><a href=\"#层次遍历\" class=\"headerlink\" title=\"层次遍历\"></a>层次遍历</h4><p>根左右入队，依次pop</p>\n<h4 id=\"队列的应用\"><a href=\"#队列的应用\" class=\"headerlink\" title=\"队列的应用\"></a>队列的应用</h4><ul>\n<li>缓冲区</li>\n<li>操作系统的请求队列</li>\n</ul>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>特殊矩阵的压缩存储</p>\n<ul>\n<li>对称矩阵<br>只存下三角的元素，存在一维数组里</li>\n<li>三角矩阵<br>省略0，摊平存在一维数组</li>\n<li>三对角<br>同理省略0，存在一维数组里</li>\n<li>稀疏矩阵<br>行标，列标，值都成三元组，存储在线性表（数组或者十字链表），保存的同时要保存系数矩阵的行数、列数和非零元素的个数</li>\n</ul>\n",
            "tags": [
                "栈、队列和数组"
            ]
        },
        {
            "id": "http://example.com/2025/09/18/computer-science/OS/ch1/",
            "url": "http://example.com/2025/09/18/computer-science/OS/ch1/",
            "title": "ch1",
            "date_published": "2025-09-17T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch1\"><a href=\"#Ch1\" class=\"headerlink\" title=\"Ch1\"></a>Ch1</h1><p>计算机系统自下而上可以大致分为硬件、操作系统、应用程序、用户<br>OS管理各种硬件，为应用程序提供基础，充当计算机硬件与用户之间的中介，是计算机系统中最基本的系统软件</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h3 id=\"操作系统的功能\"><a href=\"#操作系统的功能\" class=\"headerlink\" title=\"操作系统的功能\"></a>操作系统的功能</h3><ol>\n<li>管理计算机系统资源<br>处理机管理（进程&#x2F;线程管理）、存储器管理、设备管理、文件管理，向用户提供接口</li>\n<li>作为用户与硬件系统之间的接口</li>\n</ol>\n<ul>\n<li>命令接口（联机控制方式和脱机控制方式）<ul>\n<li>联机命令接口也称为交互式命令接口，由一组键盘操作命令组成</li>\n<li>脱机命令接口也称批处理命令接口，由一组作业控制命令组成</li>\n</ul>\n</li>\n<li>程序接口<ul>\n<li>由一组系统调用组成</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li>实现了对计算机资源的补充<br>虚拟机</li>\n</ol>\n<h3 id=\"操作系统的特征\"><a href=\"#操作系统的特征\" class=\"headerlink\" title=\"操作系统的特征\"></a>操作系统的特征</h3><p>最基本的两个：并发与共享</p>\n<ol>\n<li>并发<br>多道程序交替运行（和并行不一样）</li>\n<li>共享</li>\n</ol>\n<ul>\n<li>互斥共享</li>\n<li>同时访问</li>\n</ul>\n<ol start=\"3\">\n<li>虚拟</li>\n<li>异步</li>\n</ol>\n<h2 id=\"发展历程\"><a href=\"#发展历程\" class=\"headerlink\" title=\"发展历程\"></a>发展历程</h2><h3 id=\"手工操作阶段（无操作系统）\"><a href=\"#手工操作阶段（无操作系统）\" class=\"headerlink\" title=\"手工操作阶段（无操作系统）\"></a>手工操作阶段（无操作系统）</h3><h3 id=\"批处理阶段\"><a href=\"#批处理阶段\" class=\"headerlink\" title=\"批处理阶段\"></a>批处理阶段</h3><ol>\n<li>单道批处理<br>单道程序</li>\n</ol>\n<ul>\n<li>&#x3D;&#x3D;自动性&#x3D;&#x3D;：一批作业自动地逐个运行</li>\n<li>&#x3D;&#x3D;顺序性&#x3D;&#x3D;：顺序进入内存、顺序运行</li>\n<li>&#x3D;&#x3D;单道性&#x3D;&#x3D;：内存中仅有一道程序运行，一道程序运行完才换入下一道</li>\n</ul>\n<ol start=\"2\">\n<li>多道批处理<br>多道，宏观上并行，微观上串行</li>\n</ol>\n<ul>\n<li>多道：内存中同时存放多道相互独立的程序</li>\n<li>宏观上并行</li>\n<li>微观上串行：轮流占有CPU，交替执行<br>缺点：用户响应时间长，不提供人机交互能力，用户既不能了解自己的程序的运行情况，又不能控制计算机</li>\n</ul>\n<h3 id=\"分时操作系统\"><a href=\"#分时操作系统\" class=\"headerlink\" title=\"分时操作系统\"></a>分时操作系统</h3><p>分时技术指将运行时间分成时间片，轮流分配处理器<br>分时操作系统指多个用户通过终端同时共享一台主机，将CPU时间划分为很短的时间片，并以轮转的方式将这些时间片分配给各个用户或任务，从而实现多用户共享计算机资源<br>特征：</p>\n<ul>\n<li>&#x3D;&#x3D;同时性&#x3D;&#x3D;：也称多路性，多个用户可以同时使用</li>\n<li>&#x3D;&#x3D;交互性&#x3D;&#x3D;：用户可以与计算机进行交互（区别于批处理系统）</li>\n<li>&#x3D;&#x3D;独立性&#x3D;&#x3D;：用户可以独立运行，互不干扰</li>\n<li>&#x3D;&#x3D;及时性&#x3D;&#x3D;：用户请求可以在很短时间内获得响应<br>缺点：</li>\n<li>上下文切换带来系统开销。</li>\n<li>若用户过多，响应时间可能变长。</li>\n<li>系统复杂度高，需要良好的内存管理和调度算法</li>\n</ul>\n<h3 id=\"实时操作系统\"><a href=\"#实时操作系统\" class=\"headerlink\" title=\"实时操作系统\"></a>实时操作系统</h3><p>分为硬实时系统（必须在绝对截止时间前完成，否则会导致灾难性后果）和软实时系统（希望在时限内完成，偶尔超时可容忍，影响用户体验但不致命）<br>主要特点： &#x3D;&#x3D;及时性和可靠性&#x3D;&#x3D;</p>\n<h3 id=\"网络操作系统和分布式计算机系统\"><a href=\"#网络操作系统和分布式计算机系统\" class=\"headerlink\" title=\"网络操作系统和分布式计算机系统\"></a>网络操作系统和分布式计算机系统</h3><p>网络操作系统是指在独立计算机上运行的操作系统，它通过网络连接其他计算机，实现资源共享（如文件、打印机等），但每台计算机仍保持独立控制（常见的客户端&#x2F;服务器模式）<br>分布式系统是由多台独立计算机通过网络互联，协同工作，对外表现为一个单一、统一的系统。用户感觉不到多台机器的存在。系统中任意两台计算机通过通信方式交换信息；每台计算机都具有同等的地位，没有主机从机；每台计算机上的资源为所有用户共享；系统中的任意台计算机可以构成一个子系统，还能重构；人和网工作都可以分布在机台计算机上。主要特点：&#x3D;&#x3D;分布性和并行性&#x3D;&#x3D;</p>\n<h3 id=\"个人计算机操作系统\"><a href=\"#个人计算机操作系统\" class=\"headerlink\" title=\"个人计算机操作系统\"></a>个人计算机操作系统</h3><h2 id=\"操作系统的运行环境\"><a href=\"#操作系统的运行环境\" class=\"headerlink\" title=\"操作系统的运行环境\"></a>操作系统的运行环境</h2><h3 id=\"处理器运行模式\"><a href=\"#处理器运行模式\" class=\"headerlink\" title=\"处理器运行模式\"></a>处理器运行模式</h3><p>在计算机系统中，CPU执行两种程序：内核程序和用户自编程序</p>\n<p>特权指令：不允许用户直接使用的指令，不如I&#x2F;O指令、关中断指令、内存清零指令、修改PSW等<br>非特权指令：允许用户直接使用的指令</p>\n<p>在具体实现上，将CPU的运行模式划分为用户态和内核态<br>大多数操作系统的内核包括：</p>\n<ol>\n<li>时钟管理</li>\n<li>中断机制</li>\n<li>原语<br>操作系统内核中执行的一个不可分割的、原子性的基本操作。它是一段用机器指令编写的程序，在执行过程中不能被中断，必须一次性执行完毕，具有原子性、不可中断性、运行在内核态<br>定义原语的直接方法是关中断<br>常见的有P操作（wait操作）和V操作（signal操作）、创建进程原语、撤销进程原语、消息发送原语、消息接收原语、资源申请和释放原语</li>\n<li>系统控制的数据结构及处理<br>比如</li>\n</ol>\n",
            "tags": [
                "操作系统"
            ]
        },
        {
            "id": "http://example.com/2025/09/15/computer-science/DS/Amortized%20Analysis/",
            "url": "http://example.com/2025/09/15/computer-science/DS/Amortized%20Analysis/",
            "title": "Amortized Analysis",
            "date_published": "2025-09-14T16:00:00.000Z",
            "content_html": "<ol>\n<li><p>Aggregate analysis<br>a sequence of $n$ operations takes worst-case time $T(n)$ int total. In the worst-case, the average cost, or amortized cost, per operation is $T(n)&#x2F;n$.</p>\n<blockquote>\n<p>example: stack with MultiPop(int k, Stack S)</p>\n</blockquote>\n</li>\n<li><p>Accounting method<br>When an operation’s amortized cost is $\\hat{c_i}$ exceeds its actural cost $c_i$, we assign the dirrerence to specific objects in the data structure as credit. Credit can pay for the later operations whose amortized cost is less than their actual cost.<br>实际成本优于均摊成本，把差额分配给数据结构中的特定对象，表示为credit, credit可以帮助支付后续操作的费用，这些操作的摊还成本小于实际成本<br>For all sequences of $n$ operations, we must assure:<br>$$<br>\\sum_{i&#x3D;1}^n \\hat{c_i} \\geq \\sum_{i&#x3D;1}^n c_i<br>$$</p>\n</li>\n</ol>\n<ul>\n<li><p>当某次操作的 <strong>摊还代价 &gt; 实际代价</strong>（(\\hat{c}_i &gt; c_i)），<br>多出来的部分 (\\hat{c}_i - c_i) 被存为 <strong>credit（信用）</strong>，附着在数据结构的某些对象上。</p>\n</li>\n<li><p>当后续某次操作 <strong>实际代价 &gt; 摊还代价</strong>（(c_j &gt; \\hat{c}_j)），<br>就用之前存下的 credit 来“支付”超出的部分。</p>\n</li>\n</ul>\n<p>但有一个<strong>硬性约束</strong>：  </p>\n<blockquote>\n<p><strong>任何时候都不能透支 credit！</strong><br>也就是说，在任何前缀操作 (1..k) 中，累计的 credit 必须 ≥ 0。</p>\n</blockquote>\n<p>这等价于要求：<br>$$<br>\\forall k,\\quad \\sum_{i&#x3D;1}^k \\hat{c}<em>i \\geq \\sum</em>{i&#x3D;1}^k c_i<br>$$<br>特别地，对整个序列（(k &#x3D; n)）就有：<br>$$<br>\\sum_{i&#x3D;1}^n \\hat{c}<em>i \\geq \\sum</em>{i&#x3D;1}^n c_i<br>$$<br><img data-src=\"/1202-1.png\"><br>不同操作的摊还代价可能会不同，</p>\n<ol start=\"3\">\n<li>Potential method<br><img data-src=\"/12-5-1.png\"></li>\n</ol>\n<p>+++info<br>;;;id3 例子<br>2-5 Consider the following buffer management problem. Initially the buffer size (the number of blocks) is one. Each block can accommodate exactly one item. As soon as a new item arrives, check if there is an available block. If yes, put the item into the block, induced a cost of one. Otherwise, the buffer size is doubled, and then the item is able to put into. Moreover, the old items have to be moved into the new buffer so it costs <em>k</em>+1 to make this insertion, where <em>k</em> is the number of old items. Clearly, if there are <em>N</em> items, the worst-case cost for one insertion can be Ω(<em>N</em>). To show that the average cost is <em>O</em>(1), let us turn to the amortized analysis. To simplify the problem, assume that the buffer is full after all the <em>N</em> items are placed. Which of the following potential functions works?</p>\n<p>A. The number of items currently in the buffer</p>\n<p>B. The opposite number of items currently in the buffer</p>\n<p>C. The number of available blocks currently in the buffer</p>\n<p>D. The opposite number of available blocks in the buffer<br>;;;</p>\n<p>;;;<br>D.&#x3D;&#x3D;势能函数需要保证摊还成本都为常数，一个一个试只能选D&#x3D;&#x3D;<br><img data-src=\"/hw.png\"><br>;;;<br>+++</p>\n",
            "tags": [
                "Amortized Analysis"
            ]
        },
        {
            "id": "http://example.com/2025/09/15/computer-science/DS/ch1/",
            "url": "http://example.com/2025/09/15/computer-science/DS/ch1/",
            "title": "ch1",
            "date_published": "2025-09-14T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch1-绪论\"><a href=\"#Ch1-绪论\" class=\"headerlink\" title=\"Ch1 绪论\"></a>Ch1 绪论</h1><p>数据<br>数据元素是数据的基本单位<br>数据对象<br>数据类型：原子类型、结构类型、抽象数据类型<br>数据结构：三要素包括逻辑结构、存储结构和数据的运算</p>\n<ul>\n<li>逻辑结构：集合、线性结构、树形结构、图状或网状</li>\n<li>存储结构：顺序存储、链式存储、索引存储、散列存储</li>\n<li>数据的运算：定义针对逻辑结构，实现针对存储结构</li>\n</ul>\n<p>算法的特性：又穷行、确定性、可行性、输入、输出<br>好的算法还应该考虑：正确性、可读性、健壮性、高效率和低存储量需求</p>\n<p>复杂度：时间复杂度、空间复杂度</p>\n",
            "tags": [
                "数据结构"
            ]
        },
        {
            "id": "http://example.com/2025/09/15/computer-science/DS/ch2/",
            "url": "http://example.com/2025/09/15/computer-science/DS/ch2/",
            "title": "ch2",
            "date_published": "2025-09-14T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch2-线性表\"><a href=\"#Ch2-线性表\" class=\"headerlink\" title=\"Ch2 线性表\"></a>Ch2 线性表</h1><p>存储结构：顺序表（数组），链表</p>\n<h2 id=\"顺序表\"><a href=\"#顺序表\" class=\"headerlink\" title=\"顺序表\"></a>顺序表</h2><p>逻辑顺序和物理顺序一致，都连续<br>按下标访问O(1)，插入操作平均移动n&#x2F;2，删除操作平均移动(n-1)&#x2F;2</p>\n<figure class=\"highlight c\"><figcaption><span>静态分配</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 50</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    ElemType data[MaxSize];</span><br><span class=\"line\">    <span class=\"type\">int</span> length;</span><br><span class=\"line\">&#125;SqList;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><figcaption><span>动态分配</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> InitSize 100</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    ElemType *data;</span><br><span class=\"line\">    <span class=\"type\">int</span> MaxSize, length;</span><br><span class=\"line\">&#125;SqList;</span><br></pre></td></tr></table></figure>\n<p>初始动态分配：</p>\n<figure class=\"highlight c\"><figcaption><span>c</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L.data = (ElemType*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(ElemType)*InitSize);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>c++</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L.data = <span class=\"keyword\">new</span> ElemType[InitSize];</span><br></pre></td></tr></table></figure>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><figure class=\"highlight c++\"><figcaption><span>静态分配初始化</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">InitList</span><span class=\"params\">(SqList &amp;L)</span></span>&#123;</span><br><span class=\"line\">    L.length = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>动态分配初始化</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">InitList</span><span class=\"params\">(SqList &amp;L)</span></span>&#123;</span><br><span class=\"line\">    L.data = (ElemType*)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span>(ElemType)*InitSize);</span><br><span class=\"line\">    L.MaxSize = InitSize;</span><br><span class=\"line\">    L.length = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"插入操作\"><a href=\"#插入操作\" class=\"headerlink\" title=\"插入操作\"></a>插入操作</h3><p>在顺序表的第i个<code>位置</code>插入元素e，注意是位置不是下标(1&lt;&#x3D;i&lt;&#x3D;L.length+1)</p>\n<figure class=\"highlight c++\"><figcaption><span>插入操作</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">ListInsert</span><span class=\"params\">(SqList &amp;L, <span class=\"type\">int</span> i, ElemType e)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i&lt;<span class=\"number\">1</span> || i&gt;L.length<span class=\"number\">+1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L.length &gt;= L.MaxSize) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"built_in\">fot</span>(<span class=\"type\">int</span> j = L.length; j&gt;=i; j--)</span><br><span class=\"line\">        L.data[j] = L.data[j<span class=\"number\">-1</span>];</span><br><span class=\"line\">    L.data[i<span class=\"number\">-1</span>] = e;</span><br><span class=\"line\">    L.length++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>插入移动的平均次数为n&#x2F;2，插入算法的平均时间复杂度为$O(n)$</p>\n<h3 id=\"删除操作\"><a href=\"#删除操作\" class=\"headerlink\" title=\"删除操作\"></a>删除操作</h3><p>删除顺序表中第i个元素，返回删除的元素e</p>\n<figure class=\"highlight c++\"><figcaption><span>删除操作</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">ListDelete</span><span class=\"params\">(SqList &amp;L, <span class=\"type\">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i&lt;<span class=\"number\">1</span> || i&gt;L.length) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    e = L.data[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = i; j&lt;L.length; j++)</span><br><span class=\"line\">        L.data[j<span class=\"number\">-1</span>] = L.data[j];</span><br><span class=\"line\">    L.length--;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>删除操作的平均移动此时是(n-1)&#x2F;2，平均时间复杂度为$O(n)$</p>\n<h3 id=\"按值查找\"><a href=\"#按值查找\" class=\"headerlink\" title=\"按值查找\"></a>按值查找</h3><figure class=\"highlight c++\"><figcaption><span>按值查找</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">LocateElem</span><span class=\"params\">(SqList L, ElemType e)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i&lt;L.length; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(L.data[i] == e)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i<span class=\"number\">+1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>平均需要访问(n+1)&#x2F;2个元素，平均时间复杂度为$O(n)$</p>\n<h2 id=\"单链表\"><a href=\"#单链表\" class=\"headerlink\" title=\"单链表\"></a>单链表</h2><h3 id=\"链表结构\"><a href=\"#链表结构\" class=\"headerlink\" title=\"链表结构\"></a>链表结构</h3><figure class=\"highlight c++\"><figcaption><span>单链表结构</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">LNode</span>&#123;</span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">LNode</span> *next;</span><br><span class=\"line\">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"初始化-1\"><a href=\"#初始化-1\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><figure class=\"highlight c++\"><figcaption><span>带头节点的初始化</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">InitList</span><span class=\"params\">(LinkList &amp;L)</span></span>&#123;</span><br><span class=\"line\">    L = (LNode*)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span>(LNode));</span><br><span class=\"line\">    L-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>不带头节点的初始化</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">InitList</span><span class=\"params\">(LinkList &amp;L)</span></span>&#123;</span><br><span class=\"line\">    L = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"求表长\"><a href=\"#求表长\" class=\"headerlink\" title=\"求表长\"></a>求表长</h3><p>从头开始遍历，每访问一个节点，长度加1</p>\n<figure class=\"highlight c++\"><figcaption><span>求表长</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Length</span><span class=\"params\">(LinkList L)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    LNode *p = L;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        len++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"按序号查找\"><a href=\"#按序号查找\" class=\"headerlink\" title=\"按序号查找\"></a>按序号查找</h3><p>从头开始遍历直到找到第i个节点</p>\n<figure class=\"highlight c++\"><figcaption><span>按序号查找</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LNode* <span class=\"title\">GetElem</span><span class=\"params\">(LinkList L, <span class=\"type\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    LNode *p = L;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span> &amp;&amp; j&lt;i)&#123;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        j++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"按值查找-1\"><a href=\"#按值查找-1\" class=\"headerlink\" title=\"按值查找\"></a>按值查找</h3><p>从头开始遍历，如果找到则返回该节点</p>\n<figure class=\"highlight c++\"><figcaption><span>按值查找</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LNode* <span class=\"title\">LocateElem</span><span class=\"params\">(LinkList L, ElemType e)</span></span>&#123;</span><br><span class=\"line\">    LNode *p = L-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span> &amp;&amp; p-&gt;data != e)&#123;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"插入操作-1\"><a href=\"#插入操作-1\" class=\"headerlink\" title=\"插入操作\"></a>插入操作</h3><p>先把后继连到新节点的后继，再把前继节点的后继连到新节点</p>\n<figure class=\"highlight c++\"><figcaption><span>插入操作</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">ListInsert</span><span class=\"params\">(LinkList &amp;L, <span class=\"type\">int</span> i, ElemType e)</span></span>&#123;</span><br><span class=\"line\">    LNode p = L;</span><br><span class=\"line\">    <span class=\"type\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span> &amp;&amp; j&lt;i<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        j++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    LNode *s = (LNode*)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span>(LNode));</span><br><span class=\"line\">    s-&gt;data = e;</span><br><span class=\"line\">    s-&gt;next = p-&gt;next;</span><br><span class=\"line\">    p-&gt;next = s;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删除操作-1\"><a href=\"#删除操作-1\" class=\"headerlink\" title=\"删除操作\"></a>删除操作</h3><p>先找到待删除节点的前一个节点，再把前一个节点的next指向待删除节点的next，然后释放待删除节点</p>\n<figure class=\"highlight c++\"><figcaption><span>删除操作</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">ListDelete</span><span class=\"params\">(LinkList &amp;L, <span class=\"type\">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class=\"line\">    LNode *p = L;</span><br><span class=\"line\">    <span class=\"type\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span> &amp;&amp; j&lt;i<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        j++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p-&gt;next == <span class=\"literal\">NULL</span> || j&gt;i<span class=\"number\">-1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    LNode *q = p-&gt;next;</span><br><span class=\"line\">    e = q-&gt;data;</span><br><span class=\"line\">    p-&gt;next = q-&gt;next;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(q);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"采用头插法建立单链表\"><a href=\"#采用头插法建立单链表\" class=\"headerlink\" title=\"采用头插法建立单链表\"></a>采用头插法建立单链表</h3><p>先建立一个头结点，每次插入到头结点之后<br>可以用来实现链表逆序，总时间复杂度为$O(n)$</p>\n<figure class=\"highlight c++\"><figcaption><span>采用头插法建立单链表</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LinkLisk <span class=\"title\">List_HeadInsert</span><span class=\"params\">(LinkList &amp;L)</span></span>&#123;</span><br><span class=\"line\">    LNode *s;</span><br><span class=\"line\">    <span class=\"type\">int</span> x;</span><br><span class=\"line\">    L = (*LNode)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span>(LNode));</span><br><span class=\"line\">    L-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;x);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x != <span class=\"number\">9999</span>)&#123;</span><br><span class=\"line\">        s = (LNode*)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span>(LNode));</span><br><span class=\"line\">        s-&gt;data = x;</span><br><span class=\"line\">        s-&gt;next = L-&gt;next;</span><br><span class=\"line\">        L-&gt;next = s;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"采用尾插法建立单链表\"><a href=\"#采用尾插法建立单链表\" class=\"headerlink\" title=\"采用尾插法建立单链表\"></a>采用尾插法建立单链表</h3><figure class=\"highlight c++\"><figcaption><span>采用尾插法建立单链表</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LinkList <span class=\"title\">List_TailInsert</span><span class=\"params\">(LinkList &amp;L)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x;</span><br><span class=\"line\">    L = (LNode*)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span>(LNode));</span><br><span class=\"line\">    LNode *s, *r = L;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;x);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x != <span class=\"number\">9999</span>)&#123;</span><br><span class=\"line\">        s = (LNode*)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span>(LNode));</span><br><span class=\"line\">        s-&gt;data = x;</span><br><span class=\"line\">        r-&gt;next = s;</span><br><span class=\"line\">        r = s;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    r-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"双链表\"><a href=\"#双链表\" class=\"headerlink\" title=\"双链表\"></a>双链表</h2><h3 id=\"双链表结构\"><a href=\"#双链表结构\" class=\"headerlink\" title=\"双链表结构\"></a>双链表结构</h3><figure class=\"highlight c++\"><figcaption><span>双链表结构</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">DNode</span>&#123;</span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">DNode</span> *prior, *next;</span><br><span class=\"line\">&#125;DNode, *DLinkList;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"双链表的插入\"><a href=\"#双链表的插入\" class=\"headerlink\" title=\"双链表的插入\"></a>双链表的插入</h3><figure class=\"highlight c++\"><figcaption><span>双链表的插入</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s-&gt;next = p-&gt;next;</span><br><span class=\"line\">p-&gt;next-&gt;prior = s;</span><br><span class=\"line\">s-&gt;prior = p;</span><br><span class=\"line\">p-&gt;next = s;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"双链表的删除\"><a href=\"#双链表的删除\" class=\"headerlink\" title=\"双链表的删除\"></a>双链表的删除</h3><figure class=\"highlight c++\"><figcaption><span>双链表的删除</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p-&gt;next = q-&gt;next;</span><br><span class=\"line\">q-next-&gt;prior = p;</span><br><span class=\"line\"><span class=\"built_in\">free</span>(q);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"循环链表\"><a href=\"#循环链表\" class=\"headerlink\" title=\"循环链表\"></a>循环链表</h2><h3 id=\"循环单链表\"><a href=\"#循环单链表\" class=\"headerlink\" title=\"循环单链表\"></a>循环单链表</h3><h3 id=\"循环双链表\"><a href=\"#循环双链表\" class=\"headerlink\" title=\"循环双链表\"></a>循环双链表</h3><h2 id=\"静态链表\"><a href=\"#静态链表\" class=\"headerlink\" title=\"静态链表\"></a>静态链表</h2><p>用数组来表示线性表的链式存储结构</p>\n<figure class=\"highlight c++\"><figcaption><span>静态链表结构</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 50</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"type\">int</span> next;   <span class=\"comment\">//下一个元素的数组下标</span></span><br><span class=\"line\">&#125; SlinkList[MaxSize];</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>next &#x3D; -1表示结束标志</p>\n</blockquote>\n<h2 id=\"顺序表和链表比较\"><a href=\"#顺序表和链表比较\" class=\"headerlink\" title=\"顺序表和链表比较\"></a>顺序表和链表比较</h2><ol>\n<li>存取<br>顺序表可以顺序存取&#x2F;随机存取，链表只能顺序</li>\n<li>逻辑结构和物理结构<br>顺序表和链表的逻辑结构相同，顺序表物理结构存储连续，链表物理结构存储不一定连续</li>\n<li>删改查的复杂度<br>略</li>\n<li>空间分配<br>链表的空间分配比较灵活，但存储密度低</li>\n</ol>\n<ul>\n<li>难以估计线性表的长度时不宜采用顺序表</li>\n<li>按序号访问多选顺序表，插入删除多选链表</li>\n</ul>\n",
            "tags": [
                "线性表"
            ]
        },
        {
            "id": "http://example.com/2025/08/15/computer-science/computer-organization/ch7/",
            "url": "http://example.com/2025/08/15/computer-science/computer-organization/ch7/",
            "title": "Ch7",
            "date_published": "2025-08-14T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch7-输入-输出系统\"><a href=\"#Ch7-输入-输出系统\" class=\"headerlink\" title=\"Ch7 输入&#x2F;输出系统\"></a>Ch7 输入&#x2F;输出系统</h1><h2 id=\"I-O接口\"><a href=\"#I-O接口\" class=\"headerlink\" title=\"I&#x2F;O接口\"></a>I&#x2F;O接口</h2><p>inerrface，主机与外设之间的交接界面</p>\n<h3 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h3><ol>\n<li>进行地址译码和设备选择</li>\n<li>实现主机和外设的通信联络控制<br>解决时序、工作速度不同的问题</li>\n<li>实现数据缓冲</li>\n<li>信号格式的转换<br>电平转换、并&#x2F;串或串&#x2F;并转换、模&#x2F;数或数&#x2F;模转换</li>\n<li>传送控制命令和状态信息<br>CPU通过接口中的命令寄存器发出启动命令给外设，外设就绪是传回Ready状态信息通过接口中的状态寄存器反馈给CPU</li>\n</ol>\n<h3 id=\"基本结构\"><a href=\"#基本结构\" class=\"headerlink\" title=\"基本结构\"></a>基本结构</h3><p><img data-src=\"/f1.jpg\"><br>主机侧通过I&#x2F;O总线与内存、CPU相连。数据缓冲器用来暂存与CPU或内存之间传送的数据信息。状态寄存器用来记录接口和设备的状态信息，控制寄存器用来保存CPU对外设的控制信息<br>状态寄存器和控制寄存器在传送方向是相反的，访问时间上是错开的，所以可以合二为一<br>数据线传送读&#x2F;写数据、状态信息、控制信息、中断类型号<br>地址线传送访问I&#x2F;O接口中的寄存器的地址<br>控制线传送读写控制信号、中断请求、响应信号、仲裁信号、握手信号<br>I&#x2F;O控制逻辑需要对控制寄存器的命令字进行译码，还有收集外设状态到状态寄存器<br><img data-src=\"/f2.jpg\"></p>\n<blockquote>\n<p>对上面两个寄存器的访问操作通过I&#x2F;O指令来完成，只能在操作系统内核的底层I&#x2F;O软件中使用，是一种特权指令<br><img data-src=\"/f3.jpg\"></p>\n</blockquote>\n<h3 id=\"接口类型\"><a href=\"#接口类型\" class=\"headerlink\" title=\"接口类型\"></a>接口类型</h3><ol>\n<li>按（外设和接口一侧的）数据传送方式：并行接口、串行接口</li>\n<li>按主机访问I&#x2F;O设备的控制方式：程序查询接口、中断接口、DMA接口</li>\n<li>按功能选择的灵活性：可编程接口、不可编程接口</li>\n</ol>\n<h3 id=\"I-O端口及其编址\"><a href=\"#I-O端口及其编址\" class=\"headerlink\" title=\"I&#x2F;O端口及其编址\"></a>I&#x2F;O端口及其编址</h3><p>I&#x2F;O端口是指I&#x2F;O接口电路中<strong>可被CPU直接访问的寄存器</strong>，主要有&#x3D;&#x3D;数据端口、状态端口和控制端口&#x3D;&#x3D;。<br>CPU能对数据端口中的数据进行读&#x2F;写操作，但对状态端口中外设的状态只能读，对控制端口只能写<br>每个端口对应一个端口地址，编址方式有与存储器独立编址和统一编址两种</p>\n<ol>\n<li>独立编址<br>也称I&#x2F;O映射方式，I&#x2F;O端口的地址空间与主存地址空间是两个独立的地址空间<br>需要设置专门的I&#x2F;O指令来表明访问的是I&#x2F;O地址空间，I&#x2F;O指令的地址码给出I&#x2F;O端口号<blockquote>\n<p>x86 架构中的 IN 和 OUT 指令<br>IN AL, 0x64    从 I&#x2F;O 端口 0x64 读取一个字节的数据，存入寄存器 AL<br>优点：I&#x2F;O端口数比主存单元数少得多，秩序少量地址线，使得I&#x2F;O端口译码简单，寻址速度更快。使用专门的I&#x2F;O指令，是程序更加清晰<br>缺点：I&#x2F;O指令少，只提供简单的传输操作，灵活性差。CPU需要提供存储器读&#x2F;写、I&#x2F;O设备读写两组控制信号，增大了控制的复杂性</p>\n</blockquote>\n</li>\n<li>统一编址<br>也称存储器映射方式(Memory-Mapped I&#x2F;O)，无需设置专门的I&#x2F;O指令，用统一的访存指令就可以访问I&#x2F;O端口<blockquote>\n<p>riscv就是用Memory-Mapped I&#x2F;O<br>优点：不需要专门的I&#x2F;O指令，CPU访问I&#x2F;O更灵活方便，端口有较大的编址空间。I&#x2F;O访问的保护机制可由虚拟存储管理系统来实现，无需专门设置（内核态才能访问）<br>缺点：端口地址占用了部分主存地址空间。译码电路复杂</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"I-O方式\"><a href=\"#I-O方式\" class=\"headerlink\" title=\"I&#x2F;O方式\"></a>I&#x2F;O方式</h2><p>程序查询、程序中断、DMA<br><img data-src=\"/f5.jpg\"></p>\n<h3 id=\"程序查询方式-Polling\"><a href=\"#程序查询方式-Polling\" class=\"headerlink\" title=\"程序查询方式(Polling)\"></a>程序查询方式(Polling)</h3><p>轮询法，程序执行到某个 I&#x2F;O 操作指令时，由操作系统或设备驱动程序发起<br><img data-src=\"/f4.jpg\"><br>程序查询方式分为两类：</p>\n<ol>\n<li>独占查询<br>一旦设备启动，CPU就一直持续查询接口状态，CPU话费100%时间用于I&#x2F;O操作，外设和CPU完全串行（忙等待）</li>\n<li>定时查询<br>CPU周期性地查询接口状态，每次总是等到条件满足才进行一个数据的传送，传送完成后返回到用户程序。<br>比如设备每 10ms 产生一个数据，可以设置 5ms 查询一次，这样既能及时读取数据，又不至于过度查询。&#x3D;&#x3D;定时查询的时间间隔与设备的数据传输速率有关。&#x3D;&#x3D;</li>\n</ol>\n<h3 id=\"程序中断方式\"><a href=\"#程序中断方式\" class=\"headerlink\" title=\"程序中断方式\"></a>程序中断方式</h3><p><img data-src=\"/f6.jpg\"><br>工作流程：</p>\n<ol>\n<li>中断请求<br>中断源向CPU发送中断请求信号。中断系统对每个中断源设置中断请求标记触发器<br>可屏蔽中断：通过<code>INTR</code>线发出的，优先级低，关中断下不被响应<br>不可屏蔽中断：通过<code>NMI</code>线发出的，优先级最高</li>\n<li>中断响应<br>响应中断的条件。<br>中断判优：多个中断源同时提出请求时通过中断判优逻辑响应一个中断源。<br>一般来说：不可屏蔽中断&gt;可屏蔽中断；在I&#x2F;O传送类终端中，高速设备&gt;低速设备，输入设备&gt;输出设备，实时设备&gt;普通设备<br>CPU响应中断的条件：</li>\n</ol>\n<ul>\n<li>中断源有中断请求</li>\n<li>允许中断及开中断</li>\n<li>一条指令执行完毕（除非是指令执行异常）</li>\n</ul>\n<ol start=\"3\">\n<li>中断处理</li>\n</ol>\n<ul>\n<li>中断隐指令：<ul>\n<li>关中断（防止在中断处理程序执行期间被其他（同级或低优先级）中断再次打断）</li>\n<li>保护现场（把PC, PSW等压入内核栈）</li>\n<li>引出中断服务程序：硬件向量法和软件查询法</li>\n</ul>\n</li>\n</ul>\n<p>中断向量：硬件提供向量号，中断控制器将该中断对应的向量号放到数据总线上，CPU读取该向量号，CPU使用该向量号作为索引，查找中断向量表（IVT）获取ISR的入口地址</p>\n<p>处理流程：</p>\n<ul>\n<li>关中断</li>\n<li>保存断点</li>\n<li>中断服务程序寻址</li>\n<li>保存现场和屏蔽字</li>\n<li>开中断（允许更高级中断请求得到响应）</li>\n<li>执行ISR</li>\n<li>关中断</li>\n<li>恢复现场和屏蔽字</li>\n<li>开中断，中断返回<br>1-3由硬件自动完成，4-9由ISR完成<blockquote>\n<p>为什么要先关再开？<br>确保这个保护现场的操作不会被其他中断打断</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"多重中断和中断屏蔽技术\"><a href=\"#多重中断和中断屏蔽技术\" class=\"headerlink\" title=\"多重中断和中断屏蔽技术\"></a>多重中断和中断屏蔽技术</h4><p>通过中断屏蔽字寄存器来实现，每个中断源都有一个屏蔽触发器，&#x3D;&#x3D;1表示屏蔽该中断源的请求&#x3D;&#x3D;，0表示可以正常申请<br>&#x3D;&#x3D;屏蔽字中‘1’越多，优先级越高。每个屏蔽字中至少有一个<code>1</code>(至少要能屏蔽自身的中断)&#x3D;&#x3D;<br>方法：要能屏蔽自身所以主对角线全为1，同时优先级比自身低的中断要屏蔽屏蔽字全填1，其他的填0</p>\n<h3 id=\"DMA方式\"><a href=\"#DMA方式\" class=\"headerlink\" title=\"DMA方式\"></a>DMA方式</h3><p>DMA方式是一种完全由硬件进行组信息传送的控制方式<br><img data-src=\"/f7.jpg\"><br><img data-src=\"/f8.jpg\"><br><img data-src=\"/f9.jpg\"></p>\n<p>当I&#x2F;O设备和CPU同时访问主存时，可能发生冲突，DMA与CPU通常采用以下3种方式使用驻村：<br><img data-src=\"/f10.jpg\"><br>周期挪用：<br>一次传一组数据</p>\n<ul>\n<li>CPU不访存时：如果CPU当前并不需要访问主存，那么DMA控制器可以直接使用总线进行数据传输，此时不会对CPU的工作造成任何影响。</li>\n<li>CPU正在访存时：如果CPU正在进行主存访问，DMA控制器会等待CPU的当前访问周期结束，然后立即“借用”接下来的一个或几个总线周期来进行自己的数据传输。这种情况下，CPU的访问会被短暂延迟，但通常这种延迟非常短，以至于CPU几乎感觉不到，因此可以认为CPU的正常工作没有受到显著影响。</li>\n<li>CPU与DMA同时请求访存时：在这种情况下，I&#x2F;O设备的访存请求通常具有更高的优先级，这意味着即使CPU也在请求访问主存，DMA控制器也会被优先考虑，从而保证I&#x2F;O设备的数据传输不受阻。</li>\n</ul>\n<ol>\n<li>停止CPU访存<br>优点：控制简单，适用于数据传输速率很高的I&#x2F;O设备实现成组数据的传送<br>缺点：DMA访问主存时，CPU基本上不工作</li>\n<li>周期挪用<br>优点：既实现了I&#x2F;O传送，又较好地发挥了主存与CPU的效率<br>缺点：每挪用一个主存周期，DMA接口都要申请、建立和归还总线周期</li>\n<li>交替访存<br>优点：不需要总线控制权的申请、建立和归还过程，传送效率高<br>缺点：相应的硬件逻辑变得更复杂</li>\n</ol>\n<h4 id=\"DMA的传送过程\"><a href=\"#DMA的传送过程\" class=\"headerlink\" title=\"DMA的传送过程\"></a>DMA的传送过程</h4><p><img data-src=\"/f9.jpg\"></p>\n<ul>\n<li>预处理：由CPU初始化DMA控制其中的寄存器、设置传送方式、测试并启动设备</li>\n<li>数据传送：DMA以数据块为基本传送单位。数据传送完全由DMA控制</li>\n<li>后处理：DMA控制器向CPU发送中断请求，CPU处理中断做DMA结束处理（包括校验）</li>\n</ul>\n<p>DMA方式和中断方式的区别：</p>\n<ul>\n<li>中断需要save context，DMA不需要，除了预处理和后处理其他时候不占用CPU（我觉得DMA方式的预处理和后处理的中断也是需要save context的，只是因为DMA方式中断次数极少，整个数据块只中断一次，所以不需要保存那么多次，所以比较快）</li>\n<li>对中断请求的相应只能发生在每条指令执行结束时，但对DMA请求的相应可以发生在任意一个机器周期结束时(IF, ID, EX…  DMA请求的是总线控制权，不是CPU的执行权。它不关心 CPU正在执行哪条指令，只关心总线是否空闲。只要当前总线周期结束，DMA就可以插空使用)</li>\n<li>中断传送过程需要CPU的干预，DMA传送不需要，数据传输速率高</li>\n</ul>\n<p>优先级：</p>\n<ul>\n<li>DMA请求的优先级高于中断请求</li>\n<li>中断方式具有处理异常事件的能力，DMA方式局限于大批数据的传送</li>\n<li>中断方式靠程序传送，DMA方式靠硬件传送</li>\n</ul>\n",
            "tags": [
                "I/O"
            ]
        },
        {
            "id": "http://example.com/2025/08/10/computer-science/computer-organization/ch5/",
            "url": "http://example.com/2025/08/10/computer-science/computer-organization/ch5/",
            "title": "Ch5",
            "date_published": "2025-08-09T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch5-中央处理器\"><a href=\"#Ch5-中央处理器\" class=\"headerlink\" title=\"Ch5 中央处理器\"></a>Ch5 中央处理器</h1><h2 id=\"CPU的功能和基本结构\"><a href=\"#CPU的功能和基本结构\" class=\"headerlink\" title=\"CPU的功能和基本结构\"></a>CPU的功能和基本结构</h2><h3 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h3><p>CPU由运算器和控制器组成，具体功能包括：</p>\n<ul>\n<li>指令控制</li>\n<li>操作控制</li>\n<li>时间控制</li>\n<li>数据加工</li>\n<li>中断处理</li>\n</ul>\n<h3 id=\"基本结构\"><a href=\"#基本结构\" class=\"headerlink\" title=\"基本结构\"></a>基本结构</h3><ol>\n<li>运算器：ALU, 暂存器, ACC, GPRs, PSW, 移位寄存器， 计数器…</li>\n<li>控制器：PC, IR, ID, 时序电路，未操作信号发生器…</li>\n</ol>\n<h3 id=\"CPU的寄存器\"><a href=\"#CPU的寄存器\" class=\"headerlink\" title=\"CPU的寄存器\"></a>CPU的寄存器</h3><p>按汇编程序是否可访问分为用户可见寄存器(GPRs, PSW, PC)和用户不可见寄存器(存储器地址寄存器，存储器数据寄存器，IR, 暂存寄存器，累加寄存器，移位寄存器)<br>各寄存器的作用：</p>\n<ul>\n<li>在运算器中：<ul>\n<li>GPRs</li>\n<li>ACC: 通用寄存器，用于暂时存放ALU运算的结果</li>\n<li>SR（移位寄存器）：存放操作数且可以移位</li>\n<li>暂存寄存器：暂存从数据总线或通用寄存器送来的操作数，对应用程序员透明</li>\n<li>PSW：保留各种状态信息</li>\n</ul>\n</li>\n<li>在控制器中：<ul>\n<li>PC: 存放当前指令的地址</li>\n<li>IR: 存放当前指令</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"指令执行过程\"><a href=\"#指令执行过程\" class=\"headerlink\" title=\"指令执行过程\"></a>指令执行过程</h2><h3 id=\"指令周期\"><a href=\"#指令周期\" class=\"headerlink\" title=\"指令周期\"></a>指令周期</h3><p>&#x3D; 取值周期 + 执行周期<br>间址周期在取址和执行之间<br>如果CPU在每条指令结束前都要发中断查询信号 （轮询法），后面要加上中断周期</p>\n<h3 id=\"指令周期的数据流\"><a href=\"#指令周期的数据流\" class=\"headerlink\" title=\"指令周期的数据流\"></a>指令周期的数据流</h3><ol>\n<li>取址周期</li>\n</ol>\n<ul>\n<li>PC-&gt;MAR-&gt;地址总线-&gt;存储器</li>\n<li>CU发出读命令-&gt;控制总线-&gt;主存</li>\n<li>主存-&gt;数据总线-&gt;IR</li>\n<li>CU发出控制信号-&gt;PC&#x3D;PC+1</li>\n</ul>\n<ol start=\"2\">\n<li>间址周期<br>取指结束后，控制单元CU会检查IR中是否有间接地址（操作数有效地址的地址）。若有，CPU执行如下操作：</li>\n</ol>\n<ul>\n<li>IR(或MDR)的间址-&gt;MAR-&gt;地址总线-&gt;主存</li>\n<li>CU发出读命令-&gt;控制总线-&gt;主存</li>\n<li>主存-&gt;数据总线-&gt;MDR（取出有效地址存入MDR）</li>\n</ul>\n<ol start=\"3\">\n<li><p>执行周期</p>\n</li>\n<li><p>中断周期<br>假设程序断点存入堆栈中，push操作先修改SP再存入（x86采用满递减栈）</p>\n</li>\n</ol>\n<ul>\n<li>CU控制将SP减1，SP-&gt;MAR-&gt;地址总线-&gt;zhucun1</li>\n<li>CU发出写命令-&gt;控制总线-&gt;主存</li>\n<li>PC-&gt;MDR-&gt;数据总线-&gt;主存（把中断时的PC存入栈中）</li>\n<li>CU将中断服务程序入口地址存入PC</li>\n</ul>\n<h3 id=\"指令执行方案\"><a href=\"#指令执行方案\" class=\"headerlink\" title=\"指令执行方案\"></a>指令执行方案</h3><ol>\n<li>单周期处理器<br>CPI &#x3D; 1，指令执行周期取决于执行时间最长的指令的执行时间</li>\n<li>多周期处理器<br>CPI &gt; 1,</li>\n<li>流水线处理器<br>理想状态下CPI &#x3D; 1，流水线并行</li>\n</ol>\n<h2 id=\"数据通路\"><a href=\"#数据通路\" class=\"headerlink\" title=\"数据通路\"></a>数据通路</h2><h3 id=\"功能-1\"><a href=\"#功能-1\" class=\"headerlink\" title=\"功能\"></a>功能</h3><p>。</p>\n<h3 id=\"组成\"><a href=\"#组成\" class=\"headerlink\" title=\"组成\"></a>组成</h3><ol>\n<li>组合逻辑<br>译码器，MUX，三态门…</li>\n<li>时序逻辑<br>包含存储信号的记忆单元</li>\n</ol>\n<h3 id=\"基本结构-1\"><a href=\"#基本结构-1\" class=\"headerlink\" title=\"基本结构\"></a>基本结构</h3><p>2种：</p>\n<ul>\n<li>CPU内部总线（单总线、多总线）</li>\n<li>专用数据通路</li>\n</ul>\n<ol>\n<li>CPU内部单总线方式<br>ALU和寄存器连接到一条总线上，性能低<br>单总线的ALU要配合暂存器使用，比如从内存取出来的数据要放在暂存器中，再从暂存器中取数据给ALU<br><img data-src=\"/f1.jpg\"><br>了解每条指令的datapath</li>\n<li>CPU内部多总线方式<br>允许同时在多个总线上传送不同的数据，提高效率</li>\n<li>专用数据通路方式<br>看图说话，没什么好说的</li>\n</ol>\n<h3 id=\"数据通路的操作举例\"><a href=\"#数据通路的操作举例\" class=\"headerlink\" title=\"数据通路的操作举例\"></a>数据通路的操作举例</h3><p>会画图就会</p>\n<h2 id=\"控制器的功能和工作原理\"><a href=\"#控制器的功能和工作原理\" class=\"headerlink\" title=\"控制器的功能和工作原理\"></a>控制器的功能和工作原理</h2><h3 id=\"结构和功能\"><a href=\"#结构和功能\" class=\"headerlink\" title=\"结构和功能\"></a>结构和功能</h3><ol>\n<li>取指令，指出下一条指令的位置</li>\n<li>译码或测试，产生控制信号</li>\n<li>控制CPU，主存，I&#x2F;O的数据流动方向<br>分为硬布线控制器和微程序控制器</li>\n</ol>\n<h3 id=\"硬布线控制器\"><a href=\"#硬布线控制器\" class=\"headerlink\" title=\"硬布线控制器\"></a>硬布线控制器</h3><p>组合逻辑控制器<br>CU的输入信号来自(1)指令译码器(2)时钟脉冲(3)执行单元的反馈信息<br>比如这种：<br><img data-src=\"/f2.jpg\"></p>\n<h3 id=\"微程序控制器\"><a href=\"#微程序控制器\" class=\"headerlink\" title=\"微程序控制器\"></a>微程序控制器</h3><p>采用存储逻辑实现，将未操作信号代码化，使没调机器指令转化成一段微程序并存入专门的控制存储器中<br>晚点回来学</p>\n<h2 id=\"异常和中断机制\"><a href=\"#异常和中断机制\" class=\"headerlink\" title=\"异常和中断机制\"></a>异常和中断机制</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>内部产生的意外事件叫异常，是同步的；外部产生的事件叫中断，是异步的</p>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><ul>\n<li><p>异常：CPU内部执行指令引起的异常事件，比如整除0，溢出，单步跟踪，非法指令，栈溢出，地址越界，缺页等</p>\n<ul>\n<li><ol>\n<li>Fault故障<br>引起故障的指令启动后、执行结束前检测到的异常事件（所以处理完之后要重新执行该指令或者无法恢复的终止进程）</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>Trap自陷<br>人为设定的特殊中断机制，最常见的是sys call，还有断点、单步，还有一些条件自陷指令（MIPS的teq, teqi, tne, tnei）等<br>&#x3D;&#x3D;以上两种都属于软件中断&#x3D;&#x3D;</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>Abort终止<br>执行过程中发生了硬件故障，比如控制器出错、存储器校验错、总线错误等<br>&#x3D;&#x3D;Abort和外中断属于硬件中断&#x3D;&#x3D;</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>中断：CPU外部比如I&#x2F;O引起的中断，分为可屏蔽中断和不可屏蔽中断</p>\n<ul>\n<li>可屏蔽中断：可屏蔽中断请求线INTR向CPU发出中断请求，CPU可以设置相应的bit屏蔽</li>\n<li>不可屏蔽中断：通过专门的不可屏蔽中断请求线NMI向CPU发出的中断请求，通常是非常紧急的硬件故障<br>&#x3D;&#x3D;所有的异常和终端都是由硬件检测发现的&#x3D;&#x3D;<br>根据识别中断服务程序地址的方式，可以分为向量中断和非向量中断；<br>根据中断处理过程是否允许被打断分为单重中断和多重中断</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"异常和中断的响应过程\"><a href=\"#异常和中断的响应过程\" class=\"headerlink\" title=\"异常和中断的响应过程\"></a>异常和中断的响应过程</h3><ol>\n<li>关中断<br>保存断点和程序状态期间，把IF置0不允许响应中断</li>\n<li>保存断点和程序状态<br>将返回地址和被中断时的PSW送到栈或特定寄存器中（通常是栈，才能支持嵌套中断），处理完之后恢复</li>\n<li>识别异常和中断并转到相应的处理程序<br>异常大多采用软件识别，中断可以采用软件识别或硬件识别<br>软件识别：CPU设置异常状态寄存器，操作系统使用查询程序按优先级顺序查询异常状态寄存器以检测类型并处理<br>硬件识别：向量中断。每个异常或中断被指定一个中断类型号，发生之后查询中断向量表，找到处理程序的入口地址（中断向量），并跳转到处理程序</li>\n</ol>\n<h2 id=\"指令流水线\"><a href=\"#指令流水线\" class=\"headerlink\" title=\"指令流水线\"></a>指令流水线</h2><ul>\n<li>Performance via parallelism</li>\n<li>Performance via pipelining</li>\n<li>Performance via prediction<br>时间并行：流水线<br>空间并行：超标量</li>\n</ul>\n<h3 id=\"基本实现\"><a href=\"#基本实现\" class=\"headerlink\" title=\"基本实现\"></a>基本实现</h3><p>单周期CPU以执行最慢的指令周期作为时钟周期。不能缩短单挑指令的执行时间，但可以提高整个程序的执行速度<br>每个流水段后面都要加一个流水段寄存器锁存数据，保证本段的执行结果能在下个周期给下一流水段使用。</p>\n<h3 id=\"Hazard\"><a href=\"#Hazard\" class=\"headerlink\" title=\"Hazard\"></a>Hazard</h3><ul>\n<li>结构冒险、数据冒险、控制冒险</li>\n</ul>\n<ol>\n<li>structural hazard<br>在流水线执行期间，两条及以上指令同一时间对同一个硬件资源发起使用的请求（Memory conflicts, Register File conflicts, Other units conflicts）<br>解决方法：(1)stall (2)增加更多的硬件支持单元（比如Double Bump，前半周期写后半周期读）</li>\n<li>data hazard<br>RAW, WAR, WAW<br>统考不考乱序执行所以只需要考虑RAW写后读<br>解决方法：(1)stall (2)NOP (3)forwarding</li>\n</ol>\n<ul>\n<li>stall<br>硬件解决方法，流水线阻塞，使数据相关的后续指令延迟执行，也称为插入气泡（bubble）</li>\n<li>NOP<br>软件解决方法，编译时插入空操作（NOP）比如<code>addi x0,x0,0</code>，使数据相关的后续指令延迟执行</li>\n<li>forwarding<br>旁路转发，将数据通路生成的中间数据直接往前传递到ALU的输入端，参与下一条指令的运算<br>必须同时满足两个条件：</li>\n<li>指令确实会写入寄存器（通过检查 RegWrite 信号）。</li>\n<li>目标寄存器编号不是 x0（零寄存器不会变）<br>才需要forwarding<blockquote>\n<p>ALU-&gt;ALU<br>数据可以从 <code>EX/MEM</code> 或 <code>MEM/WB</code> 阶段转发到当前在 EX 阶段的 ALU 输入<br>MEM-&gt;ALU<br>load指令的数据只有在<code>MEM/WB</code>阶段才能被转发到当前在 EX 阶段的 ALU 输入，所以如果load下一条指令要用到load指令的数据，则需要先stall一周期再forwarding</p>\n</blockquote>\n</li>\n</ul>\n<ol start=\"3\">\n<li>control hazard<br>解决方法：</li>\n</ol>\n<ul>\n<li>插入3条<code>NOP</code>直到分支指令的<code>WB</code>阶段才进行下一条指令的<code>IF</code></li>\n<li>分支预测<br><img data-src=\"/f5.jpg\"></li>\n</ul>\n<h3 id=\"流水线的性能指标\"><a href=\"#流水线的性能指标\" class=\"headerlink\" title=\"流水线的性能指标\"></a>流水线的性能指标</h3><ol>\n<li>吞吐率<br>单位时间内流水线所完成的任务数量<br>$$<br>TP &#x3D; \\frac{n}{T_k}<br>$$<br>k是流水线的段数，n是任务数，Tk是处理n个任务所用的总时间。理想状态下一条k段流水线能在<code>k+n-1</code>个时钟周期完成<code>n</code>个任务，吞吐率为$\\frac{n}{(k + n - 1) \\Delta t}$</li>\n<li>流水线的加速比<br>完成同一批任务，不适用流水线和使用流水线所用的时间之比<br>理想状态下流水线加速比为$\\frac{k n}{k+n-1}$</li>\n</ol>\n<h3 id=\"高级流水线技术\"><a href=\"#高级流水线技术\" class=\"headerlink\" title=\"高级流水线技术\"></a>高级流水线技术</h3><ol>\n<li>超标量流水线<br>动态多发射技术，支持乱序执行</li>\n</ol>\n<ul>\n<li>Scoreboard<br><img data-src=\"/f3.jpg\"></li>\n<li>Tomasulo<br><img data-src=\"/f4.jpg\"></li>\n</ul>\n<ol start=\"2\">\n<li>超长指令字技术<br>静态多发射技术，将多条能并行操作的指令组合成一个超长指令字，需要多个处理不见</li>\n<li>超流水线技术<br>流水线功能段划分的越多，时钟周期越短，指令吞吐率越高。<br>超流水线技术通过提高流水线主频来提高性能，但是流水段越多中间寄存器的开销就越大<blockquote>\n<p>超流水线或者理想状态下流水线技术CPI&#x3D;1；多发射流水线的CPI可以小于1</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"多处理器\"><a href=\"#多处理器\" class=\"headerlink\" title=\"多处理器\"></a>多处理器</h2><h3 id=\"SISD-SIMD-MIMD\"><a href=\"#SISD-SIMD-MIMD\" class=\"headerlink\" title=\"SISD SIMD MIMD\"></a>SISD SIMD MIMD</h3><ol>\n<li>SISD: single instruction single data<br>传统串行处理器</li>\n<li>SIMD: single instruction multiple data<br>数据级并行技术(DLP)，一条指令可以同时对多个数据元素执行相同的操作，用到向量寄存器<br>在处理for循环数组时最有效（比如两个数组相加）；在使用case&#x2F;seitch时效率最低</li>\n<li>MISD: multiple instruction single data<br>实际上不存在</li>\n<li>MIMD: multiple instruction multiple data<br>TLP<br>分为多计算机系统和多处理器系统。<br>多计算机系统由多个独立的计算机节点组成，每个节点通常包含自己的存储器、CPU，具有独立的主存地址空间，通过消息传递进行数据传送，也称<code>消息传递MIMD</code><br>多处理器系统是共享存储多处理器<code>SMP</code>系统的简称，共享单一地址空间，也称共享存储MIMD<br>向量处理器是SIMD的变体，实现了直接操作一维数组指令集</li>\n</ol>\n<h3 id=\"硬件多线程\"><a href=\"#硬件多线程\" class=\"headerlink\" title=\"硬件多线程\"></a>硬件多线程</h3><ol>\n<li>细粒度多线程 Fine-grained multithreading<br>多个线程交叉执行指令，线程之间的指令不相关，可以乱序并行执行，需要频繁进行上下文切换，不需要重载流水线。牺牲单个线程执行的性能，来换取整个进程吞吐量的提升</li>\n<li>粗粒度多线程 Coarse-grained multithreading<br>连续几个时钟周期都执行同一线程的指令序列，尽在当前线程出现较大开销的阻塞才切换（比如L2 miss, L2 miss）相比细粒度多线程，上下文切换的频率较低，切换时需要重载流水线</li>\n<li>同时多线程 SMT<br>ILP+TLP，指令级并行的同时实现线程级并行，在同一个时钟周期发射多个不同线程中的多条指令执行<br>Intal的Hyper-threading就是SMT<br><img data-src=\"/f6.jpg\"></li>\n</ol>\n<h3 id=\"多核处理器\"><a href=\"#多核处理器\" class=\"headerlink\" title=\"多核处理器\"></a>多核处理器</h3><p>一个CPU有多个core，也称片上多处理器<br>每个核既可以有自己的Cache，又可以共享同一个Cache，所有核共享主存储器<br>多核处理器必须采用多线程（或多进程）才能发挥性能</p>\n<h3 id=\"共享内存多处理器-SMP\"><a href=\"#共享内存多处理器-SMP\" class=\"headerlink\" title=\"共享内存多处理器 SMP\"></a>共享内存多处理器 SMP</h3><p>处理器通过存储器中的共享变量互相通信，所有存储器都能通过存取指令访问存储器的任何位置，有两种：<br><img data-src=\"/f7.jpg\"></p>\n<ul>\n<li>UMA 统一存储访问多处理器<br>UMA中所有处理器对所有内存模块的访问延迟是相同的，由于访问延迟一致，数据放在哪个内存模块上对性能影响不大。随着系统规模扩大，所有处理器都通过同一个前端总线访问内存，导致互连网络成为瓶颈，延迟增加，带宽受限<br><img data-src=\"/f8.jpg\"></li>\n<li>NUMA 非统一存储访问多处理器<br>内存有本地内存和远程内存，访问本地内存快。CPU可以通过QPI总线访问远程内存<br><img data-src=\"/f9.jpg\"></li>\n<li>需要解决 Cache coherence 问题：Snooping(MSI, MESI, MOESI…), Directory<br>基本思想都是对共享变量加锁，保证互斥访问<ul>\n<li>Snooping:<br><img data-src=\"/f10.jpg\"><br><img data-src=\"/f11.jpg\"></li>\n<li>Directory:<br><img data-src=\"/f12.jpg\"></li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "CPU"
            ]
        },
        {
            "id": "http://example.com/2025/08/10/computer-science/computer-organization/ch6/",
            "url": "http://example.com/2025/08/10/computer-science/computer-organization/ch6/",
            "title": "Ch6",
            "date_published": "2025-08-09T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch6-总线\"><a href=\"#Ch6-总线\" class=\"headerlink\" title=\"Ch6 总线\"></a>Ch6 总线</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>总线是一组能为多个部件分时和共享的公共信息传送线路。&#x3D;&#x3D;分时&#x3D;&#x3D;和&#x3D;&#x3D;共享&#x3D;&#x3D;是总线的两个特点</p>\n<ul>\n<li>分时：同一时刻只允许有一个部件向总线发送信息</li>\n<li>共享：总线上可以挂接多个部件<br>总线设备：按对总线有无控制权分</li>\n<li>主设备：发出总线请求且获得总线控制权的设备</li>\n<li>从设备：被主设备访问的设备，只能响应从这设备发来的各种总线命令<br>特性：机械特性（尺寸、形状）、电气特性（传输方向、有效的电平范围）、功能特性（没跟传输线的功能）、时间特性（信号和时序的关系）</li>\n</ul>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><ol>\n<li>按功能</li>\n</ol>\n<ul>\n<li>片内总线（CPU内部的，连接各寄存器以及寄存器和ALU）</li>\n<li>系统总线（连接CPU、主存、I&#x2F;O）。按传输内容又分为数据总线（数据、指令、终端类型号，双向传输）、地址总线（主存单元或IO端口地址，单向传输）、控制总线（clk, rst, 总线请求&#x2F;允许, 中断请求&#x2F;回答, r&#x2F;w…）</li>\n<li>I&#x2F;O总线（将低速的IO和告诉总线分离，常见的有USB&#x2F;PCI）</li>\n<li>通信总线（外部总线，计算机系统之间或计算机系统与其他系统）</li>\n</ul>\n<ol start=\"2\">\n<li>按时序控制方式</li>\n</ol>\n<ul>\n<li>同步总线</li>\n<li>异步总线</li>\n</ul>\n<ol start=\"3\">\n<li>按数据传输方式</li>\n</ol>\n<ul>\n<li>串行总线（一条双向或两条单向，数据按bit串行顺序传输，适合长距离通信）</li>\n<li>并行总线（有多条双向，容易出现干扰&#x2F;延迟，适合近距离通信）</li>\n</ul>\n<h3 id=\"系统总线的结构\"><a href=\"#系统总线的结构\" class=\"headerlink\" title=\"系统总线的结构\"></a>系统总线的结构</h3><ol>\n<li>单总线结构<br>CPU，主存，IO，都挂在一组（地址、数据、控制）总线上，允许IO之间、IO与主存直接交换信息<br>结构简单、成本低、易于接入新的设备<br>贷款低、负载中、不支持并发传送<br><img data-src=\"/f13.jpg\"></li>\n<li>双总线结构<br>一条主存总线，一条I&#x2F;O总线<br>主存总线支持突发传送，突发传送（Burst Transfer）是一种数据传输方式，它允许在一次地址发送后，连续传输多个数据块，而不需要为每个数据块单独发送地址和控制信号<br>将低速的I&#x2F;O设备分离开来，实现了存储器总线和I&#x2F;O总线的分离<br>需要增加通道等硬件设备<br><img data-src=\"/f14.jpg\"></li>\n<li>三总线结构<br>主存总线、I&#x2F;O总线、直接内存访问(DMA)总线<br>DMA 允许外部设备（如硬盘、网卡、显卡）直接与主存进行数据交换，无需CPU的直接参与和干预,把CPU从繁琐、低效的数据搬运工作中解放出来，让它可以去做更复杂的计算任务<br>优点是提高了I&#x2F;O设备的性能，使其更快地响应命令，提高系统吞吐量；缺点是任意时刻只能使用一种总线，系统工作效率较低（意思是一个设备不能同时使用多个总线，比如主存总线和DMA总线不能同时对主存进行存取）<br><img data-src=\"/f15.jpg\"></li>\n</ol>\n<h3 id=\"常见的总线标准\"><a href=\"#常见的总线标准\" class=\"headerlink\" title=\"常见的总线标准\"></a>常见的总线标准</h3><p>略</p>\n<h3 id=\"总线的性能指标\"><a href=\"#总线的性能指标\" class=\"headerlink\" title=\"总线的性能指标\"></a>总线的性能指标</h3><ul>\n<li>总线时钟周期</li>\n<li>总线时钟频率</li>\n<li>总线传输周期：申请、寻址、传输、结束</li>\n<li>总线工作频率：1&#x2F;总线（传输）周期</li>\n<li>总线宽度：通常指数据总线的根数</li>\n<li>总线带宽：最大数据传输速率，B&#x2F;s，带宽 &#x3D; 总线工作频率*（总线宽度&#x2F;8）</li>\n<li>总线复用：一种信号现在不同的时间传输不同的信息，比如地址&#x2F;数据线复用（地址通过数据线传送）</li>\n<li>信号线数：地址总线、数据总线、控制总线数量的总和<br>最主要的性能指标：&#x3D;&#x3D;总线宽度、总线工作频率、总线带宽&#x3D;&#x3D;<br>带宽 &#x3D; 总线工作频率*总线宽度 bits&#x2F;s</li>\n</ul>\n<h2 id=\"总线事务和定时\"><a href=\"#总线事务和定时\" class=\"headerlink\" title=\"总线事务和定时\"></a>总线事务和定时</h2><h3 id=\"总线事务\"><a href=\"#总线事务\" class=\"headerlink\" title=\"总线事务\"></a>总线事务</h3><p>从请求总线到完成总线使用的操作序列称为<strong>总线事务</strong>，典型的总线事务包括请求操作、仲裁操作、地址传输、数据传输和总线释放</p>\n<ol>\n<li>请求阶段：主设备（CPU或DMA）发出总线传输请求，获得总线控制权</li>\n<li>仲裁阶段：总选仲裁机构决定将下一个传输周期的总线使用权授予某个申请者</li>\n<li>寻址阶段：传输地址和命令，启动从模块</li>\n<li>传输阶段：主模块和从模块进行数据交换，单向或双向</li>\n<li>释放阶段：主模块有关信息从系统总线上撤除，让出总线使用权、</li>\n</ol>\n<p>数据传送方式：突发方式和非突发方式<br>突发传送：寻址阶段发送的是连续数据单元的首地址，传输阶段传送多个连续单元的数据，每个时钟周期可以传送一个字长的信息（如果总线宽度等于一个字长），一组数据全部传送完毕后再释放总线<br>非突发传送：每个传送周期内都先传送地址，再传送数据，每次只能传输一个字长的数据</p>\n<h3 id=\"总线定时\"><a href=\"#总线定时\" class=\"headerlink\" title=\"总线定时\"></a>总线定时</h3><p>同步、异步、半同步、分离式</p>\n<ol>\n<li>同步定时方式<br>适用于总线较短且部件存取时间比较接近的系统。每个部件或设备发送或接收信息都在固定的总线传送周期中，一个总线的传送周期结束，下一个总线传送周期开始<br>优点：传送速度快，具有较高的传输速率；总线控制逻辑简单。<br>缺点：主从设备属于强制性同步；不能及时进行数据通信的有效性检验，可靠性较差</li>\n<li>异步定时方式<br>依靠传送双方相互制约的“握手”信号来实现定时控制。主设备发出请求，从设备接收到请求后发出回答。<br>优点：总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间的配合。<br>缺点：比同步控制方式稍复杂一些，速度比同步定时方式慢</li>\n</ol>\n<ul>\n<li>根据“请求”和“回答”的撤销是否互锁分为<ul>\n<li>不互锁方式：发出请求不必等回答，一段时间后自动撤销请求信号。收到请求信号后发出回答信号，一段时间后自动撤销回答信号。（速度最快 可靠性最差）</li>\n<li>半互锁方式：发出请求后等待收到回答信号才撤销请求信号。收到请求信号后发出回答信号，一段时间后自动撤销回答信号。</li>\n<li>全互锁方式：发出请求后等待收到回答信号才撤销请求信号，收到请求信号后发出回答，必须获知请求信号撤销之后才撤销回答信号（最可靠 速度最慢）</li>\n</ul>\n</li>\n</ul>\n<p>异步串行通信的方式一步串行通信的第一位是开始位，表示字符传送的开始。铜芯线上没有数据传送时处于逻辑”1”状态，发出逻辑”0”为开始位在从最低位开始传输信号。发送完字符之后可以发送几奇偶校验（若有），之后发送停止位。</p>\n<ol start=\"3\">\n<li><p>半同步定时方式<br><img data-src=\"/f1.jpg\"><br>保留时钟信号的同时增设Wait响应信号线，Wait&#x3D;1的时候才取数据<br>优点：控制方式比异步简单<br>缺点：时钟频率不能太高</p>\n</li>\n<li><p>分离式定时方式<br>将总线事务分解为请求和应答两个子过程。第一个子过程中，主设备发送命令、地址到总线上，发完立即释放总线（第一个字过程很短）。第二个另外以个设备接受命令并发送数据到总线。两个子过程都只有单向信息流，每个设备都变为主设备。<br><img data-src=\"/f2.jpg\"><br><img data-src=\"/f3.jpg\"><br>在空闲阶段释放总线使总线可接受其他设备的请求<br>控制复杂，开销大</p>\n</li>\n</ol>\n",
            "tags": [
                "总线"
            ]
        },
        {
            "id": "http://example.com/2025/08/02/note/20250802/",
            "url": "http://example.com/2025/08/02/note/20250802/",
            "title": "20250802阅读论文",
            "date_published": "2025-08-01T16:00:00.000Z",
            "content_html": "<blockquote>\n<p><strong>标题</strong>：Self-supervised representation learning from 12-lead ECG data<br><strong>作者</strong>：Temesgen Mehari, Nils Strodthoff<br><strong>期刊</strong>：<em>Computers in Biology and Medicine</em>, 2022<br><strong>DOI</strong>: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2kub3JnLzEwLjEwMTYvai5jb21wYmlvbWVkLjIwMjEuMTA1MTE0\">10.1016&#x2F;j.compbiomed.2021.105114</span><br><strong>关键词</strong>：自监督学习、对比学习、心电图（ECG）、时间序列分析、深度学习</p>\n</blockquote>\n<p>12-lead ECG是常见生物信号，但高质量标注数据稀缺，标注依赖专家，成本高，尤其对罕见病或睡眠相关心血管事件更难获取标签，然而，无标签ECG数据海量存在，因此利用自监督学习从大量无标签ECG中预训练模型，学习通用特征表示，再用于下游任务微调，提升性能与标签效率。</p>\n<p>本文采用 <code>xresnet1d50</code> 作为主干网络，对比了不同的自监督学习方法。</p>\n<h2 id=\"xresnet1d\"><a href=\"#xresnet1d\" class=\"headerlink\" title=\"xresnet1d\"></a>xresnet1d</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly90aW1lc2VyaWVzYWkuZ2l0aHViLmlvL3RzYWkvbW9kZWxzLnhyZXNuZXQxZC5odG1s\">https://timeseriesai.github.io/tsai/models.xresnet1d.html</span></p>\n<h2 id=\"Instance-Discrimination\"><a href=\"#Instance-Discrimination\" class=\"headerlink\" title=\"Instance Discrimination\"></a>Instance Discrimination</h2><h3 id=\"SimCLR\"><a href=\"#SimCLR\" class=\"headerlink\" title=\"SimCLR\"></a>SimCLR</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzIwMDIuMDU3MDk=\">T. Chen, S. Kornblith, M. Norouzi, G. Hinton, A simple framework for contrastive learning of visual representations, in: International Conference on Machine Learning, 2020.</span></p>\n<h3 id=\"BYOL\"><a href=\"#BYOL\" class=\"headerlink\" title=\"BYOL\"></a>BYOL</h3><h3 id=\"SwAV\"><a href=\"#SwAV\" class=\"headerlink\" title=\"SwAV\"></a>SwAV</h3><h3 id=\"CPC\"><a href=\"#CPC\" class=\"headerlink\" title=\"CPC\"></a>CPC</h3><h2 id=\"Latent-Forecasting\"><a href=\"#Latent-Forecasting\" class=\"headerlink\" title=\"Latent Forecasting\"></a>Latent Forecasting</h2>",
            "tags": [
                "自监督学习"
            ]
        },
        {
            "id": "http://example.com/2025/08/01/computer-science/computer-organization/ch4/",
            "url": "http://example.com/2025/08/01/computer-science/computer-organization/ch4/",
            "title": "Ch4",
            "date_published": "2025-07-31T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch4-指令系统\"><a href=\"#Ch4-指令系统\" class=\"headerlink\" title=\"Ch4 指令系统\"></a>Ch4 指令系统</h1><h2 id=\"指令系统\"><a href=\"#指令系统\" class=\"headerlink\" title=\"指令系统\"></a>指令系统</h2><h3 id=\"ISA（王道叫它指令集体系结构）\"><a href=\"#ISA（王道叫它指令集体系结构）\" class=\"headerlink\" title=\"ISA（王道叫它指令集体系结构）\"></a>ISA（王道叫它指令集体系结构）</h3><p>指令系统 vs ISA</p>\n<p>ISA完整地定义了软件和硬件之间的接口，规定了：</p>\n<ul>\n<li>指令格式（指令寻址方式，操作类型，操作数）</li>\n<li>操作数的类型、寻址方式、大端小端存放（大端：高位放在低地址；小端：低位放在低地址）</li>\n<li>程序可访问的寄存器编号、个数和位数，存储空间大小和编址方式</li>\n<li>指令执行过程的控制方式（PC, condition code, …）</li>\n</ul>\n<h3 id=\"指令的基本格式\"><a href=\"#指令的基本格式\" class=\"headerlink\" title=\"指令的基本格式\"></a>指令的基本格式</h3><p>操作码+地址码<br>主存一般是按字节编址，所以指令字长通常为字节的整数倍</p>\n<ol>\n<li><p>零地址指令<br>NOP, HLT<br>不需要操作数。<br>零地址的运算类指令仅用在堆栈计算机中（操作数直接从栈顶弹出）</p>\n</li>\n<li><p>一地址指令<br>OP, A1<br>OP(A1) -&gt; A1<br>加1，减1，取反，求补，移位等<br>可能有一个操作数或者两个操作数</p>\n<blockquote>\n<p>隐含约定目的地址的双操作数指令，地址码指明一个操作数，另一个操作数来自隐含寻址</p>\n</blockquote>\n</li>\n<li><p>二地址指令<br>OP, A1, A2<br>(A1)OP(A2) -&gt; A1</p>\n</li>\n<li><p>三地址指令<br>OP, A1, A2, A3<br>(A1)OP(A2) -&gt; A3</p>\n</li>\n<li><p>四地址指令<br>OP, A1, A2, A3, A4<br>(A1)OP(A2) -&gt; A3, A4 &#x3D; 下一条将要执行指令的地址</p>\n</li>\n</ol>\n<h3 id=\"定长操作码指令格式\"><a href=\"#定长操作码指令格式\" class=\"headerlink\" title=\"定长操作码指令格式\"></a>定长操作码指令格式</h3><p>n位opcode最多能表示2^n条指令<br>指令字长：单字长(PC &#x3D; PC + 1)、双字长(PC &#x3D; PC + 2)…</p>\n<h3 id=\"扩展操作码指令格式\"><a href=\"#扩展操作码指令格式\" class=\"headerlink\" title=\"扩展操作码指令格式\"></a>扩展操作码指令格式</h3><p>才去可变长度操作码，分散地放在指令字的不同位置上<br>要求：</p>\n<ol>\n<li>不允许短码是长码的前缀</li>\n<li>各指令的操作码不能重复<br><img data-src=\"/f1.jpg\"><br>RISC-V指令集</li>\n</ol>\n<h3 id=\"指令的操作类型\"><a href=\"#指令的操作类型\" class=\"headerlink\" title=\"指令的操作类型\"></a>指令的操作类型</h3><ol>\n<li>数据传送</li>\n</ol>\n<ul>\n<li>MOV: 寄存器到寄存器</li>\n<li>LOAD: 从内存读到寄存器</li>\n<li>STORE: 从寄存器写入内存</li>\n<li>PUSH</li>\n<li>POP</li>\n</ul>\n<ol start=\"2\">\n<li><p>算术和逻辑运算<br>ADD, SUB, MUL, DIV, MOD, AND, OR, XOR, NOT, XOR, INC(加一), DEC(减一)</p>\n</li>\n<li><p>移位<br>算术移位，逻辑移位，循环移位</p>\n</li>\n<li><p>转移<br>JMP, BRANCH, CALL, RET, TRAP（中断隐指令是硬件实现的，只有TRAP是软指令）</p>\n</li>\n<li><p>I&#x2F;O操作</p>\n</li>\n</ol>\n<h2 id=\"指令的寻址方式\"><a href=\"#指令的寻址方式\" class=\"headerlink\" title=\"指令的寻址方式\"></a>指令的寻址方式</h2><h3 id=\"指令寻址与数据寻址\"><a href=\"#指令寻址与数据寻址\" class=\"headerlink\" title=\"指令寻址与数据寻址\"></a>指令寻址与数据寻址</h3><ol>\n<li>指令寻址</li>\n</ol>\n<ul>\n<li>顺序： PC &#x3D; PC + 1</li>\n<li>跳转： 绝对转移(PC &#x3D; 跳转地址) ,相对转移(PC &#x3D; PC + offset)</li>\n</ul>\n<ol start=\"2\">\n<li>数据寻址<br>格式：操作码 寻址特征 形式地址A</li>\n</ol>\n<ul>\n<li>立即寻址(addi, …)</li>\n<li>直接寻址（A直接表示地址）</li>\n<li>寄存器寻址(add, …)</li>\n<li>寄存器间接寻址(lw r1 offset(r2), …)</li>\n</ul>\n<h3 id=\"常见的数据寻址方式\"><a href=\"#常见的数据寻址方式\" class=\"headerlink\" title=\"常见的数据寻址方式\"></a>常见的数据寻址方式</h3><ol>\n<li>隐含寻址<br>比如单地址的第二个操作数由ACC提供: Intel 8080的<code>ADD A</code>指令会将寄存器A的内容与指定的操作数（放在ACC内）相加，并将结果存储回累加器中<br>优点是缩短指令字长；缺点是需要增加存储操作数或隐含地址的硬件</li>\n<li>立即（数）寻址<br>比如riscv的<code>addi x5, x6, #1</code><br>优点是不用访存速度快，缺点是立即数位数有限</li>\n<li>直接寻址<br><code>OP #A</code></li>\n</ol>\n<p>比如lc3的<code>LD R1, LABEL1</code>翻译成汇编是<code>LD R1, x3100</code>表示<code>R1 &lt;- MEM[x3100]</code><br>形式地址A就是操作数的真实地址EA<br>优点是简单，缺点是寻址范围受A的位数限制<br>4. 间接寻址<br>EA &#x3D; (A)<br>指令中给出的地址是包含实际地址的内存位置或寄存器<br>比如lc3的<code>LDI R1, LABEL1</code>翻译成汇编是<code>LDI R1, x3100</code>表示<code>R1 &lt;- MEM[MEM[x3100]]</code><br>5. 寄存器寻址<br>EA &#x3D; (Ri)<br><code>ADD R1, R2, R3</code><br>6. 寄存器间接寻址<br>EA &#x3D; (Ri)<br>比如<code>LW R1, offset(R2)</code><br>7. 相对寻址<br>相对PC寻址<br>EA &#x3D; (PC) + A<br>比如branch<br>8. 基址寻址<br>EA &#x3D; (BR) + A<br>面向操作系统，优点是扩大寻址范围，有利于躲到程序设计；缺点是偏移量(A)的位数较短<br>9. 变址寻址<br>EA &#x3D; (IX) + A<br>比如用来访问数组</p>\n<blockquote>\n<p>偏址寻址：相对寻址、基址寻址、变址寻址</p>\n<ol start=\"10\">\n<li>堆栈寻址有一个堆栈指针SP，堆栈分为硬堆栈，软堆栈。寄存器堆栈是硬堆栈，内存是软堆栈。采用无操作数指令<br><img data-src=\"/f2.jpg\"></li>\n</ol>\n</blockquote>\n<h2 id=\"程序的机器级代码表示\"><a href=\"#程序的机器级代码表示\" class=\"headerlink\" title=\"程序的机器级代码表示\"></a>程序的机器级代码表示</h2><p>x86汇编</p>\n<h3 id=\"常用汇编指令介绍\"><a href=\"#常用汇编指令介绍\" class=\"headerlink\" title=\"常用汇编指令介绍\"></a>常用汇编指令介绍</h3><ol>\n<li>相关寄存器<br>x86架构有8个32位的通用寄存器：EAX、EBX、ECX、EDX、ESI、EDI、EBP、ESP<br><img data-src=\"/f3.jpg\"><br><img data-src=\"/f4.jpg\"><br><img data-src=\"/f5.jpg\"></li>\n<li>汇编指令格式<br>x86汇编指令格式有两种：AT&amp;T格式和Intel格式</li>\n</ol>\n<ul>\n<li>AT&amp;T只能小写，Intel大小写都行</li>\n<li>AT&amp;T第一个操作数是源操作数，第二个是目的操作数；Intel第一个操作数是目的操作数，第二个是源操作数</li>\n<li>AT&amp;T寄存器前缀%，立即数前缀$；Intel格式寄存器和立即数不需要加前缀</li>\n<li>内存寻址：AT&amp;T格式为(addr)，Intel格式为[addr]</li>\n<li>处理复杂寻址方式时，AT&amp;T格式为disp(base, index, scale)，表示偏移量，基址寄存器，变址寄存器，比例因子，表示的操作数为M[R[base]+R[index]*scale + disp];</li>\n<li>指定数据长度时，AT&amp;T用b, w, l; Intel用byte ptr, word ptr, dword ptr(一个word是16位，一个dword是32位)<br><img data-src=\"/f6.jpg\"><br><img data-src=\"/f7.jpg\"></li>\n</ul>\n<ol start=\"3\">\n<li>常用指令</li>\n</ol>\n<ul>\n<li><reg>表示任意寄存器，后面跟数字指定其位数</reg></li>\n<li><mem>内存地址</mem></li>\n<li><con>后面跟数字表示几位常数<br>常见的指令：</con></li>\n<li>数据传送指令<ul>\n<li>mov<ul>\n<li>mov <reg>, <reg></reg></reg></li>\n<li>mov <reg>, <mem></mem></reg></li>\n<li>mov <mem>, <reg></reg></mem></li>\n<li>mov <reg>, <con></con></reg></li>\n<li>mov <mem>, <con></con></mem></li>\n</ul>\n</li>\n<li>push(ESP指向栈顶空的位置，push之前ESP &#x3D; ESP - 4)&#x3D;&#x3D;栈中元素固定为32位&#x3D;&#x3D;<ul>\n<li>push &lt;reg32</li>\n<li>push <mem></mem></li>\n<li>push <con32></con32></li>\n</ul>\n</li>\n<li>pop(pop之后ESP &#x3D; ESP + 4)<ul>\n<li>pop <reg32></reg32></li>\n<li>pop <mem></mem></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>算术和逻辑运算<ul>\n<li>add&#x2F;sub(把两个操作数相加&#x2F;减，结果放回目的操作数)<ul>\n<li>add eax, 10    # eax &#x3D; eax + 10</li>\n<li>add byte ptr [var], 10    # 10与var指向的内存地址的一字节值相加，结果放回var指向的内存中</li>\n</ul>\n</li>\n<li>inc&#x2F;dec(把操作数自加1&#x2F;自减1)<ul>\n<li>dec eax    # eax &#x3D; eax - 1</li>\n<li>inc dword ptr [var]    # var指向的32位值自加1，结果放回var指向的32位内存中</li>\n</ul>\n</li>\n<li>imul(有符号数整数乘法, mul是无符号数乘法)目的操作数必须是寄存器，溢出时<code>OF = 1</code><ul>\n<li>imul <reg32>, <reg32></reg32></reg32></li>\n<li>imul <reg32>, <mem></mem></reg32></li>\n<li>imul <reg32>, <reg32>, <con></con></reg32></reg32></li>\n<li>imul <reg32>, <mem>, <con></con></mem></reg32></li>\n</ul>\n</li>\n<li>idiv(有符号数整数除法，&#x3D;&#x3D;只有一个操作数为除数，被除数有64位放在 <code>edx:eax</code> 中，操作结果商放到<code>eax</code>，余数放到<code>edx</code>&#x3D;&#x3D;)<ul>\n<li>idiv <reg32></reg32></li>\n<li>idiv <mem></mem></li>\n</ul>\n</li>\n<li>and&#x2F;or&#x2F;xor<ul>\n<li>and&#x2F;or&#x2F;xor <reg>, <reg></reg></reg></li>\n<li>and&#x2F;or&#x2F;xor <reg>, <mem></mem></reg></li>\n<li>and&#x2F;or&#x2F;xor <mem>, <reg></reg></mem></li>\n<li>and&#x2F;or&#x2F;xor <reg>, <con></con></reg></li>\n<li>and&#x2F;or&#x2F;xor <mem>, <con></con></mem></li>\n</ul>\n</li>\n<li>not(按位取反)<ul>\n<li>not <reg></reg></li>\n<li>not <mem></mem></li>\n</ul>\n</li>\n<li>neg(取负)<ul>\n<li>neg <reg></reg></li>\n<li>neg <mem></mem></li>\n</ul>\n</li>\n<li>shl&#x2F;shr(逻辑左移&#x2F;右移)<ul>\n<li>shl <reg>, <con8></con8></reg></li>\n<li>shl <mem>, <con8></con8></mem></li>\n<li>shr <reg>, <reg8></reg8></reg></li>\n<li>shr <mem>, <reg8></reg8></mem></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>控制流<ul>\n<li>jmp<ul>\n<li>jmp <label></label></li>\n</ul>\n</li>\n<li>jcondition<ul>\n<li>je <label></label></li>\n<li>jz <label></label></li>\n<li>jne <label></label></li>\n<li>jg <label></label></li>\n<li>jge <label></label></li>\n<li>jl <label></label></li>\n<li>jle <label></label></li>\n</ul>\n</li>\n<li>cmp&#x2F;test(cmp相当于相减，test相当于按位与，不保存操作结果仅设置条件码用于跳转指令)<ul>\n<li>cmp&#x2F;test <reg>, <reg></reg></reg></li>\n<li>cmp&#x2F;test <reg>, <mem></mem></reg></li>\n<li>cmp&#x2F;test <mem>, <reg></reg></mem></li>\n<li>cmp&#x2F;test <reg>, <con></con></reg></li>\n</ul>\n</li>\n<li>call&#x2F;ret(call将返回地址入栈然后跳转，ret弹出返回地址并跳转)<ul>\n<li>call <label></label></li>\n<li>ret</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"选择语句的机器级表示\"><a href=\"#选择语句的机器级表示\" class=\"headerlink\" title=\"选择语句的机器级表示\"></a>选择语句的机器级表示</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(test_exp)</span><br><span class=\"line\">    then_stmt</span><br><span class=\"line\">else</span><br><span class=\"line\">    else_stmt</span><br></pre></td></tr></table></figure>\n<p>翻译成</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(!t)</span><br><span class=\"line\">    goto false;</span><br><span class=\"line\">then_stmt;   </span><br><span class=\"line\">goto done;</span><br><span class=\"line\">false:  else_stmt;</span><br><span class=\"line\">done:</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"循环语句的机器级表示\"><a href=\"#循环语句的机器级表示\" class=\"headerlink\" title=\"循环语句的机器级表示\"></a>循环语句的机器级表示</h3><ol>\n<li>do-while</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">do</span><br><span class=\"line\">  body_stmt</span><br><span class=\"line\">  while(test_exp);</span><br></pre></td></tr></table></figure>\n<p>翻译成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loop:   body_stmt;</span><br><span class=\"line\">  t = test_exp;</span><br><span class=\"line\">  if(t)</span><br><span class=\"line\">    goto loop;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>while</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while(test_exp)</span><br><span class=\"line\">  body_stmt;</span><br></pre></td></tr></table></figure>\n<p>翻译成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t = test_exp;</span><br><span class=\"line\">if(!t)</span><br><span class=\"line\">  goto done;</span><br><span class=\"line\">loop:</span><br><span class=\"line\">  body_stmt;</span><br><span class=\"line\">  t = test_exp;</span><br><span class=\"line\">  if(t)</span><br><span class=\"line\">    goto loop;</span><br><span class=\"line\">done:</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>for</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(init_exp; test_exp; update_exp)</span><br><span class=\"line\">  body_stmt;</span><br></pre></td></tr></table></figure>\n<p>翻译成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init_exp;</span><br><span class=\"line\">t = test_exp;</span><br><span class=\"line\">if(!t)</span><br><span class=\"line\">  goto done;</span><br><span class=\"line\">loop:</span><br><span class=\"line\">  body_stmt;</span><br><span class=\"line\">  update_exp;</span><br><span class=\"line\">  t = test_exp;</span><br><span class=\"line\">  if(t)</span><br><span class=\"line\">    goto loop;</span><br><span class=\"line\">done:</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"过程调用的机器级表示\"><a href=\"#过程调用的机器级表示\" class=\"headerlink\" title=\"过程调用的机器级表示\"></a>过程调用的机器级表示</h3><ol>\n<li>caller将实参放到callee能访问的地方（寄存器放不下放栈里）</li>\n<li>caller保存返回地址（通过call指令实现）</li>\n<li>callee保存caller通用寄存器的内容，并为自己的非静态局部变量分配空间</li>\n<li>执行callee</li>\n<li>恢复caller的寄存器内容，将返回值放到caller能访问的地方（寄存器、栈），释放局部变量</li>\n<li>callee取出返回地址，恢复PC（ret实现）<blockquote>\n<p>EAX, ECX, EDX是caller saved register<br>通常用于传递参数、存储临时变量或返回值，所以call的时候内容可能会变，要先保存再调用。比如返回值一般保存在EAX<br>EBX, ESI, EDI是callee saved register<br>这些寄存器的值在函数调用后应保持不变，所以由callee保存，ret的时候要恢复</p>\n</blockquote>\n</li>\n</ol>\n<p>每个过程有自己的栈帧，<code>EBP</code>保存栈帧的基址，<code>ESP</code>指向栈顶位置，<code>EBP</code>的值不变，当前栈帧的范围在<code>EBP</code>和<code>ESP</code>之间（详见编译原理<code>activated record</code>）<br><img data-src=\"/f8.jpg\"><br>前三行的意思是新开一个栈帧，分配了24字节的栈帧空间。<code>push epb</code>实际上就是把static link压栈。<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ub3Jlc3BvbnNlNTI1LmdpdGh1Yi5pby8yMDI1LzA2LzE1L2NvbXB1dGVyLXNjaWVuY2UvY29tcGlsZS1wcmluY2lwbGVzL2NoNi8jJUU1JTg3JUJEJUU2JTk1JUIwJUU4JUIwJTgzJUU3JTk0JUE4JUU2JUI1JTgxJUU3JUE4JThC\">详见编译原理笔记</span><br>执行<code>call</code>之后，<code>call</code>会先将返回地址压栈，然后跳转到<code>add</code>的起始地址，为<code>add</code>创建栈帧。<code>add</code>的返回值存放在<code>EAX</code>中。<br>执行<code>ret</code>之前需要释放当前栈帧，恢复caller的栈帧。因此<code>leave</code>相当于<code>mov esp, ebp</code> <code>pop ebp</code></p>\n<h2 id=\"CISC和RISC的基本概念\"><a href=\"#CISC和RISC的基本概念\" class=\"headerlink\" title=\"CISC和RISC的基本概念\"></a>CISC和RISC的基本概念</h2><p>复杂指令系统计算机(CISC)：比如x86<br>精简指令系统计算机(RISC)：ARM, MIPS…</p>\n<h3 id=\"CISC\"><a href=\"#CISC\" class=\"headerlink\" title=\"CISC\"></a>CISC</h3><ul>\n<li>指令系统复杂庞大，指令数目多</li>\n<li>指令长度不固定，格式多，寻址方式多</li>\n<li>可以访存的指令不受限制（比如x86的add可以直接把reg和mem相加，但是riscv的只能reg和reg或者reg和imm）</li>\n<li>各种指令使用频度相差很大</li>\n<li>各种指令执行时间相差很大，大多指令需要多个时钟周期</li>\n<li>控制器大多采用微程序控制，无法采用硬连线控制</li>\n<li>难以用优化编译生成高效的目标代码程序</li>\n</ul>\n<h3 id=\"RISC\"><a href=\"#RISC\" class=\"headerlink\" title=\"RISC\"></a>RISC</h3><ul>\n<li>选取使用频率最高的一些简单指令，复杂指令的功能由简单指令的组合来实现</li>\n<li>指令长度固定，指令格式种类少，寻址方式种类少</li>\n<li>只有LOAD&#x2F;STORE访存，其余指令的操作只能访问寄存器&#x2F;imm</li>\n<li>CPU中通用寄存器数量相当多</li>\n<li>采用流水线技术，大部分指令在一个时钟周期内完成</li>\n<li>硬布线控制为主，不用或少用微程序控制</li>\n<li>重视编译优化<br>CISC兼容性好，大多RISC不能和老机器兼容，但具有更强的实用性。CISC可以提供更多的功能</li>\n</ul>\n<h3 id=\"CISC和RISC的比较\"><a href=\"#CISC和RISC的比较\" class=\"headerlink\" title=\"CISC和RISC的比较\"></a>CISC和RISC的比较</h3><p>和CISC相比，RISC的优点：</p>\n<ul>\n<li>RISC更能充分利用VLSI（超大规模集成电路）芯片的面积（减少了控制逻辑）</li>\n<li>RISC更能提高运算速度</li>\n<li>RISC便于设计，可以降低成本，提高可靠性</li>\n<li>有利于编译优化<br><img data-src=\"/f9.jpg\"></li>\n</ul>\n",
            "tags": [
                "指令系统"
            ]
        },
        {
            "id": "http://example.com/2025/07/01/computer-science/computer-organization/ch3/",
            "url": "http://example.com/2025/07/01/computer-science/computer-organization/ch3/",
            "title": "Ch3",
            "date_published": "2025-06-30T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch3-存储系统\"><a href=\"#Ch3-存储系统\" class=\"headerlink\" title=\"Ch3 存储系统\"></a>Ch3 存储系统</h1><h2 id=\"存储器概述\"><a href=\"#存储器概述\" class=\"headerlink\" title=\"存储器概述\"></a>存储器概述</h2><h3 id=\"存储器的分类\"><a href=\"#存储器的分类\" class=\"headerlink\" title=\"存储器的分类\"></a>存储器的分类</h3><ol>\n<li>按层次分</li>\n</ol>\n<ul>\n<li>主存（小、快、成本高）</li>\n<li>辅存（大、慢、成本低）</li>\n<li>Cache</li>\n</ul>\n<ol start=\"2\">\n<li>按存储介质分</li>\n</ol>\n<ul>\n<li>磁表面存储器（磁盘、磁带）</li>\n<li>磁芯存储器</li>\n<li>半导体存储器（MOS型、双极型）</li>\n<li>光存储器（光盘）</li>\n</ul>\n<ol start=\"3\">\n<li>按存储方式分</li>\n</ol>\n<ul>\n<li>RAM （随机存储器）:随机读取存储单元，存取时间与存储单元的物理位置无关。读写方便，主要用作主存和cache，分静态RAM和动态RAM。</li>\n<li>ROM （只读存储器）：只能读不能写，非易失性，随机读取。广义的ROM也可以通过电擦除进行写入(EEPROM)</li>\n<li>SAM （顺序存储器）：按顺序存储，存取时间与存储单元的物理位置有关</li>\n<li>DAM （直接存储器）：先选取信息所在区域，然后顺序存取。结合了RAM和SAM的特性（磁盘）</li>\n<li>Associated memory: 不根据地址而是根据存储内容来进行存取的存储器，可以实现快速地查找快表。既可以按照&#x3D;&#x3D;地址&#x3D;&#x3D;寻址也可以按照&#x3D;&#x3D;内容&#x3D;&#x3D;寻址（通常是某些字段）</li>\n<li>串行访问存储器：SAM和DAM都是，所以读写时间和物理位置有关</li>\n</ul>\n<ol start=\"4\">\n<li>按信息的可保存性分类</li>\n</ol>\n<ul>\n<li>易失性存储器：断电后丢失数据，如RAM</li>\n<li>非易失性存储器：断电后数据还在，如ROM，磁盘光盘</li>\n<li>破坏性读出：读出数据后数据被破坏</li>\n<li>非破坏性读出：读出数据后数据不改变</li>\n</ul>\n<h3 id=\"存储器的性能指标\"><a href=\"#存储器的性能指标\" class=\"headerlink\" title=\"存储器的性能指标\"></a>存储器的性能指标</h3><p>三个主要性能指标：存储容量、单位成本、存储速度</p>\n<ol>\n<li>容量 &#x3D; 存储字数 * 字长</li>\n<li>单位成本 &#x3D; 总成本&#x2F;总容量</li>\n<li>存储速度：<br>存取时间$T_a$: 启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入事件<br>存取周期$T_m$: 进行连续读&#x2F;写操作所允许的最短时间间隔<br>主存带宽$B_m$: b&#x2F;s, B&#x2F;s, word&#x2F;s<blockquote>\n<p>存取时间仅为完成一次操作的时间，而存取周期不仅包含操作时间，还包括操作后线路的恢复时间</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"多级层次的存储系统\"><a href=\"#多级层次的存储系统\" class=\"headerlink\" title=\"多级层次的存储系统\"></a>多级层次的存储系统</h3><p><img data-src=\"/f1.jpg\"><br>从上到下价格越来越低，速度越来越慢，容量越来越大，CPU访问频度越来越低<br><img data-src=\"/f2.jpg\"><br>存储时间与存储周期的关系</p>\n<ul>\n<li>透明（transparent）指的是某种机制或技术的存在对使用者来说是不可见或无感知的<br>主存-Cache之间的数据调用由硬件自动完成，对所有程序员均是透明的<br>主存-辅存的数据调用由硬件和操作系统共同完成，对应用程序员是透明的</li>\n</ul>\n<h2 id=\"主存储器\"><a href=\"#主存储器\" class=\"headerlink\" title=\"主存储器\"></a>主存储器</h2><p>存储元件：MOS管</p>\n<h3 id=\"SRAM-DRAM\"><a href=\"#SRAM-DRAM\" class=\"headerlink\" title=\"SRAM &amp; DRAM\"></a>SRAM &amp; DRAM</h3><p>RAM: SRAM静态随机存储器和DRAM动态随机存储器<br>&#x3D;&#x3D;主存主要是DRAM，Cache主要是SRAM&#x3D;&#x3D;，都易失</p>\n<p>DRAM芯片：使用栅极电容存储信息，只要一个晶体管，读写&#x3D;&#x3D;更慢&#x3D;&#x3D;，是&#x3D;&#x3D;破坏性读出&#x3D;&#x3D;，需要重写，&#x3D;&#x3D;成本低，集成度高，功耗低&#x3D;&#x3D;</p>\n<p>SRAM芯片：使用双稳态触发器存储信息（六晶体管MOS，RS, JK, D）。读写&#x3D;&#x3D;更快&#x3D;&#x3D;，是非破坏性读出，&#x3D;&#x3D;成本高，集成度低，功耗大&#x3D;&#x3D;<br><img data-src=\"/f4.jpg\"><br>栅极电容需要一直刷新给电容充电，触发器不需要刷新，只要不断电状态不会改变</p>\n<h4 id=\"DRAM的刷新\"><a href=\"#DRAM的刷新\" class=\"headerlink\" title=\"DRAM的刷新\"></a>DRAM的刷新</h4><ol>\n<li>多久需要刷新一次？ 刷新周期：一般为2ms</li>\n<li>每次刷新多少存储单元？以行为单位，每次刷新一行存储单元<br>——为什么要用行列地址？减少选通线的数量</li>\n<li>在什么时刻刷新？<br>有硬件支持，读出一行的信息后重新写入，占用1个读&#x2F;写周期<br>假设DRAM内部结构排列成128×128的形式，读&#x2F;写周期0.5us<br>2ms共 2ms&#x2F;0.5us &#x3D; 4000 个周期<br>三种刷新方式：<br><img data-src=\"/f5.jpg\"><br>刷新以行为单位，再生（重写）只需要恢复被读出来的存储单元<br>刷新由存储器独立完成，不需要CPU控制</li>\n</ol>\n<h5 id=\"DRAM的地址引脚复用技术\"><a href=\"#DRAM的地址引脚复用技术\" class=\"headerlink\" title=\"DRAM的地址引脚复用技术\"></a>DRAM的地址引脚复用技术</h5><p><img data-src=\"/f6.jpg\"><br>行列地址分成两次送，节省了一半的地址线<br>行列数优化原则：尽量使行、列数相同，且行数较少（因为按行刷新）<br>目前常用SDRAM（同步DRAM），数据交换同步于CPU的时钟信号，使得CPU不需要等待</p>\n<h3 id=\"ROM\"><a href=\"#ROM\" class=\"headerlink\" title=\"ROM\"></a>ROM</h3><p>结构简单、非易失性<br>类型：</p>\n<ol>\n<li>MROM 掩模式ROM<br>在芯片生产过程中写入，无法改变，可靠性高，急程度高，价格便宜，灵活性差</li>\n<li>PROM 一次可编程ROM<br>可以用专门的设备写入一次，一旦写入无法改变</li>\n<li>EPROM 可擦除可编程ROM<br>可以写入并多次改写，但是编程次数有限且时间长</li>\n<li>Flash<br>兼有RAM和ROM的优点，可以不加电长期保存信息，又能在线快速擦除和重写，价格便宜，急程度高，电可擦除重写且速度快<br>SSD 固态硬盘基于Flash，由控制单元和Flash组成，长期保存、快速擦除和重写，对比传统硬盘读写速度快。低功耗。但是价格高</li>\n</ol>\n<h3 id=\"主存储器的基本组成\"><a href=\"#主存储器的基本组成\" class=\"headerlink\" title=\"主存储器的基本组成\"></a>主存储器的基本组成</h3><p>核心部件：一个个存储0或1的存储单元构成的存储矩阵<br>访问主存时，CPU把地址送到MAR，MAR通过地址总线把地址送到主存中的地址寄存器，地址译码器进行译码，选中相应的内存单元，然后通过控制电路决定读&#x2F;写操作：</p>\n<ul>\n<li>读操作：将选中的内存单元的内容通过数据总线送到MDR中</li>\n<li>写操作：将MDR中的内容通过数据总线送到选中的内存单元中<br>MDR的位数和数据总线位数相同，通常等于存储字长；MAR的位数和地址总线位数相同</li>\n</ul>\n<h3 id=\"多模块存储器\"><a href=\"#多模块存储器\" class=\"headerlink\" title=\"多模块存储器\"></a>多模块存储器</h3><p>DRAM芯片的恢复时间比较长，有可能是存取时间的几倍（SRAM的恢复时间较短）。CPU的读写速度比主存快很多，主存恢复时间太长<br> —— 利用多个完全相同的存储模块并行工作来提高吞吐率：单体多字存储器，多体低位交叉存储器</p>\n<ul>\n<li>双端口RAM（408不考，了解即可）<br><img data-src=\"/f7.jpg\"></li>\n</ul>\n<ol>\n<li><p>单体多字存储器<br>一般一个存储单元只存储一个word，但是单体多字存储器一个存储单元存储多个word，然后读的时候一次性读取这多个字。好处是快，缺点是只有指令和数据连续存放时才能提高存取速度，否则造成不必要的读取。</p>\n</li>\n<li><p>&#x3D;&#x3D;多体并行存储器（重点）&#x3D;&#x3D;<br>分为高位交叉编址和低位交叉编址两种<br><img data-src=\"/f8.jpg\"><br>高位交叉编址每一块存储体的高位是一样的，实际上还是顺序存储。因此访问连续内存实际上访问的还是同一块存储体，并不能通过并行加快访问速度<br>低位交叉编址的每一块存储体低位相同，因此可以在恢复时间并行存取下一块内存的数据<br>存取周期为<code>T</code>, 存取时间为<code>r</code>, T &#x3D; r + 恢复时间<br>对于n个存储器并行访问的存储器：<br>采用高位交叉编址的时间为<code>n*T</code><br>低位交叉编址为<code>T + (n-1)*r</code></p>\n</li>\n</ol>\n<p><img data-src=\"/f9.png\"></p>\n<ul>\n<li>轮流启动：每个bank的存储位数等于数据总线的位数，此时采用轮流启动<ul>\n<li>对于低位交叉编址，要保证<code>m&gt;=T/r</code>，以保证流水线不间断</li>\n<li>理想情况下，m个bank的交叉存储器每隔<code>T/m</code>个周期可以读&#x2F;写一个数据，若相邻m次访问的当存地址出现在同一个模块内，则会发生访存冲突，此时需要延迟发生冲突的访问请求。</li>\n</ul>\n</li>\n<li>同时启动：如果m个bank的总位数加起来刚好等于数据总线的位数，则m个同时存&#x2F;取</li>\n</ul>\n<h2 id=\"主存储器与CPU的连接\"><a href=\"#主存储器与CPU的连接\" class=\"headerlink\" title=\"主存储器与CPU的连接\"></a>主存储器与CPU的连接</h2><h3 id=\"连接原理\"><a href=\"#连接原理\" class=\"headerlink\" title=\"连接原理\"></a>连接原理</h3><p>通过总线连接（控制、地址、数据）<br>传输速率 &#x3D; 总线宽度&#x2F;传输时间<br>地址总线的位数决定了可寻址的最大内存空间<br>控制总线指出总线周期的类型和本次输入输出完成的时刻<br>将多个芯片集成在内存条上，由多个内存条和主板上的ROM芯片组成计算机所需的主存空间，通过总线与CPU连接</p>\n<h3 id=\"主存容量的扩展\"><a href=\"#主存容量的扩展\" class=\"headerlink\" title=\"主存容量的扩展\"></a>主存容量的扩展</h3><p>数据总线宽度&gt;存储字长 —— 位扩展<br>地址总线宽度&gt;存储字数量所需的宽度<br><img data-src=\"/f10.jpg\"></p>\n<ol>\n<li><p>位扩展法：增加存储字长<br>由于数据总线宽度大于存储字长，存在浪费情况，必须进行位扩展使数据位数与数据总线位数相等<br>如图：<br><img data-src=\"/f11.jpg\"></p>\n</li>\n<li><p>字扩展法<br>地址总线存在浪费情况，对存储字的数量进行扩展<br>用多出来的地址线提供CS片选信号，决定输出的是哪个芯片的数据</p>\n</li>\n</ol>\n<ul>\n<li>线选法：n条多余的地址线，对应n个选片信号，地址空间不连续造成地址空间浪费（只能有一个1有效），电路简单<br><img data-src=\"/f13.jpg\"></li>\n<li>译码器选法：n条多余的线对应$2^n$个选片信号，地址空间可以连续<br><img data-src=\"/f12.jpg\"></li>\n</ul>\n<ol start=\"3\">\n<li>字、位同时扩展<br>既增加存储字的数量，又增加存储字长<br><img data-src=\"/f14.jpg\"></li>\n</ol>\n<h3 id=\"存储芯片的地址分配和片选\"><a href=\"#存储芯片的地址分配和片选\" class=\"headerlink\" title=\"存储芯片的地址分配和片选\"></a>存储芯片的地址分配和片选</h3><p>见上方线选法译码器选法</p>\n<h3 id=\"存储器与CPU的连接\"><a href=\"#存储器与CPU的连接\" class=\"headerlink\" title=\"存储器与CPU的连接\"></a>存储器与CPU的连接</h3><p>……<br>片选信号还与CPU的方寸控制信号$\\overline{MREQ}$有关（低电平有效），若CPU访问IO则此信号为高电平<br>MAR位数要看主存地址空间大小，而不能看实际上用了多少位</p>\n<h2 id=\"外部存储器\"><a href=\"#外部存储器\" class=\"headerlink\" title=\"外部存储器\"></a>外部存储器</h2><p>磁盘存储器是以磁盘为存储介质的存储器，优点：容量大，价格低；记录介质可重复使用；可以长期保存；非破坏性读出。缺点：存取速度慢；机械结构复杂；对工作环境要求高</p>\n<h3 id=\"磁盘存储器\"><a href=\"#磁盘存储器\" class=\"headerlink\" title=\"磁盘存储器\"></a>磁盘存储器</h3><ol>\n<li>磁盘存储器</li>\n</ol>\n<ul>\n<li>组成：磁盘驱动器，磁盘控制器，盘片<br><img data-src=\"/f15.jpg\"></li>\n<li>存储区域：&#x3D;&#x3D;扇区（也称块）是磁盘读写的最小单位&#x3D;&#x3D;，按块存取<ul>\n<li>磁头数(Heads)：一个记录面对应一个磁头</li>\n<li>柱面数(Cylinders)：表示每面盘片上的磁道数，不同记录面的相同位置的磁道构成一个柱面</li>\n<li>扇区数(Sectors)：每条磁道上有多少扇区</li>\n</ul>\n</li>\n<li>Disk Cache<ul>\n<li>在内存上的一片区域，用来缓冲被送到磁盘上的数据。优点：写磁盘时按簇进行，可以避免频繁地用小块数据写；中间结果数据写回之前可以被快速再次使用</li>\n</ul>\n</li>\n<li>磁记录原理<ul>\n<li>原理：当磁头和磁性记录介质有相对运动时，通过电磁转换完成读&#x2F;写操作。</li>\n<li>编码方法：按某种方案（规律），把一连串的二进制信息变换成存储介质磁层中一个磁化翻转状态的序列，并使读&#x2F;写控制电路容易、可靠地实现转换。</li>\n<li>磁记录方式：通常采用调频制（FM）和改进型调频制（MFM）的记录方式。</li>\n</ul>\n</li>\n<li>性能指标<ul>\n<li><p>磁盘的容量：一个磁盘所能存储的字节总数称为磁盘容量。磁盘容量有非格式化容量和格式化容量之分。<br>非格式化容量是指磁记录表面可以利用的磁化单元总数，非格式化容量 &#x3D; 记录面数 * 柱面数 * 每条磁道的磁化单元数<br>格式化容量是指按照某种特定的记录格式所能存储信息的总量，格式化容量 &#x3D; 记录面数 * 柱面数 * 每道扇区数 * 每个扇区的容量<br>&#x3D;&#x3D;格式化容量 &lt; 非格式化容量&#x3D;&#x3D;</p>\n</li>\n<li><p>记录密度:记录密度是指盘片单位面积上记录的二进制的信息量，通常以<code>道密度</code>、<code>位密度</code>和<code>面密度</code>表示。道密度是&#x3D;&#x3D;沿磁盘半径方向单位长度上的磁道数&#x3D;&#x3D;；位密度是&#x3D;&#x3D;磁道单位长度上能记录的二进制代码位数&#x3D;&#x3D;；面密度是位密度和道密度的乘积。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>&#x3D;&#x3D;磁盘所有磁道记录的信息量一定是相等的，并不是圆越大信息越多，故每个磁道的位密度都不同，越靠近圆心位密度越大&#x3D;&#x3D;</p>\n<ul>\n<li><p>平均存取时间：<br>&#x3D;&#x3D;平均存取时间 &#x3D; 寻道时间（磁头移动到目的磁道）+ 旋转延迟时间（磁头定位到所在扇区）+ 传输时间（传输数据所花费的时间）&#x3D;&#x3D;<br>&#x3D;&#x3D;寻道时间通常取从最外道到最内道时间的一半，旋转延迟时间通常取旋转半周的时间&#x3D;&#x3D;</p>\n</li>\n<li><p>数据传输率：磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输率<br>假设磁盘转速为r（转&#x2F;秒），每条磁道容量为N个字节，则数据传输率为$D_r&#x3D;rN$</p>\n</li>\n<li><p>磁盘地址<br><img data-src=\"/f16.jpg\"></p>\n</li>\n<li><p>磁盘的工作原理<br>硬盘的主要操作是寻址、读盘、写盘。每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字。<br>硬盘属于机械式部件，其读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据。</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>RAID<br>将多个独立的物理磁盘组成一个独立的逻辑磁盘，数据分割交叉存储，并行访问。</li>\n</ol>\n<ul>\n<li>RAID0：无冗余和无校验的磁盘阵列。</li>\n<li>RAID1：镜像磁盘阵列。每份数据存两遍，成本太高</li>\n<li>RAID2：采用纠错的海明码的磁盘阵列。<br>逻辑上连续的几个bit物理上分散存储在各个盘中4bit信息位+3bit海明校验位——可纠正1bit错误<br>每个码字有 <code>m</code> 个信息位和 <code>r</code> 个冗余位，$ (m+r+1)≤2^r$<br>参考xyx学长的计网笔记：<br><img data-src=\"/f17.jpg\"></li>\n<li>RAID3：位交叉奇偶校验的磁盘阵列。前三个盘的奇偶校验位写在第四个盘上</li>\n<li>RAID4：块交叉奇偶校验的磁盘阵列。</li>\n<li>RAID5：无独立校验的奇偶校验磁盘阵列。在所有磁盘之间分条，并且每个数据块的奇偶校验块 (P) 写入到同一条带上<br>RAID1-RAID5数据不会损坏</li>\n</ul>\n<h3 id=\"固态硬盘-SSD\"><a href=\"#固态硬盘-SSD\" class=\"headerlink\" title=\"固态硬盘(SSD)\"></a>固态硬盘(SSD)</h3><ol>\n<li>特性<br>属于Flash memory, EEPROM<br>组成：闪存翻译层，存储介质<br><img data-src=\"/f18.jpg\"><br>&#x3D;&#x3D;数据以页为单位读写，以块为单位擦除&#x3D;&#x3D;只有整个块被擦除之后才能写这一页，若视图修改包含已有数据的页$P_i$，则这个快中所有含有有用数据的页必须被复制到新的空白的块中，才能对$P_i$进行写操作<br>SSD的优点：&#x3D;&#x3D;随机写很慢，随机读比机械磁盘块&#x3D;&#x3D;，没噪声，能耗低，抗震性好，安全性高</li>\n<li>Wear Leveling 磨损均衡<br>重复擦写块就会磨损坏，一般是几百次到几千次<br>(1) 动态磨损均衡：&#x3D;&#x3D;写入时&#x3D;&#x3D;优先选择擦除次数少的新闪存块，只在写入时触发，仅考虑可用空间（对于冷数据不包括在空间池中，减少了可以用的block数量）<br>(2) 静态磨损均衡：就算没有写入，SSD也会监测并自动进行数据分配，让老的闪存快以读为主，让新的块腾出空间，以写为主：将数据从写入&#x2F;擦除次数较低的block移动到其他block中，这样可以将低擦写次数的block释放出来，添加到可用可用空间池中，以便后续使用。仅覆盖单个闪存芯片单元</li>\n</ol>\n<h2 id=\"Cache\"><a href=\"#Cache\" class=\"headerlink\" title=\"Cache\"></a>Cache</h2><p>解决CPU和主存速度不一致问题，由SRAM组成，通常集成在CPU中</p>\n<h3 id=\"程序访问的局部性原理\"><a href=\"#程序访问的局部性原理\" class=\"headerlink\" title=\"程序访问的局部性原理\"></a>程序访问的局部性原理</h3><ul>\n<li>时间局部性：比如循环、数组（每次循环访问一次数组能体现时间局部性）</li>\n<li>空间局部性：最近的未来用到的信息很可能和正在使用的信息在存储空间上是临近的（顺序访问数组能体现空间局部性）<br>Cache利用局部性原理，将最近或频繁访问的数据复制到更快但容量较小的存储中，以便提高访问速度和系统性能。</li>\n</ul>\n<p>:::primary<br><strong>hit&#x2F;miss计算</strong><br>设$t_c$为访问一次Cache所需时间，$t_m$为访问一次内存所需时间，则Cache和主存同时被访问总时间为$t &#x3D; Ht_c + (1 - H)t_m$<br>若先访问Cache再访问主存则时间为：$t &#x3D; t_c + (1 - H)t_m$<br>:::</p>\n<h3 id=\"Cache工作原理\"><a href=\"#Cache工作原理\" class=\"headerlink\" title=\"Cache工作原理\"></a>Cache工作原理</h3><p>主存和Cache之间以&#x3D;&#x3D;块(Block)&#x3D;&#x3D;为单位进行数据交换</p>\n<h3 id=\"映射方式\"><a href=\"#映射方式\" class=\"headerlink\" title=\"映射方式\"></a>映射方式</h3><ol>\n<li><p>直接映射 Directed mapped<br><img data-src=\"/f20.jpg\"><br><img data-src=\"/f27.jpg\"><br>cache 行号 &#x3D; 主存块号 mod cache行数<br>物理地址结构：<br>| tag | index（行号） | byte offset |<br><img data-src=\"/f19.jpg\"><br>$$ index的位数 &#x3D; log_2(cache的block数) $$<br>$$ byte\\ offset的位数 &#x3D; log_2(cache的block的字节数) $$<br>$$ tag的位数 &#x3D; 32 - index的位数 - byte\\ offset的位数 $$<br>在32位系统中，一个word是4B；64位系统中，一个word是8B<br>Cache的一行构成：<br>| valid bit | dirty bit | tag | data |<br>+++primary example<br><img data-src=\"/f21.jpg\"><br><img data-src=\"/f22.jpg\"><br><img data-src=\"/f23.jpg\"><br><img data-src=\"/f24.jpg\"><br><img data-src=\"/f25.jpg\"><br><img data-src=\"/f26.jpg\"><br>+++</p>\n</li>\n<li><p>全相连 Full Associative<br>block can go anywhere in cache<br>主存地址：<br>| tag | byte offset |<br>好处是能降低冲突率，每次需要和所有block比较是否hit开销大，不适合大容量Cache</p>\n</li>\n<li><p>组相连 Set Associative<br><img data-src=\"/f28.jpg\"><br>物理地址构成：<br>| tag | set index | 块内偏移 |<br>set index的位数表示有多少组，<br>$$ setNum &#x3D;  \\frac{Cache大小}{blockSize * 路数} $$</p>\n</li>\n</ol>\n<p>+++primary<br>一个四路相联cache，CPU字长为4字节，内存和cache都是以字节编址，cache和内存交换单位为块，每个块大小为512字节，cache能够容纳1024个块。如果物理内存为32位地址:<br>set数 &#x3D; 1024&#x2F;4 &#x3D; 256<br>index位数 &#x3D; log2(256) &#x3D; 8<br>blockOffset位数 &#x3D; log2(512) &#x3D; 9<br>tag位数 &#x3D; 32 - 8 - 9 &#x3D; 17</p>\n<ul>\n<li>物理地址构成：| tag 17位 | set index 8位 | block offset 9 位 |</li>\n<li>计算内存地址FAB12389（16进制）在cache中可能的位置块号:<br>1111 1010 1011 0001 0010 0011 1000 1001<br>set index是10010001也就是145，所以可能的block号是145*4 &#x3D; 580, 581, 582, 583<br>+++<br><img data-src=\"/f29.jpg\"><br>&#x3D;&#x3D;n路组相连需要n个比较器，位数&#x3D;tag位数&#x3D;&#x3D;</li>\n</ul>\n<h3 id=\"替换算法\"><a href=\"#替换算法\" class=\"headerlink\" title=\"替换算法\"></a>替换算法</h3><ol>\n<li><p>Random Replacement<br>随机找一块替换，实现简单，命中率低</p>\n</li>\n<li><p>FIFO<br>选择最早进入的Cache行的进行替换</p>\n</li>\n<li><p>LRU<br>选择近期用得最少的Cache行进行替换，对每个Cache行维护一个计数器表示访问的次数，每次替换掉数值最小的。<br>2-way Cache要用1 bit来记录，4-way Cache要用2 bit来记录<br>+++primary<br>4-way Cache，有五个块映射到Cache同一组，访问顺序是{1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5}<br><img data-src=\"/f30.jpg\"><br>+++</p>\n</li>\n</ol>\n<h3 id=\"Cache一致性问题\"><a href=\"#Cache一致性问题\" class=\"headerlink\" title=\"Cache一致性问题\"></a>Cache一致性问题</h3><p>当write hit时：</p>\n<ol>\n<li>Write through 直写&#x2F;全写法<br>Cache hit的时候，CPU不仅写入Cache，而且写入主存<br>为了减少写入主存的时间小号，增加一个write buffer，CPU同时写入Cache和write buffer，write buffer采用FIFO，当write buffer满时，将write buffer中的数据写入主存</li>\n<li>Write back 写回法<br>write hit时，只把数据写入Cache，只有此块被replace的时候才写入主存。减少了方寸次数，所以给cache行设置一个dirty bit，CPU写数据时将dirty bit置为1表示此块被修改过，repalce时需要写入主存</li>\n</ol>\n<p>write miss时：</p>\n<ol>\n<li>Write Allocate 写分配法<br>如果发生write miss，会从内存中加载对应的数据块到 cache 中，然后进行写操作。和 write-back搭配使用，把后续对该块的修改都缓存在 cache 中</li>\n<li>Not-Write-Allocate 非写分配法<br>只更新主存不把主存写入Cache，适用于 write-through，因为即使写入 cache，也会马上写回内存，没必要占用 cache 空间。</li>\n</ol>\n<p>&#x3D;&#x3D;write through通常和not-write-allocate一起用，write back 通常和write allocate一起用&#x3D;&#x3D;</p>\n<h4 id=\"使用分离的指令Cache和数据Cache\"><a href=\"#使用分离的指令Cache和数据Cache\" class=\"headerlink\" title=\"使用分离的指令Cache和数据Cache\"></a>使用分离的指令Cache和数据Cache</h4><p>+++primary<br><img data-src=\"/f31.jpg\"><br><img data-src=\"/f32.jpg\"><br>+++</p>\n<h2 id=\"虚拟存储器\"><a href=\"#虚拟存储器\" class=\"headerlink\" title=\"虚拟存储器\"></a>虚拟存储器</h2><h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>主存和辅存共同构成了虚拟存储器，对于应用程序员而言，虚拟存储器是透明的。（对OS开系统程序员不透明，他们必须管理TLB）<br>虚拟存储器具有主存的速度和辅存的容量</p>\n<ul>\n<li>允许多个程序之间高效、安全地共享内存</li>\n<li>允许单个程序使用超过内存容量的内存</li>\n</ul>\n<p>+++primary<br>实地址&#x3D;主存页号+页内字地址<br>虚地址&#x3D;虚存页号+页内字地址<br>辅存地址&#x3D;磁盘号+盘面号+磁道号+扇区号<br>+++</p>\n<p>虚拟存储器缺页访问辅存的代价很大，当程序访问某个virtual page时，如果该页当前不在主存中，就会发生page fault，操作系统需要从辅存加载该页到主存，访问很慢所以访问代价大。因此采用<code>full associative</code>允许virtual page可以加载到主存的任何一个空闲物理页框中，提高命中率。<br>写操作中处理一致性问题时采用 <code>write back</code>。主存中的页面状态维护一个dirty标志位。当操作系统需要将该页替换出主存时，会检查该页的脏页标志：如果dirty，说明主存页面数据修改过，必须写回辅存；如果dirty为0，说明主存数据和辅存一致，直接丢弃主存页面，无需写回</p>\n<h3 id=\"页式虚拟存储器\"><a href=\"#页式虚拟存储器\" class=\"headerlink\" title=\"页式虚拟存储器\"></a>页式虚拟存储器</h3><ul>\n<li>基本单位：页<br>主存和虚拟地址空间被划分为相同大小的页，主存中的成为物理页（实页、页框、frame），虚拟地址空间中的页称为虚拟页（虚页）<br>页表(page table)记录了程序的虚页调入贮存时被安排在主存中的位置<br>一般的page大小从4KiB ~ 64KiB不等</li>\n</ul>\n<ol>\n<li>页表(page table)<br>页表放在主存中。<br><img data-src=\"/f33.jpg\"><br>有效位（Valid Bit）：用于指示一个页面是否已经被加载到主存中。如果有效位被设置为1，这意味着对应的页面已经在物理内存中，可以立即被访问。如果有效位为0，则表示该页面当前不在内存中，可能需要从磁盘或其他存储设备中调入。当一个程序尝试访问一个页面时，操作系统会检查页表中的有效位，如果发现页面不在内存中，就会触发一个page fault，然后将页面从磁盘加载到内存中。<br>引用位（Reference Bit）：引用位主要用于页面置换算法中，它记录了页面最近是否被访问过。每当一个页面被访问时，操作系统会将该页面的引用位置为1。随着时间的推移，如果一个页面长时间没有被访问，它的引用位可能会被清零。当操作系统需要选择一个页面进行置换时，它可能会优先选择那些引用位为0的页面。</li>\n</ol>\n<p>转换过程：当一个程序尝试访问内存时，它会生成一个虚拟地址。虚拟地址包含两部分信息：页号（Page Number）和页内偏移（Offset）。用VPN作为索引查询page table，检查valid bit是否为1，从页表条目中获取PPN，PPN和page offset组合成物理地址。</p>\n<blockquote>\n<p>页式虚拟存储器的优点：页面长度固定，页表简单，调入方便<br>缺点：产生内碎片</p>\n</blockquote>\n<ol start=\"2\">\n<li><p>地址转换<br><img data-src=\"/f34.png\"><br>每个进程都有一个页表基址寄存器，存放该进程的页表首地址。然后通过VPN作为索引在页表中查找对应的页表项。物理地址&#x3D;物理页号 + 页内地址。</p>\n</li>\n<li><p>TLB（快表）<br>为了减少访问主存的此书，TLB相当于page table的cache。<br>TLB用<code>SRAM</code>实现，不在主存中，工作原理类似于Cache，通常采用full associative或者set associative。<br><img data-src=\"/f35.jpg\"><br>通过VPN查找TLB和Cache的查找一样，如果是全相连则直接比较tag，如果是组相连则通过低位查找set，然后用高位和tag比较。</p>\n</li>\n<li><p>具有TLB和Cache的多级存储系统<br><img data-src=\"/f36.jpg\"><br>查找时，TLB和page table可以同步进行，如果在TLB中找到了，page table的查找就作废。</p>\n</li>\n</ol>\n<p><img data-src=\"/f37.jpg\"></p>\n<h3 id=\"段式虚拟存储器\"><a href=\"#段式虚拟存储器\" class=\"headerlink\" title=\"段式虚拟存储器\"></a>段式虚拟存储器</h3><p><img data-src=\"/f38.jpg\"><br>按程序的逻辑结构划分，段的长度因程序而异。虚拟地址分为段号和段内地址。虚地址和实地址的转换依靠段表。<br>段表每行记录某个段的&#x3D;&#x3D;段号、有效位、段长度、段起始地址&#x3D;&#x3D;。<br>段表本身也是段，一般驻留在主存中<br>&#x3D;&#x3D;分页对程序员是透明的，分段对程序员是不透明的&#x3D;&#x3D;</p>\n<blockquote>\n<p>段式虚拟存储器的优点：具有逻辑独立性，易于编译、管理、修改和保护，便于多道程序的共享<br>缺点：产生外碎片</p>\n</blockquote>\n<h3 id=\"段页式虚拟存储器\"><a href=\"#段页式虚拟存储器\" class=\"headerlink\" title=\"段页式虚拟存储器\"></a>段页式虚拟存储器</h3><p>把程序按逻辑结构分段，再在每段划分固定大小的页。因此段的长度必须是页长度的整数倍，段的起点必须是某一页的起点。<br>虚地址分为&#x3D;&#x3D;段号，段内页号，页内地址&#x3D;&#x3D;</p>\n<ul>\n<li>访问流程：从段表基址寄存器（STBR） 中读取段表的起始地址，用段号（s）作为索引，在段表中查找第 s 个表项，从该表项中取出该段对应的页表起始地址（即页表基址），与段内页号合成得到页表地址（页表项地址 &#x3D; PTBR + p × 页表项大小），读取第 p 个页表项得到物理页号（PPN），和页内地址合成得到物理地址</li>\n</ul>\n",
            "tags": [
                "存储系统"
            ]
        },
        {
            "id": "http://example.com/2025/07/01/computer-science/computer-organization/%E9%94%99%E9%A2%98%E9%9B%86%E5%90%88/",
            "url": "http://example.com/2025/07/01/computer-science/computer-organization/%E9%94%99%E9%A2%98%E9%9B%86%E5%90%88/",
            "title": "错题集合",
            "date_published": "2025-06-30T16:00:00.000Z",
            "content_html": "<h1 id=\"错题集合\"><a href=\"#错题集合\" class=\"headerlink\" title=\"错题集合\"></a>错题集合</h1><h2 id=\"Ch2\"><a href=\"#Ch2\" class=\"headerlink\" title=\"Ch2\"></a>Ch2</h2><ol>\n<li>某计算机字长为8位，CPU中有一个8位加法器，已知无符号数x&#x3D;69, y&#x3D;38，若在该加法器中计算x-y，则加法器的两个输入短信息和输入的低位进位信息分别为（）</li>\n</ol>\n<ul>\n<li>0100 0101, 1101 1001, 1 <blockquote>\n<p>无符号数减法，在加法器中输入x的原码，y的取反和1</p>\n</blockquote>\n</li>\n</ul>\n<ol start=\"2\">\n<li>减法指令 “sub R1, R2, R3” 的功能为 “(R1) - (R2) -&gt; R3”, 该指令执行后将生成进位&#x2F;借位标志CF和溢出标志OF，若(R1) &#x3D; FFFF FFFFH, R2 &#x3D; FFFF FFF0H, 则该减法指令执行后，CF和OF分别为：</li>\n</ol>\n<ul>\n<li>CF &#x3D; 0, OF &#x3D; 0</li>\n</ul>\n<ol start=\"3\">\n<li>已知x, y为int类型，当x &#x3D; 100, y &#x3D; 200时，执行 “x - y”指令得到的溢出标志OF和结尾标志CF分别为0，1，那么当x &#x3D; 1-, y &#x3D; -20时，执行该指令得到的OF和CF分别为：</li>\n</ol>\n<ul>\n<li>OF &#x3D; 0, CF &#x3D; 1<blockquote>\n<p>ALU生成标志位时只负责计算，不管运算对象是有符号数还是无符号数。CF&#x3D;1表示当做无符号数运算时溢出，OF&#x3D;1表示当做有符号数运算时溢出。当做有符号数，10-(-20)没问题，所以OF&#x3D;0；把它俩当做无符号数的时候，x &#x3D; 10 &#x3D; 0000 0000 0000 0000 0000 0000 0000 1010，y &#x3D; -20 &#x3D; 1111 1111 1111 1111 1111 1111 1110 1100，此时x &lt; y，所以CF&#x3D;1。</p>\n</blockquote>\n</li>\n</ul>\n<ol start=\"4\">\n<li>下列关于整数乘法运算的叙述中，错误的是：D</li>\n</ol>\n<ul>\n<li>A. 用阵列乘法器实现的乘运算可以在一个时钟周期内完成 –正确，因为是组合逻辑理论上可以在一个clc里完成</li>\n<li>B. 用ALU和移位器实现的乘运算无法在一个时钟周期内完成</li>\n<li>C. 变量与常数的乘运算可编译优化为若干移位及家&#x2F;减运算指令</li>\n<li>D. 两个变量的乘运算无法编译转换为移位及加法等指令的循环实现</li>\n</ul>\n<h2 id=\"Ch4\"><a href=\"#Ch4\" class=\"headerlink\" title=\"Ch4\"></a>Ch4</h2><ol>\n<li>简化地址结构的方式是尽量采用： 隐含寻址</li>\n</ol>\n",
            "tags": [
                "错题"
            ]
        },
        {
            "id": "http://example.com/2025/06/19/SE/diagram/",
            "url": "http://example.com/2025/06/19/SE/diagram/",
            "title": "画图题",
            "date_published": "2025-06-18T16:00:00.000Z",
            "content_html": "<ol>\n<li>用例图 Use Case Diagram<br>Use-Cases: A collection of user scenarios that describe the thread of usage of a system<br>主要包含涉及的角色，角色对应的行为，第三方参与部分</li>\n</ol>\n<ul>\n<li>参与者：与系统交互的用户或其他软硬件系统，用小人形表示</li>\n<li>用例：系统中执行的一系列动作，用椭圆表示。</li>\n<li>关系参与者与用例、参与者之间、用例之间的联系。连线</li>\n<li>边界：一组用例描述的系统或子系统，用矩形框表示。</li>\n</ul>\n<p>+++primary example: SafeHome<br>;;;id3 题目<br>Our research indicates that the market for home security systems is growing at a rate of 40% per year. We would like to enter this market by building a &#x3D;&#x3D;microprocessor-based&#x3D;&#x3D; home security system that would protect against and&#x2F;or recognize a variety of &#x3D;&#x3D;undesirable situations&#x3D;&#x3D; such as illegal entry, fire, flooding, and others. The product will use appropriate &#x3D;&#x3D;sensors&#x3D;&#x3D; to detect each situation, can be programmed by the &#x3D;&#x3D;homeowner&#x3D;&#x3D;, and will automatically telephone a monitoring agency when a situation is detected.<br>;;;</p>\n<p>;;;id3 答案<br><img data-src=\"/useCase.jpg\"><br>我的理解是找到里面的人(onwer, monitoring agency, 然后可以加个administrator)，物件(sensor)，中间的框是个系统，然后里面的椭圆写上对应的交互行为，连上线，感觉比较主观<br>;;;<br>+++</p>\n<ol start=\"2\">\n<li><p>CRC Card<br>每个卡片应该包含：类名，类的描述信息，职责，合作类<br>+++primary example<br><img data-src=\"/CRC.jpg\"><br>+++</p>\n</li>\n<li><p>类图 class diagram<br>主要的信息：类名，属性(name: type)，方法(name(parameter): return type)<br>+++primary example<br>;;;id4 例子1<br><img data-src=\"/class.jpg\"><br>;;;<br>;;;id4 例子2<br><img data-src=\"/class2.jpg\"><br>;;;<br>+++</p>\n</li>\n<li><p>状态图 state diagram<br><strong>节点</strong>：开始状态，结束状态，状态<br><strong>边</strong>：行为<br>状态：圆角矩形 state name, state variables, state activities<br>转移：带有标记的箭头<br>初始状态：实心圆<br>终止状态：实心环<br>分支：菱形<br>+++primary example<br>;;;id5 状态图<br><img data-src=\"/state.png\"><br>;;;<br>;;;id5 状态图<br><img data-src=\"/state2.jpg\"><br>;;;<br>+++</p>\n</li>\n<li><p>时序图 sequence diagram<br>对象（参与者上面要画个人）、生命线（对象下面的虚线）、控制焦点、消息<br><img data-src=\"/seq.jpg\"><br>实心箭头表示同步消息：一个对象向另一个对象发出同步消息后，将处于阻塞状态，一直等到另一个对象的回应（图里面的请求是同步的）<br>简单箭头表示异步<br>:::warning<br>箭头的画法存疑<br>:::</p>\n</li>\n<li><p>数据流图 data flow diagram<br>外部实体（数据的原点和终点）：软件系统外部环境中的实体（包括人、组织或其他软件系统），用&#x3D;&#x3D;方框&#x3D;&#x3D;<br>加工Process：对数据进行处理的单元，比如内部的xx系统，用&#x3D;&#x3D;圆角矩形&#x3D;&#x3D;或椭圆<br>数据存储：数据库，用&#x3D;&#x3D;右侧开口的矩形或者左右开口的矩形&#x3D;&#x3D;<br>数据流：箭头方向即数据流动方向，数据流名标在数据流线上面<br>看例子：<br><img data-src=\"/dataflow.jpg\"></p>\n</li>\n<li><p>软件架构图 architecture<br>以前后端分离的系统为例（前端，后端，数据库）<br><img data-src=\"/arch.jpg\"><br>三个大框分别是客户端、服务器、数据库层<br>里面小框，前端就是Web app和移动app，后端就是各种系统，数据库就是各种数据库（表？）</p>\n</li>\n<li><p>泳道图 Swimlane Diagram<br>跨职能流程图。旨在展示工作流中每个步骤涉及的流程和职能部门。在表示use-case的同时，描述对活动负责的actor&#x2F;analysis class<br>最上面放实体，然后分成一列一列，其他的和流程图一样<br><img data-src=\"/swim.jpg\"></p>\n</li>\n</ol>\n",
            "tags": [
                "软件工程"
            ]
        },
        {
            "id": "http://example.com/2025/06/19/SE/note/",
            "url": "http://example.com/2025/06/19/SE/note/",
            "title": "SE note",
            "date_published": "2025-06-18T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch2-Software-Engineering\"><a href=\"#Ch2-Software-Engineering\" class=\"headerlink\" title=\"Ch2 Software Engineering\"></a>Ch2 Software Engineering</h1><ul>\n<li>Definition: The application of a &#x3D;&#x3D;systematic&#x3D;&#x3D;, &#x3D;&#x3D;disciplined&#x3D;&#x3D;, &#x3D;&#x3D;quantifiable（可量化）&#x3D;&#x3D; approach to the &#x3D;&#x3D;development&#x3D;&#x3D;, &#x3D;&#x3D;operation&#x3D;&#x3D;, and &#x3D;&#x3D;maintenance&#x3D;&#x3D; of software</li>\n<li>软件工程是一个多层次的技术体系(a layered technology)<ul>\n<li>从下往上是a “quality” focus, process model, methods, tools, 反映了构建高质量软件产品的逻辑流程</li>\n</ul>\n</li>\n<li>软件过程（The Software Process）中的两个重要概念：通用过程框架（Common Process Framework）和 伞形活动（Umbrella Activities）<ul>\n<li>通用过程框架（Common Process Framework）： 软件开发过程中的一些基本要素<ul>\n<li>工作任务（work tasks）：指在软件开发的不同阶段中需要完成的具体任务。</li>\n<li>工作产品（work products）：指在执行工作任务过程中产生的各种文档、代码等成果物。</li>\n<li>里程碑与交付物（milestones &amp; deliverables）：里程碑是项目进展的重要节点，而交付物是在这些节点上需要提交的成果。</li>\n<li>质量保证检查点（QA checkpoints）：在整个开发过程中设置的检查点，用于评估和确保软件产品的质量。</li>\n</ul>\n</li>\n<li>伞形活动（Umbrella Activities）：软件开发过程中需要执行的活动<ul>\n<li>项目管理（Project management）：负责项目的规划、组织、协调和控制，确保项目按计划进行。</li>\n<li>质量保证（Quality assurance）：通过一系列措施确保软件产品的质量符合预定标准。</li>\n<li>工作产品生产（Work product production）：涉及创建和维护软件开发过程中产生的各种工作产品。</li>\n<li>测量（Measurement）：收集和分析数据以评估项目的状态和进度。</li>\n<li>正式技术评审（Formal technical reviews）：对软件的技术设计和实现进行系统性的审查。</li>\n<li>配置管理（Configuration management）：管理软件开发过程中各种配置项的变化，确保版本的一致性和可追溯性。</li>\n<li>重用管理（Reusability management）：促进软件组件和模块的重用，提高开发效率和软件质量。</li>\n<li>风险管理（Risk management）：识别、评估和应对可能影响项目成功的各种风险。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Generic Process Framework</strong> 通用的软件开发过程框架<ul>\n<li><strong>Communication</strong>: 与客户协作并收集需求</li>\n<li><strong>Planning</strong>: establishes engineering work plan, describes technical risks, lists resource requirements, work products produced, and defines work schedule</li>\n<li><strong>Modeling</strong>: 创建模型以帮助开发者和客户理解需求和设计</li>\n<li><strong>Construction</strong>: code &amp; test</li>\n<li><strong>Deployment</strong>: 交付软件供客户评估和反馈</li>\n</ul>\n</li>\n<li><strong>Process Adaptation</strong> 过程适配: 根据项目的具体需求、限制条件和特点，对软件开发过程进行定制和调整<ul>\n<li>overall &#x3D;&#x3D;flow&#x3D;&#x3D; of activities, actions, and tasks and the interdependencies among them</li>\n<li>degree to which &#x3D;&#x3D;actions and tasks&#x3D;&#x3D; are defined within each framework activity</li>\n<li>degree to which &#x3D;&#x3D;work products&#x3D;&#x3D; are identified and required</li>\n<li>manner which &#x3D;&#x3D;quality assurance&#x3D;&#x3D; activities are applied</li>\n<li>manner in which &#x3D;&#x3D;project tracking and control&#x3D;&#x3D; activities are applied</li>\n<li>overall degree of &#x3D;&#x3D;detail and rigor&#x3D;&#x3D; with which the process is described</li>\n<li>degree to which the &#x3D;&#x3D;customer and other stakeholders&#x3D;&#x3D; are involved with the project</li>\n<li>level of autonomy given to the &#x3D;&#x3D;software team&#x3D;&#x3D;</li>\n<li>degree to which &#x3D;&#x3D;team organization and roles&#x3D;&#x3D; are prescribed</li>\n</ul>\n</li>\n<li>The Essence of Practice<ul>\n<li><strong>Understand the problem</strong> (communication and analysis).</li>\n<li><strong>Plan a solution</strong> (modeling and software design).</li>\n<li><strong>Carry out the plan</strong> (code generation).</li>\n<li><strong>Examine the result for accuracy</strong> (testing and quality assurance).</li>\n</ul>\n</li>\n<li>General Principles 通用原则：软件开发过程中应遵循的一些核心指导思想或基本原则<ul>\n<li>The reason it all exists — Provide Value to users</li>\n<li>KISS — Keep It Simple, Stupid!</li>\n<li>Maintain the Vision</li>\n<li>What you produce, others will consume</li>\n<li>Be open to the future</li>\n<li>Plan ahead for reuse</li>\n<li>Think!</li>\n</ul>\n</li>\n<li>Software Development Myths 软件开发管理中常见的误解（Myth）及其背后的现实情况（Reality）<ul>\n<li>Management myths<ul>\n<li>标准和流程的有效性依赖于团队的理解和接受程度。</li>\n<li>软件开发是一个高度协作和复杂的创造性过程，简单地增加人力并不能解决进度问题。</li>\n<li>外包项目同样需要良好的管理和沟通能力，不能因为外包就忽视了对项目的控制和监督</li>\n</ul>\n</li>\n<li>Customer myths<ul>\n<li>详细的需求分析和规划</li>\n<li>充分的沟通与确认</li>\n<li>合理的进度评估</li>\n</ul>\n</li>\n<li>Practitioner’s myths<ul>\n<li>错误：一旦我们编写好程序并使其正常运行，我们的工作就完成了</li>\n<li>过早进入编码阶段可能会导致更多的返工和调整，从而延长项目周期</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Ch3-Software-Process-Structure\"><a href=\"#Ch3-Software-Process-Structure\" class=\"headerlink\" title=\"Ch3 Software Process Structure\"></a>Ch3 Software Process Structure</h1><p>Umbrella Activities是贯穿整个软件开发过程的活动，Framework Activity是软件开发的核心阶段，如沟通、计划、建模、构建和部署，每个框架活动下都有具体的task set，每个task set中又包含多个具体的action</p>\n<ul>\n<li><p><strong>Process flow</strong> 过程流（对于之前提到的Generic Process Framework的五步）</p>\n<ol>\n<li>线性过程流（Linear process flow）</li>\n<li>迭代过程流（Iterative process flow）</li>\n<li>演化过程流（Evolutionary process flow）</li>\n<li>并行过程流（Parallel process flow）<br><img data-src=\"/f1.jpg\"></li>\n</ol>\n</li>\n<li><p><strong>Process Patterns</strong> 过程模式<br>Process patterns define a set of activities, actions, work tasks, work products and&#x2F;or related behaviors<br>提供了一种<code>template</code>用于定义模式<br><strong>Generic software pattern elements</strong>:</p>\n</li>\n<li><p>pattern name </p>\n</li>\n<li><p>Intent (objective of pattern) </p>\n</li>\n<li><p>Type (Task pattern, Stage pattern, Phase pattern)</p>\n</li>\n<li><p>Initial context</p>\n</li>\n<li><p>Solution</p>\n</li>\n<li><p>Resulting context</p>\n</li>\n<li><p>Related patterns</p>\n</li>\n<li><p>Known uses&#x2F;examples</p>\n</li>\n<li><p><strong>Process Assessment</strong><br>几种评估软件过程的方法：<br>SCAMPI (Standard CMMI Appraisal Method for Process Improvement)<br>SPICE (ISO&#x2F;IEC 15504)<br>CBA IPI (Capability Benchmarking Appraisal using the Integrated Process Improvement method)<br>ISO 9001:2000 for Software</p>\n</li>\n<li><p>The Capability Maturity Model Integration 能力成熟度模型集成（CMMI）</p>\n<ul>\n<li>Level 0: Incomplete </li>\n<li>Level 1: Performed </li>\n<li>Level 2: Managed</li>\n<li>Level 3: Defined</li>\n<li>Level 4: Quantitatively Managed 定量管理</li>\n<li>Level 5: Optimizing</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Ch4-Process-Models\"><a href=\"#Ch4-Process-Models\" class=\"headerlink\" title=\"Ch4 Process Models\"></a>Ch4 Process Models</h1><h2 id=\"Prescriptive-Models\"><a href=\"#Prescriptive-Models\" class=\"headerlink\" title=\"Prescriptive Models\"></a>Prescriptive Models</h2><p>Prescriptive(规范的) process models advocate an orderly approach to software engineering</p>\n<ul>\n<li>The Waterfall Model: A reasonable approach when requirements are well defined<br><img data-src=\"/4-1.jpg\"></li>\n<li>The V Model<br><img data-src=\"/4-2.jpg\"></li>\n<li>Incremental Process Models 增量过程模型<ul>\n<li>The Incremental Model 增量模型: 将整个系统划分为多个可交付的“增量”部分，每个增量都作为一个独立的小项目进行五步流程: A good approach when a working core product is required quickly<br> <img data-src=\"/4-3.jpg\"></li>\n<li>The Rapid Application Development (RAD) Model 快速应用开发模型: 短时间内交付功能完善的系统，communication和planning之后分成好几个team进行modeling和construction，最后合并deployment<br> <img data-src=\"/4-4.jpg\"></li>\n</ul>\n</li>\n<li>Evolutionary Process Models 进化式过程模型<ul>\n<li>Prototyping 原型化方法: 当客户有明确的需求但不清楚具体细节时，通过原型，客户可以直观地看到系统的雏形并提出修改意见；原型通常是“抛弃型”的，即在验证概念后会被丢弃，而不是直接作为最终产品的一部分<ul>\n<li>Prototype Model: Communication, Quick Plan, Modeling &amp; Quick Design, Construction of prototype, Deployment Delivery &amp; Feedback</li>\n</ul>\n</li>\n<li>The Spiral Model 螺旋模型: 螺旋模型将整个开发过程视为一个逐渐扩大的螺旋线，每个环代表一个开发阶段或迭代周期，在每一次迭代中都进行风险分析（Risk Analysis）<br> <img data-src=\"/4-5.jpg\"> </li>\n<li>The Concurrent Development Model 并行开发模型<ul>\n<li>并行开发模型定义了一系列<code>事件</code>，这些事件将触发每个活动、动作或任务<code>从一个状态到另一个状态的转换</code></li>\n<li>Especially good for client&#x2F;server applications</li>\n<li>并行开发模型定义了一个活动网络，而不是简单的线性事件序列</li>\n<li>需要在Flexibility, Extensibility, Speed of development 和 high quality 中权衡</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Specialized-Process-Models-专业化的软件过程模型\"><a href=\"#Specialized-Process-Models-专业化的软件过程模型\" class=\"headerlink\" title=\"Specialized Process Models 专业化的软件过程模型\"></a>Specialized Process Models 专业化的软件过程模型</h2><ol>\n<li>Component-Based Development （强调reuse）</li>\n<li>Formal methods （形式化方法强调使用数学手段来精确地描述需求）</li>\n<li>Aspect-Oriented Software Development （面向切面，切面指那些横跨多个模块或功能的通用关注点）</li>\n</ol>\n<h2 id=\"The-Unified-Process-统一过程\"><a href=\"#The-Unified-Process-统一过程\" class=\"headerlink\" title=\"The Unified Process 统一过程\"></a>The Unified Process 统一过程</h2><p>统一过程是一种“用例驱动、以架构为中心、迭代和增量”的软件开发过程<br>A &#x3D;&#x3D;“use-case driven, architecture-centric, iterative and incremental”&#x3D;&#x3D; software process closely aligned with the Unified Modeling Language (UML)<br><img data-src=\"/4-6.png\"><br>五个阶段: &#x3D;&#x3D;Inception, Elaboration, Construction, Transition, Production&#x3D;&#x3D;</p>\n<h3 id=\"统一过程（Unified-Process-UP）在各个阶段产生的工作产品（Work-Products）\"><a href=\"#统一过程（Unified-Process-UP）在各个阶段产生的工作产品（Work-Products）\" class=\"headerlink\" title=\"统一过程（Unified Process, UP）在各个阶段产生的工作产品（Work Products）\"></a>统一过程（Unified Process, UP）在各个阶段产生的工作产品（<code>Work Products</code>）</h3><ol>\n<li>Inception Phase（启动阶段）<br>Vision Document（愿景文档）：概述项目的总体目标、范围和预期结果。<br>Initial Use-case Model（初始用例模型）：描述系统的主要功能和用户交互场景。<br>Initial Project Glossary（初始项目术语表）：定义项目中使用的专业术语和缩写。<br>Initial Business Case（初始商业案例）：分析项目的商业价值和可行性。<br>Initial Risk Assessment（初始风险评估）：识别和评估项目可能面临的风险。<br>Project Plan Phases and Iterations（项目计划阶段和迭代）：制定项目的整体计划，包括阶段划分和迭代安排。<br>Business Model（业务模型）：描述项目的业务流程和商业模式。<br>Prototypes（原型）：创建系统的初步原型，用于验证需求和设计。</li>\n<li>Elaboration Phase（细化阶段）<br>Use-case Model（用例模型）：进一步完善和细化用例模型，明确系统功能。<br>Functional and Non-functional Requirements（功能性与非功能性需求）：详细描述系统需要满足的功能性和非功能性要求。<br>Analysis Model（分析模型）：基于需求分析建立的系统逻辑模型。<br>Software Architecture Description（软件架构描述）：定义系统的整体架构和关键组件。<br>Executable Architectural Prototype（可执行架构原型）：实现一个可运行的架构原型，验证架构的可行性和性能。<br>Preliminary Design Model（初步设计模型）：基于架构描述进行初步的设计。<br>Revise Risk List（修订风险列表）：根据新的信息和发现更新风险评估。<br>Project Plan Iteration Plan, Workflow, Milestones（项目计划迭代计划、工作流、里程碑）：细化项目计划，包括具体的迭代安排、工作流程和关键里程碑。<br>Preliminary User Manual（初步用户手册）：编写系统的初步使用说明。</li>\n<li>Construction Phase（构建阶段）<br>Design Model（设计模型）：完成详细的系统设计，包括模块设计和接口设计。<br>Software Components（软件组件）：开发和实现各个软件组件。<br>Integrated Software Increment（集成软件增量）：将各个组件集成在一起，形成可运行的软件增量。<br>Test Plan（测试计划）：制定详细的测试计划，包括测试策略和资源安排。<br>Test Cases（测试用例）：编写具体的测试用例，用于验证系统功能和质量。<br>Support Documentation User Installation Increment（支持文档用户安装增量）：编写用户安装和操作指南，帮助用户正确安装和使用系统。</li>\n<li>Transition Phase（过渡阶段）<br>Delivered Software Increment（交付的软件增量）：向用户交付经过测试和验证的软件增量。<br>Beta Test Reports（Beta测试报告）：收集和整理Beta测试期间的反馈和问题报告。<br>User Feedback（用户反馈）：收集用户的实际使用反馈，为后续改进提供依据。</li>\n<li>Production</li>\n</ol>\n<h3 id=\"个人软件过程（Personal-Software-Process-PSP）\"><a href=\"#个人软件过程（Personal-Software-Process-PSP）\" class=\"headerlink\" title=\"个人软件过程（Personal Software Process, PSP）\"></a>个人软件过程（Personal Software Process, PSP）</h3><p>Five Framework Activities:</p>\n<ol>\n<li>Planning</li>\n<li>High-Level Design</li>\n<li>High-Level Design Review</li>\n<li>Development</li>\n<li>Postmortem（事后分析）<br>Stresses the Need for Error Identification and Understanding</li>\n</ol>\n<h3 id=\"团队软件过程（Team-Software-Process-TSP）\"><a href=\"#团队软件过程（Team-Software-Process-TSP）\" class=\"headerlink\" title=\"团队软件过程（Team Software Process, TSP）\"></a>团队软件过程（Team Software Process, TSP）</h3><ol>\n<li>Each project is “launched” using a “script” that defines the tasks to be accomplished</li>\n<li>Teams are self-directed</li>\n<li>Measurement is encouraged</li>\n<li>Measures are analyzed with the intent of improving the team process</li>\n</ol>\n<h1 id=\"Ch5-Agile-Development-敏捷开发\"><a href=\"#Ch5-Agile-Development-敏捷开发\" class=\"headerlink\" title=\"Ch5 Agile Development 敏捷开发\"></a>Ch5 Agile Development 敏捷开发</h1><p>What is Agility?</p>\n<ul>\n<li>Effective (rapid and adaptive) response to change</li>\n<li>Effective communication among all stakeholders</li>\n<li>Drawing the customer onto the team</li>\n<li>Organizing a team so that it is in control of the work performed</li>\n<li>Rapid, incremental delivery of software<br>An Agile Process</li>\n<li>Is driven by customer descriptions of what is required (scenarios)</li>\n<li>Recognizes that plans are short-lived</li>\n<li>Develops software iteratively with a heavy emphasis on construction activities</li>\n<li>Delivers multiple ‘software increments’</li>\n<li>Adapts as changes occur</li>\n</ul>\n<p>Extreme Programming 极限编程(XP): &#x3D;&#x3D;planning, design, coding, testing&#x3D;&#x3D;<br>XP plan:</p>\n<ul>\n<li>begin with user stories</li>\n<li>assigns a cost</li>\n<li>Stories are grouped to for a deliverable increment</li>\n<li>commitment</li>\n<li>project velocity<br><img data-src=\"/5-1.png\"></li>\n</ul>\n<p>Industrial XP (IXP)<br>IXP incorporates six new practices: </p>\n<ul>\n<li>Readiness assessment 准备评估</li>\n<li>Project community 项目社区</li>\n<li>Project chartering 项目章程制定</li>\n<li>Test driven management 测试驱动管理</li>\n<li>Retrospectives 团队自省</li>\n<li>Continuous learning  持续学习</li>\n</ul>\n<p>Scrum 一种流行的敏捷开发框架</p>\n<ul>\n<li>Development work is partitioned into “packets”</li>\n<li>Testing and documentation are on-going (测试和文档贯穿开发流程)</li>\n<li>Work occurs in “sprints” and is derived from a “backlog” (Sprint 是 Scrum 的核心时间单位，通常为 1 到 4 周)</li>\n<li>Meetings are very short 高效沟通（三个问题：What did you do since the last meeting&#x2F; What do you plan to accomplish by the next team meeting&#x2F;What obstacles are you encountering）</li>\n<li>“demos” are delivered to the customer with the time-box allocated</li>\n</ul>\n<p>Dynamic Systems Development Method  - DSDM<br>帕累托原则（Pareto Principle），也称为 80&#x2F;20 法则<br>“80% 的价值来自 20% 的功能”，或者 “80% 的系统可以在 20% 的时间内交付”<br>DSDM 的核心理念之一就是：优先交付最有价值的功能</p>\n<p>Agile Modeling (<code>AM</code>) principals:</p>\n<ul>\n<li>Model with a purpose</li>\n<li>Use multiple models </li>\n<li>Travel light </li>\n<li>Content is more important than representation</li>\n<li>Know the models and the tools you use to create them</li>\n<li>Adapt locally</li>\n</ul>\n<p>Agile Unified Process (<code>AUP</code>) 敏捷统一流程：一个精简的软件开发过程<br>Each AUP iteration addresses these activities: </p>\n<ul>\n<li>Modeling</li>\n<li>Implementation</li>\n<li>Testing</li>\n<li>Deployment </li>\n<li>Configuration and project management </li>\n<li>Environment management</li>\n</ul>\n<h1 id=\"Ch6-Human-Aspects-of-Software-Engineering\"><a href=\"#Ch6-Human-Aspects-of-Software-Engineering\" class=\"headerlink\" title=\"Ch6 Human Aspects of Software Engineering\"></a>Ch6 Human Aspects of Software Engineering</h1><p>Traits of Successful Software Engineers: 责任感、对需求敏感、直言不讳、有弹性(Resilient under pressure)、公平意识、注重细节、务实(Pragmatic)<br>The Psychology Of Software Engineering 没看懂不管了<br>Effective Software Team Attributes</p>\n<ul>\n<li>Sense of purpose</li>\n<li>Sense of involvement</li>\n<li>Sense of trust</li>\n<li>Sense of improvement</li>\n<li>Diversity of team member skill sets<br>Avoid Team “Toxicity” 毒性<br>A frenzied work atmosphere, high frustication, Fragmented or poorly coordinated procedures(或者定义不当的模型), Unclear definition of roles, Continuous and repeated exposure to failure</li>\n</ul>\n<p>Factors Affecting Team Structure</p>\n<ul>\n<li>difficulty of the problem</li>\n<li>size of the resultant program(s)</li>\n<li>the time that the team will stay together</li>\n<li>the degree to which the problem can be modularized</li>\n<li>the required quality and reliability of the system</li>\n<li>the rigidity of the delivery date 交付日期是不是很死</li>\n<li>the degree of sociability required</li>\n</ul>\n<p>Organizational Paradigms 组织范式</p>\n<ul>\n<li>Closed paradigm</li>\n<li>Random paradigm</li>\n<li>Open paradigm</li>\n<li>Synchronous paradigm<table>\n<thead>\n<tr>\n<th>范式</th>\n<th>组织方式</th>\n<th>控制程度</th>\n<th>创新程度</th>\n<th>沟通频率</th>\n<th>适用项目类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Closed</strong></td>\n<td>层级权威</td>\n<td>高</td>\n<td>低</td>\n<td>自上而下</td>\n<td>传统行业、安全关键系统</td>\n</tr>\n<tr>\n<td><strong>Random</strong></td>\n<td>松散自由</td>\n<td>低</td>\n<td>高</td>\n<td>无固定模式</td>\n<td>初创项目、探索性任务</td>\n</tr>\n<tr>\n<td><strong>Open</strong></td>\n<td>半结构化</td>\n<td>中等</td>\n<td>高</td>\n<td>高频协作</td>\n<td>敏捷开发、创新型项目</td>\n</tr>\n<tr>\n<td><strong>Synchronous</strong></td>\n<td>模块化分工</td>\n<td>高</td>\n<td>中等</td>\n<td>极少</td>\n<td>分布式系统、大型项目</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<p>Generic Agile Teams（通用敏捷团队）</p>\n<ul>\n<li>individual competency coupled with group collaboration</li>\n<li>People trump process and politics can trump people</li>\n<li>self-organizing and have many structures</li>\n<li>Planning is kept to a minimum 不反对规划，但强调“轻量级规划”比如Sprint</li>\n</ul>\n<p>XP Team Values</p>\n<ul>\n<li>Communication</li>\n<li>Simplicity: design for immediate needs nor future needs</li>\n<li>Feedback</li>\n<li>Courage</li>\n<li>Respect</li>\n</ul>\n<p>Impact of Social Media </p>\n<p>Software Engineering using the Cloud</p>\n<p>协作工具：Services of collaborative development environments(CDEs)<br>Namespace, Calendar, Template, Metrics support(Metrics 应用于过程改进，而不是人员奖惩), Communication analysis, Artifact clustering归类</p>\n<p>Team Decisions Making Complications<br><img data-src=\"/6-1.jpg\"></p>\n<h1 id=\"Ch7-Principles-that-Guide-Practice\"><a href=\"#Ch7-Principles-that-Guide-Practice\" class=\"headerlink\" title=\"Ch7 Principles that Guide Practice\"></a>Ch7 Principles that Guide Practice</h1><p>Software development knowledgehave about a three year half-life, Software engineering principles 是永久的</p>\n<p>Principles that Guide Process:</p>\n<ol>\n<li>Be agile</li>\n<li>Focus on quality at every step</li>\n<li>Be ready to adapt</li>\n<li>Build an effective team</li>\n<li>Establish mechanisms for communication and coordination</li>\n<li>Manage change</li>\n<li>Assess risk</li>\n<li>Create work products that provide value for others</li>\n</ol>\n<p>Principles that Guide Practice:</p>\n<ol>\n<li>Divide and conquer</li>\n<li>Understand the use of abstraction</li>\n<li>Strive for consistency</li>\n<li>Focus on the transfer of information 注意接口的设计</li>\n<li>Build software that exhibits effective modularity</li>\n<li>Look for patterns</li>\n<li>When possible, represent the problem and its solution from a number of different perspectives</li>\n<li>Remember that someone will maintain the software</li>\n</ol>\n<p>Communication Principle： </p>\n<ol>\n<li>Listen</li>\n<li>Prepare before you communicate</li>\n<li>Someone should facilitate the activity</li>\n<li>Face-to-face communication is best</li>\n<li>Take notes and document decisions</li>\n<li>Strive for collaboration</li>\n<li>Stay focused, modularize your discussion</li>\n<li>If something is unclear, draw a picture</li>\n<li>不管怎样, Move on</li>\n<li>Nigotiation(谈判) works best when both parties win</li>\n</ol>\n<p>Planning Principles：<br>懒得写了考了我吃</p>\n<p>Modeling Principles： 创建两类模型</p>\n<ol>\n<li>Requirements models (also called analysis models) 需求模型</li>\n<li>Design models 设计模型</li>\n</ol>\n<p>Agile Modeling Principles 记不住，懒得写了再说</p>\n<p>Requirements Modeling Principles</p>\n<ol>\n<li>The information domain of a problem must be represented and understood  对问题领域内信息的全面了解是构建有效软件的基础</li>\n<li>The functions that the software performs must be defined  定义软件的功能，明确描述软件应提供的功能和服务</li>\n<li>The behavior of the software (as a consequence of external events) must be represented  定义软件的行为，如何响应外界事件或输入</li>\n<li>The models that depict information, function, and behavior must be partitioned in a manner that uncovers detail in a layered (or hierarchical) fashion  使用结构化的、分层次的方法来组织模型</li>\n<li>The analysis task should move from essential information toward implementation detail  先关注核心需求和架构设计，再细化到具体的实现方案</li>\n</ol>\n<p>Design Modeling Principles<br>太多了懒得看</p>\n<p>Living Modeling Principles<br>懒得看</p>\n<p>Construction Principles</p>\n<ul>\n<li>The construction activity encompasses a set of coding and testing tasks</li>\n<li><code>Coding principles and concepts</code> are closely aligned programming style, programming languages, and programming methods</li>\n<li><code>Testing principles and concepts</code> lead to the design of tests that systematically uncover different classes of errors and to do so with a minimum amount of time and effort</li>\n</ul>\n<p>…..一堆principle，看了也记不住，不看了</p>\n<h1 id=\"Ch8-Understanding-Requirements\"><a href=\"#Ch8-Understanding-Requirements\" class=\"headerlink\" title=\"Ch8 Understanding Requirements\"></a>Ch8 Understanding Requirements</h1><p>Requirements Engineering:</p>\n<ol>\n<li>Inception: ask a set of questions – basic understanding of the problem, the people who want a solution, the nature of the solution, the effectiveness of preliminary communication and collaboration</li>\n<li>Elicitation: elicit requirements</li>\n<li>Elaboration: create an analysis model</li>\n<li>Negotiation: agree on a deliverable system</li>\n<li>Specification: written document&#x2F;set of models&#x2F;formal mathematical&#x2F;use-cases&#x2F;prototype</li>\n<li>Validation: a review mechanism that looks for – errors in content or interpretation&#x2F;areas where clarification may be required&#x2F;missing information&#x2F;inconsistencies&#x2F;conflicting or unrealistic (unachievable) requirements</li>\n<li>Requirements management</li>\n</ol>\n<p>Elicitation Work Products:<br>feasibility, scope, stakeholders, description of environment, constraints, usage scenarios, prototypes</p>\n<p>Negotiating Requirements:</p>\n<ol>\n<li>Identify the key stakeholders</li>\n<li>Determine each of the stakeholders “win conditions”</li>\n<li>Negotiate</li>\n</ol>\n<p>Requirements Monitoring:</p>\n<ol>\n<li>Distributed debugging</li>\n<li>Run-time verification</li>\n<li>Run-time validation</li>\n<li>Business activity monitoring</li>\n<li>Evolution and co-design</li>\n</ol>\n<p>Validating Requirements:<br>consistent, 是否在level of abstraction规定了, 是否essential, unambiguous, 每个要求注明来源, requirements 之间是否 conflict, achievable, testable, properly reflect the information, function and behavior, partitioned方式, …</p>\n<p>Quality Function Deployment (QFD):</p>\n<ul>\n<li>Function deployment</li>\n<li>Information deployment</li>\n<li>Task deployment</li>\n<li>Value analysis</li>\n<li>identifies three types of requirements: Normal&#x2F;Expected&#x2F;Exciting</li>\n</ul>\n<p>Non-Functional Requirement (NFR): quality attribute, performance attribute, security attribute, or general system constraint</p>\n<ol>\n<li>The first phase is to create a matrix using each NFR</li>\n<li>The second phase is for the team to prioritize each NFR using a set of decision rules</li>\n</ol>\n<h1 id=\"Ch9-Requirements-Modeling：Scenario-Based-Methods-基于场景的需求建模方法\"><a href=\"#Ch9-Requirements-Modeling：Scenario-Based-Methods-基于场景的需求建模方法\" class=\"headerlink\" title=\"Ch9 Requirements Modeling：Scenario-Based Methods 基于场景的需求建模方法\"></a>Ch9 Requirements Modeling：Scenario-Based Methods 基于场景的需求建模方法</h1><p>需求分析的目标：</p>\n<ul>\n<li>描述客户所需的内容 Describe what the customer requires</li>\n<li>为软件设计提供基础 Establish a basis for the creation of a software design</li>\n<li>定义一组可以验证的需求 Define a set of requirements that can be validated<br>Rules of Thumb（基本原则）：</li>\n<li>The model should focus on requirements that are visible within the problem or business domain. The level of abstraction should be relatively high.</li>\n<li>Each element of the analysis model should add to an overall understanding of software requirements and provide insight into the information domain, function and behavior of the system.</li>\n<li>Delay consideration of infrastructure and other non-functional models until design.</li>\n<li>Minimize coupling throughout the system.</li>\n<li>Be certain that the analysis model provides value to all stakeholders.</li>\n<li>Keep the model as simple as it can be.</li>\n</ul>\n<p>system description -&gt; analysis model -&gt; design model</p>\n<p><img data-src=\"/9-1.jpg\"></p>\n<p>Domain Analysis（领域分析）：<br>Software domain analysis is the identification, analysis, and specification of common requirements from a specific application domain, typically for <code>reuse</code> on multiple projects within that application domain…</p>\n<p>Use-Case Diagram, Activity Diagrams, Swim Lane Diagrams</p>\n<p>In structured analysis, models focus on data flow and functional decomposition of the system;<br>In object-oriented analysis, models focus on the structure of the classes defined for a system along with their interactions</p>\n<p>Each primary scenario should be <code>reviewed</code> and <code>refined</code> to see ifalternative interactions are possible</p>\n<h1 id=\"Ch10-Requirements-Modeling-Class-Based-Methods\"><a href=\"#Ch10-Requirements-Modeling-Class-Based-Methods\" class=\"headerlink\" title=\"Ch10 Requirements Modeling: Class-Based Methods\"></a>Ch10 Requirements Modeling: Class-Based Methods</h1><p>Class-Based需求建模的方法：structured analysis(数据对象和数据的转换), object- oriented analysis(类和类的协作)<br>the broad categories used to classify operations: computation, data manipulation, event monitors<br>Class-Based Modeling: objects, operations, relationships, collaborations<br>类图<br>CRC Cards<br>见画图题</p>\n<h1 id=\"Ch11-Requirements-Modeling-Behavior-Patterns-and-Web-Mobile-Apps\"><a href=\"#Ch11-Requirements-Modeling-Behavior-Patterns-and-Web-Mobile-Apps\" class=\"headerlink\" title=\"Ch11 Requirements Modeling: Behavior, Patterns, and Web&#x2F;Mobile Apps\"></a>Ch11 Requirements Modeling: Behavior, Patterns, and Web&#x2F;Mobile Apps</h1><p>For purposes of behavior modeling a state is any observable mode of behavior<br>Analysis patterns are discovered, they are not explicitly created<br>行为建模: use-cases, events, sequences, state diagram, 审查<br>行为建模三种图：state diagram, sequence diagram, data-flow diagram<br>The state transition diagram indicates system reactions to external events.<br>events由系统外部的参与者触发</p>\n<h2 id=\"Requirements-Modeling-for-WebApps\"><a href=\"#Requirements-Modeling-for-WebApps\" class=\"headerlink\" title=\"Requirements Modeling for WebApps:\"></a>Requirements Modeling for WebApps:</h2><ul>\n<li>内容分析 Content Analysis：描述文本、图形和图像、视频、音频等。</li>\n<li>交互分析 Interaction Analysis：使用案例。</li>\n<li>功能分析 Functional Analysis：定义应用于WebApp内容的操作，暗示其他处理功能。</li>\n<li>配置分析 Configuration Analysis：环境和基础设施。</li>\n<li>导航分析 Navigation Analysis：关注总体要求。</li>\n</ul>\n<p>配置模型 Configuration Model</p>\n<ul>\n<li>服务器端 Server-side：必须指定服务器硬件和操作系统环境、考虑服务器端互操作性、指定适当的接口、通信协议及相关协作信息。</li>\n<li>客户端 Client-side：必须识别浏览器配置问题、定义测试要求。</li>\n</ul>\n<p>导航建模 Navigation Modeling</p>\n<ul>\n<li>考虑哪些元素应更容易到达（需要更少的导航步骤），优先级如何？</li>\n<li>如何处理导航错误？</li>\n<li>是否应该通过链接、基于搜索的访问或其他方式完成导航？</li>\n<li>是否应根据之前导航动作的上下文向用户展示某些元素？</li>\n<li>是否应维护用户的导航日志？<br> WebApps interaction model: use-cases, sequence diagrams, state diagrams, interface prototype</li>\n</ul>\n<h1 id=\"Ch12-Design-Concepts\"><a href=\"#Ch12-Design-Concepts\" class=\"headerlink\" title=\"Ch12 Design Concepts\"></a>Ch12 Design Concepts</h1><p>好的软件设计应该具备：坚固性 Firmness, 实用性 Commodity, 愉悦感 Delight<br>Software Engineering Design：设计原则与质量</p>\n<ul>\n<li>Data&#x2F;Class design</li>\n<li>Architectural design</li>\n<li>Interface design</li>\n<li>Component-level design<br>自上而下是金字塔，见下图</li>\n</ul>\n<p><img data-src=\"/12-1.jpg\"></p>\n<p>Analysis Model -&gt; Design Model（需求模型到设计模型）</p>\n<ul>\n<li>设计必须实施分析模型中包含的所有显式需求(explicit requirements)，并适应客户希望的所有隐式需求。</li>\n<li>设计应当是可读且易于理解(readable, understandable guide)的指南，帮助编写代码的人以及测试和支持软件的人。</li>\n<li>设计应该提供软件的完整画面(a complete picture)，从实现的角度解决数据、功能和行为领域的问题</li>\n</ul>\n<p>质量指南 Quality Guidelines</p>\n<ul>\n<li>设计应展示一种使用公认的架构风格创建的架构。</li>\n<li>设计应由展现良好设计特性的组件组成。</li>\n<li>设计可以逐步实现。</li>\n<li>设计应模块化，即将软件逻辑划分为元素或子系统。</li>\n<li>设计应包含数据、架构、接口和组件的不同表示形式</li>\n</ul>\n<p>设计原则 Design Principles</p>\n<ul>\n<li>设计过程不应有“隧道视野”，即应全面考虑各种因素。</li>\n<li>设计应可追溯到分析模型。</li>\n<li>设计不应重新发明轮子（即不应重复已有的解决方案）。</li>\n<li>设计应“最小化软件与现实世界中存在的问题之间的智力距离”。</li>\n<li>设计应统一且整合。</li>\n<li>设计应能够适应变化。</li>\n<li>设计应以温和的方式降级，即使遇到异常数据、事件或操作条件。</li>\n</ul>\n<p>OO Design Concepts: Design classes(<code>Entity classes</code>, <code>Boundary classes</code>, <code>Controller classes</code>), Inheritance, Messages, Polymorphism<br>:::warning<br>后面看不下去先不管了<br>:::</p>\n<h1 id=\"Ch13-Architectural-Design\"><a href=\"#Ch13-Architectural-Design\" class=\"headerlink\" title=\"Ch13 Architectural Design\"></a>Ch13 Architectural Design</h1><p>架构风格：</p>\n<ul>\n<li>Data-centered architectures</li>\n<li>Data flow architectures </li>\n<li>Call and return architectures</li>\n<li>Object-oriented architectures</li>\n<li>Layered architectures</li>\n</ul>\n<h1 id=\"Ch14-Component-Level-Design\"><a href=\"#Ch14-Component-Level-Design\" class=\"headerlink\" title=\"Ch14 Component-Level Design\"></a>Ch14 Component-Level Design</h1><p>Component: a modular, deployable, and replaceable part of a system<br>OO角度：一个组件包含一组协作类<br>传统角度：数据结构和接口<br>Basic Design Principles：OCP, LSP, DIP, ISP, REP, CCP, CRP</p>\n<ul>\n<li>Open-Closed Principle: 开放扩展，关闭修改</li>\n<li>Liskov Substitution Principle: 子类可被父类替换</li>\n<li>Dependency Inversion Principles: 依赖抽象，不要依赖具体实现</li>\n<li>Interface Segregation Principle: 多个特定于客户端的接口比一个通用接口更好</li>\n<li>Release Reuse Equivalency Principle: 发布的粒度是重用的粒度</li>\n<li>Common Closure Principle: 一起变化的类应该放在一起</li>\n<li>Common Reuse Principle: 不一起重用的类不应放在一起</li>\n</ul>\n<p>基本设计原则（Basic Design Principles）:</p>\n<ol>\n<li>命名约定 Components </li>\n<li>接口 Interfaces</li>\n<li>依赖关系和继承：建议从左到右建模依赖关系，从底向上（派生类）到底部（基类）建模继承关系</li>\n</ol>\n<p>设计指南（Design Guidelines）:<br>内聚性 Cohension</p>\n<ul>\n<li>the &#x3D;&#x3D;“single-mindedness”&#x3D;&#x3D; of a module</li>\n<li>OO view: – cohesion implies that a component or class encapsulates only attributes and operations that are closely related to one another and to the class or component itself</li>\n<li>Levels of cohesion： Functional – Layer – Communicational – Sequential – Procedural – Temporal – Utility<br>耦合度级别：内容耦合、公共耦合、控制耦合等 Coupling</li>\n<li>The degree to which a component is &#x3D;&#x3D;connected to other components and to the external world&#x3D;&#x3D;</li>\n<li>OO观点: 衡量classes are connected to one another的程度</li>\n<li>Level of coupling: Content – Common – Control – Stamp – Data – Routine call – Type use – Inclusion or import – External</li>\n</ul>\n<p>WebApps 组件设计：通常包含content design and functional design<br>……</p>\n<h1 id=\"Ch15-User-Interface-Design\"><a href=\"#Ch15-User-Interface-Design\" class=\"headerlink\" title=\"Ch15 User Interface Design\"></a>Ch15 User Interface Design</h1><p>Golden Rule：</p>\n<ol>\n<li>Place the user in control</li>\n<li>Reduce the user’s memory load</li>\n<li>Make the interface consistent<br>User Interface Design Model:<table>\n<thead>\n<tr>\n<th>模型名称</th>\n<th>中文解释</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>User Model</td>\n<td>用户模型</td>\n<td>描述用户是谁、他们的需求和行为</td>\n</tr>\n<tr>\n<td>Design Model</td>\n<td>设计模型</td>\n<td>将用户模型转化为界面设计方案</td>\n</tr>\n<tr>\n<td>Mental Model</td>\n<td>心理模型</td>\n<td>用户对界面的主观理解和预期</td>\n</tr>\n<tr>\n<td>Implementation Model</td>\n<td>实现模型</td>\n<td>开发者实际构建的界面及其交互逻辑</td>\n</tr>\n<tr>\n<td>User Interface Design Process: 螺旋模型</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<p>Interface Analysis<br>Interface Analysis旨在理解以下几点：people(user), task, content, environment</p>\n<h1 id=\"Ch16-Pattern-Based-Design\"><a href=\"#Ch16-Pattern-Based-Design\" class=\"headerlink\" title=\"Ch16 Pattern-Based Design\"></a>Ch16 Pattern-Based Design</h1><p>A design pattern is a three-part rule which expresses a relation between a certain &#x3D;&#x3D;context&#x3D;&#x3D;, a &#x3D;&#x3D;problem&#x3D;&#x3D;, and a &#x3D;&#x3D;solution&#x3D;&#x3D;.</p>\n<p>Describing a Pattern: By detailing various dimensions such as pattern name, problem, motivation, context, forces, solution, intent, collaborations, consequences, implementation, known uses, related patterns, etc. </p>\n<h1 id=\"Ch17-WebApp-Design\"><a href=\"#Ch17-WebApp-Design\" class=\"headerlink\" title=\"Ch17 WebApp Design\"></a>Ch17 WebApp Design</h1><p>two basic approaches to design: 1. artistic ideal of designers; 2. the requirements of customers</p>\n<p>Design &amp; WebApp Quality的几个关键：</p>\n<ol>\n<li>Security: 抵御攻击、排除未经授权的访问、保护用户隐私</li>\n<li>Availability: 确保系统在需要的时候可用 The measure of the percentage of time that a WebApp is available for use</li>\n<li>Scalability（可扩展性）: Can the WebApp and the systems with which it is interfaced handle significant variation in user or transaction volume 系统在用户数量或交易量增加时，仍能保持良好的性能和响应速度的能力</li>\n<li>Time to Market（上市时间）</li>\n</ol>\n<p>Quality Dimensions for End-Users:<br>对于用户而言</p>\n<ol>\n<li>Time: 网站更新的频率和程度</li>\n<li>Structural: 网站的结构、链接、图片正常显示、组件连接</li>\n<li>Content: 关键页面的内容、关键短语、关键页面的不同版本、动态生成页面的质量和一致性</li>\n<li>Accuracy and Consistency: </li>\n<li>Response Time and Latency: 响应、加载速度</li>\n<li>Performance: 站点连接速度、负载</li>\n</ol>\n<p>WebApp Design Goals：</p>\n<ol>\n<li>Consistency: Content, Graphic design (aesthetics), Architectural design, Interface design, Navigation mechanisms</li>\n<li>Identity: Web应用需要有一个清晰且与业务目标相匹配的品牌形象或身份</li>\n<li>Robustness: Web应用的内容和功能的质量和可靠性</li>\n<li>Navigability: Designed in a manner that is intuitive and predictable（以直观和可预测的方式设计）</li>\n<li>Visual appeal</li>\n<li>Compatibility 兼容性<br><img data-src=\"/17-1.jpg\"></li>\n</ol>\n<p>Interface Design需要回答: Where am I? What can I do now? Where have I been, where am I going?</p>\n<p>Interface Design Principles 太多了懒得写</p>\n<p>&#x3D;&#x3D;Aesthetic Design&#x3D;&#x3D;</p>\n<ul>\n<li>Don’t be afraid of white space.</li>\n<li>Emphasize content.</li>\n<li>Organize layout elements from top-left to bottom right.</li>\n<li>Group navigation, content, and function geographically within the page.</li>\n<li>Don’t extend your real estate with the scrolling bar.</li>\n<li>Consider resolution and browser window size when designing layout.</li>\n</ul>\n<p>Content Design</p>\n<p>Architecture Design<br>Content architecture focuses on &#x3D;&#x3D;the manner in which content objects (or composite objects such as Web pages) are structured&#x3D;&#x3D; for presentation and navigation.<br>WebApp architecture addresses &#x3D;&#x3D;the manner in which the application is structured&#x3D;&#x3D; to manage user interaction, handle internal processing tasks, effect navigation, and presentcontent.<br>Architecture design is conducted in parallel with <code>interface design</code>, <code>aesthetic design</code> and <code>content design</code></p>\n<p>MVC（Model-View-Controller）架构，一种广泛应用于软件工程中的设计模式<br>MVC将应用程序分为三个主要部分：模型（Model）、视图（View）和控制器（Controller）</p>\n<ul>\n<li>model: all application specific content and processing logic</li>\n<li>view: The view contains all interface specific functions and enables</li>\n<li>controller: The controller manages access to the model and the view and coordinates the &#x3D;&#x3D;flow of data&#x3D;&#x3D; between them</li>\n</ul>\n<p>Navigation Design<br>Navigation Syntax</p>\n<ol>\n<li>Individual navigation link（独立导航链接）<br>指单个用于跳转的元素，如文字链接、图标、按钮或开关。</li>\n<li>Horizontal navigation bar（水平导航栏）<br>水平排列的主要内容或功能分类链接。<br>通常包含4到7个选项，适合展示网站的核心栏目。</li>\n<li>Vertical navigation column（垂直导航列）<br>垂直排列的导航结构，常用于侧边栏。<br>可以列出主要内容类别或几乎所有的内容对象。</li>\n<li>Tabs（标签页）<br>类似浏览器的多标签页设计，是导航栏或列的一种变体。<br>每个标签代表一个内容区域或功能模块，点击切换。</li>\n<li>Site maps（站点地图）<br>提供整个Web应用内容与功能的完整目录，帮助用户全面了解和访问所有页面。</li>\n</ol>\n<p>Component-Level Design</p>\n<h1 id=\"Ch18-MobileApp-Design\"><a href=\"#Ch18-MobileApp-Design\" class=\"headerlink\" title=\"Ch18 MobileApp Design\"></a>Ch18 MobileApp Design</h1><p>MobileApp Design需要注意：</p>\n<ul>\n<li>Multiple hardware and software platforms</li>\n<li>Many development frameworks and programming languages</li>\n<li>Many app stores</li>\n<li>Short development cycles</li>\n<li>User interface limitations</li>\n<li>Complex camera&#x2F;sensor interaction</li>\n<li>Effective use of context</li>\n<li>Power management</li>\n<li>Security and privacy models&#x2F;policies</li>\n<li>Device limitations (computation and storage)</li>\n<li>Integration of external services</li>\n<li>Texting complexities</li>\n</ul>\n<p>MobileApp Development Process Model：</p>\n<ul>\n<li>Formulation</li>\n<li>Planning</li>\n<li>Analysis</li>\n<li>Engineering</li>\n<li>Implementation and testing</li>\n<li>User evaluation</li>\n</ul>\n<p>MobileApp Quality Checklist 略</p>\n<p>MobileApp User Interface Design Considerations</p>\n<ul>\n<li>Define user interface brand signatures</li>\n<li>Focus the portfolio of products</li>\n<li>Identify core user stories</li>\n<li>Optimize UI flows and elements</li>\n<li>Define scaling rules 适应屏幕尺寸</li>\n<li>Create user performance dashboard 收集和分析用户行为数据</li>\n<li>Rely on dedicated champion with user interface engineering skills 在项目中设立一名专门负责用户界面设计和开发的角色</li>\n</ul>\n<p>MobileApp Design Mistakes</p>\n<ul>\n<li>Kitchen sink 功能堆砌</li>\n<li>Inconsistency</li>\n<li>Overdesigning 过度设计</li>\n<li>Lack of speed</li>\n<li>Verbiage 过多、过于正式或复杂的文字描述</li>\n<li>Non-standard interaction</li>\n<li>Help-and–FAQ-itis 应用本身不好用，于是靠大量的帮助提示、FAQ、引导流程来弥补</li>\n</ul>\n<p>MobileApp Design Best Practices</p>\n<ul>\n<li>Identify the audience 识别目标用户</li>\n<li>Design for context of use 根据使用场景来设计</li>\n<li>Recognize line between simplicity is not laziness 简化 ≠ 懒惰</li>\n<li>Use the platform to its advantage</li>\n<li>Allow for discoverability of advanced functionality 让高级功能易于被发现</li>\n<li>Use clear and consistent labels</li>\n<li>Cleaver icons should never be developed at the expense of user understanding</li>\n<li>Long scrolling forms trump multiple screens 长滚动表单优于多页面跳转</li>\n</ul>\n<p>Assessing Mobile Interactive Development Environments</p>\n<ul>\n<li>General productivity features 指开发工具是否提供提高效率的功能</li>\n<li>Third-party SDK integration 是否支持主流的第三方服务和库（SDK）</li>\n<li>Post-compilation tools</li>\n<li>Over the air development support</li>\n<li>End-to-end mobile application development</li>\n<li>Documentation and tutorials</li>\n<li>Graphical user interface builders</li>\n</ul>\n<p>MobileApp Middleware 介于操作系统、网络服务与应用程序之间的一层软件，用于简化复杂的分布式系统之间的通信和数据管理</p>\n<ul>\n<li>Facilitates communication and coordination of distributed components</li>\n<li>Allows developers to rely on abstractions and hide mobile environment details</li>\n<li>Helps MobileApps to achieve context awareness as required</li>\n</ul>\n<h1 id=\"Ch19-Quality-Concepts\"><a href=\"#Ch19-Quality-Concepts\" class=\"headerlink\" title=\"Ch19 Quality Concepts\"></a>Ch19 Quality Concepts</h1><h1 id=\"Ch20-Review-Techniques\"><a href=\"#Ch20-Review-Techniques\" class=\"headerlink\" title=\"Ch20 Review Techniques\"></a>Ch20 Review Techniques</h1><p>Reviews: 由技术人员为技术人员进行的会议，是对软件工程过程中产生的工作产品的技术评估，是软件质量保证机制之一，并作为培训场所<br>Errors(软件发布前发现的问题) and defects(软件发布后发现的问题)</p>\n<p>Defect Amplification Model 描述了开发步骤中的错误如何从前一步骤传递到下一步骤以及如何被检测出来<br>缺陷放大模型<br><img data-src=\"/20-1.jpg\"><br>$$<br>E_{review} &#x3D; E_p + E_a + E_r<br>$$</p>\n<p>$$<br>Err_{tot} &#x3D; Err_{minor} + Err_{major}<br>$$</p>\n<p>$$<br>Defect\\ density &#x3D; Err_{tot} &#x2F; WPS<br>$$</p>\n",
            "tags": [
                "软件工程"
            ]
        },
        {
            "id": "http://example.com/2025/06/18/computer-science/compile-principles/ch10/",
            "url": "http://example.com/2025/06/18/computer-science/compile-principles/ch10/",
            "title": "Liveness Analysis",
            "date_published": "2025-06-17T16:00:00.000Z",
            "content_html": "<h1 id=\"Liveness-Analysis-活跃变量分析\"><a href=\"#Liveness-Analysis-活跃变量分析\" class=\"headerlink\" title=\"Liveness Analysis 活跃变量分析\"></a>Liveness Analysis 活跃变量分析</h1><p>判断在程序执行的某个点上，一个变量的值是否可能在未来被使用，是寄存器分配、死代码消除的基础</p>\n<h2 id=\"Compiler-Optimizations\"><a href=\"#Compiler-Optimizations\" class=\"headerlink\" title=\"Compiler Optimizations\"></a>Compiler Optimizations</h2><ul>\n<li>Local: 基于basic blocks</li>\n<li>Intraprocedural (or “global’): 基本块的控制流转移</li>\n<li>Interprocedural (or “whole-program”): Operate on &gt; 1 procedure, up to whole program; Sometimes, at link time (LTO, link time optimization)</li>\n</ul>\n<p>两步：</p>\n<ul>\n<li>Analyze program to gather “facts”</li>\n<li>Apply transformation (e.g., optimizations)</li>\n</ul>\n<h2 id=\"Dataflow-Analysis\"><a href=\"#Dataflow-Analysis\" class=\"headerlink\" title=\"Dataflow Analysis\"></a>Dataflow Analysis</h2><p>Control Flow Graph: A directed graph 数据流图<br>– Nodes represent statements<br>– Edges represent control flow</p>\n<p>CFG的简化：基本块<br><img data-src=\"/f1.jpg\"></p>\n<h3 id=\"变量的活跃性：\"><a href=\"#变量的活跃性：\" class=\"headerlink\" title=\"变量的活跃性：\"></a>变量的活跃性：</h3><p>变量x在语句s处（执行s之前）处于活动状态，当且仅当满足以下三个条件：</p>\n<ol>\n<li>存在一个使用x的语句s’；</li>\n<li>存在从s到s’的路径；</li>\n<li>这条路径上没有对x进行任何赋值操作</li>\n</ol>\n<p>通过分析liveness，我们可以实现：</p>\n<ol>\n<li>Register Allocation</li>\n<li>Code Optimizations：Remove unused assignments</li>\n<li>IR Construction： Optimize the construction of SSA</li>\n<li>Security&#x2F;Reliability: Detect the use of uninitialized variables</li>\n</ol>\n<h2 id=\"Dataflow-Equations-for-Liveness-构建数据流方程\"><a href=\"#Dataflow-Equations-for-Liveness-构建数据流方程\" class=\"headerlink\" title=\"Dataflow Equations for Liveness 构建数据流方程\"></a>Dataflow Equations for Liveness 构建数据流方程</h2><p>A CFG node has</p>\n<ul>\n<li>out-edges: lead to successor nodes</li>\n<li>in-edges: come from predecessor nodes</li>\n<li>pred[n]: the predecessors of node n       前驱</li>\n<li>succ[n]: the successors of node n     后继</li>\n</ul>\n<p>几个定义：</p>\n<ul>\n<li>use[n]: 在节点n被读取或使用(x &#x3D; a + b的a和b, if(a &lt; b)的a和b, return c的c)</li>\n<li>def[n]: 在节点n被定义(x &#x3D; a + b的x)</li>\n<li>in[n]: 在节点n之前，所有活跃变量的集合</li>\n<li>out[n]: 在节点n之后，所有活跃变量的集合<br>三条活跃性规则：</li>\n</ul>\n<ol>\n<li>if $a \\in in[n]$ then for $\\all m \\in pred[n]$ we have $a \\in out[m]$</li>\n<li>if $a \\in use[n]$ then $a \\in in[n]$</li>\n<li>if $a \\in out[n]$ and $a \\notin def[n]$ then $a \\in in[n]$</li>\n</ol>\n<p>得到以下两个数据流方程：<br>$$<br>out[n] &#x3D; \\cup_{s \\in succ[n]} in[s]<br>$$<br> 一个节点在n的出口处活跃当且仅当在它后继的入口处是活跃的（活跃性的反向传播）<br>$$<br>in[n] &#x3D; use[n] \\cup (out[n] - def[n])<br>$$</p>\n<h2 id=\"求解数据流方程\"><a href=\"#求解数据流方程\" class=\"headerlink\" title=\"求解数据流方程\"></a>求解数据流方程</h2><p>有了上面的两个数据流方程，就可以求解数据流方程了<br>算法：</p>\n<figure class=\"highlight plaintext\"><figcaption><span>pseudo</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for each n</span><br><span class=\"line\">    in[n] ←&#123;&#125;; out[n] ←&#123;&#125;</span><br><span class=\"line\">repeat</span><br><span class=\"line\">    for each n</span><br><span class=\"line\">        in′[n] ← in[n]; out′[n] ← out[n]</span><br><span class=\"line\">        in[n] ← use[n] ∪ (out[n] − def[n])</span><br><span class=\"line\">        out[n] ← ⋃( ∈()**[+] in[s]</span><br><span class=\"line\">until in′[n] = in[n] and out′[n] = out[n] for all n</span><br></pre></td></tr></table></figure>\n<ol>\n<li>将所有节点的 <code>in</code> 和 <code>out</code> 集合初始化为空集。</li>\n<li>写出<code>use[n]</code>和<code>def[n]</code></li>\n<li>用数据流方程更新<code>in</code>和<code>out</code>集合</li>\n<li>直到<code>in</code>和<code>out</code>集合不再改变为止<br>例：<br><img data-src=\"/f2.jpg\"><br>对于这个CFG<br>每一次迭代如图：<br><img data-src=\"/f3.jpg\"></li>\n</ol>\n<h2 id=\"Improvements\"><a href=\"#Improvements\" class=\"headerlink\" title=\"Improvements\"></a>Improvements</h2><h3 id=\"Use-Basic-Block\"><a href=\"#Use-Basic-Block\" class=\"headerlink\" title=\"Use Basic Block\"></a>Use Basic Block</h3><p>后面有点懒得看，先放着</p>\n<h2 id=\"集合的表示方法\"><a href=\"#集合的表示方法\" class=\"headerlink\" title=\"集合的表示方法\"></a>集合的表示方法</h2><p>对于in, out, use, def集合的表示和操作对性能有很大影响</p>\n<h3 id=\"Bit-Arrays\"><a href=\"#Bit-Arrays\" class=\"headerlink\" title=\"Bit Arrays\"></a>Bit Arrays</h3><p>有点像bit map，适用于稠密集合（1比较多的，如果0太多就浪费了）</p>\n<h3 id=\"Sorted-Lists\"><a href=\"#Sorted-Lists\" class=\"headerlink\" title=\"Sorted Lists\"></a>Sorted Lists</h3><p>适合稀疏集合（用一个链表存集合中的变量, Sorted by variable name&#x2F;ID）</p>\n",
            "tags": [
                "Liveness Analysis"
            ]
        },
        {
            "id": "http://example.com/2025/06/18/computer-science/compile-principles/ch11/",
            "url": "http://example.com/2025/06/18/computer-science/compile-principles/ch11/",
            "title": "Register Allocation",
            "date_published": "2025-06-17T16:00:00.000Z",
            "content_html": "<h1 id=\"Register-Allocation\"><a href=\"#Register-Allocation\" class=\"headerlink\" title=\"Register Allocation\"></a>Register Allocation</h1><p>目标：</p>\n<ul>\n<li>Map temporaries to registers</li>\n<li>Preserve program semantics</li>\n<li>Optimize performance</li>\n</ul>\n<h2 id=\"图着色算法\"><a href=\"#图着色算法\" class=\"headerlink\" title=\"图着色算法\"></a>图着色算法</h2><p>冲突图是一个无向图，冲突图中，每个节点是一个变量（寄存器分配的候选对象）。<br>如果两个变量在同一时刻是活跃的（live），它们就有冲突边（interference edge），表示它们不能被分配到同一个寄存器<br>冲突信息可以用矩阵或者图来表示</p>\n<h3 id=\"冲突图构建\"><a href=\"#冲突图构建\" class=\"headerlink\" title=\"冲突图构建\"></a>冲突图构建</h3><p>我们从一个中间代码的指令出发，根据live-out（就是out集合）添加冲突边：</p>\n<ol>\n<li>非 move 指令（不是a :&#x3D; b这种）<br>比如a :&#x3D; b1 + b2<br>对于每个bn和a之间都添加冲突边<br>比如下面这个例子：<br><img data-src=\"/f1.jpg\"><br>可以看到有ab ac同时live了，所以为a和b，a和c添加冲突边</li>\n<li>move指令<br>对于move指令，不添加冲突边：<br>比如对于第 2 条指令 d ← a，out[2] &#x3D; {a, e}，那么只对d和e添加冲突边，对d和a不添加<br>但如果move之后又对d重新赋值了，那么还是要添加上d和a之间的冲突边</li>\n</ol>\n<h3 id=\"冲突图着色\"><a href=\"#冲突图着色\" class=\"headerlink\" title=\"冲突图着色\"></a>冲突图着色</h3><p>Vertex Coloring: 给图中的顶点着色，使得图中没有边连接相同颜色的顶点<br>K-Coloring: 颜色数小于K</p>\n<h4 id=\"Kempe-简化\"><a href=\"#Kempe-简化\" class=\"headerlink\" title=\"Kempe 简化\"></a>Kempe 简化</h4><p>如果图中有一个节点 n 的度数 &lt; K（也就是它的冲突数少于寄存器数），那我们可以“临时删掉”这个节点，并递归给剩下的图上色。之后再把这个节点加回来，它一定可以找到一个合法颜色。</p>\n<p>如果图中所有节点的度数都 ≥ K，那就可能要进入溢出（spill）处理<br>算法步骤：</p>\n<ol>\n<li>build: 画冲突图</li>\n<li>simplify the nodes with insignificant degree: 选取degree &lt; k的节点，压栈</li>\n<li>select (or color) while rebuilding the graph: 出栈，分配颜色<br>A vertex such that its degree &lt; k is always k-colorable<br>Remove such vertices and push them to a stack until the graph becomes empty<br>移除顶点的同时移除相关边</li>\n</ol>\n<h4 id=\"Coalescing\"><a href=\"#Coalescing\" class=\"headerlink\" title=\"Coalescing\"></a>Coalescing</h4><p>遵循两种策略：</p>\n<ul>\n<li><strong>Briggs Criteria</strong>: 如果将节点 <code>a</code> 和 <code>b</code> 合并后得到的新节点 <code>ab</code>，其相邻节点中degree &gt;&#x3D; K 的节点（significant-degree neighbors）的数量 小于 K，则可以合并</li>\n<li><strong>George Criteria</strong>: 如果对节点 <code>a</code> 和 <code>b</code>，对于 <code>a</code> 的每一个邻居 <code>t</code>， 满足二者其中之一，就能合并：<ul>\n<li><code>t</code> 本来就和 <code>b</code> 有冲突</li>\n<li><code>t</code>的degree &lt; K</li>\n</ul>\n</li>\n</ul>\n<p>整体流程：<br><img data-src=\"/f2.jpg\"></p>\n<ul>\n<li>为什么要simplify non-move-related node: 保留move-related的后续可以合并</li>\n<li>freeze: 当我们遇到两个变量 a ← b 有 move 指令，但现在还不能安全合并，我们又不想立刻 spill，于是我们“冻结”这条 move 指令：不再试图合并 a 和 b，而是让其中一个变成非 move 相关（non-move-related），进入 Simplify 阶段继续处理</li>\n<li>spill规则：优先移除不被经常使用、degree大的节点<ul>\n<li>实际溢出的priority计算，对于节点a：<br>$$<br>priority(t) &#x3D; \\frac{(use + def outside loop) + loop_num * (use + def inside loop)}{D}<br>$$</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "Register Allocation"
            ]
        },
        {
            "id": "http://example.com/2025/06/17/computer-science/compile-principles/ch8/",
            "url": "http://example.com/2025/06/17/computer-science/compile-principles/ch8/",
            "title": "Basic Blocks & Traces",
            "date_published": "2025-06-16T16:00:00.000Z",
            "content_html": "<h1 id=\"Basic-Blocks-and-Traces\"><a href=\"#Basic-Blocks-and-Traces\" class=\"headerlink\" title=\"Basic Blocks and Traces\"></a>Basic Blocks and Traces</h1><h2 id=\"Canonical-Form\"><a href=\"#Canonical-Form\" class=\"headerlink\" title=\"Canonical Form\"></a>Canonical Form</h2><p>IR存在一些与机器语言不能完全对应的情况，和与编译优化分析相冲突的情况。</p>\n<ul>\n<li>CJUMP能够转移到t或者f，但是真正的机器语言在条件为假的时候直接下降至下一条指令（条件为真才跳转）</li>\n<li>在表达式中使用ESEQ不太方便，会使子树不同的计算顺序产生不同的计算结果</li>\n<li>CALL调用CALL作为参数的时候会有寄存器冲突、语句副作用（修改全局变量、改变堆内存, etc.）等问题</li>\n</ul>\n<p>三种方法：</p>\n<ol>\n<li>Linearize: Transform trees into a list of canonical<br>trees without SEQ or ESEQ nodes</li>\n<li>Basic blocks: Group statements into sequences with<br>no internal jumps&#x2F;labels</li>\n<li>Trace schedule: Order basic blocks so every CJUMP is followed by its false label</li>\n</ol>\n<h3 id=\"线性化\"><a href=\"#线性化\" class=\"headerlink\" title=\"线性化\"></a>线性化</h3><p>&#x3D;&#x3D;规范树（Canonical Tree）定义：&#x3D;&#x3D;</p>\n<ol>\n<li>无SEQ或ESEQ</li>\n<li>每一个CALL的父亲不是EXP(…)就是MOVE(TEMP t, …)</li>\n</ol>\n<h4 id=\"消除ESEQ\"><a href=\"#消除ESEQ\" class=\"headerlink\" title=\"消除ESEQ\"></a>消除ESEQ</h4><h5 id=\"规则\"><a href=\"#规则\" class=\"headerlink\" title=\"规则\"></a>规则</h5><p>合并副作用，提升ESEQ：</p>\n<ul>\n<li>ESEQ(s1, ESEQ(s2,e)) &#x3D;&gt; ESEQ(SEQ(s1,s2),e)</li>\n<li>BINOP(op, ESEQ(s, e1), e2) ⇒ ESEQ(s, BINOP(op, e1, e2))</li>\n<li>MEM(ESEQ(s, e1)) ⇒ ESEQ(s, MEM(e1))</li>\n<li>JUMP(ESEQ(s, e1)) ⇒ SEQ(s, JUMP(e1))</li>\n<li>CJUMP(op, ESEQ(s, e1), e2, l1, l2) ⇒ SEQ(s, CJUMP(op, e1, e2, l1, l2))</li>\n</ul>\n<h5 id=\"Commutativity（重点）\"><a href=\"#Commutativity（重点）\" class=\"headerlink\" title=\"Commutativity（重点）\"></a>Commutativity（重点）</h5><p>当<code>ESEQ</code>出现在<code>BINOP</code>的右操作数，即$BINOP(op, e1, ESEQ(s, e2))$时，我们不能再像之前那样简单地把<code>s</code>提升到整个<code>BINOP</code>之前，因为<code>e1</code>的求值在<code>e2</code>之前，否则可能影响<code>e1</code>的计算结果</p>\n<p>Commutativity：交换性</p>\n<ul>\n<li>Commuting: s不影响e1的结果<ul>\n<li>rule: $BINOP(op, e1, ESEQ(s, e2)) &#x3D; ESEQ(s, BINOP(op, e1, e2))$</li>\n</ul>\n</li>\n<li>Non-commuting: s会影响e1的结果，把e1的结果显算出来放到临时变量t里，再提升s<ul>\n<li>rule: $BINOP(op, ESEQ(s, e1), e2) &#x3D; ESEQ(MOVE(TEMP t, e1), ESEQ(s, BINOP(op, TEMP t, e2)))$</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"将CALL移到顶层\"><a href=\"#将CALL移到顶层\" class=\"headerlink\" title=\"将CALL移到顶层\"></a>将CALL移到顶层</h4><p>方法：立即将每一个返回值赋给一个新的临时寄存器<br>$$<br>CALL(fun, args) ⇒ ESEQ(MOVE(TEMP t, CALL(fun, args)), TEMP t)<br>$$</p>\n<h4 id=\"消除SEQ\"><a href=\"#消除SEQ\" class=\"headerlink\" title=\"消除SEQ\"></a>消除SEQ</h4><p>$$<br>SEQ(SEQ(a, b), c) &#x3D; SEQ(a, SEQ(b, c))<br>$$<br>把SEQ变成一个线性语句表：$SEQ(s_1, SEQ(s_2, …, SEQ(s_{n-1}, s_n) …))$<br>就可以认为是由语句组成的简单列表$s_1, s_2, …, s_n$</p>\n<h3 id=\"处理CJUMP\"><a href=\"#处理CJUMP\" class=\"headerlink\" title=\"处理CJUMP\"></a>处理CJUMP</h3><p>重排CJUMP，使得每个$CJUMP(op, e_1, e_2, l_t, l_f)后面都紧跟着$LABEL(l_f)$<br>分两步：1. 取一列canonical tree由它们形成basic block 2. 对basic block进行排序形成trace</p>\n<h4 id=\"Basic-Block\"><a href=\"#Basic-Block\" class=\"headerlink\" title=\"Basic Block\"></a>Basic Block</h4><p>一个基本块是一段连续的指令序列，即:</p>\n<ul>\n<li>第一个语句是一个<code>LABEL</code></li>\n<li>最后一个语句是<code>JUMP</code>或<code>CJUMP</code></li>\n<li>没有其他的<code>LABEL</code>, <code>JUMP</code>或<code>CJUMP</code><br>划分方法：</li>\n</ul>\n<ol>\n<li>每一个<code>LABEL</code>都对应一个基本块的开始</li>\n<li>每一个<code>JUMP</code>或<code>CJUMP</code>都对应一个基本块的结束</li>\n<li>如果遇到<code>LABEL1</code> -&gt; <code>LABEL2</code>,就在<code>LABEL2</code>前面加一个<code>JUMP</code>到<code>LABEL2</code></li>\n<li>如果遇到开头没有<code>LABEL</code>的，则加一个<code>LABEL</code>（比如程序的开头）</li>\n<li>出口处理：添加一个LABEL <code>done</code>表示出口处理的开始，并把$JUMP done$放最后一个block末尾</li>\n</ol>\n<h4 id=\"Trace\"><a href=\"#Trace\" class=\"headerlink\" title=\"Trace\"></a>Trace</h4><p>现在我们可以按任意顺序来安排这些基本块，并且程序执行的结果仍是相同的——因为无论怎么排序，每个基本块的末尾都能转移到一个正确的位置。我们可以利用这一点来选择适当的基本块排列顺序，以满足每个<code>CJUMP</code>之后都跟随它的false标号这一条件。<br>与此同时，我们也可以安排基本块使得无条件转移<code>JUMP</code>之后直接跟随的是它们的目标标号。这样便可以删除这些无条件转移，从而使编译生成的程序的执行速度更快。</p>\n<p>把basic block排成trace的方法也很简单：&#x3D;&#x3D;从每个基本块开始，追踪JUMP链，标记遇到的每一个未标记的基本快并添加到当前trace中，最终到达一个其后继都标记过的块，就是结束块。之后再选则一个未标记的基本块开始，重复上述过程。&#x3D;&#x3D;</p>\n<p>因为轨迹调度不可能覆盖所有情况，所以：</p>\n<ol>\n<li>如果CJUMP 后跟 true label: 条件取反，交换 true&#x2F;false，改成：<br>$$<br>CJUMP(!cond, lf, lt)<br>$$</li>\n<li>CJUMP 后跟的不是 true 也不是 false: 创建中间 label，插入 JUMP<br>$$<br>CJUMP(cond, lt, lf) &#x3D;&gt; CJUMP(cond, lt, l’f) LABEL l’f   JUMP NAME(lf)<br>$$</li>\n</ol>\n<h4 id=\"最优轨迹-Optimal-Trace\"><a href=\"#最优轨迹-Optimal-Trace\" class=\"headerlink\" title=\"最优轨迹(Optimal Trace)\"></a>最优轨迹(Optimal Trace)</h4><p>对于basic block可能有不同的trace划分方法</p>\n<ul>\n<li>Hot Path Prioritization（优先热路径）: 优先将**运行频率高的基本块（hot blocks）**合并在同一条轨迹（trace）里，减少跳转，提高局部性。<br>+++info example<br>假设 if-else 中 if 分支占 90% 执行概率，else 只有 10%：</li>\n</ul>\n<figure class=\"highlight c\"><figcaption><span>tiger</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> x &gt; <span class=\"number\">0</span> then</span><br><span class=\"line\">    a := a + <span class=\"number\">1</span>   -- 热路径</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    a := a - <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>生成时应把 x &gt; 0 为真的路径（包括 CJUMP 的 false 分支）安排成 fall-through，避免跳转开销出现在热路径上。<br>+++</p>\n<ul>\n<li>Locality Enhancement（增强局部性）: 把逻辑上相关联的代码块放得更近一些，让它们在内存中“邻近”。<ul>\n<li>原因：<ul>\n<li>更好地利用 CPU cache、预取机制。</li>\n<li>避免指令 cache miss 导致性能下降。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>比如：将循环体和循环条件代码块排在一起（而不是让条件跳到远处），从而保持指令流顺序性。</p>\n<ul>\n<li>Jump Minimization（最小化跳转）: 尽量减少无条件跳转（JUMP）和不必要的条件跳转（CJUMP），尤其在常走路径上，\t减少分支预测失败。</li>\n</ul>\n<p><img data-src=\"/f1.jpg\"><br>哪个划分比较好？<br>根据3，c比a好；</p>\n",
            "tags": [
                "Basic Blocks and Traces"
            ]
        },
        {
            "id": "http://example.com/2025/06/17/computer-science/compile-principles/ch9/",
            "url": "http://example.com/2025/06/17/computer-science/compile-principles/ch9/",
            "title": "指令选择",
            "date_published": "2025-06-16T16:00:00.000Z",
            "content_html": "<h1 id=\"指令选择\"><a href=\"#指令选择\" class=\"headerlink\" title=\"指令选择\"></a>指令选择</h1><p>找出实现一个给定的IR Tree的恰当机器指令序列。Mapping IR into abstract assembly code</p>\n<ul>\n<li>Abstract assembly &#x3D; assembly with infinite registers<ul>\n<li>Invent new temporaries for intermediate results</li>\n<li>Map to actual registers later<br>Tree pattern, 也叫tile<br>本质上是pattern matching, 我们使用tree covering 来实现</li>\n</ul>\n</li>\n</ul>\n<p>我们<code>Jouette</code>体系将树模式映射为指令:</p>\n<ul>\n<li>寄存器中可以存储数据或地址，每条指令可以访问任意寄存器</li>\n<li>寄存器r0的值永远是0</li>\n<li>每条指令的latency都是一周期（除了MOVEM的周期是m）</li>\n<li>每个周期执行一条指令</li>\n</ul>\n<p><img data-src=\"/f2.jpg\"><br><img data-src=\"/f1.jpg\"><br>将IR与后端的机器指令都转换为树结构。这样就把指令选择问题转换为机器指令树覆盖全IR Tree的问题。<br>一棵树可以有多种tiling方式</p>\n<h2 id=\"Optimal-Tiling-Optimum-Tiling\"><a href=\"#Optimal-Tiling-Optimum-Tiling\" class=\"headerlink\" title=\"Optimal Tiling &amp; Optimum Tiling\"></a>Optimal Tiling &amp; Optimum Tiling</h2><ul>\n<li>Optimum Tiling：使得tiling数最少，是&#x3D;&#x3D;全局最优&#x3D;&#x3D;</li>\n<li>Optimal Tiling：No two adjacent tiles can be combined into a single tile of lower cost，是&#x3D;&#x3D;局部最优&#x3D;&#x3D;<br>一个optimum tiling必定是optimal tiling<br><img data-src=\"/f3.jpg\"></li>\n</ul>\n<h2 id=\"Algorithms-for-Instruction-Selection\"><a href=\"#Algorithms-for-Instruction-Selection\" class=\"headerlink\" title=\"Algorithms for Instruction Selection\"></a>Algorithms for Instruction Selection</h2><h3 id=\"Maximal-Munch-Find-an-optimal-tiling\"><a href=\"#Maximal-Munch-Find-an-optimal-tiling\" class=\"headerlink\" title=\"Maximal Munch: Find an optimal tiling\"></a>Maximal Munch: Find an optimal tiling</h3><p>最大匹配：贪心算法、自顶向下<br>方法：从IR树的根节点开始，用&#x3D;&#x3D;最大的&#x3D;&#x3D;tile覆盖当前节点（包含最多节点的），然后在子树中重复此过程</p>\n<h3 id=\"DP\"><a href=\"#DP\" class=\"headerlink\" title=\"DP\"></a>DP</h3><p>动态规划：自底向上<br>方法：</p>\n<ol>\n<li>递归计算每个子树的最优平铺成本</li>\n<li>对于每个节点，考虑所有可能的匹配平铺</li>\n<li>对于每个匹配平铺，计算其成本如下：cost &#x3D; tile_cost + sum（costs_of_children）</li>\n<li>选择成本最低的平铺</li>\n</ol>\n<ul>\n<li>对于$CONST i$，它的代价为1( ADD r1, r0, i)</li>\n<li>对于这棵树，有三种匹配方法<br><img data-src=\"/f4.jpg\"><br><img data-src=\"/f5.jpg\"><br>因为2&lt;3，所以我们从cost&#x3D;2的两个任选一个<br>接下来对于MEM，用的都是LOAD，代价都是1，2&lt;3所以选cost&#x3D;2的</li>\n</ul>\n<figure class=\"highlight c\"><figcaption><span>指令发射</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function <span class=\"title function_\">Emission</span><span class=\"params\">(node n)</span>:</span><br><span class=\"line\">    For each leaf l_i of the tile selected at node n:</span><br><span class=\"line\">        <span class=\"title function_\">Emission</span><span class=\"params\">(l_i)</span> </span><br><span class=\"line\">    Emit the instruction matched at node n</span><br></pre></td></tr></table></figure>\n<h3 id=\"最大匹配-vs-动态规划\"><a href=\"#最大匹配-vs-动态规划\" class=\"headerlink\" title=\"最大匹配 vs 动态规划\"></a>最大匹配 vs 动态规划</h3><ul>\n<li><strong>T</strong> - tile的总种类数  </li>\n<li><strong>K</strong> - 一个matching tile平均覆盖的节点数  </li>\n<li><strong>K’</strong> - 需要检查的最大tile尺寸（即最大的瓦片包含的节点数）  </li>\n<li><strong>T’</strong> - 每个树节点平均能匹配上的tile数量  </li>\n<li><strong>N</strong> - 输入的中间表示IR Tree中的总节点数</li>\n</ul>\n<p>两种算法的运行时间复杂度：</p>\n<ul>\n<li><p><strong>最大匹配（Maximal Munch）</strong> - 其时间复杂度与<br>$$<br>\\frac{(K’ + T’) * K}{K} * N &#x3D; (K’ + T’) * N<br>$$<br>成正比</p>\n</li>\n<li><p><strong>动态规划（Dynamic Programming）</strong> - 其时间复杂度与<br>$$<br>(K’ + T’) * N<br>$$<br>成正比</p>\n</li>\n</ul>\n<h2 id=\"Tree-Grammar-树文法\"><a href=\"#Tree-Grammar-树文法\" class=\"headerlink\" title=\"Tree Grammar 树文法\"></a>Tree Grammar 树文法</h2><p>问题：对于具有复杂指令集和多种寄存器类型及寻址模式的机器，难以使用简单的tree pattern和tiling算法。<br>用一种文法来描述tiles，代替手写过程式匹配代码，支持自动化的指令选择，增强了可移植性<br>图没看懂，后面再回来研究</p>\n",
            "tags": [
                "指令选择"
            ]
        },
        {
            "id": "http://example.com/2025/06/16/AI/week10-11/",
            "url": "http://example.com/2025/06/16/AI/week10-11/",
            "title": "Week10-11",
            "date_published": "2025-06-15T16:00:00.000Z",
            "content_html": "<h1 id=\"深度学习\"><a href=\"#深度学习\" class=\"headerlink\" title=\"深度学习\"></a>深度学习</h1><h2 id=\"前馈神经网络\"><a href=\"#前馈神经网络\" class=\"headerlink\" title=\"前馈神经网络\"></a>前馈神经网络</h2><ul>\n<li>神经元</li>\n<li>感知机（多一个激活函数）</li>\n<li>激活函数: .RelU, Sigmoid, Softmax, tanh..</li>\n<li>损失函数: MSE, Cross Entropy…s</li>\n<li>参数优化: BP, 梯度下降<br>具体懒得写了，都说烂了<br>记一下这几个激活函数的形状和应用: tanh和sigmoid大多用于二分类，RelU一般用在隐藏层，Softmax用在多分类而且概率和为1</li>\n</ul>\n<h2 id=\"CNN\"><a href=\"#CNN\" class=\"headerlink\" title=\"CNN\"></a>CNN</h2><ul>\n<li><p>了解卷积操作和操作之后的结果</p>\n</li>\n<li><p>池化操作（最大池化、平均池化）<br>卷积层负责提取图像中的局部特征；<br>池化层用来大幅降低参数量级(降维)；<br>激活函数负责非线性化；<br>全连接层类似传统神经网络的部分，用来输出想要的结果</p>\n</li>\n<li><p>神经网络正则化：为了缓解神经网络在训练过程中出现的过拟合问题，需要采取一些正则化技术来提升神经网络的泛化能力(generalization)</p>\n<ul>\n<li>Dropout：在训练神经网络过程中，每次参数更新时随机丢掉一部分神经元来减少神经网络复杂度，防止过拟合<br> <img data-src=\"/f1.jpg\"></li>\n<li>Batch-Normalization（批归一化）:通过规范化的手段，把神经网络每层中任意神经元的输入值分布改变到均值为0、方差为1的标准正态分布。防止梯度消失，收敛更快</li>\n<li>L1-Norm &amp; L2-Norm</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"循环神经网络（RNN）\"><a href=\"#循环神经网络（RNN）\" class=\"headerlink\" title=\"循环神经网络（RNN）\"></a>循环神经网络（RNN）</h2><p>RNN对具有序列特性的数据非常有效，它能挖掘数据中的时序信息以及语义信息</p>\n<p>为了解决&#x3D;&#x3D;梯度消失问题&#x3D;&#x3D;，长短时记忆模型（Long Short-Term Memory，LSTM）被提出<br>LSTM：<br>与简单的循环神经网络结构不同，长短时记忆网络（Long Short-Term Memory，LSTM）中引入了&#x3D;&#x3D;内部记忆单元&#x3D;&#x3D;（internal memory cell）和&#x3D;&#x3D;门&#x3D;&#x3D;（gates）两种结构来对当前时刻输入信息以及前序时刻所生成信息进行整合和传递。</p>\n<ul>\n<li>输入门(input gate)、遗忘门(forget gate)和输出门(output gate)三种gate</li>\n</ul>\n<p>门控循环单元（GRU）是一种对LSTM简化的深度学习模型。与长短时记忆网络相比，GRU不再使用记忆单元来传递信息，仅使用隐藏状态来进行信息的传递。相比于长短时记忆网络来说，GRU有更高的计算速度。</p>\n<h3 id=\"注意力机制\"><a href=\"#注意力机制\" class=\"headerlink\" title=\"注意力机制\"></a>注意力机制</h3><p>注意力机制对不同信息的关注程度（重要程度）由权值来体现，注意力机制可以视为&#x3D;&#x3D;查询矩阵(Query)&#x3D;&#x3D;&#x3D;&#x3D;、键(key)&#x3D;&#x3D;以及&#x3D;&#x3D;加权平均值&#x3D;&#x3D;构成了多层感知机(Multilayer Perceptron, MLP)</p>\n<h2 id=\"深度生成学习（deep-generative-learning-model）\"><a href=\"#深度生成学习（deep-generative-learning-model）\" class=\"headerlink\" title=\"深度生成学习（deep generative learning model）\"></a>深度生成学习（deep generative learning model）</h2><p>判别模型vs生成模型<br>变分自编码器 (variational auto-encoder, VAE) 、 自回归模型 (Autoregressivemodels)与生成对抗网络（generative adversarial network，GAN）等</p>\n",
            "tags": [
                "人工智能"
            ]
        },
        {
            "id": "http://example.com/2025/06/16/AI/week12-13/",
            "url": "http://example.com/2025/06/16/AI/week12-13/",
            "title": "Week12-13",
            "date_published": "2025-06-15T16:00:00.000Z",
            "content_html": "<h1 id=\"强化学习\"><a href=\"#强化学习\" class=\"headerlink\" title=\"强化学习\"></a>强化学习</h1><p>根据环境所提供的奖罚反馈来学习所处状态可施加的最佳行动，在“探索（未知空间）-利用（已有经验）（exploration vs. exploitation）”之间寻找平衡，完成某个序列化任务，具备自我学习能力</p>\n<ul>\n<li>智能体（agent）：智能体是强化学习算法的主体，它能够根据经验做出主观判断并执行动作，是整个智能系统的核心。</li>\n<li>环境（environment）：智能体以外的一切统称为环境，环境在与智能体的交互中，能被智能体所采取的动作影响，同时环境也能向智能体反馈状态和奖励。虽说智能体以外的一切都可视为环境，但在设计算法时常常会排除不相关的因素建立一个理想的环境模型来对算法功能进行模拟。</li>\n<li>状态（state）：状态可以理解为智能体对环境的一种理解和编码，通常包含了对智能体所采取决策产生影响的信息。</li>\n<li>动作（action）：动作是智能体对环境产生影响的方式，这里说的动作常常指概念上的动作，如果是在设计机器人时还需考虑动作的执行机构。</li>\n<li>策略（policy）：策略是智能体在所处状态下去执行某个动作的依据，即给定一个状态，智能体可根据一个策略来选择应该采取的动作。</li>\n<li>奖励（reward）：奖励是智能体序贯式采取一系列动作后从环境获得的收益。注意奖励概念是现实中奖励和惩罚的统合，一般用正值来代表实际奖励，用负值来代表实际惩罚。<br><img data-src=\"/f1.jpg\"></li>\n</ul>\n<p>强化学习的特点</p>\n<ul>\n<li>&#x3D;&#x3D;基于评估&#x3D;&#x3D;：强化学习利用环境评估当前策略，以此为依据进行优化</li>\n<li>&#x3D;&#x3D;交互性&#x3D;&#x3D;：强化学习的数据在与环境的交互中产生</li>\n<li>&#x3D;&#x3D;序列决策过程&#x3D;&#x3D;：智能主体在与环境的交互中需要作出一系列的决策，这些决策往往是前后关联的</li>\n</ul>\n<h2 id=\"离散马尔可夫过程（Discrete-Markov-Process）\"><a href=\"#离散马尔可夫过程（Discrete-Markov-Process）\" class=\"headerlink\" title=\"离散马尔可夫过程（Discrete Markov Process）\"></a>离散马尔可夫过程（Discrete Markov Process）</h2><p>满足马尔可夫性的离散随机过程<br>用数学归纳法，推出t+1时刻状态仅与t时刻状态有关（一阶马尔可夫链）<br>强化学习是一种机器学习方法，通过与环境的交互来学习最优策略。下面我将通过具体的例子来解释这些公式和概念。</p>\n<h3 id=\"马尔可夫奖励过程\"><a href=\"#马尔可夫奖励过程\" class=\"headerlink\" title=\"马尔可夫奖励过程\"></a>马尔可夫奖励过程</h3><p>$$<br>G_t &#x3D; R_{t+1} + \\gamma R_{t+2} + \\gamma^2 R_{t+3} + \\ldots<br>$$<br>这个公式表示从时间步 t开始的累积回报 $G_t$，其中 $R_{t+i}$ 是在时间步 $t+i$ 获得的即时奖励，$\\gamma$ 是折扣因子（范围在 [0, 1] 之间），用于减少未来奖励对当前决策的影响。</p>\n<p>例: 假在一个迷宫中寻找宝藏，每走一步都有可能获得或失去一些分数（奖励）。如果你在第 1 步获得 10 分，在第 2 步获得 5 分，在第 3 步获得 2 分，且折扣因子 $\\gamma &#x3D; 0.9$，那么从第 0 步开始的累积回报 $G_0$ 就是：<br>$$<br>G_0 &#x3D; 10 + 0.9 \\times 5 + 0.9^2 \\times 2 &#x3D; 10 + 4.5 + 1.62 &#x3D; 16.12<br>$$</p>\n<p>强化学习的求解方法：</p>\n<ul>\n<li>基于价值（1.策略优化 2.策略评估）</li>\n<li>基于策略</li>\n<li>基于模型</li>\n</ul>\n<h3 id=\"策略学习\"><a href=\"#策略学习\" class=\"headerlink\" title=\"策略学习\"></a>策略学习</h3><p>价值函数 (value function):<br>$$<br>V_\\pi(s) &#x3D; E_\\pi[G_t | S_t &#x3D; s]<br>$$</p>\n<p>在状态 s 下，按照策略 $\\pi$ 行动后在未来所获得的回报的期望值。</p>\n<p>动作-价值函数 (action-value function):<br>$$<br>q_\\pi(s, a) &#x3D; E_\\pi[G_t | S_t &#x3D; s, A_t &#x3D; a]<br>$$</p>\n<p>在状态 s 下采取动作 a，按照策略 $\\pi 行动后在未来获得的回报值。</p>\n<p>例: 继续迷宫的例子，假设在某个位置（状态 s有两个选择：向左走（动作 $a_1$ 或向右走（动作 $a_2$）。根据历史数据，向左走的平均回报是 8 分，向右走的平均回报是 12 分。那么在这个状态下，动作-价值函数 $q_\\pi(s, a_1) &#x3D; 8$，$q_\\pi(s, a_2) &#x3D; 12$。</p>\n<h3 id=\"贝尔曼方程\"><a href=\"#贝尔曼方程\" class=\"headerlink\" title=\"贝尔曼方程\"></a>贝尔曼方程</h3><p>价值函数的贝尔曼方程:<br>$$<br>V_\\pi(s) &#x3D; \\sum_a \\pi(s, a) q_\\pi(s, a)<br>$$<br>在状态 s 下，采取各个动作的概率加权平均的动作-价值函数。</p>\n<p>动作-价值函数的贝尔曼方程:<br>$$<br>q_\\pi(s, a) &#x3D; \\sum_{s’} P(s’ | s, a) [R(s, a, s’) + \\gamma V_\\pi(s’)]<br>$$<br>在状态s采取动作a的概率*（采取a进入s’得到的回报+处于s’可以得到的回报）。</p>\n<h3 id=\"策略评估算法步骤\"><a href=\"#策略评估算法步骤\" class=\"headerlink\" title=\"策略评估算法步骤\"></a>策略评估算法步骤</h3><h4 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h4><ol>\n<li>初始化 $V_\\pi$ 函数：首先需要对所有状态 s 的价值函数 $V_\\pi(s)$ 进行初始化，通常可以设置为0或者任意合理的初始值。</li>\n<li>循环迭代：<ul>\n<li>对于每一个状态 $s \\in S$，根据当前的策略 $\\pi$ 和已知的状态转移概率 $Pr(s’|s, a)$，以及即时奖励 $R(s, a, s’)$，更新该状态的价值函数 $V_\\pi(s)$。</li>\n<li>更新公式如下：<br>$$<br>V_\\pi(s) \\leftarrow \\sum_{a \\in A} \\pi(a|s) \\sum_{s’ \\in S} Pr(s’|s, a) [R(s, a, s’) + \\gamma V_\\pi(s’)]<br>$$</li>\n</ul>\n</li>\n<li>直到收敛：重复上述迭代过程，直到价值函数 $V_\\pi(s)$ 在所有状态上都几乎不再发生变化，即达到收敛状态。这表明我们已经找到了在当前策略 $\\pi$ 下各个状态的稳定价值。<br>&#x3D;&#x3D;当前状态的价值是由后续状态的价值通过贝尔曼方程传播回来的&#x3D;&#x3D;</li>\n</ol>\n<p>策略评估：动态规划、蒙特卡洛采样、时序差分</p>\n<h4 id=\"蒙特卡洛采样\"><a href=\"#蒙特卡洛采样\" class=\"headerlink\" title=\"蒙特卡洛采样\"></a>蒙特卡洛采样</h4><p>通过随机采样来估计期望值</p>\n<ol>\n<li>选择起始状态：从状态空间 S 中选择不同的起始状态。</li>\n<li>按照当前策略采样轨迹：从每个起始状态出发，按照当前策略 $\\pi$ 生成若干条完整的轨迹（episode）。这些轨迹构成了集合 D。</li>\n<li>计算反馈：对于每条轨迹中的每个状态 s，记录该状态出现时对应的回报 $G_i$ 。</li>\n<li>平均回报：对所有轨迹中状态 s 出现时的回报进行平均，得到该状态的价值 $V_\\pi(s)$。<br>假设我们有 k 条轨迹，每条轨迹中状态 s 出现时对应的回报分别为$G_1, G_2, \\ldots, G_k$，那么该状态的价值 $V_\\pi(s)$ 可以通过以下公式计算：<br>$$<br>V_\\pi(s) &#x3D; \\frac{1}{k} \\sum_{i&#x3D;1}^k G_i<br>$$</li>\n</ol>\n<h4 id=\"时序差分-TD\"><a href=\"#时序差分-TD\" class=\"headerlink\" title=\"时序差分(TD)\"></a>时序差分(TD)</h4><p>时序差分算法通过在每个时间步 t 上更新状态价值函数 $V_\\pi(s_t)$，而不是在每个状态 $s_t$ 上进行批量更新。<br>$$<br>V_\\pi(s) \\leftarrow V_\\pi(s) + \\alpha [R(s, a, s’) + \\gamma V_\\pi(s’) - V_\\pi(s)]<br>$$<br>其中：</p>\n<ul>\n<li>$\\alpha$ 是学习率，通常取较小的值，如0.1。</li>\n<li>$R(s, a, s’)$ 是即时奖励</li>\n<li>$V_\\pi(s’)$ 是状态 $s’$ 的价值函数</li>\n<li>$\\gamma$ 是折扣因子，通常取较小的值，如0.9。</li>\n</ul>\n<h4 id=\"Q-learning\"><a href=\"#Q-learning\" class=\"headerlink\" title=\"Q-learning\"></a>Q-learning</h4><h4 id=\"DQN\"><a href=\"#DQN\" class=\"headerlink\" title=\"DQN\"></a>DQN</h4>",
            "tags": [
                "人工智能"
            ]
        },
        {
            "id": "http://example.com/2025/06/16/AI/week14-15/",
            "url": "http://example.com/2025/06/16/AI/week14-15/",
            "title": "Week14-15",
            "date_published": "2025-06-15T16:00:00.000Z",
            "content_html": "<h1 id=\"人工智能博弈\"><a href=\"#人工智能博弈\" class=\"headerlink\" title=\"人工智能博弈\"></a>人工智能博弈</h1><h2 id=\"博弈论\"><a href=\"#博弈论\" class=\"headerlink\" title=\"博弈论\"></a>博弈论</h2><p>博弈的要素：</p>\n<ul>\n<li>player</li>\n<li>strategy</li>\n<li>payoff</li>\n<li>rule</li>\n</ul>\n<h2 id=\"博弈策略求解\"><a href=\"#博弈策略求解\" class=\"headerlink\" title=\"博弈策略求解\"></a>博弈策略求解</h2><h3 id=\"遗憾最小化算法（Regret-Minimization）\"><a href=\"#遗憾最小化算法（Regret-Minimization）\" class=\"headerlink\" title=\"遗憾最小化算法（Regret Minimization）\"></a>遗憾最小化算法（Regret Minimization）</h3><p>下一步选择策略$\\Sigma_i$的概率P:<br>$$<br>P(\\sigma_i^{T+1}) &#x3D; \\begin{cases}<br>\\frac{\\text{Regret}<em>i^{T,+}(\\sigma_i)}{\\sum</em>{\\sigma_i’ \\in \\Sigma_i} \\text{Regret}<em>i^{T,+}(\\sigma_i’)} &amp; \\text{if } \\sum</em>{\\sigma_i’ \\in \\Sigma_i} \\text{Regret}_i^{T,+}(\\sigma_i’) &gt; 0 \\<br>\\frac{1}{|\\Sigma_i|} &amp; \\text{otherwise}<br>\\end{cases}<br>$$<br>为什么不直接选遗憾最大的：防止对手发现自己所采取的策略<br>+++info 例子</p>\n<ul>\n<li>假设两个玩家A和B进行石头-剪刀-布（Rock-Paper-Scissors, RPS）的游戏，获胜玩家收益为1分，失败玩家收益为-1分，平局则两个玩家收益均为零分。</li>\n<li>第一局时，若玩家A出石头（R），玩家B出布（P），则此时玩家A的收益 $\\mu_A(R, P) &#x3D; -1$，玩家B的收益为 $\\mu_B(P, R) &#x3D; 1$。</li>\n<li>对于玩家A来说，在玩家B出布（P）这个策略情况下，如果玩家A选择出布（P）或者剪刀（S），则玩家A对应的收益值 $\\mu_A(P, P) &#x3D; 0$ 或者 $\\mu_A(S, P) &#x3D; 1$。</li>\n<li>所以第一局之后，玩家A没有出布的遗憾值为 $\\mu_A(P, P) - \\mu_A(R, P) &#x3D; 0 - (-1) &#x3D; 1$，没有出剪刀的遗憾值为 $\\mu_A(S, P) - \\mu_A(R, P) &#x3D; 1 - (-1) &#x3D; 2$。</li>\n<li>所以在第二局中，玩家A选择石头、剪刀和布这三个策略的概率分别为 0、$\\frac{2}{3}$、$\\frac{1}{3}$。因此，玩家A趋向于在第二局中选择出剪刀这个策略。</li>\n<li>第二局中，玩家A选择剪刀和玩家B选择石头情况下，第二轮石头、剪刀、布的Regret分别为1，0，2，把前两轮的regret加起来计算概率，得到出石头、剪刀、布的概率分别为$\\frac{1}{6}$、$\\frac{2}{6}$、$\\frac{3}{6}$。<br>+++</li>\n</ul>\n<h3 id=\"双边匹配算法\"><a href=\"#双边匹配算法\" class=\"headerlink\" title=\"双边匹配算法\"></a>双边匹配算法</h3><p><img data-src=\"/f2.jpg\"><br>在第一轮中，4名男性分别向自己最喜欢的女性表白，而收到3人表白的女性A选择了自己最喜欢的男性3，另一个收到表白的女性B选择了男性4；在第二轮中，尚未匹配的男性1和男性2继续向自己第二喜欢的对象表白，收到表白的女性B选择了自己更喜欢的男性2而放弃了男性4；同理，继续三轮表白和选择，所有人都找到了自己的伴侣，且所有匹配都是稳定的。可以看出，使用G-S算法得到了稳定匹配的结果。</p>\n<h3 id=\"单边匹配算法-最大交易圈\"><a href=\"#单边匹配算法-最大交易圈\" class=\"headerlink\" title=\"单边匹配算法-最大交易圈\"></a>单边匹配算法-最大交易圈</h3><p><img data-src=\"/f3.jpg\"></p>\n<ol>\n<li>每个人指向最喜欢的物，每个物指向占有它的人</li>\n<li>如果有圈，就把打成交易的人和物和相关边都删掉</li>\n<li>继续<br><img data-src=\"/f4.jpg\"></li>\n</ol>\n",
            "tags": [
                "人工智能"
            ]
        },
        {
            "id": "http://example.com/2025/06/16/computer-science/compile-principles/ch7/",
            "url": "http://example.com/2025/06/16/computer-science/compile-principles/ch7/",
            "title": "IR",
            "date_published": "2025-06-15T16:00:00.000Z",
            "content_html": "<h1 id=\"IR\"><a href=\"#IR\" class=\"headerlink\" title=\"IR\"></a>IR</h1><p>Intermediate Representation<br>解决高级语言和目标机器汇编语言之间的转化<br>为什么需要IR:</p>\n<ul>\n<li>更模块化、可迁移</li>\n<li>分层分析和优化<br>IR可以有好多层：IR1-&gt;IR2-&gt;…-&gt;IRn<br>+++info 编译流程划分<br>前端：源代码-&gt;词法分析-&gt;语法分析-&gt;语义分析（IR之前的都是）<br>中端：基于IR的分析与变换（可能生成新IR，可以做一些机器无关优化比如循环展开等）<br>后端：指令选择-&gt;寄存器分配-&gt;指令调度-&gt;机器码（IR之后的）<br>+++</li>\n</ul>\n<h2 id=\"Three-Address-Code\"><a href=\"#Three-Address-Code\" class=\"headerlink\" title=\"Three-Address Code\"></a>Three-Address Code</h2><p>最多有三个操作数<br>x &#x3D; y op z<br>“地址”可以具有如下形式</p>\n<ul>\n<li>源程序中的名字(name)</li>\n<li>常量 (constant)</li>\n<li>临时变量(temporary)<br><img data-src=\"/f1.jpg\"><br>最常见的实现方法是将三地址代码作为四元组实现<br>+++info example<br>t1&#x3D;x&gt;0                  (gt, x, 0, t1)<br>if_false t1 goto L1     (if_f, t1, L1, _)<br>fact&#x3D;1                  (asn, 1, fact, _)<br>label L2                (lab, L2, _, _)<br>+++</li>\n</ul>\n<h2 id=\"IR-Tree\"><a href=\"#IR-Tree\" class=\"headerlink\" title=\"IR Tree\"></a>IR Tree</h2><p>两大类节点：</p>\n<ol>\n<li>表达式Exp</li>\n<li>语句Stmt<br>文法：<br><img data-src=\"/f2.jpg\"><br>表达式：<table>\n<thead>\n<tr>\n<th>Node</th>\n<th>Description</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CONST(i)</td>\n<td>整数常量i</td>\n<td>CONST(42) → the value 42</td>\n</tr>\n<tr>\n<td>NAME(n)</td>\n<td>符号常量n，通常是一个label，值是label的地址</td>\n<td>NAME(L1) → address of label L1</td>\n</tr>\n<tr>\n<td>TEMP(t)</td>\n<td>临时变量t (like register)</td>\n<td>TEMP(t123) → contents of temporary t123</td>\n</tr>\n<tr>\n<td>BINOP(o,e1,e2)</td>\n<td>对e1和e2执行二元操作o</td>\n<td>BINOP(PLUS,TEMP(t1),CONST(1)) → t1+1</td>\n</tr>\n<tr>\n<td>MEM(e)</td>\n<td>Memory access</td>\n<td>MEM(CONST(100)) → contents at address 100</td>\n</tr>\n<tr>\n<td>CALL(f,l)</td>\n<td>Function call, l是参数列表</td>\n<td>CALL(NAME(print),[TEMP(t1)]) → call print(t1)</td>\n</tr>\n<tr>\n<td>ESEQ(s,e)</td>\n<td>先执行语句s，再求值表达式e并返回e的结果</td>\n<td>ESEQ(MOVE(TEMP(t),CONST(1)),TEMP(t)) → (t&#x3D;1; t)</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<p>语句：</p>\n<table>\n<thead>\n<tr>\n<th>Node</th>\n<th>Description</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>MOVE(TEMP t, e)</td>\n<td>将表达式e的值赋给临时变量t</td>\n<td>MOVE(TEMP(t1), CONST(42)) → t1 &#x3D; 42</td>\n</tr>\n<tr>\n<td>MOVE(MEM(e1), e2)</td>\n<td>将表达式e2的值存储到由e1指定的内存地址中</td>\n<td>MOVE(MEM(TEMP(t1)), CONST(42)) → *t1 &#x3D; 42</td>\n</tr>\n<tr>\n<td>EXP(e)</td>\n<td>计算表达式e的值但不返回结果，通常用于有副作用的操作（如函数调用）</td>\n<td>EXP(CALL(NAME(print), …)) → 调用print()函数以产生效果</td>\n</tr>\n<tr>\n<td>JUMP(e, labs)</td>\n<td>无条件跳转到由e指定的地址</td>\n<td>JUMP(NAME(L1), [L1]) → goto L1</td>\n</tr>\n<tr>\n<td>CJUMP(o,e1,e2,t,f)</td>\n<td>条件跳转，根据操作o对e1和e2的结果决定跳转到t或f</td>\n<td>CJUMP(LT, TEMP(t1), CONST(0), L1, L2) → 如果t1 &lt; 0则跳转到L1，否则跳转到L2</td>\n</tr>\n<tr>\n<td>SEQ(s1, s2)</td>\n<td>语句序列，先执行s1再执行s2</td>\n<td>SEQ(MOVE(…), JUMP(…)) → 先赋值再跳转</td>\n</tr>\n<tr>\n<td>LABEL(n)</td>\n<td>定义一个标签</td>\n<td>LABEL(L1) → L1:</td>\n</tr>\n</tbody></table>\n<p>例子：<br><img data-src=\"/f3.jpg\"><br>ADD那个地方写成BINOP的写法也可以</p>\n<h2 id=\"翻译AST成IR-Tree\"><a href=\"#翻译AST成IR-Tree\" class=\"headerlink\" title=\"翻译AST成IR Tree\"></a>翻译AST成IR Tree</h2><p>把AST表达式分为三类：</p>\n<ul>\n<li>Ex: 有结果的AST表达式比如a+b</li>\n<li>Nx：无结果的语句的比如print</li>\n<li>Cx：条件语句，值为bool的AST表达式</li>\n</ul>\n<h3 id=\"translate-Exp\"><a href=\"#translate-Exp\" class=\"headerlink\" title=\"translate Exp\"></a>translate Exp</h3><ol>\n<li>翻译简单变量：<br>在函数中访问一个局部变量实际上是访问它在当前栈帧中的位置，所以访问一个距离fp的offset为k的局部变量v，其IR Tree表示为:<br>$$<br>MEM(BINOP(PLUS, TEMP fp, CONST k))<br>$$<br><img data-src=\"/f4.jpg\"><br>如果通过static link访问一个变量，就要嵌套好几层MEM和BINOP<br>比如这个访问嵌套两层外面的x<br>最内层使用 CONST(8)：是因为需要从 inner 函数的帧指针 FP 开始，偏移 8 字节来访问静态链，该静态链指向 middle 函数的帧。<br>中间层和最外层使用 CONST(0)：是因为它们分别通过静态链直接访问 outer 函数的帧和变量 x，不需要额外的偏移<br><img data-src=\"/f5.jpg\"><br>:::danger<br>这个地方为什么内层是8中层是0存疑<br>:::</li>\n</ol>\n<p>左值和右值：&#x3D;左右的<br>MEM(addr)可以是左值也可以是右值</p>\n<ul>\n<li>Scalar L-value(Tiger): 一个地址</li>\n<li>Structured L-value(Pascal&#x2F;C): 一块内存</li>\n</ul>\n<ol start=\"2\">\n<li>翻译算术运算</li>\n</ol>\n<ul>\n<li>二元: BINOP(op, e1, e2)</li>\n<li>一元: <ul>\n<li>-x &#x3D;&#x3D;&gt; BINOP(MINUS, CONST(0), e_x)</li>\n<li>~x &#x3D;&#x3D;&gt; BINOP(XOR, e_x, CONST(-1))</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li>数组访问<br>$$<br>MEM(BINOP(PLUS, MEM(e_a), BINOP(MUL, e_i, CONST(W))))<br>$$</li>\n</ol>\n<ul>\n<li><code>e_a</code> 是表示变量 <code>a</code> 的表达式，通常是&#x3D;&#x3D; <code>MEM(+(TEMP(fp), CONST(k_a)))</code>&#x3D;&#x3D;</li>\n<li><code>MEM(e_a)</code>：&#x3D;&#x3D;获取存储在变量 <code>a</code> 中的值，即数组基地址&#x3D;&#x3D;</li>\n<li><code>e_i</code> 是计算索引 <code>i</code> 的表达式</li>\n<li><code>BINOP(MUL, e_i, CONST(W))</code>：计算偏移<br><img data-src=\"/f6.jpg\"></li>\n</ul>\n<p>记录字段r.f访问:<br>$$<br>MEM(BINOP(PLUS, MEM(e_r), BINOP(MUL, n, CONST(W))))<br>$$</p>\n<ol start=\"4\">\n<li>翻译控制流<br>对于if e1 op e2 then stmt1 else stmt2翻译成</li>\n</ol>\n<figure class=\"highlight c\"><figcaption><span>IR</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 6个SEQ</span></span><br><span class=\"line\">SEQ(</span><br><span class=\"line\">    CJUMP(op, e1, e2, t, f),</span><br><span class=\"line\">    SEQ(</span><br><span class=\"line\">        LABEL(t),</span><br><span class=\"line\">        SEQ(</span><br><span class=\"line\">            stm1,</span><br><span class=\"line\">            SEQ(</span><br><span class=\"line\">                JUMP(NAME(end)),</span><br><span class=\"line\">                SEQ(</span><br><span class=\"line\">                    LABEL(f),</span><br><span class=\"line\">                    SEQ(stm2, LABEL(end))</span><br><span class=\"line\">                )</span><br><span class=\"line\">            )</span><br><span class=\"line\">        )</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>Tiger的逻辑运算符&amp;(and)和|(or)需要实现短路求值：只计算必要的操作数<br>每个Cx是一个Label</p>\n<ul>\n<li>逻辑与 (a &amp; b)的短路规则：<ul>\n<li>计算a<br>  -若a为假，直接得到假结果（不计算b）<br>  -若a为真，继续计算b，最终结果即为b的值</li>\n</ul>\n</li>\n<li>逻辑或 (a | b)的短路规则：<br>  -计算a<br>  -若a为真，直接得到真结果（不计算b）<ul>\n<li>若a为假，继续计算b，最终结果即为b的值</li>\n</ul>\n</li>\n</ul>\n<ol start=\"5\">\n<li>循环语句</li>\n</ol>\n<figure class=\"highlight c\"><figcaption><span>tiger</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> a &gt; <span class=\"number\">0</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">a := a - <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>翻译成</p>\n<figure class=\"highlight c\"><figcaption><span>IR</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SEQ(LABEL test, </span><br><span class=\"line\">    SEQ(CJUMP(GT, TEMP a, CONST <span class=\"number\">0</span>, body, done), </span><br><span class=\"line\">        SEQ(LABEL body, </span><br><span class=\"line\">            SEQ(MOVE(TEMP a, BINOP(MINUS, TEMP a, CONST <span class=\"number\">1</span>)), </span><br><span class=\"line\">                SEQ(JUMP(NAME(test), [test]), </span><br><span class=\"line\">                    LABEL done)))))</span><br></pre></td></tr></table></figure>\n<p>break翻译为直接跳转到done<br>for循环我懒得写了，也是一个道理<br>和汇编差不多意思</p>\n<ol start=\"6\">\n<li>翻译函数<br>$$<br>CALL(NAME(l_f), [sl, a_1, …, a_n])<br>$$<br>sl是static link。</li>\n</ol>\n<h3 id=\"translate-Declaration\"><a href=\"#translate-Declaration\" class=\"headerlink\" title=\"translate Declaration\"></a>translate Declaration</h3><ul>\n<li>Variable declaration</li>\n<li>Type declaration</li>\n<li>Function declaration</li>\n</ul>\n<ol>\n<li>翻译变量声明</li>\n</ol>\n<figure class=\"highlight c\"><figcaption><span>tiger</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let</span><br><span class=\"line\">    var x := <span class=\"number\">10</span></span><br><span class=\"line\">    var y := x + <span class=\"number\">5</span></span><br><span class=\"line\">in </span><br><span class=\"line\">    x + y</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><figcaption><span>IR</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ESEQ( </span><br><span class=\"line\">    SEQ( </span><br><span class=\"line\">        MOVE(MEM(+(FP, CONST(x_offset))), CONST(<span class=\"number\">10</span>)), </span><br><span class=\"line\">        MOVE(MEM(+(FP, CONST(y_offset))), </span><br><span class=\"line\">        BINOP(PLUS, </span><br><span class=\"line\">        MEM(+(FP, CONST(x_offset))), </span><br><span class=\"line\">        CONST(<span class=\"number\">5</span>))) </span><br><span class=\"line\">    ), </span><br><span class=\"line\">    BINOP(PLUS, </span><br><span class=\"line\">    MEM(+(FP, CONST(x_offset))), </span><br><span class=\"line\">    MEM(+(FP, CONST(y_offset)))) </span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>let body in e end翻译成ESEQ(body, e)<br>变量定义翻译成 MEM(+(FP, CONST(offset)))<br>初始化翻译成 MOVE(MEM(+(FP, CONST(offset))), CONST(value))</p>\n<ol start=\"2\">\n<li><p>类型声明<br>No need to generate any IR tree code</p>\n</li>\n<li><p>函数声明<br> – Prologue（序言）<br> – Body（函数体）<br> – Epilogue（尾声）</p>\n</li>\n</ol>\n<ul>\n<li>Prologue<ul>\n<li>pseudo-instructions to announce the beginning of a function</li>\n<li>定义函数标签用于跳转&#x2F;调用</li>\n<li>修改栈指针（SP），为新栈帧分配空间，一般是$SP :&#x3D; SP - frame_size$</li>\n<li>保存被调用者需要保存的寄存器（callee-save），如 $s0-$s7；保存返回地址（RA）</li>\n<li>保存函数参数到栈中（尤其是传值调用时）；保存静态链（static link）</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "中间代码"
            ]
        },
        {
            "id": "http://example.com/2025/06/15/AI/week8-9/",
            "url": "http://example.com/2025/06/15/AI/week8-9/",
            "title": "Week8-9",
            "date_published": "2025-06-14T16:00:00.000Z",
            "content_html": "<h1 id=\"K-Means\"><a href=\"#K-Means\" class=\"headerlink\" title=\"K-Means\"></a>K-Means</h1><p>问题描述：如何将n个数据依据其相似度大小将它们分别聚类到k个集合，使得每个数据仅属于一个聚类集合。</p>\n<ul>\n<li>初始化质心：随机选择k个数据点作为初始质心$c_1, c_2, …, c_k$。</li>\n<li>分配数据点：对于每个数据点$x_i$，计算它与所有质心的距离，并将其分配到距离最近的质心所在的簇中</li>\n<li>更新质心：对于每个簇，计算该簇内所有数据点的平均值，将该平均值作为新的质心。</li>\n<li>迭代过程：重复执行分配和更新步骤，直到质心不再发生变化或达到预设的最大迭代次数。</li>\n</ul>\n<h1 id=\"主成分分析-PCA\"><a href=\"#主成分分析-PCA\" class=\"headerlink\" title=\"主成分分析(PCA)\"></a>主成分分析(PCA)</h1><ul>\n<li>输入：n个d维样本数据所构成的矩阵$\\mathbf{X}$，降维后的维数l</li>\n<li>输出：映射矩阵$\\mathbf{W} &#x3D; {\\mathbf{w}_1, \\mathbf{w}_2, …, \\mathbf{w}_l}$<br>算法步骤：</li>\n</ul>\n<ol>\n<li><p>对于每个样本数据$\\mathbf{x}_i$进行中心化处理：<br>$$<br>\\mathbf{x}_i’ &#x3D; \\mathbf{x}<em>i - \\mu, \\quad \\mu &#x3D; \\frac{1}{n}\\sum</em>{j&#x3D;1}^{n} \\mathbf{x}_j<br>$$</p>\n</li>\n<li><p>计算原始样本数据的协方差矩阵：<br>$$<br>\\Sigma &#x3D; \\frac{1}{n-1} \\mathbf{X}^T \\mathbf{X}<br>$$</p>\n</li>\n<li><p>对协方差矩阵$\\Sigma$进行特征值分解，对所得特征根按其值大到小排序$\\lambda_1 \\geq \\lambda_2 \\geq \\cdots \\geq \\lambda_d$</p>\n</li>\n<li><p>取前$l$个最大特征根所对应特征向量$\\mathbf{w}_1, \\mathbf{w}_2, …, \\mathbf{w}_l$组成映射矩阵$\\mathbf{W}$</p>\n</li>\n<li><p>将每个样本数据$\\mathbf{x}<em>i$按照如下方法降维：<br>$$<br>(\\mathbf{x}<em>i)</em>{1 \\times d} (\\mathbf{W})</em>{d \\times l} &#x3D; 1 \\times l<br>$$<br>区分：</p>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>PCA</th>\n<th>LDA</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>类型</strong></td>\n<td>无监督</td>\n<td>有监督</td>\n</tr>\n<tr>\n<td><strong>目标</strong></td>\n<td>最大化方差，保留主要分布信息</td>\n<td>最大化类间距离，最小化类内距离</td>\n</tr>\n<tr>\n<td><strong>是否使用类别信息</strong></td>\n<td>? 不使用</td>\n<td>? 使用</td>\n</tr>\n<tr>\n<td><strong>适用任务</strong></td>\n<td>数据压缩、可视化、去噪</td>\n<td>分类任务的特征提取</td>\n</tr>\n<tr>\n<td><strong>降维后维度上限</strong></td>\n<td>可任意，但一般小于原维度</td>\n<td>最多降到 $k-1$ 维（$k$ 是类别数）</td>\n</tr>\n<tr>\n<td><strong>数学基础</strong></td>\n<td>协方差矩阵的特征值分解</td>\n<td>类间&#x2F;类内散度矩阵的广义特征值分解</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<ul>\n<li>其他降维方法：<ul>\n<li>非负矩阵分解 （non-negative matrix factorization, NMF）</li>\n<li>多维尺度法（Metric multidimensional scaling, MDS）</li>\n<li>局部线性嵌入（Locally Linear Embedding，LLE）</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"特征人脸方法\"><a href=\"#特征人脸方法\" class=\"headerlink\" title=\"特征人脸方法\"></a>特征人脸方法</h1><p>输入时将每幅人脸图像转换成列向量<br><img data-src=\"/f1.jpg\"><br>算法描述</p>\n<ul>\n<li>输入：$n$个1024维人脸样本数据所构成的矩阵$\\mathbf{X}$，降维后的维数$l$</li>\n<li>输出：映射矩阵$\\mathbf{W} &#x3D; {\\mathbf{w}_1, \\mathbf{w}_2, …, \\mathbf{w}_l}$（其中每个$\\mathbf{w}_j (1 \\leq j \\leq l)$是一个特征人脸）<br>算法步骤</li>\n</ul>\n<ol>\n<li><p>中心化处理：</p>\n<ul>\n<li>对每个人脸样本数据$x_i$进行中心化处理：<br>$$<br>x_i’ &#x3D; x_i - \\mu, \\quad \\mu &#x3D; \\frac{1}{n}\\sum_{j&#x3D;1}^{n} x_j<br>$$</li>\n</ul>\n</li>\n<li><p>计算协方差矩阵：</p>\n<ul>\n<li>计算原始人脸样本数据的协方差矩阵：<br>$$<br>\\Sigma &#x3D; \\frac{1}{n-1} \\mathbf{X}^T \\mathbf{X}<br>$$</li>\n</ul>\n</li>\n<li><p>特征值分解：</p>\n<ul>\n<li>对协方差矩阵$\\Sigma$进行特征值分解，对所得特征根按从大到小排序：<br>$$<br>\\lambda_1 \\geq \\lambda_2 \\geq \\cdots \\geq \\lambda_d<br>$$</li>\n</ul>\n</li>\n<li><p>构建映射矩阵：</p>\n<ul>\n<li>取前$l$个最大特征根所对应特征向量$\\mathbf{w}_1, \\mathbf{w}_2, …, \\mathbf{w}_l$组成映射矩阵$\\mathbf{W}$。</li>\n</ul>\n</li>\n<li><p>数据降维：</p>\n<ul>\n<li>将每个人脸图像$x_i$按照如下方法降维：<br>$$<br>(\\mathbf{x}<em>i)</em>{1 \\times d} (\\mathbf{W})_{d \\times l} &#x3D; 1 \\times l<br>$$<br>（其实用的是pca，多的一步就是输入的时候把32*32的图摊开成1024*1的列向量而已）</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"潜在语义分析（Latent-Semantic-Analysis-LSA）\"><a href=\"#潜在语义分析（Latent-Semantic-Analysis-LSA）\" class=\"headerlink\" title=\"潜在语义分析（Latent Semantic Analysis, LSA）\"></a>潜在语义分析（Latent Semantic Analysis, LSA）</h1><p>步骤</p>\n<ol>\n<li><p>构建单词-文档矩阵：</p>\n<ul>\n<li>构建一个单词-文档矩阵$A$，其中每个元素$a_{ij}$表示第$i$个单词在第$j$个文档中的频率（通常使用词频-逆文档频率TF-IDF进行加权）。</li>\n</ul>\n</li>\n<li><p>奇异值分解（SVD）：</p>\n<ul>\n<li>对单词-文档矩阵$A$进行奇异值分解，即$A &#x3D; U \\Sigma V^T$，其中$U$和$V$分别是左奇异向量和右奇异向量组成的矩阵，$\\Sigma$是对角矩阵，其对角线上的元素是$A$的奇异值（按降序排列）。</li>\n</ul>\n</li>\n<li><p>选择前$k$个最大奇异值及对应的奇异向量：</p>\n<ul>\n<li>选取前$k$个最大的奇异值及其对应的奇异向量，形成低秩逼近矩阵$A_k &#x3D; U_k \\Sigma_k V_k^T$。这里$k$的选择取决于保留多少原始信息量，通常根据累积能量准则或经验确定。</li>\n</ul>\n</li>\n<li><p>重建矩阵并挖掘语义关系：</p>\n<ul>\n<li>使用$A_k$代替原始矩阵$A$，可以计算任意两个文档之间的相似度（如皮尔逊相关系数），从而发现文档-文档之间的关联关系。</li>\n<li>同样地，也可以用于探索单词-单词、单词-文档间的隐含关系。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"期望最大化算法（Expectation-Maximization-Algorithm-EM）\"><a href=\"#期望最大化算法（Expectation-Maximization-Algorithm-EM）\" class=\"headerlink\" title=\"期望最大化算法（Expectation-Maximization Algorithm, EM）\"></a>期望最大化算法（Expectation-Maximization Algorithm, EM）</h1><p>EM算法是一种迭代方法，主要用于含有隐变量的概率模型参数估计问题。它分为&#x3D;&#x3D;E步（求期望）&#x3D;&#x3D;和&#x3D;&#x3D;M步（最大化）&#x3D;&#x3D;，通过迭代方式逼近模型参数的最大似然估计值。</p>\n<p>步骤</p>\n<ol>\n<li><p>初始化模型参数：</p>\n<ul>\n<li>首先为模型参数设定初始值（例如高斯混合模型中的均值、方差等）。</li>\n</ul>\n</li>\n<li><p>E步（Expectation Step）：计算隐变量</p>\n<ul>\n<li>基于当前的模型参数，计算隐变量的后验概率分布。对于每一个样本$x_i$和可能的隐变量$z_i$，计算$p(z_i|x_i, \\theta)$，其中$\\theta$表示当前的模型参数。</li>\n</ul>\n</li>\n<li><p>M步（Maximization Step）：最大化似然函数和更新模型参数</p>\n<ul>\n<li>根据观测数据$x_i$、隐变量$z_i$的后验概率分布，重新估计模型参数$\\theta$，以最大化完整数据的对数似然函数$\\log p(x,z|\\theta)$的期望。</li>\n</ul>\n</li>\n<li><p>重复E步和M步：</p>\n<ul>\n<li>不断重复执行E步和M步，直到模型参数收敛或者达到预定的迭代次数为止。</li>\n</ul>\n</li>\n</ol>\n<p>具体的没看懂，等我懂了再说</p>\n",
            "tags": [
                "人工智能"
            ]
        },
        {
            "id": "http://example.com/2025/06/15/computer-science/compile-principles/ch6/",
            "url": "http://example.com/2025/06/15/computer-science/compile-principles/ch6/",
            "title": "活动记录",
            "date_published": "2025-06-14T16:00:00.000Z",
            "content_html": "<h1 id=\"Activation-Record-Stack-Frame\"><a href=\"#Activation-Record-Stack-Frame\" class=\"headerlink\" title=\"Activation Record&#x2F;Stack Frame\"></a>Activation Record&#x2F;Stack Frame</h1><p>函数的栈帧是栈上用来放函数的局部变量、参数、返回地址以及其他临时变量的区域<br>stack一般从高地址向低地址，heap从低地址向高地址<br>layout:<br><img data-src=\"/f1.jpg\"></p>\n<ul>\n<li>incoming arguments: 存储caller传递给callee的参数</li>\n<li>frame pointer: 帧指针，用来访问incoming arguments，从低向高是argument 1, argument 2, …</li>\n<li>local variables: 存储函数的局部变量（还有一些保存在寄存器里）</li>\n<li>return address: 存储需要返回caller的哪里；non-leaf过程会把return address写入栈帧里面</li>\n<li>temporaries: 存储临时变量，复杂表达式拆出来的中间变量放的地方</li>\n<li>saved registers</li>\n<li>outgoing arguments: 存储当前函数要传递给别的函数的参数</li>\n<li>stack pointer: 栈指针，从低向高</li>\n</ul>\n<h2 id=\"函数调用流程：\"><a href=\"#函数调用流程：\" class=\"headerlink\" title=\"函数调用流程：\"></a>函数调用流程：</h2><ul>\n<li>g调用f的时候</li>\n</ul>\n<ol>\n<li>进入f的时候，保存旧的FP(g的FP)</li>\n<li>把FP设置为原来的SP，把SP &#x3D; SP - frame size<br><img data-src=\"/f2.jpg\"></li>\n</ol>\n<ul>\n<li>f返回的时候</li>\n</ul>\n<ol>\n<li>让SP &#x3D; FP(恢复g的SP)</li>\n<li>从内存中读出g的FP恢复回去</li>\n</ol>\n<p>如果栈帧大小固定就只需要FP不需要SP了，因为FP &#x3D; SP + frame size</p>\n<h2 id=\"saved-register\"><a href=\"#saved-register\" class=\"headerlink\" title=\"saved register\"></a>saved register</h2><p>函数g调用f的时候，用到了寄存器r，调用f的时候要把r保存在saved register中，等调用结束再恢复回去</p>\n<ul>\n<li>caller-saved register: 函数调用的时候用到的寄存器，调用结束后可以恢复</li>\n<li>callee-saved register: 函数调用的时候用不到的寄存器，调用结束后不能恢复<br>&#x3D;&#x3D;FP是由callee保存和恢复的&#x3D;&#x3D;</li>\n</ul>\n<h2 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h2><p>一般约定把前k(4 or 6)个参数放在寄存器传递，剩下的参数放在栈中传递<br>四种传参方法：</p>\n<ol>\n<li>不给叶过程 (leaf procedure) 分配栈帧<br>叶过程是指不调用其他过程的过程。在这种情况下，可以不为叶过程分配栈帧</li>\n<li>过程间寄存器分配 (interprocedural register allocation)<br>这种方法需要先分析代码中全部的函数，然后再根据分析结果来分配寄存器。<br>假设有一个程序包含多个函数，通过全局分析发现某些变量在多个函数之间频繁使用，可以为其分配固定的寄存器，避免频繁的内存读写</li>\n<li>若变量 x 不再被使用，可以直接写其寄存器，不需要再保存 x 到栈帧中<br>当一个变量在当前作用域内不再被使用时，可以直接将其值写入寄存器，而无需保存到栈帧中</li>\n</ol>\n<figure class=\"highlight c\"><figcaption><span>example</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">exampleFunction</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> y = x * <span class=\"number\">2</span>;  <span class=\"comment\">// 使用x后，x不再被使用</span></span><br><span class=\"line\">    <span class=\"comment\">// 直接将y的值写入寄存器，无需保存x到栈帧中</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Result: %d\\n&quot;</span>, y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>寄存器窗口技术 (register windows)<br>在每次函数调用时，系统会自动切换到一组新的寄存器，称为寄存器窗口。这样，每个函数都可以独立地使用自己的寄存器，而不会影响其他函数的寄存器状态。</li>\n</ol>\n<figure class=\"highlight c\"><figcaption><span>example</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">functionA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用寄存器窗口A</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">functionB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用寄存器窗口B</span></span><br><span class=\"line\">    functionA();  <span class=\"comment\">// 调用functionA时，自动切换到寄存器窗口A</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Frame-Resident-Variables\"><a href=\"#Frame-Resident-Variables\" class=\"headerlink\" title=\"Frame-Resident Variables\"></a>Frame-Resident Variables</h2><p>什么情况下要把变量写入栈帧里面？、</p>\n<ol>\n<li>the varibles will be passed by reference 变量传地址&#x2F;引用</li>\n<li>变量被嵌套在函数内部的函数访问（不绝对）</li>\n<li>变量太大了没法直接放寄存器</li>\n<li>变量是一个数组</li>\n<li>传递参数</li>\n<li>有太多局部变量和临时变量放不下了</li>\n</ol>\n<ul>\n<li>escape 逃逸：如果一个变量需要传地址&#x2F;取地址&#x2F;被过程内部嵌套的函数访问，那么这个变量就会逃逸。</li>\n</ul>\n<h2 id=\"static-links\"><a href=\"#static-links\" class=\"headerlink\" title=\"static links\"></a>static links</h2><p>在嵌套的函数声明中，内层函数是有可能用到外层函数的局部变量的。</p>\n<ul>\n<li>static links是指向上一层嵌套层级的栈帧的指针。内层嵌套函数调用外层定义的变量的时候需要用到static links，否则无法寻址。<br><img data-src=\"/f3.jpg\"><br><img data-src=\"/f4.jpg\"><br>只有调用自身的时候才传递自己的static link作为static link，其他的都是把外层函数的fp作为static link<br>如果要访问外层变量，就顺着static一层一层查上去直到找到了为止。<br>其他访问方法：</li>\n<li>嵌套层次显示表(display)<br>建立一个全局数组，位置i包含一个指针，指向最近一次进入的，其静态嵌套深度是i的过程的栈帧<br><img data-src=\"/f5.jpg\"><br>先给它们标上嵌套深度<br>直接把链表变成数组了，需要用到一个变量，就查看当前变量的嵌套深度i然后直接找那个数组i位置的座位fp地址来找</li>\n<li>lambda lifting<br>g调用f时，g中每一个实际（或被嵌套在f内的任意函数）访问了的变量，都将作为额外的参数传递给f<br>把内部的函数，从内往外进行改写，改写函数的参数实现lambda lifting<br><img data-src=\"/f6.jpg\"></li>\n</ul>\n<h2 id=\"tiger编译器的栈帧\"><a href=\"#tiger编译器的栈帧\" class=\"headerlink\" title=\"tiger编译器的栈帧\"></a>tiger编译器的栈帧</h2><p>tiger不支持高阶函数<br>看不完了。。再说吧</p>\n",
            "tags": [
                "活动记录"
            ]
        },
        {
            "id": "http://example.com/2025/06/12/AI/week6-7/",
            "url": "http://example.com/2025/06/12/AI/week6-7/",
            "title": "Week6-7",
            "date_published": "2025-06-11T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch4-机器学习\"><a href=\"#Ch4-机器学习\" class=\"headerlink\" title=\"Ch4 机器学习\"></a>Ch4 机器学习</h1><h2 id=\"监督学习\"><a href=\"#监督学习\" class=\"headerlink\" title=\"监督学习\"></a>监督学习</h2><ul>\n<li>标注数据</li>\n<li>学习模型</li>\n<li>损失函数<br>典型的损失函数<br><img data-src=\"/figure2.png\"></li>\n</ul>\n<p>经验风险(empirical risk )</p>\n<ul>\n<li>训练集中数据产生的损失。</li>\n<li>经验风险越小说明学习模型对训练数据拟合程度越好。</li>\n</ul>\n<p>期望风险(expected risk):</p>\n<ul>\n<li>当测试集中存在无穷多数据时产生的损失。</li>\n<li>期望风险越小，学习所得模型越好。</li>\n</ul>\n<p>经验风险最小化</p>\n<p>$$\\min_{f \\in \\Phi} \\frac{1}{n} \\sum_{i&#x3D;1}^{n} Loss(y_i, f(x_i))$$</p>\n<p>期望风险最小化</p>\n<p>$$\\min_{f \\in \\Phi} \\int_{x \\times y} Loss(y, f(x)) P(x, y) dx dy$$</p>\n<p>模型泛化能力与经验风险、期望风险的关系</p>\n<table>\n<thead>\n<tr>\n<th>经验风险小（训练集上表现好）</th>\n<th>期望风险小（测试集上表现好）</th>\n<th>泛化能力强</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>经验风险小（训练集上表现好）</td>\n<td>期望风险大（测试集上表现不好）</td>\n<td>过学习（模型过于复杂）</td>\n</tr>\n<tr>\n<td>经验风险大（训练集上表现不好）</td>\n<td>期望风险大（测试集上表现不好）</td>\n<td>欠学习</td>\n</tr>\n<tr>\n<td>经验风险大（训练集上表现不好）</td>\n<td>期望风险小（测试集上表现好）</td>\n<td>“神仙算法”或“黄粱美梦”</td>\n</tr>\n</tbody></table>\n<p>结构风险最小化 (structural risk minimization)</p>\n<p>为了防止过拟合，在经验风险上加上表示模型复杂度的正则化项 (regularizer) 或惩罚项 (penalty term):</p>\n<p>$$\\min_{f \\in \\Phi} \\frac{1}{n} \\sum_{i&#x3D;1}^{n} Loss(y_i, f(x_i)) + \\lambda J(f)$$</p>\n<ul>\n<li>经验风险: $\\frac{1}{n} \\sum_{i&#x3D;1}^{n} Loss(y_i, f(x_i))$</li>\n<li>模型复杂度: $\\lambda J(f)$</li>\n</ul>\n<p>监督学习方法又可以分为 生成方法 (generative approach) 和 判别方法(discriminative approach)。所学到的模型分别称为生成模型(generative model)和判别模型(discriminative model)<br><img data-src=\"/figure1.png\"></p>\n<h1 id=\"回归分析\"><a href=\"#回归分析\" class=\"headerlink\" title=\"回归分析\"></a>回归分析</h1><h2 id=\"线性回归\"><a href=\"#线性回归\" class=\"headerlink\" title=\"线性回归\"></a>线性回归</h2><ul>\n<li>一元线性回归</li>\n</ul>\n<p>$$y_i &#x3D; ax_i + b \\quad (1 \\leq i \\leq n)$$</p>\n<p>$$a &#x3D; \\frac{\\sum_{i&#x3D;1}^{n} x_i y_i - n \\bar{x} \\bar{y}}{\\sum_{i&#x3D;1}^{n} x_i^2 - n \\bar{x}^2}$$</p>\n<p>$$b &#x3D; \\bar{y} - a \\bar{x}$$</p>\n<ul>\n<li><p>多元线性回归<br>$$f(x_i) &#x3D; a_0 + \\sum_{j&#x3D;1}^{D} a_j x_{i,j} &#x3D; a_0 + \\mathbf{a}^T \\mathbf{x}_i$$<br>a是要求的参数，x是输入的数据，f是预测值。<br>为了方便，使用矩阵来表示所有的训练数据和数据标签。<br>$$X &#x3D; [x_1, …, x_m], \\quad y &#x3D; [y_1, …, y_m]$$<br>最小化均方误差得到：<br>$$a &#x3D; (XX^T)^{-1}X^Ty$$</p>\n</li>\n<li><p>逻辑斯蒂回归&#x2F;对数几率回归<br>线性回归一个明显的问题是对离群点导致模型建模不稳定，使结果有偏，为了缓解这个问题（特别是在二分类场景中）带来的影响，可考虑逻辑斯蒂回归<br>逻辑斯蒂回归就是在回归模型中引入 sigmoid函数的一种非线性回归模型</p>\n</li>\n</ul>\n<h2 id=\"逻辑斯蒂回归-Logistic-Regression\"><a href=\"#逻辑斯蒂回归-Logistic-Regression\" class=\"headerlink\" title=\"逻辑斯蒂回归 (Logistic Regression)\"></a>逻辑斯蒂回归 (Logistic Regression)</h2><p>逻辑斯蒂回归（logistic regression）就是在回归模型中引入 sigmoid 函数的一种非线性回归模型。Logistic 回归模型可如下表示：</p>\n<p>$$ y &#x3D; \\frac{1}{1 + e^{-z}} &#x3D; \\frac{1}{1 + e^{-(w^T x + b)}} $$<br>其中 $y \\in (0, 1)$，$z &#x3D; w^T x + b$。<br>这里 $\\frac{1}{1 + e^{-z}}$ 是 sigmoid 函数，$x \\in \\mathbb{R}^d$ 是输入数据，$w \\in \\mathbb{R}^d$ 和 $b \\in \\mathbb{R}$ 是回归函数的参数。</p>\n<p>逻辑斯蒂回归多用于&#x3D;&#x3D;二分类&#x3D;&#x3D;问题<br>Sigmoid 函数将任意实数映射到区间(0,1)，这正好符合“概率”的取值范围，所以函数的输出y可以被解释为输入数据x属于正例的概率<br>因此我们可以将输出 y 解释为：</p>\n<blockquote>\n<p>在给定输入特征 x 的条件下，该样本属于正类（例如类别 1）的概率。<br>即：<br>$$<br>y &#x3D; P(y &#x3D; 1 \\mid x)<br>$$<br>如果 $P(y&#x3D;1|x)$ 表示给定输入 $x$ 属于正类的概率，则 $1 - P(y&#x3D;1|x)$ 表示属于负类的概率。<br>$\\frac{P(y&#x3D;1|x)}{1 - P(y&#x3D;1|x)}$ 就是正类相对于负类的优势比。所以&gt;1就归为正类，反之就是负类。</p>\n</blockquote>\n<p>$$<br>\\log \\frac{P(y&#x3D;1|x)}{P(y&#x3D;0|x)} &#x3D; {w^T x + b} &gt; \\log{1} &#x3D; 0<br>$$<br>从这里可以看出，logistic回归本质上是一个线性模型。在预测时，可以计算线性函数$w^T x + b$取值是否大于0来判断输入数据x的类别归属</p>\n<p>为了找到最优参数w和b，我们使用最大似然估计，假设每个样本独立同分布，则<br>……<br>公式懒得敲了，</p>\n<p>为什么基于相关性的方法可能会导致模型的不可解释性和不稳定性</p>\n<ul>\n<li>因果特征和非因果特征</li>\n<li>Making V⊥Y: 最终目标是让非因果特征 V 与输出 Y 独立，即消除虚假相关性，使得模型更加稳定和可解释</li>\n</ul>\n<h1 id=\"决策树\"><a href=\"#决策树\" class=\"headerlink\" title=\"决策树\"></a>决策树</h1><p>决策树是一种通过树形结构来进行分类的方法</p>\n<ul>\n<li>信息熵（entropy）是度量样本集合纯度最常用的一种指标<br>假设有一个K个信息（类别），其组成了集合样本D，记第k个信息（类别）发生的概率为$p_k (1 \\leq k \\leq K)$。如下定义这K个信息的信息熵：</li>\n</ul>\n<p>$$Ent(D) &#x3D; -\\sum_{k&#x3D;1}^{K} p_k \\log_2 p_k$$</p>\n<p>&#x3D;&#x3D;$Ent(D)$值越小，表示D包含的信息越确定，也称D的纯度越高。&#x3D;&#x3D;所有$p_k$累加起来的和为1。</p>\n<ul>\n<li>信息增益:衡量使用某个属性进行划分后，数据集不确定性减少的程度<br>得到信息熵后可以进一步计算信息增益：<br>$$Gain(D, A) &#x3D; Ent(D) - \\sum_{i&#x3D;1}^{n} \\frac{|D_i|}{|D|} Ent(D_i)$$<br><img data-src=\"/f3.png\"><br><img data-src=\"/f4.png\"><br>ID3决策树学习算法[Quinlan, 1986]以信息增益为准则来选择划分属性<br>目标：通过不断划分，使得每个子集尽可能“纯净”，即子集内的样本属于同一类</li>\n</ul>\n<p>信息熵（和上面的一样的）<br>$$<br>info &#x3D; -\\sum_{i&#x3D;1}^{n} \\frac{|D_i|}{|D|} \\log_2 \\frac{|D_i|}{|D|}<br>$$</p>\n<p>增益率（Gain-ratio）：</p>\n<p>$$<br>Gain-ratio &#x3D; \\frac{Gain(D, A)}{info}<br>$$<br>存在的问题：增益率准则对可取数目较少的属性有所偏好</p>\n<p>另一种计算更简的度量指标是如下的 Gini 指数（基尼指数）：</p>\n<p>$$<br>Gini(D) &#x3D; 1 - \\sum_{k&#x3D;1}^{K} p_k^2<br>$$</p>\n<p>相对于信息熵的计算 $E(D) &#x3D; -\\sum_{k&#x3D;1}^{K} p_k \\log_2 p_k$，不用计算对数 log，计算更为简易。</p>\n<h2 id=\"连续属性离散化\"><a href=\"#连续属性离散化\" class=\"headerlink\" title=\"连续属性离散化\"></a>连续属性离散化</h2><ol>\n<li><p>确定连续属性的取值范围，确定划分点集合<br>考虑包含 n-1 个元素的候选划分点集合：<br>$$<br>T_a &#x3D; \\left{ \\frac{a^i + a^{i+1}}{2} ,\\middle|, 1 \\leq i \\leq n - 1 \\right}<br>$$<br>这里的每个候选划分点是相邻两个取值的中点，即区间 $[a^i, a^{i+1})$ 的中位点 $\\frac{a^i + a^{i+1}}{2}$</p>\n</li>\n<li><p>计算信息增益<br>$$<br>\\text{Gain}(D, a, t) &#x3D; \\text{Ent}(D) - \\sum_{\\lambda \\in {-, +}} \\frac{|D_t^\\lambda|}{|D|} \\cdot \\text{Ent}(D_t^\\lambda)<br>$$<br>计算每个划分点的信息增益率，选择信息增益最大的划分点</p>\n</li>\n</ol>\n<p>+++info example<br>;;;id3 example<br>给定数据点及其对应的类别标签如下：</p>\n<ul>\n<li>$a_1 &#x3D; 1$ -&gt; 类别为 0</li>\n<li>$a_2 &#x3D; 3$ -&gt; 类别为 1</li>\n<li>$a_3 &#x3D; 5$ -&gt; 类别为 0</li>\n<li>$a_4 &#x3D; 7$ -&gt; 类别为 1</li>\n<li>$a_5 &#x3D; 9$ -&gt; 类别为 0</li>\n</ul>\n<p>因此，我们的数据集 $D$ 是 ${1, 3, 5, 7, 9}$，对应的类别标签分别为 ${0, 1, 0, 1, 0}$。</p>\n<p>第一步：计算原始数据集的信息熵</p>\n<p>$$<br>Ent(D) &#x3D; -\\left( p_0 \\log_2 p_0 + p_1 \\log_2 p_1 \\right)<br>$$</p>\n<p>其中，$p_0 &#x3D; \\frac{3}{5}$，$p_1 &#x3D; \\frac{2}{5}$，则：</p>\n<p>$$<br>Ent(D) &#x3D; -\\left( \\frac{3}{5} \\log_2 \\frac{3}{5} + \\frac{2}{5} \\log_2 \\frac{2}{5} \\right) \\approx 0.971<br>$$</p>\n<p>第二步：确定候选划分点集合</p>\n<p>根据公式 $T_a &#x3D; \\left{ \\frac{a^i + a^{i+1}}{2} ,\\middle|, 1 \\leq i \\leq n - 1 \\right}$，我们得到候选划分点集合：</p>\n<p>$$<br>T_a &#x3D; {2, 4, 6, 8}<br>$$</p>\n<p>第三步：计算每个候选划分点的信息增益</p>\n<p>以划分点 $t &#x3D; 4$ 为例：</p>\n<ul>\n<li>$D_t^{-} &#x3D; {1, 3}$，类别为 ${0, 1}$</li>\n<li>$D_t^{+} &#x3D; {5, 7, 9}$，类别为 ${0, 1, 0}$</li>\n</ul>\n<p>计算这两个子集的熵：</p>\n<ul>\n<li>$$Ent(D_t^{-}) &#x3D; -\\left( \\frac{1}{2} \\log_2 \\frac{1}{2} + \\frac{1}{2} \\log_2 \\frac{1}{2} \\right) &#x3D; 1$$</li>\n<li>$$Ent(D_t^{+}) &#x3D; -\\left( \\frac{2}{3} \\log_2 \\frac{2}{3} + \\frac{1}{3} \\log_2 \\frac{1}{3} \\right) \\approx 0.918$$</li>\n</ul>\n<p>计算信息增益：</p>\n<p>$$<br>Gain(D, a, t&#x3D;4) &#x3D; Ent(D) - \\left( \\frac{|D_t^{-}|}{|D|} \\cdot Ent(D_t^{-}) + \\frac{|D_t^{+}|}{|D|} \\cdot Ent(D_t^{+}) \\right)<br>$$</p>\n<p>代入数值：</p>\n<p>$$<br>Gain(D, a, t&#x3D;4) &#x3D; 0.971 - \\left( \\frac{2}{5} \\cdot 1 + \\frac{3}{5} \\cdot 0.918 \\right) \\approx 0.029<br>$$</p>\n<p>重复上述过程，对所有划分点 $t &#x3D; 2, 4, 6, 8$ 进行类似计算，并选择使 $Gain(D, a, t)$ 最大的那个作为最优划分点。<br>;;;<br>+++</p>\n<h1 id=\"线性区别分析-LDA-FDA\"><a href=\"#线性区别分析-LDA-FDA\" class=\"headerlink\" title=\"线性区别分析 (LDA&#x2F;FDA)\"></a>线性区别分析 (LDA&#x2F;FDA)</h1><p>线性判别分析(linear discriminant analysis， LDA)是一种基于监督学习的降维方法，也称为Fisher线性判别分析(fisher’s discriminant analysis，FDA),对于一组具有标签信息的高维数据样本，LDA利用其类别信息，将其线性投影到一个低维空间上，在低维空间中同一类别样本尽可能靠近，不同类别样本尽可能彼此远离。</p>\n<ol>\n<li>计算数据样本集中每个类别样本的均值</li>\n<li>计算类内散度矩阵$S_w$和类间散度矩阵$S_b$</li>\n<li>根据$S_w^{-1}S_bW&#x3D;\\lambda W$来求解$S_w^{-1}S_b$所对应前$r$个最大特征值所对应特征向量$(w_1,w_2,…,w_r)$，构成矩阵W</li>\n<li>通过矩阵$W$将每个样本映射到低维空间，实现特征降维。</li>\n</ol>\n<p>具体不想看，考到就给了</p>\n<h1 id=\"Ada-Boosting\"><a href=\"#Ada-Boosting\" class=\"headerlink\" title=\"Ada Boosting\"></a>Ada Boosting</h1><p>。。看不懂懒得看</p>\n<h1 id=\"支持向量机\"><a href=\"#支持向量机\" class=\"headerlink\" title=\"支持向量机\"></a>支持向量机</h1><h1 id=\"生成学习模型\"><a href=\"#生成学习模型\" class=\"headerlink\" title=\"生成学习模型\"></a>生成学习模型</h1>",
            "tags": [
                "人工智能"
            ]
        },
        {
            "id": "http://example.com/2025/06/11/AI/week4-5/",
            "url": "http://example.com/2025/06/11/AI/week4-5/",
            "title": "Week4-5",
            "date_published": "2025-06-10T16:00:00.000Z",
            "content_html": "<p>#Ch3 搜索算法</p>\n<h2 id=\"无信息搜索\"><a href=\"#无信息搜索\" class=\"headerlink\" title=\"无信息搜索\"></a>无信息搜索</h2><p>BFS DFS 略</p>\n<h2 id=\"启发式搜索\"><a href=\"#启发式搜索\" class=\"headerlink\" title=\"启发式搜索\"></a>启发式搜索</h2><ul>\n<li>贪婪优先搜索<ul>\n<li>每次取最短的；缺点：不一定是最优的</li>\n<li>时间和空间复杂度均为 $O(b_m)$，b是搜索树分支因子，m是最大深度<br><img data-src=\"/figure1.png\"><br>:::info<br>每次取当前节点的下一个节点到终点中直线距离最短的<br>:::</li>\n</ul>\n</li>\n<li>A*算法<ul>\n<li>评价函数：f(n) &#x3D; g(n) + h(n)</li>\n<li>代价函数 g(n) 表示从起始结点到结点n的开销代价值</li>\n<li>启发函数 h(n) 表示从结点n到目标结点路径中所估算的最小开销代价值。</li>\n<li>评价函数 f(n) 可视为经过结点n、具有最小开销代价值的路径。<ul>\n<li>在最短路径问题中，g(?)为当前选择的路径的实际距离，即从上一个节点到下一个节点的实际距离，?(?)为下一个节点到目标城市的直线距离。每一次搜索，下一个节点选择与此刻城市连接的所有节点中，g(?)+?(?)最小的城市节点。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>:::info<br>取（当前节点到下一节点的距离+下一节点到目标城市的距离）最短的<br>:::<br>A*算法的完备性和最优性取决于搜索问题和启发函数的性质<br>一个良好的启发函数需要满足:可容性（admissible）;一致性（consistency）<br>如果启发函数是可容的，那么树搜索的A*算法满足最优性(最优性:搜索算法是否能保证找到的第一个解是最优解)<br>满足一致性条件的启发函数一定满足可容性条件，反之不一定</p>\n<h2 id=\"对抗搜索\"><a href=\"#对抗搜索\" class=\"headerlink\" title=\"对抗搜索\"></a>对抗搜索</h2><ul>\n<li><p>最小最大搜索（minimax）</p>\n<ul>\n<li>最小最大搜索是一个在你和对手轮流行动的情况下，为你自己寻找最优策略的算法。</li>\n<li>算法：略</li>\n<li>时间复杂度：$O(b^m)$</li>\n<li>空间复杂度：$O(bm)$</li>\n</ul>\n</li>\n<li><p>\\alpha-\\beta剪枝</p>\n<ul>\n<li>Minimax 会穷举整个博弈树，但我们可以用剪枝技巧跳过一些无用分支，让它跑得更快</li>\n<li>max层的下界取下一层（上界）里面最大的；min层的上界取下一层（下界）里面最小的<br>懒得写直接看例子：<br><img data-src=\"/figure2.png\"><br> Alpha-Beta 剪枝算法什么时候扩展的结点数量最少？</li>\n<li>每一层最左端结点的所有孩子结点均被访问，其他节点仅有最左端孩子结点被访问、其他孩子结点被剪枝。<br> 如果一个节点导致了其兄弟节点被剪枝，可知其孩子节点必然被扩展。</li>\n<li>最优效率下时间复杂度：$O(b^{m&#x2F;2})$  (或者m+1);最差的就是完全没剪枝和minimax一样</li>\n</ul>\n</li>\n<li><p>蒙特卡洛树搜索</p>\n<ul>\n<li>选择(UCB)、扩展、模拟(随机)、反向传播</li>\n<li>悔值函数<br>:::info<br>没完全懂，后面再回来研究<br>:::</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "人工智能"
            ]
        },
        {
            "id": "http://example.com/2025/05/20/AI/week1/",
            "url": "http://example.com/2025/05/20/AI/week1/",
            "title": "Week1",
            "date_published": "2025-05-19T16:00:00.000Z",
            "content_html": "<blockquote>\n<p>2025-2026春夏人工智能课程笔记</p>\n</blockquote>\n<h1 id=\"Ch1-绪论\"><a href=\"#Ch1-绪论\" class=\"headerlink\" title=\"Ch1 绪论\"></a>Ch1 绪论</h1><ul>\n<li>人工智能求解：<ul>\n<li>以符号主义为核心的逻辑推理：将概念（如命题等）符号化，从若干判断（前提）出发得到新判断（结论）</li>\n<li>以问题求解为核心的探寻搜索:探寻搜索依据已有信息来寻找满足约束条件的待求解问题的答案</li>\n<li>以数据驱动为核心的机器学习:从数据中发现数据所承载语义（如概念）的内在模式</li>\n<li>以行为主义为核心的强化学习:根据环境所提供的奖罚反馈来学习所处状态可施加的最佳行动，在“探索（未知空间）-利用（已有经验）（exploration vs. exploitation）”之间寻找平衡，完成某个序列化任务，具备自我学习能力</li>\n<li>以博弈对抗为核心的群体智能:从“数据拟合”优化解的求取向“均衡解”的求取迈进</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "人工智能"
            ]
        },
        {
            "id": "http://example.com/2025/05/20/AI/week2-3/",
            "url": "http://example.com/2025/05/20/AI/week2-3/",
            "title": "Week2-3",
            "date_published": "2025-05-19T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch2-知识表达与推理\"><a href=\"#Ch2-知识表达与推理\" class=\"headerlink\" title=\"Ch2 知识表达与推理\"></a>Ch2 知识表达与推理</h1><h2 id=\"命题逻辑\"><a href=\"#命题逻辑\" class=\"headerlink\" title=\"命题逻辑\"></a>命题逻辑</h2><p><img data-src=\"/img1.png\"><br>真值表：<br><img data-src=\"/img2.png\"></p>\n<blockquote>\n<p>“条件”命题联结词中前提为假时命题结论永远为真，bi-conditional只有两个都是true或者都是false才是true<br>逻辑等价：给定命题p和命题q，如果&#x3D;&#x3D;p和q在所有情况下都具有同样真假结果&#x3D;&#x3D;，那么p和q在逻辑上等价，一般用 $\\equiv$ 来表示，即p $\\equiv$ q。<br>判断逻辑等价：画真值表<br>逻辑等价式：<br><img data-src=\"/img3.jpg\"><br><img data-src=\"/img4.png\"></p>\n</blockquote>\n<ul>\n<li>normal form<ul>\n<li>有限个简单合取式构成的析取式称为析取(or)范式</li>\n<li>由有限个简单析取式构成的合取式称为合取(and)范式</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"谓词逻辑\"><a href=\"#谓词逻辑\" class=\"headerlink\" title=\"谓词逻辑\"></a>谓词逻辑</h2><ul>\n<li>全称量词与存在量词</li>\n<li>约束变元、自由变元<br>:::info<br>在约束变元相同的情况下，量词的运算满足分配律：全称量词对析取没有分配律、存在量词对合取没有分配律<br>:::<br>$$\\begin{aligned}<br>(\\forall x)(A(x) \\lor B(x)) \\equiv (\\forall x)A(x) \\lor (\\forall x)B(x) 不成立<br>\\end{aligned}$$</li>\n</ul>\n<p>$$\\begin{aligned}<br>(\\forall x)(A(x) \\land B(x)) \\equiv (\\forall x)A(x) \\land (\\forall x)B(x) 成立<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>(\\exists x)(A(x) \\lor B(x)) \\equiv (\\exists x)A(x) \\lor (\\exists x)B(x) 成立<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>(\\exists x)(A(x) \\land B(x)) \\equiv (\\exists x)A(x) \\land (\\exists x)B(x) 不成立<br>\\end{aligned}$$<br>:::info<br>当公式中存在多个量词时，若多个量词都是全称量词或者都是存在量词，则量词的位置可以互换；若多个量词中既有全称量词又有存在量词，则量词的位置不可以随意互换<br>:::<br>$$\\begin{aligned}<br>(\\forall x)(\\forall y)A(x, y) \\equiv (\\forall y)(\\forall x)A(x, y)<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>(\\exists x)(\\exists y)A(x, y) \\equiv (\\exists y)(\\exists x)A(x, y)<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>(\\forall x)(\\forall y)A(x, y) \\equiv (\\exists y)(\\forall x)A(x, y)<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>(\\forall x)(\\forall y)A(x, y) \\equiv (\\exists x)(\\forall y)A(x, y)<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>(\\exists y)(\\forall x)A(x, y) \\equiv (\\forall x)(\\exists y)A(x, y)<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>(\\exists x)(\\forall y)A(x, y) \\equiv (\\forall y)(\\exists x)A(x, y)<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>(\\forall x)(\\exists y)A(x, y) \\equiv (\\exists y)(\\exists x)A(x, y)<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>(\\forall y)(\\exists x)A(x, y) \\equiv (\\exists x)(\\exists y)A(x, y)<br>\\end{aligned}$$</p>\n<ul>\n<li>利用谓词逻辑进行推理<ul>\n<li>全称量词消去： $(\\forall x) A(x) \\equiv A(y)$</li>\n<li>全称量词引入： $A(y) \\equiv (\\forall x) A(x)$</li>\n<li>存在量词消去： $(\\exists x) A(x) \\equiv A(c)$</li>\n<li>存在量词引入： $A(c) \\equiv (\\exists x) A(x)$</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"知识图谱推理\"><a href=\"#知识图谱推理\" class=\"headerlink\" title=\"知识图谱推理\"></a>知识图谱推理</h2><ul>\n<li>知识图谱可视为包含多种关系的图。在图中，每个节点是一个实体（如人名、地名、事件和活动等），任意两个节点之间的边表示这两个节点之间存在的关系。</li>\n<li>可将知识图谱中任意两个相连节点及其连接边表示成一个三元组（triplet）,即 (left_node, relation, right_node)<br>两类代表性方法：</li>\n<li>归纳逻辑程序设计 (inductive logic programming，ILP)算法</li>\n<li>路径排序算法（path ranking algorithm, PRA）</li>\n</ul>\n<p>ILP: 一阶归纳学习FOIL（First Order Inductive Learner）<br>推理手段: 正例集合 + 反例集合 + 背景知识样例 ⟹ 目标谓词作为结论的推理规则<br><img data-src=\"/img5.png\"><br>懒得写了，看ppt吧<br><img data-src=\"/img6.png\"><br>推理规则覆盖所有正例且不覆盖任何反例的时候算法结束</p>\n<p>PRA: 路径排序算法<br><img data-src=\"/img7.png\"><br>(4)的意思是看两个实体能不能通过(3)的关系从第一个走到第二个。<br>后面的1表示正例，-1表示负例。</p>\n<h2 id=\"概率图推理\"><a href=\"#概率图推理\" class=\"headerlink\" title=\"概率图推理\"></a>概率图推理</h2><p>贝叶斯网络<br><img data-src=\"/img14.png\"><br>要会算</p>\n<p>马尔科夫逻辑网络</p>\n<h2 id=\"因果推理\"><a href=\"#因果推理\" class=\"headerlink\" title=\"因果推理\"></a>因果推理</h2><p>因果定义：变量X是变量Y的原因，当且仅当保持其它所有变量不变的情况下，改变X的值能导致Y的值发生变化。<br>因果效应：因变量X改变一个单位时，果变量Y的变化程度</p>\n<p>因果图是有向无环图</p>\n<p>结构因果模型：结构因果模型由两组变量集合U和V以及一组函数f组成。其中，f是根据模型中其他变量取值而给V中每一个变量赋值的函数<br>结构因果模型中的原因：如果变量X出现在给变量X赋值的函数中，如$Y &#x3D; f(X) + \\epsilon$，则X是Y的直接原因<br>因果图中的联合概率分布：直接看图<br><img data-src=\"/img8.png\"><br>因果图的基本结构：</p>\n<ul>\n<li>链结构<br>  - <img data-src=\"/img9.png\"><br>  - 对于变量X和Y，若X和Y之间只有一条单向的路径，变量Z是截断(intercept)该路径的集合中的任一变量，则在给定Z时，X和Y条件独立。</li>\n</ul>\n<p>$$<br>P(X, Y | Z) &#x3D; P(X | Z)P(Y | Z)<br>$$</p>\n<ul>\n<li>分连结构<br>  - <img data-src=\"/img10.png\"></li>\n</ul>\n<p>$$<br>P(X, Y | Z) &#x3D; \\frac {P(X, Y, Z)}{P(Z)} &#x3D; \\frac {P(X | Z)P(Y | Z)P(Z)}{P(Z)} &#x3D; P(X | Z)P(Y | Z)<br>$$</p>\n<ul>\n<li>汇联结构<br>  - <img data-src=\"/img11.jpg\"></li>\n</ul>\n<p>$$<br>P(X, Y | Z) &#x3D; \\frac{P(X, Y, Z)} {P(Z)} &#x3D; \\frac {P(X, Y, Z)}{P(Z)} &#x3D; \\frac {P(X)P(Y)P(Z&#x2F;X, Y)}{P(Z)} \\neq P(X | Z)P(Y | Z)<br>$$</p>\n<h3 id=\"D-分离-directional-separation-d-separation-，可用于判断任意两个节点的相关性和独立性\"><a href=\"#D-分离-directional-separation-d-separation-，可用于判断任意两个节点的相关性和独立性\" class=\"headerlink\" title=\"D-分离(directional separation, d-separation)，可用于判断任意两个节点的相关性和独立性\"></a>D-分离(directional separation, d-separation)，可用于判断任意两个节点的相关性和独立性</h3><ul>\n<li>限定集：已知或观察到的变量集合（给定的变量集合）</li>\n<li>路径p被限定集Z阻塞(block)当且仅当：<ul>\n<li>(1) 路径p含有链结构A → B → C或分连结构A ← B → C且中间节点B在Z中，或</li>\n<li>(2) 路径p含有汇连结构A → B ← C且汇连节点B及其后代都不在Z中。</li>\n<li>若Z阻塞了节点X和节点Y之间的每一条路径，则称给定Z时，X和Y是D-分离，即给定Z时，X和Y条件独立</li>\n<li>&#x3D;&#x3D;链式、分连中间节点在，汇联中间节点和后代不在则D-分离&#x3D;&#x3D;</li>\n</ul>\n</li>\n</ul>\n<p>因果定义：变量X是变量Y的原因，当且仅当保持其它所有变量不变的情况下，改变X的值能导致Y的值发生变化。<br>因果效应：因变量X改变一个单位时，果变量Y的变化程度因果推理的两个关键因素：</p>\n<ul>\n<li>改变因变量T</li>\n<li>保证其它变量不变<br>干预：干预(intervention)指的是固定(fix)系统中的变量，然后改变系统，观察其他变量的变化。<br>为了与X自然取值x时进行区分，在对X进行干预时，引入“do算子”(do-calculus)，记作do(X &#x3D; x)。<br>因此，P(Y &#x3D; y|X &#x3D; x)表示的是当发现X &#x3D; x时，Y&#x3D; y的概率；而P(Y &#x3D; y|do(X &#x3D;x))表示的是对X进行干预，固定其值为x时，Y &#x3D; y的概率。<br>用统计学的术语来说，P(Y &#x3D; y|X &#x3D; x)反映的是在取值为x的个体X上，Y的总体分布；而P(Y &#x3D; y|do(X &#x3D;x))反映的是如果将每一个X取值都固定为x时，Y的总体分布。</li>\n</ul>\n<p>因果效应差&#x2F;平均因果效应 (ACE)  懒得写了看图吧<br><img data-src=\"/img12.png\"><br><img data-src=\"/img13.png\"><br>计算因果效应的关键在于计算操纵概率(manipulatedprobability) $P_m$<br>调整公式：<br>$$<br>P(Y &#x3D; y \\mid do(X &#x3D; x)) &#x3D; \\sum_z P(Y &#x3D; y \\mid X &#x3D; x, Z &#x3D; z) \\cdot P(Z &#x3D; z)<br>$$<br>对于Z的每一个取值z，计算X和Y的条件概率并取均值<br>+++info example<br>;;;id3 例题<br>假设我们研究以下变量：</p>\n<ul>\n<li>X：是否服药  <ul>\n<li>$X &#x3D; 1$：服药  </li>\n<li>$X &#x3D; 0$：不服药</li>\n</ul>\n</li>\n<li>Y：是否康复  <ul>\n<li>$Y &#x3D; 1$：康复  </li>\n<li>$Y &#x3D; 0$：未康复</li>\n</ul>\n</li>\n<li>Z：性别  <ul>\n<li>$Z &#x3D; 0$：男  </li>\n<li>$Z &#x3D; 1$：女<br>我们知道性别会影响：</li>\n</ul>\n</li>\n<li>是否选择服药（比如男性更倾向于尝试新药）</li>\n<li>康复率（比如女性可能有更强的免疫力）<br>因此，性别 Z 是一个混杂变量，需要在分析中进行控制。<br>已知：<table>\n<thead>\n<tr>\n<th>Z（性别）</th>\n<th>P(Z)</th>\n<th>P(Y&#x3D;1 | X&#x3D;1, Z)</th>\n<th>P(Y&#x3D;1 | X&#x3D;0, Z)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>男（0）</td>\n<td>0.6</td>\n<td>0.7</td>\n<td>0.4</td>\n</tr>\n<tr>\n<td>女（1）</td>\n<td>0.4</td>\n<td>0.5</td>\n<td>0.3</td>\n</tr>\n<tr>\n<td>我们想知道：</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>如果强制所有人都服药（即 $do(X&#x3D;1)$），整体康复率是多少？</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>也就是要计算：</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>$$</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>P(Y&#x3D;1 \\mid do(X&#x3D;1))</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>$$</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>;;;</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>;;;id3 答案</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>根据调整公式：</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<p>$$<br>P(Y&#x3D;1 \\mid do(X&#x3D;1)) &#x3D; \\sum_z P(Y&#x3D;1 \\mid X&#x3D;1, Z&#x3D;z) \\cdot P(Z&#x3D;z)<br>$$</p>\n<p>代入数据计算</p>\n<p>$$<br>P(Y&#x3D;1 \\mid do(X&#x3D;1)) &#x3D; P(Y&#x3D;1 \\mid X&#x3D;1, Z&#x3D;0) \\cdot P(Z&#x3D;0) + P(Y&#x3D;1 \\mid X&#x3D;1, Z&#x3D;1) \\cdot P(Z&#x3D;1)<br>$$</p>\n<p>$$<br>&#x3D; 0.7 \\times 0.6 + 0.5 \\times 0.4 &#x3D; 0.42 + 0.2 &#x3D; 0.62<br>$$<br>+++</p>\n<p>(因果效应)给定因果图G，PA表示X的父节点集合，则X对Y的因果效应为<br>$$<br>P(Y&#x3D;y \\mid do(X&#x3D;x)) &#x3D; \\sum_z P(Y&#x3D;y \\mid X&#x3D;x, PA&#x3D;z) \\cdot P(PA&#x3D;z)<br>$$<br>后门调整：<br>不写了</p>\n",
            "tags": [
                "人工智能"
            ]
        },
        {
            "id": "http://example.com/2025/05/14/computer-science/computer-organization/ch2/",
            "url": "http://example.com/2025/05/14/computer-science/computer-organization/ch2/",
            "title": "Ch2",
            "date_published": "2025-05-13T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch2-数据的表示和运算\"><a href=\"#Ch2-数据的表示和运算\" class=\"headerlink\" title=\"Ch2 数据的表示和运算\"></a>Ch2 数据的表示和运算</h1><h2 id=\"2-1-进位计数制及其相互转换\"><a href=\"#2-1-进位计数制及其相互转换\" class=\"headerlink\" title=\"2.1 进位计数制及其相互转换\"></a>2.1 进位计数制及其相互转换</h2><h3 id=\"2-1-1\"><a href=\"#2-1-1\" class=\"headerlink\" title=\"2.1.1\"></a>2.1.1</h3><ul>\n<li>十进制二进制八进制十六进制转换<ul>\n<li>略</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-1-2-定点数的编码表示\"><a href=\"#2-1-2-定点数的编码表示\" class=\"headerlink\" title=\"2.1.2 定点数的编码表示\"></a>2.1.2 定点数的编码表示</h3><ul>\n<li>定点数一般表示定点小数和定点整数，小数是符号位.xxx，整数是符号位xxxx.0</li>\n<li><blockquote>\n<p>感觉不是什么重要的东西，浮点数表示比较重要</p>\n</blockquote>\n</li>\n<li>原码，反码，补码<ul>\n<li>正数的原码反码补码相同</li>\n<li>原码表示的范围为 $-2^n+1 ~ 2^n-1$</li>\n<li>补码表示的范围为 $-2^n ~ 2^n-1$</li>\n<li>负数的原码是1+绝对值，反码是1+绝对值取反，补码是反码+1</li>\n</ul>\n</li>\n<li>移码：用来表示浮点数的阶码，只能表示整数<ul>\n<li>一般用移码表示浮点数的阶码，用补码表示定点整数<br>$$ [x]_移 &#x3D; 2^n + x $$<br>移码就是在真值x前面加一个offset，比如取offset为2^7，就在补码的第8位加上1</li>\n<li>比如正数10101，移码是10010101，负数-10101的补码是11101011，所以移码是01101011</li>\n<li>移码的作用是&#x3D;&#x3D;保持数据原有的大小顺序&#x3D;&#x3D;，移码大真值大，移码小真值小，所以可以直观地进行比较<br>:::warning<br>相同位数的补码和移码表示具有相同的数据表示范围，区别只是表示方法不同<br>补码与移码只差一个符号位。同一个数的补码和移码表示，其数值部分相同，而符号位相反。<br>:::</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-1-3-整数表示\"><a href=\"#2-1-3-整数表示\" class=\"headerlink\" title=\"2.1.3 整数表示\"></a>2.1.3 整数表示</h3><p>略</p>\n<h3 id=\"2-1-4\"><a href=\"#2-1-4\" class=\"headerlink\" title=\"2.1.4\"></a>2.1.4</h3><p>c中的强制转换<br>short转成unsigned short直接把二进制看成unsigned short，比如-1变成65535<br>int变成short直接截断<br>小字长转大字长不会改变值，如果是unsigned就会在前面补0，如果是有符号数就在前面补符号位<br>short转unsigned int，先对short进行符号扩展到int，再把它当做unsigned int，如果是unsigned short转int，就进行零扩展再看成int……</p>\n<p>一些题目<br>+++info example<br>;;;id3 t1<br>若$[x]_补 &#x3D; 1,x_1x_2x_3x_4x_5x_6$,其中$x_i$取0或1，若要x&gt;-32，应当满足：<br>C. $x_1$为1，$x_2…x_6$中至少有一位为1<br>1100000是-32，要比-32大所以绝对值要小，所以数值部分要大，所以$x_1$必须是1,后面随便有个1就行<br>;;;<br>;;;id3 t2<br>设x为正数，$[x]_补 &#x3D; 1,x_1x_2x_3x_4x_5$,若要x&lt;-16，应当满足：<br>C. $x_1$必须为0，其它任意<br>110000是-16，要小于-16所以数值部分绝对值要小，所以只要$x_1$为0就比-16小<br>;;;<br>;;;id3 t3<br>一个8位的二进制整数由2个“0”和6个“1”组成，采用补码或者移码表示，则<br>若采用移码表示，偏置值为127，则此整数最小为-64（偏置为127需要在补码加上1111111，&#x3D;&#x3D;要让数值最小，应该把1放低位&#x3D;&#x3D;，所以移码是00111111，补码是10111111是-64）</p>\n<blockquote>\n<p>：前面说过，移码大真值大，移码小真值小，所以要让数值最小把1放低位就行了</p>\n</blockquote>\n<p>若采用补码表示，则此整数最小为-97（10011111&#x3D;-97）<br>;;;<br>;;;id3 比较大小的方法<br>对于无符号数，数值大的数就大<br>对于有符号数的原码和反码比较大小：先看正负然后看数值，反码数值转成原码再比<br>对于补码比较大小，正数正常比较，负数数值部分越小，绝对值越大（前面1更多的数的绝对值越小，所以11111111是-1）<br>;;;<br>+++</p>\n<h2 id=\"2-2-运算方法和运算电路\"><a href=\"#2-2-运算方法和运算电路\" class=\"headerlink\" title=\"2.2 运算方法和运算电路\"></a>2.2 运算方法和运算电路</h2><h3 id=\"2-2-1-基本运算部件\"><a href=\"#2-2-1-基本运算部件\" class=\"headerlink\" title=\"2.2.1 基本运算部件\"></a>2.2.1 基本运算部件</h3><h4 id=\"一位全加器\"><a href=\"#一位全加器\" class=\"headerlink\" title=\"一位全加器\"></a>一位全加器</h4><ul>\n<li>用真值表实现的：进位C，和S<table>\n<thead>\n<tr>\n<th align=\"center\">A</th>\n<th align=\"center\">B</th>\n<th align=\"center\">Cin</th>\n<th align=\"center\">Cout</th>\n<th align=\"center\">S</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n</tr>\n</tbody></table>\n<ul>\n<li>可以用卡诺图或者直接理解<br><img data-src=\"/img2.jpg\"><br>$$<br>\\begin{aligned}<br>S &amp;&#x3D; \\overline{A} , \\overline{B} , C_i + \\overline{A} , B , \\overline{C_i} + A , \\overline{B} , \\overline{C_i} + A , B , C_i \\<br>&amp;&#x3D; A \\oplus B \\oplus C_i<br>\\end{aligned}<br>$$<br>$$<br>\\begin{aligned}<br>Co &amp;&#x3D; AB + A \\overline{B} C_i + \\overline{A} B C_i \\<br>&amp;&#x3D; AB + (A \\oplus B) \\cdot C_i<br>\\end{aligned}<br>$$</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"串行进位加法器\"><a href=\"#串行进位加法器\" class=\"headerlink\" title=\"串行进位加法器\"></a>串行进位加法器</h4><ul>\n<li>把n个一位全加器连起来<br><img data-src=\"/img3.png\"><br>Carry Propagation &amp; Delay</li>\n</ul>\n<h4 id=\"并行进位加法器\"><a href=\"#并行进位加法器\" class=\"headerlink\" title=\"并行进位加法器\"></a>并行进位加法器</h4><p>对Cin进行look ahead</p>\n<p><img data-src=\"/img4.png\"></p>\n<p>前面提到：<br>$$<br>\\begin{aligned}<br>Co &amp;&#x3D; AB + A \\overline{B} C_i + \\overline{A} B C_i \\<br>   &amp;&#x3D; AB + (A \\oplus B) \\cdot C_i<br>\\end{aligned}<br>$$<br>下一位的Cin等于上一位的Cout，所以可以进行look ahead，这里让<br>$$<br>\\begin{aligned}<br>G_i &amp;&#x3D; A_iB_i<br>\\end{aligned}<br>$$<br>$$<br>\\begin{aligned}<br>P_i &amp;&#x3D; A_i \\oplus B_i<br>\\end{aligned}<br>$$<br>所以<br>$$<br>\\begin{aligned}<br>C_{i+1} &amp;&#x3D; G_i + P_iC_i<br>\\end{aligned}<br>$$<br>$$<br>\\begin{aligned}<br>S_i &amp;&#x3D; P_i \\oplus C_i<br>\\end{aligned}<br>$$<br>就能得到超前进位的效果</p>\n<h4 id=\"带标志加法器\"><a href=\"#带标志加法器\" class=\"headerlink\" title=\"带标志加法器\"></a>带标志加法器</h4><p><img data-src=\"/img5.jpg\"></p>\n<ul>\n<li>溢出标志 $OF &#x3D; C_n  \\oplus C_{n-1}$，只能判断有符号数是否溢出<br>-两个正数加起来变成负数或者两个负数加起来变成正数，就会溢出<table>\n<thead>\n<tr>\n<th align=\"center\">A</th>\n<th align=\"center\">B</th>\n<th align=\"center\">$C_{n-1}$</th>\n<th align=\"center\">F</th>\n<th align=\"center\">$C_n$</th>\n<th align=\"center\">OF</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<blockquote>\n<p>第二行A&#x3D;0, B&#x3D;0, F&#x3D;1，正+正&#x3D;负<br>  第七行A&#x3D;0, B&#x3D;1, F&#x3D;0，负+负&#x3D;正<br>  所以OF&#x3D;1，表示有溢出<br>  观察发现$OF &#x3D; C_{n-1}  \\oplus C_n$</p>\n</blockquote>\n<ul>\n<li>符号标志 $SF &#x3D; F_{n-1}$，输出的最高位决定有符号数的正负</li>\n<li><code>CF</code>进位&#x2F;借位标志：用于判断无符号数的加减运算是否溢出<ul>\n<li>$CF &#x3D; Cin \\oplus Cout$</li>\n<li>此处的Cin和Cout表示最开始的输入和最后的输出，还没理解</li>\n</ul>\n</li>\n<li><code>ZF</code>零标志 当且仅当所有F&#x3D;0时为1，否则为0（把所有F作或非）</li>\n<li><code>SF</code>符号标志位,结果为负，即符号位为1时SF&#x3D;1，否则为0<br>具体可以看这篇：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhYmJ5X19fXy9hcnRpY2xlL2RldGFpbHMvODA4MjU1NDk=\">https://blog.csdn.net/gabby____/article/details/80825549</span></li>\n</ul>\n<h4 id=\"ALU\"><a href=\"#ALU\" class=\"headerlink\" title=\"ALU\"></a>ALU</h4><p>略</p>\n<h3 id=\"2-2-2-定点数的移位运算\"><a href=\"#2-2-2-定点数的移位运算\" class=\"headerlink\" title=\"2.2.2 定点数的移位运算\"></a>2.2.2 定点数的移位运算</h3><ul>\n<li>左移一位*2，右移一位&#x2F;2</li>\n<li>逻辑移位：移完直接补0<ul>\n<li>无符号数若高位的1移出，则发生溢出</li>\n</ul>\n</li>\n<li>算数移位：有符号数右移时，补符号位，左移直接移，如果高位和符号位不同，则发生溢出</li>\n</ul>\n<h3 id=\"定点数的加减运算\"><a href=\"#定点数的加减运算\" class=\"headerlink\" title=\"定点数的加减运算\"></a>定点数的加减运算</h3><p>补码相加减，略<br>主要是溢出判断：符号相同的数相加或者符号相异的数相减会发生溢出</p>\n<ul>\n<li>一位符号位（参考前面OF）</li>\n<li>双符号位（模4补码）<ul>\n<li>符号位左边那一位表示正确的符号，0为正，1为负；右边那一位如果和左边的相同，如 “00”表示正且无溢出，”11”表示负且无溢出。如果右边那一位与左边那一位不一样，则表示有溢出</li>\n<li>溢出逻辑判断：若V为0则无溢出，V为1则溢出</li>\n<li>&#x3D;&#x3D;存储的时候，模4补码只需要一位符号位&#x3D;&#x3D;，因为任何一个正确的数值它的两个符号位是相同的。它只是把两个模4补码的数送往ALU进行运算的时候，把符号位同时送入ALU的双符号位中，即&#x3D;&#x3D;只在ALU中采用双符号位&#x3D;&#x3D;<br>$$<br>V &#x3D; S_{s1} \\oplus S_{s2}<br>$$<br>例子看这篇写的挺清楚：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1bl9ib3lfYm95X3N1bi9hcnRpY2xlL2RldGFpbHMvODc5MTcwMjA=\">https://blog.csdn.net/sun_boy_boy_sun/article/details/87917020</span><br>总之两位不同则有溢出</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"定点数的乘除运算\"><a href=\"#定点数的乘除运算\" class=\"headerlink\" title=\"定点数的乘除运算\"></a>定点数的乘除运算</h3><p>略，列竖式即可</p>\n<h3 id=\"浮点数的表示与运算\"><a href=\"#浮点数的表示与运算\" class=\"headerlink\" title=\"浮点数的表示与运算\"></a>浮点数的表示与运算</h3><ol>\n<li>浮点数的表示格式<br>$$<br>N &#x3D; (-1)^s \\cdot M \\cdot R^E<br>$$<br>s符号，M尾数，E阶码，R基数</li>\n<li>浮点数的表示范围<br>范围关于原点对称，运算结果大于最大正数时成为正上溢，小遇绝对值最大负数是成为负上溢，统称上溢。运算结果在0-最小整数之间成为正下溢，负数同理，统称下溢（原因是精度不够）</li>\n<li>浮点数的规格化<br>化成$1.xxxxx… \\cdot 2^n$的形式</li>\n<li>IEEE754<br>符号，阶码，尾数<br>32位单精度：1 8 23，偏置为$2^7-1&#x3D;127$，真值为$(-1)^s \\cdot 2^{e-127} \\cdot (1.M)$<br>单精度表示的最小值为$1 \\cdot 2^{1-127} \\cdot (1.000…) &#x3D; 2^{-126}$，最大值为$1 \\cdot 2^{254-127} \\cdot (1.111…) &#x3D; (2 - 2^{-23}) \\cdot 2^{127}$}<br>64位双精度：1 11 52，偏置为$2^{10}-1&#x3D;1023$，真值为$(-1)^s \\cdot 2^{e-1023} \\cdot (1.M)$，最大值为$1 \\cdot 2^{2046-1023} \\cdot (1.111…) &#x3D; (2 - 2^{-52}) \\cdot 2^{1023}$<br>阶码全为0或者全为1有特殊意义<br><img data-src=\"/f1.jpg\"><br>阶码全1尾数不全0表示无穷大<br>阶码全1尾数全0表示NaN<br>阶码全0尾数不全0表示非规格化数，隐藏位为0（精度不够表示，需要特殊处理）</li>\n</ol>\n<h3 id=\"浮点数的加减运算\"><a href=\"#浮点数的加减运算\" class=\"headerlink\" title=\"浮点数的加减运算\"></a>浮点数的加减运算</h3><ol>\n<li>对阶</li>\n<li>尾数相加减</li>\n<li>尾数规格化，修改阶数</li>\n<li>舍入</li>\n</ol>\n<ul>\n<li>就近舍入：舍入为最近的可表示数，当结果是两个可表示数的中间时，选择结果为偶数</li>\n<li>正向舍入：朝数轴正无穷方向舍入，取右边最近的可表示数</li>\n<li>负向舍入：和正向相反</li>\n<li>截断法：直接截取所需位数，是一种趋向原点的舍入</li>\n</ul>\n<ol start=\"5\">\n<li>溢出判断<br>对阶码加减时要判断是否溢出</li>\n</ol>\n",
            "tags": [
                "数据的表示与运算"
            ]
        },
        {
            "id": "http://example.com/2025/05/13/computer-science/computer-network/ch1/",
            "url": "http://example.com/2025/05/13/computer-science/computer-network/ch1/",
            "title": "Ch1",
            "date_published": "2025-05-12T16:00:00.000Z",
            "content_html": "",
            "tags": [
                "计算机网络"
            ]
        },
        {
            "id": "http://example.com/2025/05/13/computer-science/computer-organization/ch1/",
            "url": "http://example.com/2025/05/13/computer-science/computer-organization/ch1/",
            "title": "Ch1",
            "date_published": "2025-05-12T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch1-计算机系统概述\"><a href=\"#Ch1-计算机系统概述\" class=\"headerlink\" title=\"Ch1 计算机系统概述\"></a>Ch1 计算机系统概述</h1><h2 id=\"1-1-计算机发展历程\"><a href=\"#1-1-计算机发展历程\" class=\"headerlink\" title=\"1.1 计算机发展历程\"></a>1.1 计算机发展历程</h2><ul>\n<li>四代计算机：电子管-&gt;晶体管-&gt;集成电路-&gt;超大规模集成电路</li>\n<li>摩尔定律：集成电路上可以容纳的晶体管数目在大约每经过18个月到24个月便会增加一倍</li>\n</ul>\n<h2 id=\"1-2-计算机系统层次结构\"><a href=\"#1-2-计算机系统层次结构\" class=\"headerlink\" title=\"1.2 计算机系统层次结构\"></a>1.2 计算机系统层次结构</h2><ul>\n<li>计算机系统：硬件+软件</li>\n<li>对于某一功能，既能用软件实现又能用硬件实现，称为软、硬件在逻辑功能上是等价的</li>\n</ul>\n<h3 id=\"1-2-2-硬件\"><a href=\"#1-2-2-硬件\" class=\"headerlink\" title=\"1.2.2 硬件\"></a>1.2.2 硬件</h3><ul>\n<li>冯·诺依曼机的特点：<ul>\n<li>采用“存储程序”的工作方式</li>\n<li>冯·诺依曼计算机由五大部件组成：运算器、控制器、存储器、输入设备和输出设备</li>\n<li>指令和数据以同等地位存储在存储器中</li>\n<li>指令和数据均用二进制代码表示</li>\n<li>指令由操作码和地址码组成</li>\n<li><img data-src=\"/img1.png\"></li>\n</ul>\n</li>\n<li>计算机的功能部件：<ul>\n<li>输入设备</li>\n<li>输出设备</li>\n<li>存储器：主存+外存<ul>\n<li>CPU能直接访问的是主存</li>\n<li><img data-src=\"/img2.jpg\"></li>\n<li>MAR位10位则最多有$2^{10}$个存储单元</li>\n<li>在现代计算机中MAR和MDR存在CPU中</li>\n</ul>\n</li>\n<li>运算器：进行算术运算和逻辑运算<ul>\n<li>核心是ALU：通用寄存器有&#x3D;&#x3D;累加器(ACC)，乘商寄存器(MQ)，操作数寄存器(X)&#x3D;&#x3D;，变址寄存器(IX)，基址寄存器(BR)等，前三个必备</li>\n<li>程序状态寄存器(PSW)</li>\n<li><img data-src=\"/img3.jpg\"></li>\n</ul>\n</li>\n<li>控制器：由PC, IR和control unit组成<ul>\n<li>: RISCV控制器</li>\n<li><img data-src=\"/img4.png\"></li>\n</ul>\n</li>\n<li>CPU由运算器、控制器和cache组成</li>\n<li>总线有地址总线、数据总线、控制总线</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-2-3-软件\"><a href=\"#1-2-3-软件\" class=\"headerlink\" title=\"1.2.3 软件\"></a>1.2.3 软件</h3><ul>\n<li>组成：系统软件(OS, DBMS, 编译器, …)+应用软件</li>\n<li>语言：汇编语言、机器语言、高级语言<ul>\n<li>汇编器：把汇编语言翻译成机器语言</li>\n<li>编译器：把高级语言翻译成汇编语言或机器语言</li>\n<li>解释器：把高级语言翻译成&#x3D;&#x3D;机器语言&#x3D;&#x3D;(比如python)<br>  +++info example<br>  ;;;id3 题目<br>  :chestnut:<br>  将高级语言源程序转换为机器级目标代码文件的程序是 []。<br>  A. 汇编程序<br>  B. 链接程序<br>  C. 编译程序<br>  D. 解释程序<br>  ;;;<br>  ;;;id3 答案<br>  C. 编译程序<br>  因为解释程序不生成目标代码，编译器可以把高级语言翻译成汇编语言或者直接翻译成机器语言<br>  ;;;<br>  +++</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-2-4-计算机系统的层次结构\"><a href=\"#1-2-4-计算机系统的层次结构\" class=\"headerlink\" title=\"1.2.4 计算机系统的层次结构\"></a>1.2.4 计算机系统的层次结构</h3><ul>\n<li>看看就好</li>\n<li><img data-src=\"/img5.png\"></li>\n</ul>\n<h3 id=\"1-2-5-计算机系统的工作原理\"><a href=\"#1-2-5-计算机系统的工作原理\" class=\"headerlink\" title=\"1.2.5 计算机系统的工作原理\"></a>1.2.5 计算机系统的工作原理</h3><ul>\n<li>程序执行前，需要把所含的指令和数据一起放入主存中</li>\n<li>五个阶段：IF-ID-EX-MEM-WB</li>\n<li>c程序怎么变成可执行文件的：直接看图<ul>\n<li><img data-src=\"/img6.png\"></li>\n<li>汇编器把指令打包成可重定位目标代码文件：使用相对地址和符号引用来表示各个代码段之间的关系（代码段、数据段、符号表、重定位表…）使得代码或数据能在内存中任意位置加载或运行</li>\n</ul>\n</li>\n<li>指令执行过程：后面几章会具体讲</li>\n</ul>\n<h2 id=\"1-3-计算机的性能指标\"><a href=\"#1-3-计算机的性能指标\" class=\"headerlink\" title=\"1.3 计算机的性能指标\"></a>1.3 计算机的性能指标</h2><h3 id=\"1-3-1-主要性能指标\"><a href=\"#1-3-1-主要性能指标\" class=\"headerlink\" title=\"1.3.1 主要性能指标\"></a>1.3.1 主要性能指标</h3><ul>\n<li>字长：一次整数运算所能处理的二进制数据的位数<br> :::info<br> 机器字长、指令字长和存储字长<br> :::</li>\n<li>带宽<code>bandwidth</code>：总线一次能并行传送信息的位数</li>\n<li>主存容量</li>\n<li>运算速度<ul>\n<li>吞吐量<code>throughput</code>：一次输入数据所对应的输出数据个数</li>\n<li>响应时间<code>Response (Execution) time</code></li>\n<li>主频</li>\n<li>clock cycle time( &#x3D; 1&#x2F;CPU frequency)</li>\n<li>MIPS: million instructions per second</li>\n<li>FLOPS: floating-point operations per second<blockquote>\n<p>CPI: clock cycles per instruction(IPC: CPI的倒数)</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<p>$$ \\begin{aligned}<br>    \\text{CPU execution time} &amp;&#x3D; \\text{CPU clock cycles} \\times \\text{Clock cycle time} \\<br>    &amp;&#x3D; \\frac{\\text{CPU clock cycles}}{\\text{Clock rate}}<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>    \\text{CPU clock cycles} &amp;&#x3D; \\text{Instructions count} \\times \\text{Average cycles per instruction}<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>    \\text{CPU execution time} &amp;&#x3D; \\text{CPU clock cycles} \\times \\text{Clock cycle time} \\<br>    &amp;&#x3D; \\frac{\\text{CPU clock cycles}}{\\text{Clock rate}}<br>\\end{aligned} $$</p>\n<p>$$ \\begin{aligned}<br>     \\text{performance} &amp;&#x3D; \\frac{1}{\\text{CPU execution time}}<br>\\end{aligned}$$</p>\n<p>“Processor X is n times fast than Y” is<br>$$ \\begin{aligned}<br>    \\text{n} &amp;&#x3D; \\frac{\\text{CPU execution time of Y}}{\\text{CPU execution time of X}}<br>\\end{aligned}$$</p>\n<p>IPS: instructions per second<br>$$ \\begin{aligned}<br>    \\text{IPS} &amp;&#x3D; \\frac{\\text{CPU frequency}}{\\text{CPI}}<br>        &amp;&#x3D; \\frac{1}{\\text{CPU clock cycles} \\times \\text{CPU execution time}}<br>\\end{aligned}$$</p>\n<ul>\n<li>其他公式，，，用到再说吧</li>\n<li>兼容：软件或硬件的通用性</li>\n</ul>\n<blockquote>\n<p>在用于科学计算的计算机中，标志系统性能最有用的参数是浮点数运算相关的</p>\n<ul>\n<li>MFLOPS 10^6</li>\n<li>GFLOPS 10^9</li>\n<li>TFLOPS 10^12</li>\n<li>PFLOPS 10^15</li>\n<li>EFLOPS 10^18</li>\n<li>ZFLOPS 10^21</li>\n</ul>\n</blockquote>\n",
            "tags": [
                "计算机组成"
            ]
        },
        {
            "id": "http://example.com/2025/03/30/computer-science/compile-principles/ch5/",
            "url": "http://example.com/2025/03/30/computer-science/compile-principles/ch5/",
            "title": "语义分析",
            "date_published": "2025-03-29T16:00:00.000Z",
            "content_html": "<h1 id=\"语义分析\"><a href=\"#语义分析\" class=\"headerlink\" title=\"语义分析\"></a>语义分析</h1><blockquote>\n<p>绑定，类型检查</p>\n</blockquote>\n<h2 id=\"symbol-table\"><a href=\"#symbol-table\" class=\"headerlink\" title=\"symbol table\"></a>symbol table</h2><ul>\n<li><p>Imperative style: 命令式风格</p>\n<ul>\n<li>Modify $\\sigma_1$ until it becomes $\\sigma_2$. </li>\n<li>While $\\sigma_2$ exists, we cannot look things up in $\\sigma_1$. </li>\n<li>When done with $\\sigma_2$, can undo the modification to get $\\sigma_1$ back again.<br>+++info 方法：<br>Hashing<br>插入：找到哈希值然后插入链表的表头<br>查找：找到哈希值然后遍历链表<br>pop: 找到哈希值然后把链表表头删掉  table[hash(key)] &#x3D; table[hash(key)].next<br>+++</li>\n</ul>\n</li>\n<li><p>Functional style: 函数式风格</p>\n<ul>\n<li>To keep $\\sigma_1$ in pristine condition while creating create $\\sigma_2$ and $\\sigma_3$<br>+++info 方法：<br>如果依旧用哈希，每次要复制一遍哈希表，开销太大了，不现实<br><img data-src=\"/f2.jpg\"><br>所以用persistent BST<br><img data-src=\"/f1.jpg\"><br>先遍历二叉搜索树找到要插入的位置，然后对于插入节点把它从根节点到它全都复制一遍然后插入<br>+++</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Tiger编译器中的符号\"><a href=\"#Tiger编译器中的符号\" class=\"headerlink\" title=\"Tiger编译器中的符号\"></a>Tiger编译器中的符号</h2><p>对链表进行lookup的时候每一次都要进行string compare，开销是很大的。所以使用新的数据结构将符号对象关联到一个整数上，因此对于任意给定字符串的所有不同出现，都会被转换成同一个符号对象。<br>Symbol的实现：通过hash函数将字符串映射到一个symbol对象上<br>SymbolTable的实现：beginScope()和endScope()的实现</p>\n<ul>\n<li>beginScope()：添加一个marksym</li>\n<li>endScope()：从符号表中不断pop直到marksym</li>\n<li>引入一个 辅助栈(Auxiliary stack) 来维护<ul>\n<li>符号入栈时，会将binding联动地插入对应bucket的链表头</li>\n<li>弹出栈顶符号时，对应bucket的链表头也会联动地被移除</li>\n<li>beginScope: 压入一个特殊标记到辅助栈中</li>\n<li>endScope: 一直弹出符号直到弹出了一个特殊标记</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"类型检查\"><a href=\"#类型检查\" class=\"headerlink\" title=\"类型检查\"></a>类型检查</h2><h3 id=\"哪些类型表达式是合法-非法的\"><a href=\"#哪些类型表达式是合法-非法的\" class=\"headerlink\" title=\"哪些类型表达式是合法&#x2F;非法的\"></a>哪些类型表达式是合法&#x2F;非法的</h3><p>Tiger的类型系统：</p>\n<ul>\n<li>两种primitive type: int, string</li>\n<li>两种constructed type: records, arrays</li>\n</ul>\n<p>文法</p>\n<ol>\n<li>typec → type type-id &#x3D; ty<ul>\n<li>这表示定义一个类型。<code>typec</code> 是一个类型定义的开始，它由关键字 <code>type</code>、一个类型标识符 <code>type-id</code> 和一个等号 <code>=</code> 后跟类型定义 <code>ty</code> 组成。</li>\n</ul>\n</li>\n<li>ty → type-id<ul>\n<li>这表示类型 <code>ty</code> 可以直接是一个已定义的类型标识符 <code>type-id</code>。</li>\n</ul>\n</li>\n<li>ty → ‘{’ tyfields ‘}’<ul>\n<li>这表示类型 <code>ty</code> 可以是一个记录（record），由花括号 <code>&#123;&#125;</code> 包围的一系列字段 <code>tyfields</code> 定义。</li>\n</ul>\n</li>\n<li>ty → array of type-id<ul>\n<li>这表示类型 <code>ty</code> 可以是一个数组，由关键字 <code>array of</code> 后跟一个类型标识符 <code>type-id</code> 定义。</li>\n</ul>\n</li>\n<li>tyfields → ε<ul>\n<li>这表示字段列表 <code>tyfields</code> 可以为空（ε 表示空串）。</li>\n</ul>\n</li>\n<li>tyfields → id: type-id {, id:type-id}<ul>\n<li>这表示字段列表 <code>tyfields</code> 由一个或多个字段组成，每个字段由一个标识符 <code>id</code> 和冒号 <code>:</code> 后跟一个类型标识符 <code>type-id</code> 定义，多个字段之间用逗号 <code>,</code> 分隔。</li>\n</ul>\n</li>\n</ol>\n<p>示例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let type a = &#123;x: int; y: int&#125;</span><br><span class=\"line\">    type b = a</span><br><span class=\"line\">    var i : a := ...</span><br><span class=\"line\">    var j : b := ...</span><br><span class=\"line\">in i := j</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"类型等价\"><a href=\"#类型等价\" class=\"headerlink\" title=\"类型等价\"></a>类型等价</h3><ul>\n<li>Name equivalence (NE): 必须声明是同一个类型才是同一类型</li>\n<li>Structure equivalence (SE): 如果两个类型的结构完全相同（即它们由相同的构造器以相同的顺序组成），那么它们就被认为是等价的，即使它们的名字不同</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type A = &#123;x: int; y: int&#125;</span><br><span class=\"line\">type B = &#123;x: int; y: int&#125; </span><br></pre></td></tr></table></figure>\n<p>Tiger用的是NE<br>在Tiger编程语言中，存在两个独立的命名空间：一个用于类型（Types），另一个用于函数和变量（Functions and Variables）。所以类型和函数&#x2F;变量可以存在相同的名字，但是函数和变量不能存在相同的名字。<br>所以需要两个env</p>\n<ul>\n<li>Type env<ul>\n<li>symbol -&gt; Ty_ty</li>\n</ul>\n</li>\n<li>Value env<ul>\n<li>对于变量，symbol -&gt; Ty_ty</li>\n<li>对于函数，symbol -&gt; struct{Ty_tyList formals, Ty_ty results}</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"类型检查的rule\"><a href=\"#类型检查的rule\" class=\"headerlink\" title=\"类型检查的rule\"></a>类型检查的rule</h3><p>类型检查分为两部分:</p>\n<ul>\n<li>Type-checking expressions: 对于每个表达式，根据当前的Type和Value环境来确定其类型，并检查是否符合语言的类型规则</li>\n<li>Type-checking declarations: 在Tiger语言中声明只可能在let语句中出现<br>好像就是讲了transExp, transDec, transVar，AST递归检查每个节点的类型然后一层一层往上传再检查</li>\n</ul>\n",
            "tags": [
                "语义分析"
            ]
        },
        {
            "id": "http://example.com/2025/03/29/computer-science/compile-principles/ch4/",
            "url": "http://example.com/2025/03/29/computer-science/compile-principles/ch4/",
            "title": "抽象语法",
            "date_published": "2025-03-28T16:00:00.000Z",
            "content_html": "",
            "tags": [
                "抽象语法"
            ]
        },
        {
            "id": "http://example.com/2025/03/23/computer-science/compile-principles/ch3/",
            "url": "http://example.com/2025/03/23/computer-science/compile-principles/ch3/",
            "title": "语法分析",
            "date_published": "2025-03-22T16:00:00.000Z",
            "content_html": "<h1 id=\"语法分析\"><a href=\"#语法分析\" class=\"headerlink\" title=\"语法分析\"></a>语法分析</h1><h2 id=\"CFG\"><a href=\"#CFG\" class=\"headerlink\" title=\"CFG\"></a>CFG</h2><p>见计算理论<br>Parse tree</p>\n<h3 id=\"Ambiguous-grammars\"><a href=\"#Ambiguous-grammars\" class=\"headerlink\" title=\"Ambiguous grammars\"></a>Ambiguous grammars</h3><h2 id><a href=\"#\" class=\"headerlink\" title></a></h2>",
            "tags": [
                "语法分析"
            ]
        },
        {
            "id": "http://example.com/2025/03/22/computer-science/compile-principles/ch2/",
            "url": "http://example.com/2025/03/22/computer-science/compile-principles/ch2/",
            "title": "词法分析",
            "date_published": "2025-03-21T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch2-词法分析\"><a href=\"#Ch2-词法分析\" class=\"headerlink\" title=\"Ch2 词法分析\"></a>Ch2 词法分析</h1><blockquote>\n<p>把input分解成一个个token</p>\n</blockquote>\n<h2 id=\"Regular-Expression\"><a href=\"#Regular-Expression\" class=\"headerlink\" title=\"Regular Expression\"></a>Regular Expression</h2><ul>\n<li>Language: a set of strings</li>\n<li>String: a finite sequence of characters<blockquote>\n<p>Regular Experssion Notations:<br><img data-src=\"/image-1.png\"></p>\n</blockquote>\n</li>\n</ul>\n<p>:::info<br>DFA, NFA相关 见计算理论<br>:::</p>\n<h2 id=\"RE转NFA\"><a href=\"#RE转NFA\" class=\"headerlink\" title=\"RE转NFA\"></a>RE转NFA</h2><p>:::info 方法：</p>\n<ol>\n<li>画出初始态和终态</li>\n<li>分裂规则：<br><img data-src=\"/image-2.jpg\"><br>:::</li>\n</ol>\n<h2 id=\"NFA转DFA\"><a href=\"#NFA转DFA\" class=\"headerlink\" title=\"NFA转DFA\"></a>NFA转DFA</h2><p>从初始状态的闭包开始，每次根据\\epsilon和当前状态的闭包，得到下一个状态的闭包，直到得到终态的闭包。</p>\n<p>+++info example<br>;;;id3 题目<br>:chestnut:<br>把这个NFA转成等价的DFA<br><img data-src=\"/image-3.png\"><br>;;;<br>;;;id3 答案<br>初态的闭包是1、2、6，1、2、6经过a可以转移到3、7，因为有\\epsilon转移，所以3、7的闭包是3、4、7、8，同理3、4、7、8经过b可以到5、8，由于8是终态，把所有包含8的圆圈画成终态的环。<br><img data-src=\"/image-4.png\"><br>;;;<br>+++</p>\n<h2 id=\"最小化DFA\"><a href=\"#最小化DFA\" class=\"headerlink\" title=\"最小化DFA\"></a>最小化DFA</h2><p>含义：</p>\n<ol>\n<li>没有多余状态：</li>\n</ol>\n<ul>\n<li>从这个状态没有通路到达终态</li>\n<li>从开始状态出发，任何输入串也不能到达的那个状态</li>\n</ul>\n<ol start=\"2\">\n<li>没有两个状态相互等价<br>:::info 方法：</li>\n<li>多余状态直接删除<br><img data-src=\"/image-5.png\"></li>\n<li>合并等价状态</li>\n</ol>\n<ul>\n<li>将状态分为终态和非终态两个集合</li>\n<li>遍历每个集合，如果经过转换到达的状态都在当前集合里，则不用分，否则划分子集，直到划分不了为止</li>\n<li>:chestnut: 例子</li>\n<li><img data-src=\"/image-6.png\"><br>:::</li>\n</ul>\n",
            "tags": [
                "词法分析"
            ]
        },
        {
            "id": "http://example.com/2025/03/21/computer-science/compile-principles/ch1/",
            "url": "http://example.com/2025/03/21/computer-science/compile-principles/ch1/",
            "title": "Introduction",
            "date_published": "2025-03-20T16:00:00.000Z",
            "content_html": "<blockquote>\n<p>ZJU 2025春夏编译原理 学习笔记</p>\n<p>主要基于虎书（<em>Modern Compiler Implementation in C</em>, Andrew W. Appel）和好多老师的ppt（ldm, yps），还有lzx的智云</p>\n</blockquote>\n<h1 id=\"CH1-Introduction\"><a href=\"#CH1-Introduction\" class=\"headerlink\" title=\"CH1 Introduction\"></a>CH1 Introduction</h1><ul>\n<li>Two Important Concepts<ul>\n<li>Phases（阶段）</li>\n<li>Interfaces（接口）</li>\n</ul>\n</li>\n</ul>\n<p>方框里的是phase，中间的是interface<br><img data-src=\"/image.png\"><br>各个阶段的描述<br><img data-src=\"/image-1.png\"><img data-src=\"/image-2.png\"></p>\n",
            "tags": [
                "编译原理"
            ]
        },
        {
            "id": "http://example.com/2023/10/31/computer-science/DS/fds/",
            "url": "http://example.com/2023/10/31/computer-science/DS/fds/",
            "title": "fds课程笔记",
            "date_published": "2023-10-30T16:00:00.000Z",
            "content_html": "<h1 id=\"FDS复习\"><a href=\"#FDS复习\" class=\"headerlink\" title=\"FDS复习\"></a>FDS复习</h1><h2 id=\"期中模拟卷\"><a href=\"#期中模拟卷\" class=\"headerlink\" title=\"期中模拟卷\"></a>期中模拟卷</h2><h5 id=\"1-sqrt-N-logN-is-O-N\"><a href=\"#1-sqrt-N-logN-is-O-N\" class=\"headerlink\" title=\"1.$\\sqrt N logN$ is $O(N)$.\"></a>1.$\\sqrt N logN$ is $O(N)$.</h5><p>T</p>\n<h5 id=\"2-In-Union-Find-algorithm-if-Unions-are-done-by-size-the-depth-of-any-node-must-be-no-more-than-N-2-but-not-O-logN\"><a href=\"#2-In-Union-Find-algorithm-if-Unions-are-done-by-size-the-depth-of-any-node-must-be-no-more-than-N-2-but-not-O-logN\" class=\"headerlink\" title=\"2.In Union&#x2F;Find algorithm, if Unions are done by size, the depth of any node must be no more than N&#x2F;2 , but not $O(logN)$.\"></a>2.In <em>Union&#x2F;Find</em> algorithm, if <em>Unions</em> are done by size, the depth of any node must be no more than N&#x2F;2 , but not $O(logN)$.</h5><p>F</p>\n<p>每做一次归并，都会使得小的集合深度加1，但是总的深度还是看大的集合。只有深度相同的归并才能使得总的深度加1，2,2归并，深度变为3；3,3归并深度变为4。因此深度最大为**$log_2 N+1$**.</p>\n<h5 id=\"3-For-a-sequentially-stored-linear-list-of-length-N-the-time-complexities-for-query-and-insertion-are\"><a href=\"#3-For-a-sequentially-stored-linear-list-of-length-N-the-time-complexities-for-query-and-insertion-are\" class=\"headerlink\" title=\"3.For a sequentially stored linear list of length N, the time complexities for query and insertion are:\"></a>3.For a <code>sequentially stored</code> linear list of length <em>N</em>, the time complexities for query and insertion are:</h5><p>C.$O(1)$,$O(N)$.</p>\n<p>注意是顺序存储，因此查询只需要$O(1)$, 插入需要调整后面的元素的位置，因此是$O(N)$.</p>\n<h5 id=\"4-The-following-figure-shows-the-AOE-network-of-a-project-with-8-activities-The-earliest-and-the-latest-start-times-of-the-activity-d-are-respectively\"><a href=\"#4-The-following-figure-shows-the-AOE-network-of-a-project-with-8-activities-The-earliest-and-the-latest-start-times-of-the-activity-d-are-respectively\" class=\"headerlink\" title=\"4.The following figure shows the AOE network of a project with 8 activities. The earliest and the latest start times of the activity d are __, respectively.\"></a>4.The following figure shows the AOE network of a project with 8 activities. The earliest and the latest start times of the activity <code>d</code> are __, respectively.</h5><p><img data-src=\"https://images.ptausercontent.com/28de33de-076f-4f94-b856-445865994fb0.jpg\" alt=\"GRE19-5.jpg\"></p>\n<p>还没学，下次再来补</p>\n<h5 id=\"5-If-besides-finding-the-shortest-path-from-S-to-every-other-vertices-we-also-need-to-count-the-number-of-different-shortest-paths-we-can-modify-the-Dijkstra-algorithm-in-the-following-way-add-an-array-count-so-that-count-V-records-the-number-of-different-shortest-paths-from-S-to-V-Then-count-V-shall-be-initialized-as\"><a href=\"#5-If-besides-finding-the-shortest-path-from-S-to-every-other-vertices-we-also-need-to-count-the-number-of-different-shortest-paths-we-can-modify-the-Dijkstra-algorithm-in-the-following-way-add-an-array-count-so-that-count-V-records-the-number-of-different-shortest-paths-from-S-to-V-Then-count-V-shall-be-initialized-as\" class=\"headerlink\" title=\"5.If besides finding the shortest path from S to every other vertices, we also need to count the number of different shortest paths, we can modify the Dijkstra algorithm in the following way: add an array count[] so that count[V] records the number of different shortest paths from S to V. Then count[V] shall be initialized as:\"></a>5.If besides finding the shortest path from <code>S</code> to every other vertices, we also need to count the number of different shortest paths, we can modify the Dijkstra algorithm in the following way: add an array <code>count[]</code> so that <code>count[V]</code> records the number of different shortest paths from <code>S</code> to <code>V</code>. Then <code>count[V]</code> shall be initialized as:</h5><p>A. count[S]&#x3D;1; and count[V]&#x3D;0 for other V</p>\n<p>还没学应该不考，下次再来补</p>\n<h5 id=\"6-程序填空题-Reverse-Linked-List\"><a href=\"#6-程序填空题-Reverse-Linked-List\" class=\"headerlink\" title=\"6.程序填空题  Reverse Linked List\"></a>6.程序填空题  Reverse Linked List</h5><p>The function is to return the reverse linked list of <code>L</code>, with a dummy head.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List <span class=\"title function_\">Reverse</span><span class=\"params\">( List L )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Position Old_head, New_head, Temp;</span><br><span class=\"line\">    New_head = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    Old_head = L-&gt;Next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( Old_head )  &#123;</span><br><span class=\"line\">        Temp = Old_head-&gt;Next;</span><br><span class=\"line\">        Old_head-&gt;Next = New_head;</span><br><span class=\"line\">        New_head = Old_head;  </span><br><span class=\"line\">        Old_head = Temp; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    L-&gt;Next = New_head;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>先把下一个节点用temp存起来，然后把当前节点指向上一个节点，然后移动上一个节点的指针到当前节点，把当前节点指针移动到下一节点。</p>\n<h5 id=\"7-程序填空题-MinHeap-Deletion\"><a href=\"#7-程序填空题-MinHeap-Deletion\" class=\"headerlink\" title=\"7.程序填空题  MinHeap Deletion\"></a>7.程序填空题  MinHeap Deletion</h5><p>Please fill in the blanks in the program which deletes a given element at position <code>p</code> from a min-heap <code>H</code>.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Deletion ( PriorityQueue H,  <span class=\"type\">int</span> p )  <span class=\"comment\">/* delete the element H-&gt;Elements[p] */</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   ElementType temp;</span><br><span class=\"line\">   <span class=\"type\">int</span> child;</span><br><span class=\"line\"></span><br><span class=\"line\">   temp = H-&gt; Elements[ H-&gt;Size-- ];</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( temp &lt; H-&gt;Elements[p] ) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> ( (p != <span class=\"number\">1</span>) &amp;&amp; (temp &lt; H-&gt;Elements[p/<span class=\"number\">2</span>]) ) &#123; </span><br><span class=\"line\">         H-&gt;Elements[p] = H-&gt;Elements[p/<span class=\"number\">2</span>]；</span><br><span class=\"line\">         p /= <span class=\"number\">2</span>;</span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">while</span>( (child = <span class=\"number\">2</span>*p) &lt;= H-&gt;Size) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> ( child != H-&gt;Size &amp;&amp; H-&gt;Elements[child] &lt; H-&gt;Elements[child + <span class=\"number\">1</span>] )</span><br><span class=\"line\">            child ++;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> ( temp &gt; H-&gt;Elements[child] ) &#123;</span><br><span class=\"line\">            H-&gt;Elements[p] = H-&gt;Elements[child];</span><br><span class=\"line\">            p = child;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   H-&gt;Elements[p] = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"HW1\"><a href=\"#HW1\" class=\"headerlink\" title=\"HW1\"></a>HW1</h2><h5 id=\"1-2-The-Fibonacci-number-sequence-F-N-is-defined-as-F-0-0-F-1-1-F-N-F-N-1-F-N-2-N-2-3-…-The-time-complexity-of-the-function-which-calculates-F-N-recursively-is-Theta-N\"><a href=\"#1-2-The-Fibonacci-number-sequence-F-N-is-defined-as-F-0-0-F-1-1-F-N-F-N-1-F-N-2-N-2-3-…-The-time-complexity-of-the-function-which-calculates-F-N-recursively-is-Theta-N\" class=\"headerlink\" title=\"1-2 The Fibonacci number sequence {$F_N$} is defined as: $F_0&#x3D;0,F_1&#x3D;1,$ $F_N&#x3D;F_{N-1}+F_{N-2}$, N&#x3D;2, 3, …. The time complexity of the function which calculates $F_N$ recursively is $\\Theta(N!)$.\"></a>1-2 The Fibonacci number sequence {$F_N$} is defined as: $F_0&#x3D;0,F_1&#x3D;1,$ $F_N&#x3D;F_{N-1}+F_{N-2}$, <em>N</em>&#x3D;2, 3, …. The time complexity of the function which calculates $F_N$ recursively is $\\Theta(N!)$.</h5><p>F</p>\n<p>递归求斐波那契数的时间复杂度是$O(2^N)$.</p>\n<p>二叉树的高度是 n-1，一个高度为k的二叉树最多可以由 $2^k-1$个叶子节点，也就是递归过程函数调用的次数，所以时间复杂度为 $O(2^N)$，而空间复杂度就是树的高度 $S(N)$.</p>\n<h5 id=\"2-1-Given-the-following-four-algorithms-with-their-runtimes-for-problem-size-100-and-their-time-complexities\"><a href=\"#2-1-Given-the-following-four-algorithms-with-their-runtimes-for-problem-size-100-and-their-time-complexities\" class=\"headerlink\" title=\"2-1 Given the following four algorithms with their runtimes for problem size 100 and their time complexities:\"></a>2-1 Given the following four algorithms with their runtimes for problem size 100 and their time complexities:</h5><table>\n<thead>\n<tr>\n<th>Algorithm</th>\n<th>Runtime</th>\n<th>Time Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>A</td>\n<td>100</td>\n<td>$O(N)$</td>\n</tr>\n<tr>\n<td>B</td>\n<td>50</td>\n<td>$O(N^2)$</td>\n</tr>\n<tr>\n<td>C</td>\n<td>2</td>\n<td>$O(N^3)$</td>\n</tr>\n<tr>\n<td>D</td>\n<td>10</td>\n<td>$O(N^4)$</td>\n</tr>\n</tbody></table>\n<p><strong>Which algorithm is the fastest for problem size 200?</strong></p>\n<p>D</p>\n<p>200 &#x3D; 100*2</p>\n<p>A 100*2 &#x3D; 200</p>\n<p>B 50 * $2^2$&#x3D;200</p>\n<p>C 25*$2^3$&#x3D;200</p>\n<p>&#x3D;&#x3D;D 10*$2^4$&#x3D;160 最快&#x3D;&#x3D;</p>\n<h5 id=\"2-3-The-recurrent-equations-for-the-time-complexities-of-programs-P1-and-P2-are\"><a href=\"#2-3-The-recurrent-equations-for-the-time-complexities-of-programs-P1-and-P2-are\" class=\"headerlink\" title=\"2-3 The recurrent equations for the time complexities of programs P1 and P2 are:\"></a>2-3 The recurrent equations for the time complexities of programs P1 and P2 are:</h5><ul>\n<li>P1: <em>T</em>(1)&#x3D;1,<em>T</em>(<em>N</em>)&#x3D;<em>T</em>(<em>N</em>&#x2F;3)+1</li>\n<li>P2: <em>T</em>(1)&#x3D;1,<em>T</em>(<em>N</em>)&#x3D;3<em>T</em>(<em>N</em>&#x2F;3)+1</li>\n</ul>\n<p>Then the correct conclusion about their time complexities is:</p>\n<p>A.they are both <em>O</em>(log<em>N</em>)</p>\n<p>B.O*(log*N) for P1, <em>O</em>(<em>N</em>) for P2</p>\n<p>C.they are both <em>O</em>(<em>N</em>)</p>\n<p>D.<em>O</em>(log<em>N</em>) for P1, <em>O</em>(<em>N</em>log<em>N</em>) for P2</p>\n<p><strong>B</strong></p>\n<p>$T(N)&#x3D;T(N&#x2F;3)+1&#x3D;T(N&#x2F;3&#x2F;3)+1+1&#x3D;…&#x3D;O(logN)$</p>\n<p>$T(N)&#x3D;3T(N&#x2F;3)+1&#x3D;3(3T(N&#x2F;3&#x2F;3)+1)+1&#x3D;…&#x3D;3^{log_3N}&#x3D;O(N)$</p>\n<h5 id=\"R1-2-logN-2-is-O-N\"><a href=\"#R1-2-logN-2-is-O-N\" class=\"headerlink\" title=\"R1-2 $(logN)^2$is $O(N)$.\"></a>R1-2 $(logN)^2$is $O(N)$.</h5><p>T</p>\n<p>记住即可</p>\n<h5 id=\"R1-3-The-time-comlexity-of-Selection-Sort-will-be-the-same-no-matter-we-store-the-elements-in-an-array-or-a-linked-list\"><a href=\"#R1-3-The-time-comlexity-of-Selection-Sort-will-be-the-same-no-matter-we-store-the-elements-in-an-array-or-a-linked-list\" class=\"headerlink\" title=\"R1-3 The time comlexity of Selection Sort will be the same no matter we store the elements in an array or a linked list.\"></a>R1-3 The time comlexity of Selection Sort will be the same no matter we store the elements in an array or a linked list.</h5><p>T</p>\n<h2 id=\"HW2\"><a href=\"#HW2\" class=\"headerlink\" title=\"HW2\"></a>HW2</h2><h5 id=\"1-1-For-a-sequentially-stored-linear-list-of-length-N-the-time-complexities-for-deleting-the-first-element-and-inserting-the-last-element-are-O-1-and-O-N-respectively\"><a href=\"#1-1-For-a-sequentially-stored-linear-list-of-length-N-the-time-complexities-for-deleting-the-first-element-and-inserting-the-last-element-are-O-1-and-O-N-respectively\" class=\"headerlink\" title=\"1-1 For a sequentially stored linear list of length N, the time complexities for deleting the first element and inserting the last element are O(1) and O(N), respectively.\"></a>1-1 For a <code>sequentially stored</code> linear list of length <em>N</em>, the time complexities for deleting the first element and inserting the last element are <em>O</em>(1) and <em>O</em>(<em>N</em>), respectively.</h5><p>F</p>\n<p>注意是顺序存储的。删除第一个节点需要把后面的都往前移动一个位置，所以是$O(N)$，插入最后一个节点是$O(1)$。</p>\n<p>对于顺序存储的长度为N的线性表，访问节点的时间复杂度是$O(1)$（线性存储，直接按标号访问就可以了），插入的时间复杂度是$O(N)$（要调整后面的元素的位置）。</p>\n<h5 id=\"2-3-To-merge-two-singly-linked-ascending-lists-both-with-N-nodes-into-one-singly-linked-ascending-list-the-minimum-possible-number-of-comparisons-is\"><a href=\"#2-3-To-merge-two-singly-linked-ascending-lists-both-with-N-nodes-into-one-singly-linked-ascending-list-the-minimum-possible-number-of-comparisons-is\" class=\"headerlink\" title=\"2-3 To merge two singly linked ascending lists, both with N nodes, into one singly linked ascending list, the minimum possible number of comparisons is:\"></a>2-3 To merge two singly linked ascending lists, both with <em>N</em> nodes, into one singly linked ascending list, the minimum possible number of comparisons is:</h5><p>B.$N$</p>\n<p>最少比较的次数就是第一个链表的每个节点都和第二个链表的头节点比较一次，所以是N</p>\n<h4 id=\"函数题\"><a href=\"#函数题\" class=\"headerlink\" title=\"函数题\"></a>函数题</h4><h5 id=\"6-1-Add-Two-Polynomials\"><a href=\"#6-1-Add-Two-Polynomials\" class=\"headerlink\" title=\"6-1 Add Two Polynomials\"></a>6-1 Add Two Polynomials</h5><p>Write a function to add two polynomials. Do not destroy the input. Use a linked list implementation with a dummy head node.<br>Note: The zero polynomial is represented by an empty list with only the dummy head node.</p>\n<h3 id=\"Format-of-functions\"><a href=\"#Format-of-functions\" class=\"headerlink\" title=\"Format of functions:\"></a>Format of functions:</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Polynomial <span class=\"title function_\">Add</span><span class=\"params\">( Polynomial a, Polynomial b )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>where <code>Polynomial</code> is defined as the following:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> *<span class=\"title\">PtrToNode</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> Coefficient;</span><br><span class=\"line\">    <span class=\"type\">int</span> Exponent;</span><br><span class=\"line\">    PtrToNode Next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToNode Polynomial;</span><br><span class=\"line\"><span class=\"comment\">/* Nodes are sorted in decreasing order of exponents.*/</span>  </span><br></pre></td></tr></table></figure>\n\n<p>The function <code>Add</code> is supposed to return a polynomial which is the sum of <code>a</code> and <code>b</code>.</p>\n<h3 id=\"Sample-program-of-judge\"><a href=\"#Sample-program-of-judge\" class=\"headerlink\" title=\"Sample program of judge:\"></a>Sample program of judge:</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> *<span class=\"title\">PtrToNode</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>  &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> Coefficient;</span><br><span class=\"line\">    <span class=\"type\">int</span> Exponent;</span><br><span class=\"line\">    PtrToNode Next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToNode Polynomial;</span><br><span class=\"line\"></span><br><span class=\"line\">Polynomial <span class=\"title function_\">Read</span><span class=\"params\">()</span>; <span class=\"comment\">/* details omitted */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Print</span><span class=\"params\">( Polynomial p )</span>; <span class=\"comment\">/* details omitted */</span></span><br><span class=\"line\">Polynomial <span class=\"title function_\">Add</span><span class=\"params\">( Polynomial a, Polynomial b )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Polynomial a, b, s;</span><br><span class=\"line\">    a = Read();</span><br><span class=\"line\">    b = Read();</span><br><span class=\"line\">    s = Add(a, b);</span><br><span class=\"line\">    Print(s);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Your function will be put here */</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Sample-Input\"><a href=\"#Sample-Input\" class=\"headerlink\" title=\"Sample Input:\"></a>Sample Input:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4</span><br><span class=\"line\">3 4 -5 2 6 1 -2 0</span><br><span class=\"line\">3</span><br><span class=\"line\">5 20 -7 4 3 1</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Sample-Output\"><a href=\"#Sample-Output\" class=\"headerlink\" title=\"Sample Output:\"></a>Sample Output:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5 20 -4 4 -5 2 9 1 -2 0</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Polynomial <span class=\"title function_\">Add</span><span class=\"params\">( Polynomial a, Polynomial b )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//如果有一个为空则直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(b==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    <span class=\"comment\">//head用于保存头结点，pre用于遍历，tmp用于产生新节点</span></span><br><span class=\"line\">    Polynomial head,pre,tmp;</span><br><span class=\"line\">    pre=(<span class=\"keyword\">struct</span> Node*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> Node));<span class=\"comment\">//申请内存</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    head=pre;<span class=\"comment\">//head保存头结点</span></span><br><span class=\"line\">    a=a-&gt;Next;<span class=\"comment\">//因为有头结点，所以需要next一下寻找第一个元素</span></span><br><span class=\"line\">    b=b-&gt;Next;<span class=\"comment\">//因为有头结点，所以需要next一下寻找第一个元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(a!=<span class=\"literal\">NULL</span>&amp;&amp;b!=<span class=\"literal\">NULL</span>)&#123;<span class=\"comment\">//两多项式都没遍历完</span></span><br><span class=\"line\">    </span><br><span class=\"line\">        tmp=(Polynomial)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Polynomial));  </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a-&gt;Exponent == b-&gt;Exponent)&#123;</span><br><span class=\"line\">            tmp-&gt;Exponent=a-&gt;Exponent;</span><br><span class=\"line\">            tmp-&gt;Coefficient=a-&gt;Coefficient+b-&gt;Coefficient;</span><br><span class=\"line\">            a=a-&gt;Next;</span><br><span class=\"line\">            b=b-&gt;Next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp-&gt;Coefficient==<span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;<span class=\"comment\">//系数可能为0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a-&gt;Exponent&gt;b-&gt;Exponent)&#123;</span><br><span class=\"line\">            tmp-&gt;Exponent=a-&gt;Exponent;</span><br><span class=\"line\">            tmp-&gt;Coefficient=a-&gt;Coefficient;</span><br><span class=\"line\">            a=a-&gt;Next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            tmp-&gt;Exponent=b-&gt;Exponent;</span><br><span class=\"line\">            tmp-&gt;Coefficient=b-&gt;Coefficient;</span><br><span class=\"line\">            b=b-&gt;Next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        tmp-&gt;Next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        pre-&gt;Next=tmp;<span class=\"comment\">//pre遍历</span></span><br><span class=\"line\">        pre=tmp;<span class=\"comment\">//遍历</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//其中一个多项式遍历完了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a!=<span class=\"literal\">NULL</span>&amp;&amp;b==<span class=\"literal\">NULL</span>) pre-&gt;Next=a;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a==<span class=\"literal\">NULL</span>&amp;&amp;b!=<span class=\"literal\">NULL</span>) pre-&gt;Next=b;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"6-2-Reverse-Linked-List\"><a href=\"#6-2-Reverse-Linked-List\" class=\"headerlink\" title=\"6-2 Reverse Linked List\"></a>6-2 Reverse Linked List</h5><p>Write a nonrecursive procedure to reverse a singly linked list in <em>O</em>(<em>N</em>) time using constant extra space.</p>\n<h3 id=\"Format-of-functions-1\"><a href=\"#Format-of-functions-1\" class=\"headerlink\" title=\"Format of functions:\"></a>Format of functions:</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List <span class=\"title function_\">Reverse</span><span class=\"params\">( List L )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>where <code>List</code> is defined as the following:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> *PtrToNode;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToNode List;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToNode Position;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">    ElementType Element;</span><br><span class=\"line\">    Position Next;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>The function <code>Reverse</code> is supposed to return the reverse linked list of <code>L</code>, with a dummy header.</p>\n<h3 id=\"Sample-program-of-judge-1\"><a href=\"#Sample-program-of-judge-1\" class=\"headerlink\" title=\"Sample program of judge:\"></a>Sample program of judge:</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> ElementType;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> *<span class=\"title\">PtrToNode</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToNode List;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToNode Position;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">    ElementType Element;</span><br><span class=\"line\">    Position Next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">List <span class=\"title function_\">Read</span><span class=\"params\">()</span>; <span class=\"comment\">/* details omitted */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Print</span><span class=\"params\">( List L )</span>; <span class=\"comment\">/* details omitted */</span></span><br><span class=\"line\">List <span class=\"title function_\">Reverse</span><span class=\"params\">( List L )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    List L1, L2;</span><br><span class=\"line\">    L1 = Read();</span><br><span class=\"line\">    L2 = Reverse(L1);</span><br><span class=\"line\">    Print(L1);</span><br><span class=\"line\">    Print(L2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Your function will be put here */</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Sample-Input-1\"><a href=\"#Sample-Input-1\" class=\"headerlink\" title=\"Sample Input:\"></a>Sample Input:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">1 3 4 5 2</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Sample-Output-1\"><a href=\"#Sample-Output-1\" class=\"headerlink\" title=\"Sample Output:\"></a>Sample Output:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2 5 4 3 1</span><br><span class=\"line\">2 5 4 3 1</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List <span class=\"title function_\">Reverse</span><span class=\"params\">( List L )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    PtrToNode p = <span class=\"literal\">NULL</span>, q = <span class=\"literal\">NULL</span>, r = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    p = L-&gt;Next;</span><br><span class=\"line\">    r = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L-&gt;Next == <span class=\"literal\">NULL</span> || p-&gt;Next == <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> L;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p)&#123;</span><br><span class=\"line\">        q = p-&gt;Next;</span><br><span class=\"line\">        p-&gt;Next = r;</span><br><span class=\"line\">        r = p;</span><br><span class=\"line\">        p = q;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    L-&gt;Next = r;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>见期中模拟卷</p>\n<h3 id=\"线性表\"><a href=\"#线性表\" class=\"headerlink\" title=\"线性表\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODAyNTMxNS9hcnRpY2xlL2RldGFpbHMvMTE5Nzc4MDY4\">线性表</span></h3><h4 id=\"线性表的定义与操作–顺序表\"><a href=\"#线性表的定义与操作–顺序表\" class=\"headerlink\" title=\"线性表的定义与操作–顺序表\"></a>线性表的定义与操作–顺序表</h4><p>顺序表是用一段<strong>物理地址连续的存储单元</strong>依次存储数据元素的线性结构，一般情况下采用数组存储。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> Position;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">List</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> &#123;</span> </span><br><span class=\"line\">    ElementType Data[MAXSIZE];</span><br><span class=\"line\">    Position Last;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 初始化 */</span></span><br><span class=\"line\">List <span class=\"title function_\">MakeEmpty</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    List L; </span><br><span class=\"line\">    L = (List)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> LNode)); </span><br><span class=\"line\">    L-&gt;Last = <span class=\"number\">-1</span>; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> L;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 查找 */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ERROR -1</span></span><br><span class=\"line\">Position <span class=\"title function_\">Find</span><span class=\"params\">( List L, ElementType X )</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    Position i = <span class=\"number\">0</span>; </span><br><span class=\"line\">    <span class=\"keyword\">while</span>( i &lt;= L-&gt;Last &amp;&amp; L-&gt;Data[i]!= X ) </span><br><span class=\"line\">        i++; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( i &gt; L-&gt;Last ) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ERROR; <span class=\"comment\">/* 如果没找到，返回错误信息 */</span> </span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> i; <span class=\"comment\">/* 找到后返回的是存储位置 */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 插入 */</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Insert</span><span class=\"params\">( List L, ElementType X, Position P )</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    <span class=\"comment\">/* 在L的指定位置P前插入一个新元素X */</span> </span><br><span class=\"line\">    Position i; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( L-&gt;Last == MAXSIZE<span class=\"number\">-1</span>) &#123; <span class=\"comment\">/* 表空间已满，不能插入 */</span> </span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;表满&quot;</span>); </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( P&lt;<span class=\"number\">0</span> || P&gt;L-&gt;Last+<span class=\"number\">1</span> ) &#123; <span class=\"comment\">/* 检查插入位置的合法性 */</span> </span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;位置不合法&quot;</span>); </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">for</span>( i=L-&gt;Last; i&gt;=P; i-- ) </span><br><span class=\"line\">        L-&gt;Data[i+<span class=\"number\">1</span>] = L-&gt;Data[i]; <span class=\"comment\">/* 将位置P及以后的元素顺序向后移动 */</span> </span><br><span class=\"line\">    L-&gt;Data[P] = X; <span class=\"comment\">/* 新元素插入 */</span> </span><br><span class=\"line\">    L-&gt;Last++; <span class=\"comment\">/* Last仍指向最后元素 */</span> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 删除 */</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Delete</span><span class=\"params\">( List L, Position P )</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    <span class=\"comment\">/* 从L中删除指定位置P的元素 */</span> </span><br><span class=\"line\">    Position i; </span><br><span class=\"line\">    <span class=\"keyword\">if</span>( P&lt;<span class=\"number\">0</span> || P&gt;L-&gt;Last ) &#123; <span class=\"comment\">/* 检查空表及删除位置的合法性 */</span> </span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;位置%d不存在元素&quot;</span>, P ); </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">for</span>( i=P+<span class=\"number\">1</span>; i&lt;=L-&gt;Last; i++ ) </span><br><span class=\"line\">        L-&gt;Data[i<span class=\"number\">-1</span>] = L-&gt;Data[i]; <span class=\"comment\">/* 将位置P+1及以后的元素顺序向前移动 */</span> </span><br><span class=\"line\">    L-&gt;Last--; <span class=\"comment\">/* Last仍指向最后元素 */</span> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"线性表的定义与操作–链表\"><a href=\"#线性表的定义与操作–链表\" class=\"headerlink\" title=\"线性表的定义与操作–链表\"></a>线性表的定义与操作–<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Vkd2FyZF9Bc2lhL2FydGljbGUvZGV0YWlscy8xMjA4NzYzMTQ=\">链表</span></h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">PtrToLNode</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> &#123;</span> </span><br><span class=\"line\">    ElementType Data; </span><br><span class=\"line\">    PtrToLNode Next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToLNode Position;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToLNode List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 查找 */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ERROR NULL</span></span><br><span class=\"line\">Position <span class=\"title function_\">Find</span><span class=\"params\">( List L, ElementType X )</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    Position p = L; <span class=\"comment\">/* p指向L的第1个结点 */</span> </span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( p &amp;&amp; p-&gt;Data!=X ) </span><br><span class=\"line\">        p = p-&gt;Next; </span><br><span class=\"line\">    <span class=\"comment\">/* 下列语句可以用 return p; 替换 */</span> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( p ) <span class=\"keyword\">return</span> p; </span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 带头结点的插入 */</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Insert</span><span class=\"params\">( List L, ElementType X, Position P )</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    <span class=\"comment\">/* 这里默认L有头结点 */</span> </span><br><span class=\"line\">    Position tmp, pre; </span><br><span class=\"line\">    <span class=\"comment\">/* 查找P的前一个结点 */</span> </span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( pre=L; pre&amp;&amp;pre-&gt;Next!=P; pre=pre-&gt;Next ) ; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( pre==<span class=\"literal\">NULL</span> ) &#123; </span><br><span class=\"line\">        <span class=\"comment\">/* P所指的结点不在L中 */</span> </span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;插入位置参数错误\\n&quot;</span>); </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">/* 找到了P的前一个结点pre */</span> </span><br><span class=\"line\">        <span class=\"comment\">/* 在P前插入新结点 */</span> </span><br><span class=\"line\">        tmp = (Position)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> LNode)); </span><br><span class=\"line\">        <span class=\"comment\">/* 申请、填装结点 */</span> </span><br><span class=\"line\">        tmp-&gt;Data = X; </span><br><span class=\"line\">        tmp-&gt;Next = P; </span><br><span class=\"line\">        pre-&gt;Next = tmp; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 带头结点的删除 */</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Delete</span><span class=\"params\">( List L, Position P )</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    <span class=\"comment\">/* 这里默认L有头结点 */</span> </span><br><span class=\"line\">    Position pre; </span><br><span class=\"line\">    <span class=\"comment\">/* 查找P的前一个结点 */</span> </span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( pre=L; pre&amp;&amp;pre-&gt;Next!=P; pre=pre-&gt;Next ) ; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( pre==<span class=\"literal\">NULL</span> || P==<span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* P所指的结点不在L中 */</span> </span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;删除位置参数错误\\n&quot;</span>); </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">/* 找到了P的前一个结点pre */</span> </span><br><span class=\"line\">        <span class=\"comment\">/* 将P位置的结点删除 */</span> </span><br><span class=\"line\">        pre-&gt;Next = P-&gt;Next; </span><br><span class=\"line\">        <span class=\"built_in\">free</span>(P); </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p> <strong>If N numbers are stored in a singly linked list in increasing order, then the average time complexity for binary search is O(logN).</strong></p>\n<p>F</p>\n<p>链表不能用二分查找，只能从头开始遍历</p>\n<h2 id=\"HW3\"><a href=\"#HW3\" class=\"headerlink\" title=\"HW3\"></a>HW3</h2><h5 id=\"2-1-Push-5-characters-ooops-onto-a-stack-In-how-many-different-ways-that-we-can-pop-these-characters-and-still-obtain-ooops\"><a href=\"#2-1-Push-5-characters-ooops-onto-a-stack-In-how-many-different-ways-that-we-can-pop-these-characters-and-still-obtain-ooops\" class=\"headerlink\" title=\"2-1 Push 5 characters ooops onto a stack. In how many different ways that we can pop these characters and still obtain ooops?\"></a>2-1 Push 5 characters <code>ooops</code> onto a stack. In how many different ways that we can pop these characters and still obtain <code>ooops</code>?</h5><p>C.5</p>\n<p>stack-FILO</p>\n<p>queue-FIFO</p>\n<h5 id=\"2-3-Suppose-that-an-array-of-size-6-is-used-to-store-a-circular-queue-and-the-values-of-front-and-rear-are-0-and-4-respectively-Now-after-2-dequeues-and-2-enqueues-what-will-the-values-of-front-and-rear-be\"><a href=\"#2-3-Suppose-that-an-array-of-size-6-is-used-to-store-a-circular-queue-and-the-values-of-front-and-rear-are-0-and-4-respectively-Now-after-2-dequeues-and-2-enqueues-what-will-the-values-of-front-and-rear-be\" class=\"headerlink\" title=\"2-3 Suppose that an array of size 6 is used to store a circular queue, and the values of front and rear are 0 and 4, respectively. Now after 2 dequeues and 2 enqueues, what will the values of front and rear be?\"></a>2-3 Suppose that an array of size 6 is used to store a circular queue, and the values of <code>front</code> and <code>rear</code> are 0 and 4, respectively. Now after 2 dequeues and 2 enqueues, what will the values of <code>front</code> and <code>rear</code> be?</h5><pre class=\"mermaid\">graph LR;\n0-->1;\n1-->2;\n2-->3;\n3-->4;\n4-->5;\n5-->0;</pre>\n\n<p>In circular queue:</p>\n<p>Rear &#x3D; 0, front &#x3D; 1</p>\n<p>Empty: Rear &#x3D; front-1</p>\n<p>When enqueue, rear ++</p>\n<p>When dequeue, front++</p>\n<p>front &#x3D; 0 + 2 &#x3D; 2</p>\n<p>rear &#x3D; (4 + 2)%6 &#x3D; 0</p>\n<h4 id=\"编程题\"><a href=\"#编程题\" class=\"headerlink\" title=\"编程题\"></a>编程题</h4><h5 id=\"7-1-Pop-Sequence\"><a href=\"#7-1-Pop-Sequence\" class=\"headerlink\" title=\"7-1 Pop Sequence\"></a>7-1 Pop Sequence</h5><p>Given a stack which can keep <em>M</em> numbers at most. Push <em>N</em> numbers in the order of 1, 2, 3, …, <em>N</em> and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if <em>M</em> is 5 and <em>N</em> is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.</p>\n<h3 id=\"Input-Specification\"><a href=\"#Input-Specification\" class=\"headerlink\" title=\"Input Specification:\"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): <em>M</em> (the maximum capacity of the stack), <em>N</em> (the length of push sequence), and <em>K</em> (the number of pop sequences to be checked). Then <em>K</em> lines follow, each contains a pop sequence of <em>N</em> numbers. All the numbers in a line are separated by a space.</p>\n<h3 id=\"Output-Specification\"><a href=\"#Output-Specification\" class=\"headerlink\" title=\"Output Specification:\"></a>Output Specification:</h3><p>For each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not.</p>\n<h3 id=\"Sample-Input-2\"><a href=\"#Sample-Input-2\" class=\"headerlink\" title=\"Sample Input:\"></a>Sample Input:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5 7 5</span><br><span class=\"line\">1 2 3 4 5 6 7</span><br><span class=\"line\">3 2 1 7 5 6 4</span><br><span class=\"line\">7 6 5 4 3 2 1</span><br><span class=\"line\">5 6 4 3 7 2 1</span><br><span class=\"line\">1 7 6 5 4 3 2</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Sample-Output-2\"><a href=\"#Sample-Output-2\" class=\"headerlink\" title=\"Sample Output:\"></a>Sample Output:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">YES</span><br><span class=\"line\">NO</span><br><span class=\"line\">NO</span><br><span class=\"line\">YES</span><br><span class=\"line\">NO</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> m, n, k;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d %d&quot;</span>,&amp;m, &amp;n, &amp;k);</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"built_in\">stack</span>[n], pop[n], result[k];</span><br><span class=\"line\">    <span class=\"type\">int</span> i, j;</span><br><span class=\"line\">    <span class=\"type\">int</span> ptr_s = <span class=\"number\">0</span>, ptr_p = <span class=\"number\">0</span>, element = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i&lt;k; i++)&#123;</span><br><span class=\"line\">        ptr_s =<span class=\"number\">0</span>, ptr_p = <span class=\"number\">0</span>, element = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; j&lt;n; j++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;pop[j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(ptr_p&lt;n)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(element == pop[ptr_p]&amp;&amp;ptr_s&lt;m)&#123;</span><br><span class=\"line\">                element++;</span><br><span class=\"line\">                ptr_p++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">stack</span>[ptr_s<span class=\"number\">-1</span>] == pop[ptr_p] &amp;&amp; ptr_s&gt;=<span class=\"number\">0</span> &amp;&amp; ptr_s&lt;=m)&#123;</span><br><span class=\"line\">                ptr_p++;</span><br><span class=\"line\">                ptr_s--;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(element&lt;=n &amp;&amp; ptr_s&lt;=m)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">stack</span>[ptr_s] = element;</span><br><span class=\"line\">                ptr_s++;</span><br><span class=\"line\">                element++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ptr_p&lt;n)&#123;</span><br><span class=\"line\">            result[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            result[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i&lt;k; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(result[i] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;NO\\n&quot;</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;YES\\n&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>新开一个栈用来存1234567，然后依次比较用来pop栈顶元素和popseq的栈的元素，相等就pop。</p>\n<h2 id=\"HW4\"><a href=\"#HW4\" class=\"headerlink\" title=\"HW4\"></a>HW4</h2><h5 id=\"1-1-It-is-always-possible-to-represent-a-tree-by-a-one-dimensional-integer-array\"><a href=\"#1-1-It-is-always-possible-to-represent-a-tree-by-a-one-dimensional-integer-array\" class=\"headerlink\" title=\"1-1 It is always possible to represent a tree by a one-dimensional integer array.\"></a>1-1 It is always possible to represent a tree by a one-dimensional integer array.</h5><p>T</p>\n<p>二叉树可以经过前序遍历、中序遍历、后序遍历得到一维数组。其他degree的树也同理。</p>\n<h5 id=\"1-2-There-exists-a-binary-tree-with-2016-nodes-in-total-and-with-16-nodes-having-only-one-child\"><a href=\"#1-2-There-exists-a-binary-tree-with-2016-nodes-in-total-and-with-16-nodes-having-only-one-child\" class=\"headerlink\" title=\"1-2 There exists a binary tree with 2016 nodes in total, and with 16 nodes having only one child.\"></a>1-2 There exists a binary tree with 2016 nodes in total, and with 16 nodes having only one child.</h5><p>F</p>\n<p>假设没有孩子的结点（叶结点）个数为n₀，只有一个孩子的结点（度为1的结点）个数为n₁，有两个孩子的结点（度为2的结点）个数为n₂。<br>则n₀+n₁+n₂&#x3D;2016<br>&#x3D;&#x3D;∵n₀&#x3D;n₂+1（二叉树的性质：叶结点个数等于度为2的结点个数加1）&#x3D;&#x3D;<br>∴n₀+n₁+n₂&#x3D;2016<br>⇨n₂+1+16+n₂&#x3D;2016<br>⇨2n₂&#x3D;1999<br>n₂除不尽，所以答案错误。</p>\n<p>【 Theorem 】 A tree with n vertices has n-1 edges.</p>\n<p>【 Theorem 】 edge &#x3D; 1&#x2F;2(sum of degree)</p>\n<p>【 Theorem 】A full m-ary tree with i internal vertices contains n&#x3D;mi+1 vertices.</p>\n<p>&#x3D;&#x3D;<strong>For a full binary tree,</strong> <strong>l&#x3D; i +1</strong>, <strong>e</strong> <strong>&#x3D;</strong> <strong>v</strong> <strong>- 1.</strong>&#x3D;&#x3D;</p>\n<p>对于二叉树来说，叶子结点的个数等于中间节点个数+1，边数等于节点数-1</p>\n<h5 id=\"2-1-Given-a-tree-of-degree-3-Suppose-that-there-are-3-nodes-of-degree-2-and-2-nodes-of-degree-3-Then-the-number-of-leaf-nodes-must-be\"><a href=\"#2-1-Given-a-tree-of-degree-3-Suppose-that-there-are-3-nodes-of-degree-2-and-2-nodes-of-degree-3-Then-the-number-of-leaf-nodes-must-be\" class=\"headerlink\" title=\"2-1 Given a tree of degree 3. Suppose that there are 3 nodes of degree 2 and 2 nodes of degree 3. Then the number of leaf nodes must be ____.\"></a>2-1 Given a tree of degree 3. Suppose that there are 3 nodes of degree 2 and 2 nodes of degree 3. Then the number of leaf nodes must be ____.</h5><p>$n&#x3D;n_0+n_1+n_2+n_3$</p>\n<p>$e&#x3D;n-1&#x3D;n_1+2n_2+3n_3$</p>\n<p>$–&gt;n_0&#x3D;n_2+2n_3+1$</p>\n<p>直接画一棵树</p>\n<pre class=\"mermaid\">graph TD;\n0-->1;\n0-->2;\n1-->3;\n1-->4;\n2-->5;\n2-->6;\n3-->7;\n3-->8;\n3-->9;\n5-->10;\n5-->11;\n5-->12;</pre>\n\n\n\n<h5 id=\"2-2-If-a-general-tree-T-is-converted-into-a-binary-tree-BT-then-which-of-the-following-BT-traversals-gives-the-same-sequence-as-that-of-the-post-order-traversal-of-T\"><a href=\"#2-2-If-a-general-tree-T-is-converted-into-a-binary-tree-BT-then-which-of-the-following-BT-traversals-gives-the-same-sequence-as-that-of-the-post-order-traversal-of-T\" class=\"headerlink\" title=\"2-2 If a general tree T is converted into a binary tree BT, then which of the following BT traversals gives the same sequence as that of the post-order traversal of T?\"></a>2-2 If a general tree <em>T</em> is converted into a binary tree <em>BT</em>, then which of the following <em>BT</em> traversals gives the same sequence as that of the post-order traversal of <em>T</em>?</h5><p>B. In-order traversal</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV2ZXJfZHJlYW1zL2FydGljbGUvZGV0YWlscy84MTAzMjg2MT9vcHNfcmVxdWVzdF9taXNjPSZyZXF1ZXN0X2lkPSZiaXpfaWQ9MTAyJnV0bV90ZXJtPSVFNiU5OSVBRSVFOSU4MCU5QSVFNiVBMCU5MSVFOCVCRCVBQyVFNSU4QyU5NiVFNiU4OCU5MCVFNCVCQSU4QyVFNSU4RiU4OSVFNiVBMCU5MSZ1dG1fbWVkaXVtPWRpc3RyaWJ1dGUucGNfc2VhcmNoX3Jlc3VsdC5ub25lLXRhc2stYmxvZy0yfmFsbH5zb2JhaWR1d2VifmRlZmF1bHQtMy04MTAzMjg2MS5ub25lY2FzZSZzcG09MTAxOC4yMjI2LjMwMDEuNDE4Nw==\">普通树转二叉树</span></p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">将树的根节点直接作为二叉树的根节点</span><br><span class=\"line\">将树的根节点的第一个子节点作为根节点的左儿子，若该子节点存在兄弟节点，则将该子节点的第一个兄弟节点（方向从左往右）作为该子节点的右儿子</span><br><span class=\"line\">将树中的剩余节点按照上一步的方式，依序添加到二叉树中，直到树中所有的节点都在二叉树中</span><br></pre></td></tr></table></figure>\n\n<p><img data-src=\"https://img-blog.csdn.net/20180713160942112?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV2ZXJfZHJlYW1z/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"img\"></p>\n<p>T：<br>前序preorder：ABEICFDGJH<br>中序无（多节点没法定义中序）<br>后序：IEBFCJGHDA</p>\n<p>BT：<br>前序preorder: ABEICFDGJH<br>中序inorder：IEBFCJGHDA<br>后序postorder:IEBFJHGDCBA<br>层级levelorder：ABECIFDGJH</p>\n<p><strong>结论：</strong></p>\n<p><strong>T的preorder &#x3D; BT的preorder<br>T的postorder &#x3D; BT的inorder</strong></p>\n<p>preorder-根左右  inorder-左根右  postorder-左右根</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">还可以这样理解普通树转换成二叉树（实际上是一样的）：</span><br><span class=\"line\"></span><br><span class=\"line\">在所有兄弟结点之间加一连线</span><br><span class=\"line\">对每个结点，除了保留与其第一个儿子的连线外，去掉该结点与其它孩子的连线</span><br></pre></td></tr></table></figure>\n\n<p><img data-src=\"https://img-blog.csdn.net/20180724230432154?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV2ZXJfZHJlYW1z/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"img\"></p>\n<h5 id=\"2-3-Given-the-shape-of-a-binary-tree-shown-by-the-figure-below-If-its-inorder-traversal-sequence-is-E-A-D-B-F-H-C-G-then-the-node-on-the-same-level-of-C-must-be\"><a href=\"#2-3-Given-the-shape-of-a-binary-tree-shown-by-the-figure-below-If-its-inorder-traversal-sequence-is-E-A-D-B-F-H-C-G-then-the-node-on-the-same-level-of-C-must-be\" class=\"headerlink\" title=\"2-3 Given the shape of a binary tree shown by the figure below. If its inorder traversal sequence is { E, A, D, B, F, H, C, G }, then the node on the same level of C must be:\"></a>2-3 Given the shape of a binary tree shown by the figure below. If its inorder traversal sequence is { E, A, D, B, F, H, C, G }, then the node on the same level of C must be:</h5><p><img data-src=\"https://images.ptausercontent.com/19185355-2b08-4b74-9bb7-8262720437bd.jpg\" alt=\"未标题-2.jpg\"></p>\n<p>B.E</p>\n<pre class=\"mermaid\">graph TD\nF-->E\nF-->C\nE-->_\nE-->D\nD-->A\nD-->B\nC-->H\nC-->G</pre>\n\n<p>中序遍历：左根右</p>\n<h5 id=\"2-4-Among-the-following-threaded-binary-trees-the-threads-are-represented-by-dotted-curves-which-one-is-the-postorder-threaded-tree\"><a href=\"#2-4-Among-the-following-threaded-binary-trees-the-threads-are-represented-by-dotted-curves-which-one-is-the-postorder-threaded-tree\" class=\"headerlink\" title=\"2-4 Among the following threaded binary trees (the threads are represented by dotted curves), which one is the postorder threaded tree?\"></a>2-4 Among the following threaded binary trees (the threads are represented by dotted curves), which one is the postorder threaded tree?</h5><p>A. <img data-src=\"https://images.ptausercontent.com/64\" alt=\"64\"></p>\n<p>B. <img data-src=\"https://images.ptausercontent.com/65\" alt=\"65\"></p>\n<p>C. <img data-src=\"https://images.ptausercontent.com/66\" alt=\"66\"></p>\n<p>D. <img data-src=\"https://images.ptausercontent.com/67\" alt=\"67\"></p>\n<p><strong>B</strong></p>\n<p>thread tree 线索二叉树</p>\n<p>下面这个树，<strong>后序排序</strong>是：dbca<br>前驱就是前面的，比如b的前驱是d, d的前驱是Null<br>后驱就是后面的，比如d的后驱是b，a的后驱是Null<br>d有两个指针没有用，左边指向前驱Null，右边指向b（然后就选出来B了）<br>b的右节点有用的（已经指向d了），左节点指向其前驱，也就是d<br>c前驱是b，后驱是a，所以左指向b，右指向a<br>a没有指针可用了（已经左为b右为c）了<br>所以选B。</p>\n<h5 id=\"Expression-Trees-syntax-trees\"><a href=\"#Expression-Trees-syntax-trees\" class=\"headerlink\" title=\"Expression Trees (syntax trees)\"></a>Expression Trees (syntax trees)</h5><p>prefix&#x2F;infix&#x2F;postfix分别对应前序遍历、中序遍历、后序遍历</p>\n<h5 id=\"6-1-Isomorphic\"><a href=\"#6-1-Isomorphic\" class=\"headerlink\" title=\"6-1 Isomorphic\"></a><strong>6-1 Isomorphic</strong></h5><p>Two trees, <code>T1</code> and <code>T2</code>, are <strong>isomorphic</strong> if <code>T1</code> can be transformed into <code>T2</code> by swapping left and right children of (some of the) nodes in <code>T1</code>. For instance, the two trees in Figure 1 are isomorphic because they are the same if the children of A, B, and G, but not the other nodes, are swapped. Give a polynomial time algorithm to decide if two trees are isomorphic.</p>\n<p><img data-src=\"https://images.ptausercontent.com/37\" alt=\"37\"></p>\n<h3 id=\"Format-of-functions-2\"><a href=\"#Format-of-functions-2\" class=\"headerlink\" title=\"Format of functions:\"></a>Format of functions:</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Isomorphic</span><span class=\"params\">( Tree T1, Tree T2 )</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>where <code>Tree</code> is defined as the following:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">TreeNode</span> *Tree;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TreeNode</span> &#123;</span><br><span class=\"line\">    ElementType Element;</span><br><span class=\"line\">    Tree  Left;</span><br><span class=\"line\">    Tree  Right;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>The function is supposed to return 1 if <code>T1</code> and <code>T2</code> are indeed isomorphic, or 0 if not.</p>\n<h3 id=\"Sample-program-of-judge-2\"><a href=\"#Sample-program-of-judge-2\" class=\"headerlink\" title=\"Sample program of judge:\"></a>Sample program of judge:</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">char</span> ElementType;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">TreeNode</span> *Tree;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TreeNode</span> &#123;</span><br><span class=\"line\">    ElementType Element;</span><br><span class=\"line\">    Tree  Left;</span><br><span class=\"line\">    Tree  Right;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Tree <span class=\"title\">BuildTree</span><span class=\"params\">()</span></span>; <span class=\"comment\">/* details omitted */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Isomorphic</span><span class=\"params\">( Tree T1, Tree T2 )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Tree T1, T2;</span><br><span class=\"line\">    T1 = <span class=\"built_in\">BuildTree</span>();</span><br><span class=\"line\">    T2 = <span class=\"built_in\">BuildTree</span>();</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(“%d\\n”, <span class=\"built_in\">Isomorphic</span>(T1, T2));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Your function will be put here */</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Sample-Output-1-for-the-trees-shown-in-Figure-1\"><a href=\"#Sample-Output-1-for-the-trees-shown-in-Figure-1\" class=\"headerlink\" title=\"Sample Output 1 (for the trees shown in Figure 1):\"></a>Sample Output 1 (for the trees shown in Figure 1):</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Sample-Output-2-for-the-trees-shown-in-Figure-2\"><a href=\"#Sample-Output-2-for-the-trees-shown-in-Figure-2\" class=\"headerlink\" title=\"Sample Output 2 (for the trees shown in Figure 2):\"></a>Sample Output 2 (for the trees shown in Figure 2):</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n\n<p><img data-src=\"https://images.ptausercontent.com/38\" alt=\"img\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Isomorphic</span><span class=\"params\">(Tree T1,Tree T2)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> \t<span class=\"keyword\">if</span>((T1 == <span class=\"literal\">NULL</span>) &amp;&amp; (T2 == <span class=\"literal\">NULL</span>))  <span class=\"comment\">//树都为空树，视为同构 </span></span><br><span class=\"line\"> \t    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"> \t<span class=\"keyword\">if</span>(((T1 == <span class=\"literal\">NULL</span>)&amp;&amp;(T2 != <span class=\"literal\">NULL</span>)) || ((T1 != <span class=\"literal\">NULL</span>)&amp;&amp;(T2 == <span class=\"literal\">NULL</span>)))  <span class=\"comment\">//两树其中之一为空树,不同构 </span></span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(T1-&gt;Element != T2-&gt;Element)  <span class=\"comment\">//若两树都非空的话，比较根结点 </span></span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>((T1-&gt;Left == <span class=\"literal\">NULL</span>) &amp;&amp; (T2-&gt;Left == <span class=\"literal\">NULL</span>))  <span class=\"comment\">//左子树都为空，比较右子树 </span></span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> Isomorphic(T1-&gt;Right,T2-&gt;Right);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((T1-&gt;Left != <span class=\"literal\">NULL</span>)&amp;&amp;(T2-&gt;Left != <span class=\"literal\">NULL</span>) &amp;&amp; (T1-&gt;Left-&gt;Element == T2-&gt;Left-&gt;Element))</span><br><span class=\"line\">    <span class=\"comment\">/*左子树非空，并且左子树根结点相同，递归比较左右子树*/</span> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> (Isomorphic(T1-&gt;Left,T2-&gt;Left) &amp;&amp; Isomorphic(T1-&gt;Right,T2-&gt;Right));</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (Isomorphic(T1-&gt;Left,T2-&gt;Right) &amp;&amp; Isomorphic(T1-&gt;Right,T2-&gt;Left));</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"HW5\"><a href=\"#HW5\" class=\"headerlink\" title=\"HW5\"></a>HW5</h2><h5 id=\"1-2-In-a-binary-search-tree-which-contains-several-integer-keys-including-4-5-and-6-if-4-and-6-are-on-the-same-level-then-5-must-be-their-parent\"><a href=\"#1-2-In-a-binary-search-tree-which-contains-several-integer-keys-including-4-5-and-6-if-4-and-6-are-on-the-same-level-then-5-must-be-their-parent\" class=\"headerlink\" title=\"1-2 In a binary search tree which contains several integer keys including 4, 5, and 6, if 4 and 6 are on the same level, then 5 must be their parent.\"></a>1-2 In a binary search tree which contains several integer keys including 4, 5, and 6, if 4 and 6 are on the same level, then 5 must be their parent.</h5><p>F</p>\n<p>不一定是父节点，可能是祖先节点。</p>\n<h5 id=\"2-2-Given-the-structure-of-a-binary-search-tree-as-shown-in-the-figure-which-one-of-the-following-insertion-sequences-is-impossible\"><a href=\"#2-2-Given-the-structure-of-a-binary-search-tree-as-shown-in-the-figure-which-one-of-the-following-insertion-sequences-is-impossible\" class=\"headerlink\" title=\"2-2 Given the structure of a binary search tree (as shown in the figure), which one of the following insertion sequences is impossible?\"></a>2-2 Given the structure of a binary search tree (as shown in the figure), which one of the following insertion sequences is impossible?</h5><p><img data-src=\"https://images.ptausercontent.com/84984823-130d-462a-ad9e-ee6457b1ce56.jpg\" alt=\"206.jpg\"></p>\n<p>A.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">83 67 91 98 20 75</span><br></pre></td></tr></table></figure>\n\n<p>B.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">83 67 75 91 20 98</span><br></pre></td></tr></table></figure>\n\n<p>C.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">83 91 75 67 20 98</span><br></pre></td></tr></table></figure>\n\n<p>D.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">83 91 98 67 75 20</span><br></pre></td></tr></table></figure>\n\n<p><strong>C</strong></p>\n<h5 id=\"Binary-Search-Tree\"><a href=\"#Binary-Search-Tree\" class=\"headerlink\" title=\"Binary Search Tree\"></a>Binary Search Tree</h5><p>二叉搜索树（BST，Binary Search Tree），也称二叉排序树或二叉查找树。<br>二叉搜索树：一棵二叉树，可以为空；如果不为空，满足以下性质：</p>\n<ol>\n<li>非空左子树的所有键值小于其根结点的键值。</li>\n<li>非空右子树的所有键值大于其根结点的键值。</li>\n<li>左、右子树都是二叉搜索树。</li>\n</ol>\n<p><strong>定义：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> ElementType;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TNode</span> *<span class=\"title\">Position</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> Position BinTree; <span class=\"comment\">/* 二叉树类型 */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TNode</span>&#123;</span> <span class=\"comment\">/* 树结点定义 */</span></span><br><span class=\"line\">    ElementType Data; <span class=\"comment\">/* 结点数据 */</span></span><br><span class=\"line\">    BinTree Left;     <span class=\"comment\">/* 指向左子树 */</span></span><br><span class=\"line\">    BinTree Right;    <span class=\"comment\">/* 指向右子树 */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>查找</strong></p>\n<p>（1）查找从根结点开始，如果树为空，返回NULL<br>（2）若搜索树非空，则根结点关键字和X进行比较，并进行不同处理：<br>  ① 若X小于根结点键值，只需在左子树中继续搜索；<br>  ② 如果X大于根结点的键值，在右子树中进行继续搜索；<br>  ③若两者比较结果是相等，搜索完成，返回指向此结点的指针。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Position <span class=\"title function_\">Find</span><span class=\"params\">( ElementType X, BinTree BST )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>( !BST ) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>; <span class=\"comment\">/*查找失败*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>( X &gt; BST-&gt;Data )</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Find( X, BST-&gt;Right ); <span class=\"comment\">/*在右子树中继续查找*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>( X &lt; BST-&gt;Data )</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Find( X, BST-&gt;Left ); <span class=\"comment\">/*在左子树中继续查找*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"comment\">/* X == BST-&gt;Data */</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> BST; <span class=\"comment\">/*查找成功，返回结点的找到结点的地址*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>查找最小（递归法）</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Position <span class=\"title function_\">FindMin</span><span class=\"params\">( BinTree BST )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t <span class=\"keyword\">if</span>( !BST ) </span><br><span class=\"line\">\t \t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>; <span class=\"comment\">/*空的二叉搜索树，返回NULL*/</span></span><br><span class=\"line\">\t <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>( !BST-&gt;Left )</span><br><span class=\"line\">\t \t<span class=\"keyword\">return</span> BST; <span class=\"comment\">/*找到最左叶结点并返回*/</span></span><br><span class=\"line\">\t <span class=\"keyword\">else</span></span><br><span class=\"line\">\t \t<span class=\"keyword\">return</span> FindMin( BST-&gt;Left ); <span class=\"comment\">/*沿左分支继续查找*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>查找最大（迭代法）</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Position <span class=\"title function_\">FindMax</span><span class=\"params\">( BinTree BST )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t <span class=\"keyword\">if</span>(BST )</span><br><span class=\"line\">\t \t<span class=\"keyword\">while</span>( BST-&gt;Right )  <span class=\"comment\">/*沿右分支继续查找，直到最右叶结点*/</span></span><br><span class=\"line\">\t \t\tBST = BST-&gt;Right;</span><br><span class=\"line\">\t <span class=\"keyword\">return</span> BST;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p><strong>插入</strong></p>\n<p>从根节点开始比较，大的插右边，小的插左边</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BinTree <span class=\"title function_\">Insert</span><span class=\"params\">( BinTree BST, ElementType X )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( !BST )&#123; <span class=\"comment\">/* 若原树为空，生成并返回一个结点的二叉搜索树 */</span></span><br><span class=\"line\">        BST = (BinTree)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> TNode));</span><br><span class=\"line\">        BST-&gt;Data = X;</span><br><span class=\"line\">        BST-&gt;Left = BST-&gt;Right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123; <span class=\"comment\">/* 开始找要插入元素的位置 */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>( X &lt; BST-&gt;Data )</span><br><span class=\"line\">            BST-&gt;Left = Insert( BST-&gt;Left, X );   <span class=\"comment\">/*递归插入左子树*/</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>  <span class=\"keyword\">if</span>( X &gt; BST-&gt;Data )</span><br><span class=\"line\">            BST-&gt;Right = Insert( BST-&gt;Right, X ); <span class=\"comment\">/*递归插入右子树*/</span></span><br><span class=\"line\">        <span class=\"comment\">/* else X已经存在，什么都不做 */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BST;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>删除</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BinTree <span class=\"title function_\">Delete</span><span class=\"params\">( BinTree BST, ElementType X )</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    Position Tmp; </span><br><span class=\"line\">    <span class=\"keyword\">if</span>( !BST ) </span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;要删除的元素未找到&quot;</span>); </span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( X &lt; BST-&gt;Data ) </span><br><span class=\"line\">            BST-&gt;Left = Delete( BST-&gt;Left, X );   <span class=\"comment\">/* 从左子树递归删除 */</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>( X &gt; BST-&gt;Data ) </span><br><span class=\"line\">            BST-&gt;Right = Delete( BST-&gt;Right, X ); <span class=\"comment\">/* 从右子树递归删除 */</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> </span><br><span class=\"line\">        &#123; <span class=\"comment\">/* BST就是要删除的结点 */</span></span><br><span class=\"line\">            <span class=\"comment\">/* 如果被删除结点有左右两个子结点 */</span> </span><br><span class=\"line\">            <span class=\"keyword\">if</span>( BST-&gt;Left &amp;&amp; BST-&gt;Right ) </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">/* 从右子树中找最小的元素填充删除结点 */</span></span><br><span class=\"line\">                Tmp = FindMin( BST-&gt;Right );</span><br><span class=\"line\">                BST-&gt;Data = Tmp-&gt;Data;</span><br><span class=\"line\">                <span class=\"comment\">/* 从右子树中删除最小元素 */</span></span><br><span class=\"line\">                BST-&gt;Right = Delete( BST-&gt;Right, BST-&gt;Data );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> </span><br><span class=\"line\">            &#123; <span class=\"comment\">/* 被删除结点有一个或无子结点 */</span></span><br><span class=\"line\">                Tmp = BST; </span><br><span class=\"line\">                <span class=\"keyword\">if</span>( !BST-&gt;Left )       <span class=\"comment\">/* 只有右孩子或无子结点 */</span></span><br><span class=\"line\">                    BST = BST-&gt;Right; </span><br><span class=\"line\">                <span class=\"keyword\">else</span>                   <span class=\"comment\">/* 只有左孩子 */</span></span><br><span class=\"line\">                    BST = BST-&gt;Left;</span><br><span class=\"line\">                <span class=\"built_in\">free</span>( Tmp );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BST;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"Given-a-binary-search-tree-with-its-preorder-traversal-sequence-8-2-15-10-12-21-If-8-is-deleted-from-the-tree-which-one-of-the-following-statements-is-FALSE\"><a href=\"#Given-a-binary-search-tree-with-its-preorder-traversal-sequence-8-2-15-10-12-21-If-8-is-deleted-from-the-tree-which-one-of-the-following-statements-is-FALSE\" class=\"headerlink\" title=\"Given a binary search tree with its preorder traversal sequence { 8, 2, 15, 10, 12, 21 }. If 8 is deleted from the tree, which one of the following statements is FALSE?\"></a>Given a binary search tree with its preorder traversal sequence { 8, 2, 15, 10, 12, 21 }. If 8 is deleted from the tree, which one of the following statements is FALSE?</h5><p>A. One possible preprder traversal sequence of the resulting tree may be { 2, 15, 10, 12, 21 }</p>\n<p>B. One possible preprder traversal sequence of the resulting tree may be { 10, 2, 15, 12, 21 }</p>\n<p>C. One possible preprder traversal sequence of the resulting tree may be { 15, 10, 2, 12, 21 }</p>\n<p>D. It is possible that the new root may have 2 children</p>\n<p>C</p>\n<p>8是根节点，删除之后根可能是左子树最大的元素或者右子树最小的元素</p>\n<pre class=\"mermaid\">graph TD\n8-->2\n8-->15\n15-->10\n10-->_\n10-->12\n15-->21</pre>\n\n<p>delete 8:</p>\n<pre class=\"mermaid\">graph TD\n2-->15\n15-->10\n10-->-\n10-->12\n15-->21</pre>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">10--&gt;2</span><br><span class=\"line\">10--&gt;15</span><br><span class=\"line\">15--&gt;12</span><br><span class=\"line\">15--&gt;21</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h5 id=\"2-4-Insert-5-2-7-3-4-1-6-one-by-one-into-an-initially-empty-binary-search-tree-The-postorder-traversal-sequence-of-the-resulting-tree-is\"><a href=\"#2-4-Insert-5-2-7-3-4-1-6-one-by-one-into-an-initially-empty-binary-search-tree-The-postorder-traversal-sequence-of-the-resulting-tree-is\" class=\"headerlink\" title=\"2-4 Insert {5, 2, 7, 3, 4, 1, 6} one by one into an initially empty binary search tree. The postorder traversal sequence of the resulting tree is:\"></a>2-4 Insert {5, 2, 7, 3, 4, 1, 6} one by one into an initially empty binary search tree. The postorder traversal sequence of the resulting tree is:</h5><p>A. 1, 2, 3, 4, 6, 7, 5</p>\n<p>B. 1, 4, 2, 6, 3, 7, 5</p>\n<p>C. 1, 4, 3, 2, 6, 7, 5</p>\n<p>D. 5, 4, 3, 7, 6, 2, 1</p>\n<p>注意是&#x3D;&#x3D;one by one&#x3D;&#x3D;，所以选C</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">5--&gt;2</span><br><span class=\"line\">5--&gt;7</span><br><span class=\"line\">2--&gt;1</span><br><span class=\"line\">2--&gt;3</span><br><span class=\"line\">3--&gt;_</span><br><span class=\"line\">3--&gt;4</span><br><span class=\"line\">7--&gt;6</span><br><span class=\"line\">7--&gt;-</span><br></pre></td></tr></table></figure>\n\n<p>后序遍历：1 4 3 2 6 7 5</p>\n<h5 id=\"2-5-Among-the-following-binary-trees-which-one-can-possibly-be-the-decision-tree-the-external-nodes-are-excluded-for-binary-search\"><a href=\"#2-5-Among-the-following-binary-trees-which-one-can-possibly-be-the-decision-tree-the-external-nodes-are-excluded-for-binary-search\" class=\"headerlink\" title=\"2-5 Among the following binary trees, which one can possibly be the decision tree (the external nodes are excluded) for binary search?\"></a>2-5 Among the following binary trees, which one can possibly be the decision tree (the external nodes are excluded) for binary search?</h5><p>A.</p>\n<p><img data-src=\"https://images.ptausercontent.com/282\" alt=\"img\"></p>\n<p>B.</p>\n<p><img data-src=\"https://images.ptausercontent.com/283\" alt=\"img\"></p>\n<p>C.</p>\n<p><img data-src=\"https://images.ptausercontent.com/284\" alt=\"img\"></p>\n<p>D.</p>\n<p><img data-src=\"https://images.ptausercontent.com/285\" alt=\"img\"></p>\n<p><strong>A</strong></p>\n<p>决策树：左子树总是大于等于右子树或者右子树总是大于等于左子树才符合。</p>\n<p>用排除法可得A</p>\n<h5 id=\"2-6-For-a-binary-search-tree-in-which-order-of-traversal-that-we-can-obtain-a-non-decreasing-sequence\"><a href=\"#2-6-For-a-binary-search-tree-in-which-order-of-traversal-that-we-can-obtain-a-non-decreasing-sequence\" class=\"headerlink\" title=\"2-6 For a binary search tree, in which order of traversal that we can obtain a non-decreasing sequence?\"></a>2-6 For a binary search tree, in which order of traversal that we can obtain a non-decreasing sequence?</h5><p>A. preorder traversal</p>\n<p>B. postorder traversal</p>\n<p>C. inorder traversal</p>\n<p>D. level-order traversal</p>\n<p><strong>C</strong></p>\n<p>中序遍历得到的序列是非递减的，前序遍历和后序遍历得到的都是无序的。</p>\n<h2 id=\"HW6\"><a href=\"#HW6\" class=\"headerlink\" title=\"HW6\"></a>HW6</h2><h5 id=\"1-1-If-a-complete-binary-tree-with-137-nodes-is-stored-in-an-array-root-at-position-1-then-the-nodes-at-positions-128-and-137-are-at-the-same-level\"><a href=\"#1-1-If-a-complete-binary-tree-with-137-nodes-is-stored-in-an-array-root-at-position-1-then-the-nodes-at-positions-128-and-137-are-at-the-same-level\" class=\"headerlink\" title=\"1-1 If a complete binary tree with 137 nodes is stored in an array (root at position 1), then the nodes at positions 128 and 137 are at the same level.\"></a>1-1 If a complete binary tree with 137 nodes is stored in an array (root at position 1), then the nodes at positions 128 and 137 are at the same level.</h5><p>T</p>\n<p>完全二叉树：若二叉树的深度为h，则除第h层外，其他层的结点全部达到最大值，且第h层的所有结点都集中在左子树。</p>\n<p>满二叉树：满二叉树是一种特殊的的完全二叉树，所有层的结点都是最大值。</p>\n<p><a href=\"https://blog.csdn.net/xiaomucgwlmx/article/details/103522410\"><strong>堆（heap)</strong></a></p>\n<p>堆（英语：heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质：</p>\n<p>堆中某个节点的值总是不大于或不小于其父节点的值；</p>\n<p>堆总是一棵完全二叉树。</p>\n<p>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。</p>\n<p>堆是非线性数据结构，相当于一维数组，有两个直接后继。</p>\n<p><strong>注意： 在二叉树中，若当前节点的下标为 i， 则其父节点的下标为 i&#x2F;2，其左子节点的下标为 i*2，其右子节点的下标为i*2+1；</strong></p>\n<h5 id=\"1-2-The-inorder-traversal-sequence-of-any-min-heap-must-be-in-sorted-order\"><a href=\"#1-2-The-inorder-traversal-sequence-of-any-min-heap-must-be-in-sorted-order\" class=\"headerlink\" title=\"1-2 The inorder traversal sequence of any min-heap must be in sorted order.\"></a>1-2 The inorder traversal sequence of any min-heap must be in sorted order.</h5><p><strong>F</strong></p>\n<p>在最小堆中，虽然父节点的值小于或等于其子节点的值，但是并没有要求兄弟节点之间的大小关系。因此，在进行中序遍历时，并不能保证得到一个有序的序列。（完全二叉树vs二叉搜索树）</p>\n<h5 id=\"2-1-In-a-max-heap-with-n-1-elements-the-array-index-of-the-minimum-key-may-be\"><a href=\"#2-1-In-a-max-heap-with-n-1-elements-the-array-index-of-the-minimum-key-may-be\" class=\"headerlink\" title=\"2-1 In a max-heap with n (&gt;1) elements, the array index of the minimum key may be __.\"></a>2-1 In a max-heap with <em>n</em> (&gt;1) elements, the array index of the minimum key may be __.</h5><p>A. 1</p>\n<p>B. ⌊<em>n</em>&#x2F;2⌋−1</p>\n<p>C. ⌊<em>n</em>&#x2F;2⌋</p>\n<p>D. ⌊<em>n</em>&#x2F;2⌋+2</p>\n<p><strong>D</strong></p>\n<p>最大堆最小的元素在叶子结点上，⌊<em>n</em>&#x2F;2⌋有子节点是⌊<em>n</em>⌋，所以肯定不是最小的元素，只能选D</p>\n<h5 id=\"2-2-Using-the-linear-algorithm-to-build-a-min-heap-from-the-sequence-15-26-32-8-7-20-12-13-5-19-and-then-insert-6-Which-one-of-the-following-statements-is-FALSE\"><a href=\"#2-2-Using-the-linear-algorithm-to-build-a-min-heap-from-the-sequence-15-26-32-8-7-20-12-13-5-19-and-then-insert-6-Which-one-of-the-following-statements-is-FALSE\" class=\"headerlink\" title=\"2-2 Using the linear algorithm to build a min-heap from the sequence {15, 26, 32, 8, 7, 20, 12, 13, 5, 19}, and then insert 6. Which one of the following statements is FALSE?\"></a>2-2 Using the linear algorithm to build a min-heap from the sequence {15, 26, 32, 8, 7, 20, 12, 13, 5, 19}, and then insert 6. Which one of the following statements is FALSE?</h5><p>A. The root is 5</p>\n<p>B. The path from the root to 26 is {5, 6, 8, 26}</p>\n<p>C. 32 is the left child of 12</p>\n<p>D. 7 is the parent of 19 and 15</p>\n<p><strong>C</strong></p>\n<p>先按level order建堆，然后从第一个父节点开始上滤，直到得到MinHeap</p>\n<p>插入6：插入之后依旧是完全二叉树，然后上滤</p>\n<p><strong>堆的插入</strong></p>\n<p>插入到最后一层最左侧的位置，然后和父节点比较，如果最小堆插入的元素比父节点小就和父节点交换位置，一直换到比父节点大为止，复杂度O(logn)。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span>  <span class=\"title function_\">Insert</span><span class=\"params\">( ElementType  X,  PriorityQueue  H )</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">     <span class=\"type\">int</span>  i; </span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">if</span> ( IsFull( H ) ) </span><br><span class=\"line\">     &#123; </span><br><span class=\"line\">\t\tError( <span class=\"string\">&quot;Priority queue is full&quot;</span> ); </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>; </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">\t<span class=\"comment\">/*首先确定初始位置是堆的个数+1，这个位置到根的路径是i/2*/</span></span><br><span class=\"line\">     <span class=\"keyword\">for</span> ( i = ++H-&gt;Size; H-&gt;Elements[ i / <span class=\"number\">2</span> ] &gt; X; i /= <span class=\"number\">2</span> ) </span><br><span class=\"line\">\t\tH-&gt;Elements[ i ] = H-&gt;Elements[ i / <span class=\"number\">2</span> ]; </span><br><span class=\"line\">\t\t<span class=\"comment\">/*当第(i/2)个大于X的时候，就往后移动，i/2小于X的时候，就让孩子i变成X*/</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">     H-&gt;Elements[ i ] = X; <span class=\"comment\">//</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>堆的删除</strong></p>\n<p>堆中每次都只能删除堆顶元素。为了便于重建堆，实际的操作是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整(shift_down)。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ElementType  <span class=\"title function_\">DeleteMin</span><span class=\"params\">( PriorityQueue  H )</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    <span class=\"type\">int</span>  i, Child; </span><br><span class=\"line\">    ElementType  MinElement, LastElement; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( IsEmpty( H ) ) </span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">         Error( <span class=\"string\">&quot;Priority queue is empty&quot;</span> ); </span><br><span class=\"line\">         <span class=\"keyword\">return</span>  H-&gt;Elements[ <span class=\"number\">0</span> ];   </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    MinElement = H-&gt;Elements[ <span class=\"number\">1</span> ];  <span class=\"comment\">/* save the min element */</span></span><br><span class=\"line\">    LastElement = H-&gt;Elements[ H-&gt;Size-- ];  <span class=\"comment\">/* take last and reset size */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( i = <span class=\"number\">1</span>; i * <span class=\"number\">2</span> &lt;= H-&gt;Size; i = Child ) </span><br><span class=\"line\">    &#123;  <span class=\"comment\">/* Find smaller child */</span> </span><br><span class=\"line\">         Child = i * <span class=\"number\">2</span>; </span><br><span class=\"line\">         <span class=\"keyword\">if</span> (Child != H-&gt;Size &amp;&amp; H-&gt;Elements[Child+<span class=\"number\">1</span>] &lt; H-&gt;Elements[Child]) </span><br><span class=\"line\">\t       Child++;     <span class=\"comment\">/*如果child+1更小，让child指向child+1*/</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> ( LastElement &gt; H-&gt;Elements[ Child ] )   <span class=\"comment\">/* Percolate one level */</span> </span><br><span class=\"line\">\t     \tH-&gt;Elements[ i ] = H-&gt;Elements[ Child ]; <span class=\"comment\">/*把child放在i的位置，和最后一句对应*/</span></span><br><span class=\"line\">         <span class=\"keyword\">else</span></span><br><span class=\"line\">         \t<span class=\"keyword\">break</span>;   <span class=\"comment\">/* find the proper position */</span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    H-&gt;Elements[ i ] = LastElement; <span class=\"comment\">/*把本来的最后一个元素放在i的位置，和上面那句对应*/</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>  MinElement; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>建堆</strong></p>\n<p>1)首先把数组按照层序（level order）放在一个空堆中<br>(2)从最后一个父节点开始，让父节点，右孩子，左孩子中最小的放在父节点的位置。<br>(3)如果父节点被换下去了，那么必须执行shiftdown操作，即被换下去的结点与当前的子节点比较，并交换，直到符合比任何一个子节点大的条件。<br>对于2-2</p>\n<pre class=\"mermaid\">graph TD;\n15-->26;\n15-->32;\n26-->8;\n26-->7;\n32-->20;\n32-->12;\n8-->13;\n8-->5;\n7-->19;</pre>\n\n<p>一开始按层序遍历建堆，接下来从第一个父节点7开始执行shift_down，不变</p>\n<p>然后对8shift_down，交换8和5</p>\n<pre class=\"mermaid\">graph TD;\n15-->26;\n15-->32;\n26-->5;\n26-->7;\n32-->20;\n32-->12;\n5-->13;\n5-->8;\n7-->19;</pre>\n\n<p>以此类推</p>\n<p>总的过程：</p>\n<p>对7shiftdown:不变<br>对8shiftdown:15 26 32 5 7 20 12 13 8 19<br>对32shiftdown:15 26 12 5 7 20 32 13 8 19<br>对26shiftdown:15 5 12 8 7 20 32 13 26 19<br>对15shiftdown: 5 7 12 8 15 20 32 13 26 19<br>插入6: 6 12 8 7 20 32 13 20 19 15</p>\n<h5 id=\"2-3-If-a-d-heap-is-stored-as-an-array-for-an-entry-located-in-position-i-the-parent-the-first-child-and-the-last-child-are-at\"><a href=\"#2-3-If-a-d-heap-is-stored-as-an-array-for-an-entry-located-in-position-i-the-parent-the-first-child-and-the-last-child-are-at\" class=\"headerlink\" title=\"2-3 If a d-heap is stored as an array, for an entry located in position i, the parent, the first child and the last child are at:\"></a>2-3 If a <em>d</em>-heap is stored as an array, for an entry located in position <em>i</em>, the parent, the first child and the last child are at:</h5><p>A. ⌈(<em>i</em>+<em>d</em>−2)&#x2F;<em>d</em>⌉, (<em>i</em>−2)<em>d</em>+2, and (<em>i</em>−1)<em>d</em>+1</p>\n<p>B. ⌈(<em>i</em>+<em>d</em>−1)&#x2F;<em>d</em>⌉, (<em>i</em>−2)<em>d</em>+1, and (<em>i</em>−1)<em>d</em></p>\n<p>C. ⌊(<em>i</em>+<em>d</em>−2)&#x2F;<em>d</em>⌋, (<em>i</em>−1)<em>d</em>+2, and <em>id</em>+1</p>\n<p>D. ⌊(<em>i</em>+<em>d</em>−1)&#x2F;<em>d</em>⌋, (<em>i</em>−1)<em>d</em>+1, and <em>id</em></p>\n<p><strong>C</strong></p>\n<h5 id=\"2-6-If-a-binary-search-tree-of-N-nodes-is-complete-which-one-of-the-following-statements-is-FALSE\"><a href=\"#2-6-If-a-binary-search-tree-of-N-nodes-is-complete-which-one-of-the-following-statements-is-FALSE\" class=\"headerlink\" title=\"2-6 If a binary search tree of N nodes is complete, which one of the following statements is FALSE?\"></a>2-6 If a binary search tree of <em>N</em> nodes is complete, which one of the following statements is FALSE?</h5><p>A. the average search time for all nodes is <em>O</em>(log<em>N</em>)\t\t</p>\n<p>二叉搜索的时间复杂度是O(logN)，对</p>\n<p>B. the minimum key must be at a leaf node</p>\n<p>最左边的节点</p>\n<p>C. the maximum key must be at a leaf node</p>\n<p>最大值可能在上一层的最右边的结点（此节点只有leftchildren），错</p>\n<p>D. the median node must either be the root or in the left subtree</p>\n<h4 id=\"函数题-1\"><a href=\"#函数题-1\" class=\"headerlink\" title=\"函数题\"></a>函数题</h4><p><strong>6-1 Percolate Up and Down</strong></p>\n<p>Write the routines to do a “percolate up” and a “percolate down” in a binary min-heap.</p>\n<h3 id=\"Format-of-functions-3\"><a href=\"#Format-of-functions-3\" class=\"headerlink\" title=\"Format of functions:\"></a>Format of functions:</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">PercolateUp</span><span class=\"params\">( <span class=\"type\">int</span> p, PriorityQueue H )</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">PercolateDown</span><span class=\"params\">( <span class=\"type\">int</span> p, PriorityQueue H )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>where <code>int p</code> is the position of the element, and <code>PriorityQueue</code> is defined as the following:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HeapStruct</span> *<span class=\"title\">PriorityQueue</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HeapStruct</span> &#123;</span></span><br><span class=\"line\">    ElementType  *Elements;</span><br><span class=\"line\">    <span class=\"type\">int</span> Capacity;</span><br><span class=\"line\">    <span class=\"type\">int</span> Size;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Sample-program-of-judge-3\"><a href=\"#Sample-program-of-judge-3\" class=\"headerlink\" title=\"Sample program of judge:\"></a>Sample program of judge:</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> ElementType;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MinData -1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HeapStruct</span> *<span class=\"title\">PriorityQueue</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HeapStruct</span> &#123;</span></span><br><span class=\"line\">    ElementType  *Elements;</span><br><span class=\"line\">    <span class=\"type\">int</span> Capacity;</span><br><span class=\"line\">    <span class=\"type\">int</span> Size;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">PriorityQueue <span class=\"title function_\">Initialize</span><span class=\"params\">( <span class=\"type\">int</span> MaxElements )</span>; <span class=\"comment\">/* details omitted */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">PercolateUp</span><span class=\"params\">( <span class=\"type\">int</span> p, PriorityQueue H )</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">PercolateDown</span><span class=\"params\">( <span class=\"type\">int</span> p, PriorityQueue H )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Insert</span><span class=\"params\">( ElementType X, PriorityQueue H )</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> p = ++H-&gt;Size;</span><br><span class=\"line\">    H-&gt;Elements[p] = X;</span><br><span class=\"line\">    PercolateUp( p, H );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ElementType <span class=\"title function_\">DeleteMin</span><span class=\"params\">( PriorityQueue H )</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    ElementType MinElement; </span><br><span class=\"line\">    MinElement = H-&gt;Elements[<span class=\"number\">1</span>];</span><br><span class=\"line\">    H-&gt;Elements[<span class=\"number\">1</span>] = H-&gt;Elements[H-&gt;Size--];</span><br><span class=\"line\">    PercolateDown( <span class=\"number\">1</span>, H );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MinElement; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n, i, op, X;</span><br><span class=\"line\">    PriorityQueue H;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">    H = Initialize(n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( i=<span class=\"number\">0</span>; i&lt;n; i++ ) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;op);</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>( op ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;X);</span><br><span class=\"line\">            Insert(X, H);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, DeleteMin(H));</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\nInside H:&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( i=<span class=\"number\">1</span>; i&lt;=H-&gt;Size; i++ )</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; %d&quot;</span>, H-&gt;Elements[i]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Your function will be put here */</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Sample-Input-3\"><a href=\"#Sample-Input-3\" class=\"headerlink\" title=\"Sample Input:\"></a>Sample Input:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">9</span><br><span class=\"line\">1 10</span><br><span class=\"line\">1 5</span><br><span class=\"line\">1 2</span><br><span class=\"line\">0</span><br><span class=\"line\">1 9</span><br><span class=\"line\">1 1</span><br><span class=\"line\">1 4</span><br><span class=\"line\">0</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Sample-Output-3\"><a href=\"#Sample-Output-3\" class=\"headerlink\" title=\"Sample Output:\"></a>Sample Output:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2 1 4 </span><br><span class=\"line\">Inside H: 5 10 9</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">PercolateUp</span><span class=\"params\">( <span class=\"type\">int</span> p, PriorityQueue H )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p&gt;<span class=\"number\">1</span> &amp;&amp; H-&gt;Elements[p] &lt; H-&gt;Elements[p/<span class=\"number\">2</span>])&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> temp;</span><br><span class=\"line\">        temp = H-&gt;Elements[p];</span><br><span class=\"line\">        H-&gt;Elements[p] = H-&gt;Elements[p/<span class=\"number\">2</span>];</span><br><span class=\"line\">        H-&gt;Elements[p/<span class=\"number\">2</span>] = temp;</span><br><span class=\"line\">        p = p/<span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">PercolateDown</span><span class=\"params\">( <span class=\"type\">int</span> p, PriorityQueue H )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p*<span class=\"number\">2</span>&lt;=H-&gt;Size &amp;&amp; H-&gt;Elements[p*<span class=\"number\">2</span>] &lt; H-&gt;Elements[p])&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> temp;</span><br><span class=\"line\">        temp = H-&gt;Elements[p];</span><br><span class=\"line\">        H-&gt;Elements[p] = H-&gt;Elements[p*<span class=\"number\">2</span>];</span><br><span class=\"line\">        H-&gt;Elements[p*<span class=\"number\">2</span>] = temp;</span><br><span class=\"line\">        p = p*<span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>PercolateUp就是和父节点比较，如果比父节点小就交换，直到根节点或者比父节点大为止；</p>\n<p>PercolateDown就是和子节点比较，同理。</p>\n<h2 id=\"HW7\"><a href=\"#HW7\" class=\"headerlink\" title=\"HW7\"></a>HW7</h2><p>并查集（disjoint set)</p>\n<p><strong>查找</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SetType  <span class=\"title function_\">Find</span> <span class=\"params\">( ElementType X, </span></span><br><span class=\"line\"><span class=\"params\">                           DisjSet S )</span></span><br><span class=\"line\">&#123;   <span class=\"keyword\">for</span> ( ; S[X] &gt; <span class=\"number\">0</span>; X = S[X] )   ;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>  X ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>Please fill in the blanks in the program which performs <code>Find</code> as a Union&#x2F;Find operation with path compression.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SetType <span class=\"title function_\">Find</span> <span class=\"params\">( ElementType X, DisjSet S )</span></span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">   ElementType root, trail, lead;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">for</span> ( root = X; S[root] &gt; <span class=\"number\">0</span>; root=S[root] );  <span class=\"comment\">//查找</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> ( trail = X; trail != root; trail = lead ) &#123;</span><br><span class=\"line\">      lead = S[trail];   </span><br><span class=\"line\">       S[trail]=root;</span><br><span class=\"line\">   &#125; <span class=\"comment\">//路径压缩</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>合并</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Union</span><span class=\"params\">( ElementType i, ElementType j, DisjSet S )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> root1, root2;</span><br><span class=\"line\">    root1 = Find(i);</span><br><span class=\"line\">    root2 = Find(j);</span><br><span class=\"line\">    S[root2] = root1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Union by size:</strong></p>\n<p>Union by size 是一种基于并查集（Disjoint Set）的合并策略，用于在合并两个集合时选择根节点。该策略<strong>将小集合合并到大集合中</strong>，以减少合并后的树高度，提高查找效率。</p>\n<p>具体来说，在 Union by size 策略中，每个集合的大小都可以表示为其根节点的负值，即 S[root] 的值是集合的大小。因此，当要将两个集合合并时，首先找到它们各自的根节点 root1 和 root2，并比较两个根节点所代表的集合大小。如果 S[root1] 大于 S[root2]，则将 root2 的父节点设为 root1，同时将 root1 的大小更新为两个集合的大小之和；否则，将 root1 的父节点设为 root2，同时将 root2 的大小更新为两个集合的大小之和。</p>\n<p>这样做的原理是，将小集合合并到大集合中可以减少树的高度，从而提高了查找效率。因为树的高度越低，查找元素的时间复杂度就越小，路径压缩也更容易实现。</p>\n<p>1-1 In <em>Union&#x2F;Find</em> algorithm, if <em>Unions</em> are done by size, the depth of any node must be no more than <em>N</em>&#x2F;2, but not $$O(logN)$$.</p>\n<p>F</p>\n<pre class=\"mermaid\">graph TD\n0-->1\n0-->2\n2-->3\n2-->4\n4-->5\n4-->6</pre>\n\n<p>$$height(T)&lt;&#x3D;log_2N+1$$\t</p>\n<h5 id=\"2-3-Let-T-be-a-tree-created-by-union-by-size-with-N-nodes-then-the-height-of-T-can-be\"><a href=\"#2-3-Let-T-be-a-tree-created-by-union-by-size-with-N-nodes-then-the-height-of-T-can-be\" class=\"headerlink\" title=\"2-3 Let T be a tree created by union-by-size with N nodes, then the height of T can be .\"></a>2-3 Let <em>T</em> be a tree created by union-by-size with <em>N</em> nodes, then the height of <em>T</em> can be .</h5><p>A.at most $$log_2N+1$$</p>\n<p>B.at least $$log_2N+1$$</p>\n<p>C.as large as $$N$$</p>\n<p>D.anything that is greater than 1</p>\n<p><strong>A</strong></p>\n<h2 id=\"HW8\"><a href=\"#HW8\" class=\"headerlink\" title=\"HW8\"></a>HW8</h2><p><strong>一些定义：</strong></p>\n<p>Complete graph:  a graph that has the maximum number of edges.</p>\n<p>An undirected graph G is <strong>connected</strong> if every pair of distinct vi and vj are connected.</p>\n<p> (Connected) <strong>Component</strong> of an undirected G ::&#x3D; the maximal connected subgraph——联通分量</p>\n<p>最大联通分量</p>\n<p>A tree ::&#x3D; a graph that is connected and acyclic(无环的)</p>\n<p>A DAG ::&#x3D; a directed acyclic graph</p>\n<p>Strongly connected directed graph G ::&#x3D; for every pair of vi and vj in V( G ), there exist directed paths from vi to vj and from vj to vi.  If the graph is connected without direction to the edges, then it is said to be weakly connected.</p>\n<p>强联通：有向图的每一对顶点之间都有路径</p>\n<p>弱连通：有向图底下的无向图之间都是联通的</p>\n<p>边数最小的联通图是树，E&#x3D;V-1</p>\n<h5 id=\"2-3-Given-the-adjacency-list-of-a-directed-graph-as-shown-by-the-figure-There-is-are-strongly-connected-component-s\"><a href=\"#2-3-Given-the-adjacency-list-of-a-directed-graph-as-shown-by-the-figure-There-is-are-strongly-connected-component-s\" class=\"headerlink\" title=\"2-3 Given the adjacency list of a directed graph as shown by the figure. There is(are) __ strongly connected component(s).\"></a>2-3 Given the adjacency list of a directed graph as shown by the figure. There is(are) __ strongly connected component(s).</h5><p><img data-src=\"https://images.ptausercontent.com/119\" alt=\"img\"></p>\n\nA. 4 {{0, 1, 5}, {2}, {3}, {4}}\n\nB. 3 {{2}, {4}, {0, 1, 3, 5}}\n\nC. 1 {0, 1, 2, 3, 4, 5}\n\nD. 1 {0, 5, 1, 3}\n\n\n<p><strong>B</strong></p>\n<pre class=\"mermaid\">graph LR;\n0-->5;\n1-->0;\n1-->3;\n2-->1;\n2-->4;\n3-->0;\n3-->4;\n5-->1;</pre>\n\n<p>强联通分量</p>\n<p>在有向图G中，如果两个顶点vi,vj间（vi&gt;vj）有一条从vi到vj的有向路径，同时还有一条从vj到vi的有向路径，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)，也就是说是图G的一些特殊子集。</p>\n<h5 id=\"1-3-If-a-directed-graph-G-V-E-is-weakly-connected-then-there-must-be-at-least-V-edges-in-G\"><a href=\"#1-3-If-a-directed-graph-G-V-E-is-weakly-connected-then-there-must-be-at-least-V-edges-in-G\" class=\"headerlink\" title=\"1-3 If a directed graph G&#x3D;(V, E) is weakly connected, then there must be at least |V| edges in G.\"></a>1-3 If a directed graph G&#x3D;(V, E) is weakly connected, then there must be at least |V| edges in G.</h5><p>F</p>\n<p>至少|V|-1</p>\n<h5 id=\"2-1-If-graph-G-is-NOT-connected-and-has-35-edges-then-it-must-have-at-least-vertices\"><a href=\"#2-1-If-graph-G-is-NOT-connected-and-has-35-edges-then-it-must-have-at-least-vertices\" class=\"headerlink\" title=\"2-1 If graph G is NOT connected and has 35 edges, then it must have &#x3D;&#x3D;at least&#x3D;&#x3D; ____ vertices.\"></a>2-1 If graph G is NOT connected and has 35 edges, then it must have &#x3D;&#x3D;at least&#x3D;&#x3D; ____ vertices.</h5><p>A.7</p>\n<p>B.8</p>\n<p>C.9</p>\n<p>D.10</p>\n<p>D</p>\n<p>$$\\frac{9×8}{2}&#x3D;36&gt;35$$</p>\n<p>9+1&#x3D;10</p>\n<p>&#x3D;&#x3D;重点区分：&#x3D;&#x3D;</p>\n<h5 id=\"2-2-A-graph-with-90-vertices-and-20-edges-must-have-at-least-connected-component-s\"><a href=\"#2-2-A-graph-with-90-vertices-and-20-edges-must-have-at-least-connected-component-s\" class=\"headerlink\" title=\"2-2 A graph with 90 vertices and 20 edges must have &#x3D;&#x3D;at least&#x3D;&#x3D; __ connected component(s).\"></a>2-2 A graph with 90 vertices and 20 edges must have &#x3D;&#x3D;at least&#x3D;&#x3D; __ connected component(s).</h5><p>A.69</p>\n<p>&#x3D;&#x3D;B.70&#x3D;&#x3D;</p>\n<p>C.84</p>\n<p>D.85</p>\n<p>【解析】20×2&#x3D;40，90-40+20&#x3D;70</p>\n<h5 id=\"【区分】：A-graph-with-90-vertices-and-20-edges-must-have-at-most-connected-component-s\"><a href=\"#【区分】：A-graph-with-90-vertices-and-20-edges-must-have-at-most-connected-component-s\" class=\"headerlink\" title=\"【区分】：A graph with 90 vertices and 20 edges must have &#x3D;&#x3D;at most&#x3D;&#x3D; __ connected component(s).\"></a>【区分】：A graph with 90 vertices and 20 edges must have &#x3D;&#x3D;at most&#x3D;&#x3D; __ connected component(s).</h5><p>A.69</p>\n<p>B.70</p>\n<p>&#x3D;&#x3D;C.84&#x3D;&#x3D;</p>\n<p>D.85</p>\n<p>【解析】 (7×6)&#x2F;2&#x3D;21，90-7+1&#x3D;84</p>\n<h5 id=\"2-4-Given-an-undirected-graph-G-with-16-edges-where-3-vertices-are-of-degree-4-4-vertices-are-of-degree-3-and-all-the-other-vertices-are-of-degrees-less-than-3-Then-G-must-have-at-least-vertices\"><a href=\"#2-4-Given-an-undirected-graph-G-with-16-edges-where-3-vertices-are-of-degree-4-4-vertices-are-of-degree-3-and-all-the-other-vertices-are-of-degrees-less-than-3-Then-G-must-have-at-least-vertices\" class=\"headerlink\" title=\"2-4 Given an undirected graph G with 16 edges, where 3 vertices are of degree 4, 4 vertices are of degree 3, and all the other vertices are of degrees less than 3. Then G must have at least __ vertices.\"></a>2-4 Given an undirected graph G with 16 edges, where 3 vertices are of degree 4, 4 vertices are of degree 3, and all the other vertices are of degrees less than 3. Then G must have at least __ vertices.</h5><p>A.10</p>\n<p>B.11</p>\n<p>C.13</p>\n<p>D.15</p>\n<p>$$e&#x3D;n_1+2n_2+3×4+4×3&#x3D;16×2&#x3D;32$$</p>\n<p>因为要求至少有几个，所以假设剩下的都是度为2的节点，32-24&#x3D;8，8÷2&#x3D;4，4+3+4&#x3D;11</p>\n<p><strong>拓扑排序</strong></p>\n<p>拓扑排序存在的前提：</p>\n<p>当且仅当一个有向图为有向无环图（directed acyclic graph，或称DAG）时，才能得到对应于该图的拓扑排序。每一个有向无环图都至少存在一种拓扑排序。</p>\n<p>方法：不断寻找入度为0的节点pop出去，删除该节点和相关的边</p>\n<p><strong>6-1 Is Topological Order</strong></p>\n<p>Write a program to test if a give sequence <code>Seq</code> is a topological order of a given graph <code>Graph</code>.</p>\n<h3 id=\"Format-of-functions-4\"><a href=\"#Format-of-functions-4\" class=\"headerlink\" title=\"Format of functions:\"></a>Format of functions:</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">IsTopSeq</span><span class=\"params\">( LGraph Graph, Vertex Seq[] )</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>where <code>LGraph</code> is defined as the following:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">AdjVNode</span> *PtrToAdjVNode; </span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">AdjVNode</span>&#123;</span><br><span class=\"line\">    Vertex AdjV;</span><br><span class=\"line\">    PtrToAdjVNode Next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">Vnode</span>&#123;</span><br><span class=\"line\">    PtrToAdjVNode FirstEdge;</span><br><span class=\"line\">&#125; AdjList[MaxVertexNum];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">GNode</span> *PtrToGNode;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">GNode</span>&#123;  </span><br><span class=\"line\">    <span class=\"type\">int</span> Nv;</span><br><span class=\"line\">    <span class=\"type\">int</span> Ne;</span><br><span class=\"line\">    AdjList G;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToGNode LGraph;</span><br></pre></td></tr></table></figure>\n\n<p>The function <code>IsTopSeq</code> must return <code>true</code> if <code>Seq</code> does correspond to a topological order; otherwise return <code>false</code>.</p>\n<p><strong>Note:</strong> Although the vertices are numbered from 1 to MaxVertexNum, they are <strong>indexed from 0</strong> in the LGraph structure.</p>\n<h3 id=\"Sample-program-of-judge-4\"><a href=\"#Sample-program-of-judge-4\" class=\"headerlink\" title=\"Sample program of judge:\"></a>Sample program of judge:</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span> &#123;</span><span class=\"literal\">false</span>, <span class=\"literal\">true</span>&#125; <span class=\"type\">bool</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxVertexNum 10  <span class=\"comment\">/* maximum number of vertices */</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> Vertex;      <span class=\"comment\">/* vertices are numbered from 1 to MaxVertexNum */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AdjVNode</span> *<span class=\"title\">PtrToAdjVNode</span>;</span> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AdjVNode</span>&#123;</span></span><br><span class=\"line\">    Vertex AdjV;</span><br><span class=\"line\">    PtrToAdjVNode Next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Vnode</span>&#123;</span></span><br><span class=\"line\">    PtrToAdjVNode FirstEdge;</span><br><span class=\"line\">&#125; AdjList[MaxVertexNum];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GNode</span> *<span class=\"title\">PtrToGNode</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GNode</span>&#123;</span>  </span><br><span class=\"line\">    <span class=\"type\">int</span> Nv;</span><br><span class=\"line\">    <span class=\"type\">int</span> Ne;</span><br><span class=\"line\">    AdjList G;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToGNode LGraph;</span><br><span class=\"line\"></span><br><span class=\"line\">LGraph <span class=\"title function_\">ReadG</span><span class=\"params\">()</span>; <span class=\"comment\">/* details omitted */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">IsTopSeq</span><span class=\"params\">( LGraph Graph, Vertex Seq[] )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i, j, N;</span><br><span class=\"line\">    Vertex Seq[MaxVertexNum];</span><br><span class=\"line\">    LGraph G = ReadG();</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;N);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;N; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j=<span class=\"number\">0</span>; j&lt;G-&gt;Nv; j++)</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;Seq[j]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( IsTopSeq(G, Seq)==<span class=\"literal\">true</span> ) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;yes\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;no\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Your function will be put here */</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Sample-Input-for-the-graph-shown-in-the-figure\"><a href=\"#Sample-Input-for-the-graph-shown-in-the-figure\" class=\"headerlink\" title=\"Sample Input (for the graph shown in the figure):\"></a>Sample Input (for the graph shown in the figure):</h3><p><img data-src=\"https://images.ptausercontent.com/5373e878-196d-45dd-a82f-555b1fea6929.JPG\" alt=\"topord.JPG\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6 8</span><br><span class=\"line\">1 2</span><br><span class=\"line\">1 3</span><br><span class=\"line\">5 2</span><br><span class=\"line\">5 4</span><br><span class=\"line\">2 3</span><br><span class=\"line\">2 6</span><br><span class=\"line\">3 4</span><br><span class=\"line\">6 4</span><br><span class=\"line\">5</span><br><span class=\"line\">1 5 2 3 6 4</span><br><span class=\"line\">5 1 2 6 3 4</span><br><span class=\"line\">5 1 2 3 6 4</span><br><span class=\"line\">5 2 1 6 3 4</span><br><span class=\"line\">1 2 3 4 5 6</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Sample-Output-4\"><a href=\"#Sample-Output-4\" class=\"headerlink\" title=\"Sample Output:\"></a>Sample Output:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yes</span><br><span class=\"line\">yes</span><br><span class=\"line\">yes</span><br><span class=\"line\">no</span><br><span class=\"line\">no</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">IsTopSeq</span><span class=\"params\">( LGraph Graph, Vertex Seq[] )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Vertex InDegree[<span class=\"number\">9999</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i&lt;<span class=\"number\">9999</span>; i++)&#123;</span><br><span class=\"line\">        InDegree[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    PtrToAdjVNode p;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; Graph-&gt;Nv; i++)&#123;</span><br><span class=\"line\">        p = Graph-&gt;G[i].FirstEdge;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            InDegree[p-&gt;AdjV]++;</span><br><span class=\"line\">            p = p-&gt;Next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; Graph-&gt;Nv; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(InDegree[Seq[i]<span class=\"number\">-1</span>] != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        InDegree[Seq[i]<span class=\"number\">-1</span>] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        p = Graph-&gt;G[Seq[i]<span class=\"number\">-1</span>].FirstEdge;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            InDegree[p-&gt;AdjV]--;</span><br><span class=\"line\">            p = p-&gt;Next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>Hamiltonian Cycle: 无向图中包含所有顶点的<strong>回路</strong></p>\n<p>Hamiltonian Path: 无向图中包含所有顶点的<strong>路径</strong></p>\n<p>哈密顿图：具有哈密顿回路的无向图</p>\n<h2 id=\"HW9\"><a href=\"#HW9\" class=\"headerlink\" title=\"HW9\"></a>HW9</h2><p>无权图的单源最短路算法（BFS）</p>\n<p><strong>无权图的建立：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AdjVNode</span> *<span class=\"title\">PtrToAdjVNode</span>;</span> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AdjVNode</span>&#123;</span></span><br><span class=\"line\">    Vertex AdjV;</span><br><span class=\"line\">    PtrToAdjVNode Next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Vnode</span>&#123;</span></span><br><span class=\"line\">    PtrToAdjVNode FirstEdge;</span><br><span class=\"line\">&#125; AdjList[MaxVertexNum];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GNode</span> *<span class=\"title\">PtrToGNode</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GNode</span>&#123;</span>  </span><br><span class=\"line\">    <span class=\"type\">int</span> Nv;</span><br><span class=\"line\">    <span class=\"type\">int</span> Ne;</span><br><span class=\"line\">    AdjList G;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToGNode LGraph;</span><br></pre></td></tr></table></figure>\n\n<p>跟hw8的一样</p>\n<p><strong>求从顶点S到任意一个顶点的最短路径</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Unweighted</span><span class=\"params\">( Graph G, Queue Q, <span class=\"type\">int</span> dist[], <span class=\"type\">int</span> path[], Vertex S )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  Vertex V, U;</span><br><span class=\"line\">  NodePtr ptr;</span><br><span class=\"line\"></span><br><span class=\"line\">  dist[S] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  Enqueue(S, Q);</span><br><span class=\"line\">  <span class=\"keyword\">while</span> ( !IsEmpty(Q) ) &#123;</span><br><span class=\"line\">    V = Dequeue( Q ); <span class=\"comment\">//弹出队列的第一个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( ptr=G-&gt;List[V].FirstEdge; ptr; ptr=ptr-&gt;Next) &#123; <span class=\"comment\">//找到V的邻接点</span></span><br><span class=\"line\">      U = ptr-&gt;AdjV;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( dist[U] == INFINITY ) &#123;</span><br><span class=\"line\">         dist[U] = dist[V] + <span class=\"number\">1</span>; <span class=\"comment\">//路径长度等于前一个点的路经长度+1</span></span><br><span class=\"line\">         path[U] = V; <span class=\"comment\">//把前一个点记录在当前点的path上</span></span><br><span class=\"line\">         Enqueue(U, Q); <span class=\"comment\">//把当前点入队</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>有权图的单源最短路算法</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaWNvdXJzZTE2My5vcmcvbGVhcm4vWkpVLTkzMDAxP3RpZD0xNDcxMjE4NDkxIy9sZWFybi9jb250ZW50P3R5cGU9ZGV0YWlsJmlkPTEyNTYxODE3NTkmY2lkPTEyODg5OTQ3MTAmcmVwbGF5PXRydWU=\">Dijkstra算法</span></p>\n<p>多源最短路算法</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaWNvdXJzZTE2My5vcmcvbGVhcm4vWkpVLTkzMDAxP3RpZD0xNDcxMjE4NDkxIy9sZWFybi9jb250ZW50P3R5cGU9ZGV0YWlsJmlkPTEyNTYxODE3NTkmY2lkPTEyODg5OTQ3MTEmY29udGVudGlkPTE4NDAwMTU=\">Floyd算法</span></p>\n<h5 id=\"2-3-If-besides-finding-the-shortest-path-from-S-to-every-other-vertices-we-also-need-to-count-the-number-of-different-shortest-paths-we-can-modify-the-Dijkstra-algorithm-in-the-following-way-add-an-array-count-so-that-count-V-records-the-number-of-different-shortest-paths-from-S-to-V-Then-count-V-shall-be-initialized-as\"><a href=\"#2-3-If-besides-finding-the-shortest-path-from-S-to-every-other-vertices-we-also-need-to-count-the-number-of-different-shortest-paths-we-can-modify-the-Dijkstra-algorithm-in-the-following-way-add-an-array-count-so-that-count-V-records-the-number-of-different-shortest-paths-from-S-to-V-Then-count-V-shall-be-initialized-as\" class=\"headerlink\" title=\"2-3 If besides finding the shortest path from S to every other vertices, we also need to count the number of different shortest paths, we can modify the Dijkstra algorithm in the following way: add an array count[] so that count[V] records the number of different shortest paths from S to V. Then count[V] shall be initialized as:\"></a>2-3 If besides finding the shortest path from <code>S</code> to every other vertices, we also need to count the number of different shortest paths, we can modify the Dijkstra algorithm in the following way: add an array <code>count[]</code> so that <code>count[V]</code> records the number of different shortest paths from <code>S</code> to <code>V</code>. Then <code>count[V]</code> shall be initialized as:</h5><p>A.<code>count[S]=1; </code> and <code>count[V]=0</code> for other <code>V</code></p>\n<p>B.<code>count[S]=0; </code> and <code>count[V]=1</code> for other <code>V</code></p>\n<p>C.<code>count[V]=1</code> for all vertices</p>\n<p>D.<code>count[V]=0</code> for all vertices</p>\n<p><strong>A</strong></p>\n<h1 id=\"HW10\"><a href=\"#HW10\" class=\"headerlink\" title=\"HW10\"></a>HW10</h1><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMW1WNHkxZTdCNS8/c3BtX2lkX2Zyb209MzMzLjEwMDcudG9wX3JpZ2h0X2Jhcl93aW5kb3dfaGlzdG9yeS5jb250ZW50LmNsaWNrJnZkX3NvdXJjZT0xYTdkOGY1OTZmM2RmZTQwZmVlMzRjODU4ZWQ0N2U3Mw==\">AOE网</span></p>\n<p>最早开始时间和最晚结束时间</p>\n<p><img data-src=\"/image-20240116202502513.png\"></p>\n<p>V代表事件，a代表活动</p>\n<p>事件（V）：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>V1</th>\n<th>V2</th>\n<th>V3</th>\n<th>V4</th>\n<th>V5</th>\n<th>V6</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>最早开始时间</td>\n<td>0</td>\n<td>3</td>\n<td>2</td>\n<td>6</td>\n<td>6</td>\n<td>8</td>\n</tr>\n<tr>\n<td>最晚完成时间</td>\n<td>0</td>\n<td>4</td>\n<td>2</td>\n<td>6</td>\n<td>7</td>\n<td>8</td>\n</tr>\n</tbody></table>\n<p>最早开始时间从前往后取最大的</p>\n<p>最晚完成时间从后往前推(用最早开始时间 - a），取最小的</p>\n<p>&#x3D;&#x3D;最早开始时间 &#x3D; 最晚完成时间 —— 关键路径&#x3D;&#x3D;</p>\n<p>活动（A）：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>a1</th>\n<th>a2</th>\n<th>a3</th>\n<th>a4</th>\n<th>a5</th>\n<th>a6</th>\n<th>a7</th>\n<th>a8</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>最早开始时间</td>\n<td>0</td>\n<td>0</td>\n<td>3</td>\n<td>3</td>\n<td>2</td>\n<td>2</td>\n<td>6</td>\n<td>6</td>\n</tr>\n<tr>\n<td>最晚完成时间</td>\n<td>1</td>\n<td>0</td>\n<td>4</td>\n<td>4</td>\n<td>2</td>\n<td>5</td>\n<td>6</td>\n<td>7</td>\n</tr>\n</tbody></table>\n<p>最早开始时间取箭头的出发点的最早开始时间，最晚完成时间取箭头指向的点的最晚完成时间 - a</p>\n<p>&#x3D;&#x3D;最早开始时间 &#x3D; 最晚完成时间 —— 关键活动&#x3D;&#x3D;</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVB2NDExNTd4aC8/cD05JnNwbV9pZF9mcm9tPXBhZ2VEcml2ZXI=\">Ford-Fulkerson Algorithm 寻找网络最大流</span></p>\n<p>用Residual Graph添加反向路径，然后用原图减去Residual Graph</p>\n<p>worst-case time complexity: O(f*m)\t\tf是最大流的大小，m是边数</p>\n<p><strong>最小生成树</strong></p>\n<p>最小生成树：从连通无向图中找出一棵树（包含所有n个节点和n-1条边），同时边的权重之和要最小</p>\n<p>Prim算法：随便取一个根节点记作visited，不断寻找visited节点和unvisited节点之间权重最小的边</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUE1NDExTTd6Yy8/c3BtX2lkX2Zyb209cGFnZURyaXZlciZ2ZF9zb3VyY2U9MWE3ZDhmNTk2ZjNkZmU0MGZlZTM0Yzg1OGVkNDdlNzM=\">Prim算法 寻找最小生成树</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVN2NDExVjc4MS8/c3BtX2lkX2Zyb209MzMzLjc4OCZ2ZF9zb3VyY2U9MWE3ZDhmNTk2ZjNkZmU0MGZlZTM0Yzg1OGVkNDdlNzM=\">Kruskal算法：</span>（1）创建一个队列，将边按权重排序，最小的在最上面；（2）从顶端不断dequeue，如果符合就在图中圈出那条边</p>\n<p>——并查集</p>\n<p><strong>一句话：Prim算法对点做操作，Kruskal算法对边做操作</strong></p>\n<h1 id=\"HW11\"><a href=\"#HW11\" class=\"headerlink\" title=\"HW11\"></a>HW11</h1><h5 id=\"1-1-For-a-graph-if-each-vertex-has-an-even-degree-or-only-two-vertexes-have-odd-degree-we-can-find-a-cycle-that-visits-every-edge-exactly-once\"><a href=\"#1-1-For-a-graph-if-each-vertex-has-an-even-degree-or-only-two-vertexes-have-odd-degree-we-can-find-a-cycle-that-visits-every-edge-exactly-once\" class=\"headerlink\" title=\"1-1 For a graph, if each vertex has an even degree or only two vertexes have odd degree, we can find a cycle that visits every edge exactly once\"></a>1-1 For a graph, if each vertex has an even degree or only two vertexes have odd degree, we can find a cycle that visits every edge exactly once</h5><p>F</p>\n<p>欧拉回路：当且仅当图中每个顶点的度数都为偶数，并且图是连通的（一笔画）</p>\n<p>欧拉路径：当且仅当图中恰有两个顶点的度数为奇数，其余顶点的度数都为偶数，并且图是连通的</p>\n<p>哈密顿Cycle：经过所有节点的环</p>\n<p>哈密顿Path：经过所有节点的回路</p>\n<p>DFS:寻路–回溯</p>\n<h5 id=\"2-1-Apply-DFS-to-a-directed-acyclic-graph-and-output-the-vertex-before-the-end-of-each-recursion-The-output-sequence-will-be\"><a href=\"#2-1-Apply-DFS-to-a-directed-acyclic-graph-and-output-the-vertex-before-the-end-of-each-recursion-The-output-sequence-will-be\" class=\"headerlink\" title=\"2-1 Apply DFS to a directed acyclic graph, and output the vertex before the end of each recursion. The output sequence will be:\"></a>2-1 Apply DFS to a directed acyclic graph, and output the vertex before the end of each recursion. The output sequence will be:</h5><p>A.unsorted</p>\n<p>&#x3D;&#x3D;B.topologically sorted&#x3D;&#x3D;</p>\n<p>C.reversely topologically sorted</p>\n<p>D.None of the above</p>\n<p>Biconnected:（重连通）</p>\n<p><img data-src=\"/image-20240116215902974.png\"><br><img data-src=\"/image-20240116221328431.png\"></p>\n<p>插入排序：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InsertionSort</span><span class=\"params\">( ElementType A[], <span class=\"type\">int</span> N )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> j, P;</span><br><span class=\"line\">    ElementType Tmp;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(P=<span class=\"number\">1</span>; P&lt;N; P++)&#123;</span><br><span class=\"line\">        Tmp = A[P];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j=P; j&gt;<span class=\"number\">0</span> &amp;&amp; A[j<span class=\"number\">-1</span>]&gt;Tmp; j--)&#123;</span><br><span class=\"line\">            A[j]=A[j<span class=\"number\">-1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        A[j]=Tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>worst-case time complexity: $$O(N^2)$$</p>\n<p>best-case time complexity: $$O(N)$$</p>\n<p>$$T(N,I) &#x3D; O(I+N)$$ —— I:逆序对</p>\n<p>对于任意一个交换相邻元素的排序算法，平均时间复杂度都是$$\\Omega(N^2)$$.</p>\n<p><strong>ShellSort</strong></p>\n<p><strong>希尔排序</strong></p>\n<p>5-sort</p>\n<p>3-sort</p>\n<p>1-sort</p>\n<p>每一步都是插入排序</p>\n<p>（1）Define an increment sequence h1 &lt; h2 &lt; … &lt; ht  ( h1 &#x3D; 1 )</p>\n<p>（2）Define an $$h_k-sort$$ at each phase for k &#x3D; t, t - 1, …, 1</p>\n<p><strong>Shell’s increment sequence：$$h_t&#x3D;\\lfloor N \\rfloor$$, $$h_k &#x3D; \\lfloor h_k+1 &#x2F; 2\\rfloor $$</strong></p>\n<p>worst-case time complexity: $$\\theta(N^2)$$</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Shellsort</span><span class=\"params\">( ElementType A[ ], <span class=\"type\">int</span> N )</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">      <span class=\"type\">int</span>  i, j, Increment; </span><br><span class=\"line\">      ElementType  Tmp; </span><br><span class=\"line\">      <span class=\"keyword\">for</span> ( Increment = N / <span class=\"number\">2</span>; Increment &gt; <span class=\"number\">0</span>; Increment /= <span class=\"number\">2</span> )  </span><br><span class=\"line\">\t<span class=\"comment\">/*h sequence */</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( i = Increment; i &lt; N; i++ ) &#123; <span class=\"comment\">/* insertion sort */</span></span><br><span class=\"line\">\t      Tmp = A[ i ]; </span><br><span class=\"line\">\t      <span class=\"keyword\">for</span> ( j = i; j &gt;= Increment; j - = Increment ) </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>( Tmp &lt; A[ j - Increment ] ) </span><br><span class=\"line\">\t\t      A[ j ] = A[ j - Increment ]; </span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> </span><br><span class=\"line\">\t\t      <span class=\"keyword\">break</span>; </span><br><span class=\"line\">\t\tA[ j ] = Tmp; </span><br><span class=\"line\">\t&#125; <span class=\"comment\">/* end for-I and for-Increment loops */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>**Hibbard’s Increment Sequence: ** $$h_k &#x3D; 2^k-1$$</p>\n<p>worst-case time complexity: $$\\theta(N$$^2&#x2F;3^$$)$$</p>\n<p>in-place 不需要申请其余的空间</p>\n<p>stability （插入排序稳定，希尔排序不稳定）</p>\n<p><strong>HeapSort</strong></p>\n<p><strong>堆排序</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Heapsort</span><span class=\"params\">( ElementType A[ ], <span class=\"type\">int</span> N )</span> </span><br><span class=\"line\">&#123;  <span class=\"type\">int</span> i; </span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( i = N / <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i - - ) <span class=\"comment\">/* BuildHeap */</span> </span><br><span class=\"line\">        PercDown( A, i, N ); </span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( i = N - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i - - ) &#123; </span><br><span class=\"line\">        Swap( &amp;A[ <span class=\"number\">0</span> ], &amp;A[ i ] ); <span class=\"comment\">/* DeleteMax */</span> </span><br><span class=\"line\">        PercDown( A, <span class=\"number\">0</span>, i ); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度$$O(NlogN)$$</p>\n<p>归并排序</p>\n<p>$$O(NlogN)$$</p>\n<p>快排</p>\n",
            "tags": [
                "fds"
            ]
        }
    ]
}