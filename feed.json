{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/07/01/computer-science/computer-organization/%E9%94%99%E9%A2%98%E9%9B%86%E5%90%88/",
            "url": "http://example.com/2025/07/01/computer-science/computer-organization/%E9%94%99%E9%A2%98%E9%9B%86%E5%90%88/",
            "title": "错题集合",
            "date_published": "2025-06-30T16:00:00.000Z",
            "content_html": "<h1 id=\"错题集合\"><a href=\"#错题集合\" class=\"headerlink\" title=\"错题集合\"></a>错题集合</h1><h2 id=\"Ch2\"><a href=\"#Ch2\" class=\"headerlink\" title=\"Ch2\"></a>Ch2</h2><ol>\n<li>某计算机字长为8位，CPU中有一个8位加法器，已知无符号数x&#x3D;69, y&#x3D;38，若在该加法器中计算x-y，则加法器的两个输入短信息和输入的低位进位信息分别为（）</li>\n</ol>\n<ul>\n<li>0100 0101, 1101 1001, 1 <blockquote>\n<p>无符号数减法，在加法器中输入x的原码，y的取反和1</p>\n</blockquote>\n</li>\n</ul>\n<ol start=\"2\">\n<li>减法指令 “sub R1, R2, R3” 的功能为 “(R1) - (R2) -&gt; R3”, 该指令执行后将生成进位&#x2F;借位标志CF和溢出标志OF，若(R1) &#x3D; FFFF FFFFH, R2 &#x3D; FFFF FFF0H, 则该减法指令执行后，CF和OF分别为：</li>\n</ol>\n<ul>\n<li>CF &#x3D; 0, OF &#x3D; 0</li>\n</ul>\n<ol start=\"3\">\n<li>已知x, y为int类型，当x &#x3D; 100, y &#x3D; 200时，执行 “x - y”指令得到的溢出标志OF和结尾标志CF分别为0，1，那么当x &#x3D; 1-, y &#x3D; -20时，执行该指令得到的OF和CF分别为：</li>\n</ol>\n<ul>\n<li>OF &#x3D; 0, CF &#x3D; 1<blockquote>\n<p>ALU生成标志位时只负责计算，不管运算对象是有符号数还是无符号数。CF&#x3D;1表示当做无符号数运算时溢出，OF&#x3D;1表示当做有符号数运算时溢出。当做有符号数，10-(-20)没问题，所以OF&#x3D;0；把它俩当做无符号数的时候，x &#x3D; 10 &#x3D; 0000 0000 0000 0000 0000 0000 0000 1010，y &#x3D; -20 &#x3D; 1111 1111 1111 1111 1111 1111 1110 1100，此时x &lt; y，所以CF&#x3D;1。</p>\n</blockquote>\n</li>\n</ul>\n<ol start=\"4\">\n<li>下列关于整数乘法运算的叙述中，错误的是：D</li>\n</ol>\n<ul>\n<li>A. 用阵列乘法器实现的乘运算可以在一个时钟周期内完成 –正确，因为是组合逻辑理论上可以在一个clc里完成</li>\n<li>B. 用ALU和移位器实现的乘运算无法在一个时钟周期内完成</li>\n<li>C. 变量与常数的乘运算可编译优化为若干移位及家&#x2F;减运算指令</li>\n<li>D. 两个变量的乘运算无法编译转换为移位及加法等指令的循环实现</li>\n</ul>\n",
            "tags": [
                "错题"
            ]
        },
        {
            "id": "http://example.com/2025/07/01/computer-science/computer-organization/ch3/",
            "url": "http://example.com/2025/07/01/computer-science/computer-organization/ch3/",
            "title": "Ch3",
            "date_published": "2025-06-30T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch3-存储系统\"><a href=\"#Ch3-存储系统\" class=\"headerlink\" title=\"Ch3 存储系统\"></a>Ch3 存储系统</h1><h2 id=\"存储器概述\"><a href=\"#存储器概述\" class=\"headerlink\" title=\"存储器概述\"></a>存储器概述</h2><h3 id=\"存储器的分类\"><a href=\"#存储器的分类\" class=\"headerlink\" title=\"存储器的分类\"></a>存储器的分类</h3><ol>\n<li>按层次分</li>\n</ol>\n<ul>\n<li>主存（小、快、成本高）</li>\n<li>辅存（大、慢、成本低）</li>\n<li>Cache</li>\n</ul>\n<ol start=\"2\">\n<li>按存储介质分</li>\n</ol>\n<ul>\n<li>磁表面存储器（磁盘、磁带）</li>\n<li>磁芯存储器</li>\n<li>半导体存储器（MOS型、双极型）</li>\n<li>光存储器（光盘）</li>\n</ul>\n<ol start=\"3\">\n<li>按存储方式分</li>\n</ol>\n<ul>\n<li>RAM （随机存储器）:随机读取存储单元，存取时间与存储单元的物理位置无关。读写方便，主要用作主存和cache，分静态RAM和动态RAM。</li>\n<li>ROM （只读存储器）：只能读不能写，非易失性，随机读取。广义的ROM也可以通过电擦除进行写入(EEPROM)</li>\n<li>SAM （顺序存储器）：按顺序存储，存取时间与存储单元的物理位置有关</li>\n<li>DAM （直接存储器）：先选取信息所在区域，然后顺序存取。结合了RAM和SAM的特性（磁盘）</li>\n<li>Associated memory: 不根据地址而是根据存储内容来进行存取的存储器，可以实现快速地查找快表。既可以按照&#x3D;&#x3D;地址&#x3D;&#x3D;寻址也可以按照&#x3D;&#x3D;内容&#x3D;&#x3D;寻址（通常是某些字段）</li>\n<li>串行访问存储器：SAM和DAM都是，所以读写时间和物理位置有关</li>\n</ul>\n<ol start=\"4\">\n<li>按信息的可保存性分类</li>\n</ol>\n<ul>\n<li>易失性存储器：断电后丢失数据，如RAM</li>\n<li>非易失性存储器：断电后数据还在，如ROM，磁盘光盘</li>\n<li>破坏性读出：读出数据后数据被破坏</li>\n<li>非破坏性读出：读出数据后数据不改变</li>\n</ul>\n<h3 id=\"存储器的性能指标\"><a href=\"#存储器的性能指标\" class=\"headerlink\" title=\"存储器的性能指标\"></a>存储器的性能指标</h3><p>三个主要性能指标：存储容量、单位成本、存储速度</p>\n<ol>\n<li>容量 &#x3D; 存储字数 * 字长</li>\n<li>单位成本 &#x3D; 总成本&#x2F;总容量</li>\n<li>存储速度：<br>存取时间$T_a$: 启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入事件<br>存取周期$T_m$: 进行连续读&#x2F;写操作所允许的最短时间间隔<br>主存带宽$B_m$: b&#x2F;s, B&#x2F;s, word&#x2F;s<blockquote>\n<p>存取时间仅为完成一次操作的时间，而存取周期不仅包含操作时间，还包括操作后线路的恢复时间</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"多级层次的存储系统\"><a href=\"#多级层次的存储系统\" class=\"headerlink\" title=\"多级层次的存储系统\"></a>多级层次的存储系统</h3><p><img data-src=\"/f1.jpg\"><br>从上到下价格越来越低，速度越来越慢，容量越来越大，CPU访问频度越来越低<br><img data-src=\"/f2.jpg\"><br>存储时间与存储周期的关系</p>\n<p>主存-Cache之间的数据调用由硬件自动完成，对所有程序员均是透明的<br>主存-辅存的数据调用由硬件和操作系统共同完成，对应用程序员是透明的</p>\n<h2 id=\"主存储器\"><a href=\"#主存储器\" class=\"headerlink\" title=\"主存储器\"></a>主存储器</h2><p>存储元件：MOS管</p>\n<h3 id=\"SRAM-DRAM\"><a href=\"#SRAM-DRAM\" class=\"headerlink\" title=\"SRAM &amp; DRAM\"></a>SRAM &amp; DRAM</h3><p>RAM: SRAM静态随机存储器和DRAM动态随机存储器<br>&#x3D;&#x3D;主存主要是DRAM，Cache主要是SRAM&#x3D;&#x3D;，都易失</p>\n<p>DRAM芯片：使用栅极电容存储信息，只要一个晶体管，读写&#x3D;&#x3D;更慢&#x3D;&#x3D;，是&#x3D;&#x3D;破坏性读出&#x3D;&#x3D;，需要重写，&#x3D;&#x3D;成本低，集成度高，功耗低&#x3D;&#x3D;</p>\n<p>SRAM芯片：使用双稳态触发器存储信息（六晶体管MOS，RS, JK, D）。读写&#x3D;&#x3D;更快&#x3D;&#x3D;，是非破坏性读出，&#x3D;&#x3D;成本高，集成度低，功耗大&#x3D;&#x3D;<br><img data-src=\"/f4.jpg\"><br>栅极电容需要一直刷新给电容充电，触发器不需要刷新，只要不断电状态不会改变</p>\n<h4 id=\"DRAM的刷新\"><a href=\"#DRAM的刷新\" class=\"headerlink\" title=\"DRAM的刷新\"></a>DRAM的刷新</h4><ol>\n<li>多久需要刷新一次？ 刷新周期：一般为2ms</li>\n<li>每次刷新多少存储单元？以行为单位，每次刷新一行存储单元<br>——为什么要用行列地址？减少选通线的数量</li>\n<li>在什么时刻刷新？<br>有硬件支持，读出一行的信息后重新写入，占用1个读&#x2F;写周期<br>假设DRAM内部结构排列成128×128的形式，读&#x2F;写周期0.5us<br>2ms共 2ms&#x2F;0.5us &#x3D; 4000 个周期<br>三种刷新方式：<br><img data-src=\"/f5.jpg\"><br>刷新以行为单位，再生（重写）只需要恢复被读出来的存储单元<br>刷新由存储器独立完成，不需要CPU控制</li>\n</ol>\n<h5 id=\"DRAM的地址引脚复用技术\"><a href=\"#DRAM的地址引脚复用技术\" class=\"headerlink\" title=\"DRAM的地址引脚复用技术\"></a>DRAM的地址引脚复用技术</h5><p><img data-src=\"/f6.jpg\"><br>行列地址分成两次送，节省了一半的地址线<br>行列数优化原则：尽量使行、列数相同，且行数较少（因为按行刷新）<br>目前常用SDRAM（同步DRAM），数据交换同步于CPU的时钟信号，使得CPU不需要等待</p>\n<h3 id=\"ROM\"><a href=\"#ROM\" class=\"headerlink\" title=\"ROM\"></a>ROM</h3><p>结构简单、非易失性<br>类型：</p>\n<ol>\n<li>MROM 掩模式ROM<br>在芯片生产过程中写入，无法改变，可靠性高，急程度高，价格便宜，灵活性差</li>\n<li>PROM 一次可编程ROM<br>可以用专门的设备写入一次，一旦写入无法改变</li>\n<li>EPROM 可擦除可编程ROM<br>可以写入并多次改写，但是编程次数有限且时间长</li>\n<li>Flash<br>兼有RAM和ROM的优点，可以不加电长期保存信息，又能在线快速擦除和重写，价格便宜，急程度高，电可擦除重写且速度快<br>SSD 固态硬盘基于Flash，由控制单元和Flash组成，长期保存、快速擦除和重写，对比传统硬盘读写速度快。低功耗。但是价格高</li>\n</ol>\n<h3 id=\"主存储器的基本组成\"><a href=\"#主存储器的基本组成\" class=\"headerlink\" title=\"主存储器的基本组成\"></a>主存储器的基本组成</h3><p>核心部件：一个个存储0或1的存储单元构成的存储矩阵<br>访问主存时，CPU把地址送到MAR，MAR通过地址总线把地址送到主存中的地址寄存器，地址译码器进行译码，选中相应的内存单元，然后通过控制电路决定读&#x2F;写操作：</p>\n<ul>\n<li>读操作：将选中的内存单元的内容通过数据总线送到MDR中</li>\n<li>写操作：将MDR中的内容通过数据总线送到选中的内存单元中<br>MDR的位数和数据总线位数相同，通常等于存储字长；MAR的位数和地址总线位数相同</li>\n</ul>\n<h3 id=\"多模块存储器\"><a href=\"#多模块存储器\" class=\"headerlink\" title=\"多模块存储器\"></a>多模块存储器</h3><p>DRAM芯片的恢复时间比较长，有可能是存取时间的几倍（SRAM的恢复时间较短）。CPU的读写速度比主存快很多，主存恢复时间太长<br> —— 利用多个完全相同的存储模块并行工作来提高吞吐率：单体多字存储器，多体低位交叉存储器</p>\n<ul>\n<li>双端口RAM（408不考，了解即可）<br><img data-src=\"/f7.jpg\"></li>\n</ul>\n<ol>\n<li><p>单体多字存储器<br>一般一个存储单元只存储一个word，但是单体多字存储器一个存储单元存储多个word，然后读的时候一次性读取这多个字。好处是快，缺点是只有指令和数据连续存放时才能提高存取速度，否则造成不必要的读取。</p>\n</li>\n<li><p>&#x3D;&#x3D;多体并行存储器（重点）&#x3D;&#x3D;<br>分为高位交叉编址和低位交叉编址两种<br><img data-src=\"/f8.jpg\"><br>高位交叉编址每一块存储体的高位是一样的，实际上还是顺序存储。因此访问连续内存实际上访问的还是同一块存储体，并不能通过并行加快访问速度<br>低位交叉编址的每一块存储体低位相同，因此可以在恢复时间并行存取下一块内存的数据<br>存取周期为<code>T</code>, 存取时间为<code>r</code>, T &#x3D; r + 恢复时间<br>对于n个存储器并行访问的存储器：<br>采用高位交叉编址的时间为<code>n*T</code><br>低位交叉编址为<code>T + (n-1)*r</code></p>\n</li>\n</ol>\n<p><img data-src=\"/f9.png\"></p>\n<ul>\n<li>轮流启动：每个bank的存储位数等于数据总线的位数，此时采用轮流启动<ul>\n<li>对于低位交叉编址，要保证<code>m&gt;=T/r</code>，以保证流水线不间断</li>\n<li>理想情况下，m个bank的交叉存储器每隔<code>T/m</code>个周期可以读&#x2F;写一个数据，若相邻m次访问的当存地址出现在同一个模块内，则会发生访存冲突，此时需要延迟发生冲突的访问请求。</li>\n</ul>\n</li>\n<li>同时启动：如果m个bank的总位数加起来刚好等于数据总线的位数，则m个同时存&#x2F;取</li>\n</ul>\n<h2 id=\"主存储器与CPU的连接\"><a href=\"#主存储器与CPU的连接\" class=\"headerlink\" title=\"主存储器与CPU的连接\"></a>主存储器与CPU的连接</h2><h3 id=\"连接原理\"><a href=\"#连接原理\" class=\"headerlink\" title=\"连接原理\"></a>连接原理</h3><p>通过总线连接（控制、地址、数据）<br>传输速率 &#x3D; 总线宽度&#x2F;传输时间<br>地址总线的位数决定了可寻址的最大内存空间<br>控制总线指出总线周期的类型和本次输入输出完成的时刻<br>将多个芯片集成在内存条上，由多个内存条和主板上的ROM芯片组成计算机所需的主存空间，通过总线与CPU连接</p>\n<h3 id=\"主存容量的扩展\"><a href=\"#主存容量的扩展\" class=\"headerlink\" title=\"主存容量的扩展\"></a>主存容量的扩展</h3><p>数据总线宽度&gt;存储字长 —— 位扩展<br>地址总线宽度&gt;存储字数量所需的宽度<br><img data-src=\"/f10.jpg\"></p>\n<ol>\n<li><p>位扩展法：增加存储字长<br>由于数据总线宽度大于存储字长，存在浪费情况，必须进行位扩展使数据位数与数据总线位数相等<br>如图：<br><img data-src=\"/f11.jpg\"></p>\n</li>\n<li><p>字扩展法<br>地址总线存在浪费情况，对存储字的数量进行扩展<br>用多出来的地址线提供CS片选信号，决定输出的是哪个芯片的数据</p>\n</li>\n</ol>\n<ul>\n<li>线选法：n条多余的地址线，对应n个选片信号，地址空间不连续造成地址空间浪费（只能有一个1有效），电路简单<br><img data-src=\"/f13.jpg\"></li>\n<li>译码器选法：n条多余的线对应$2^n$个选片信号，地址空间可以连续<br><img data-src=\"/f12.jpg\"></li>\n</ul>\n<ol start=\"3\">\n<li>字、位同时扩展<br>既增加存储字的数量，又增加存储字长<br><img data-src=\"/f14.jpg\"></li>\n</ol>\n<h3 id=\"存储芯片的地址分配和片选\"><a href=\"#存储芯片的地址分配和片选\" class=\"headerlink\" title=\"存储芯片的地址分配和片选\"></a>存储芯片的地址分配和片选</h3><p>见上方线选法译码器选法</p>\n<h3 id=\"存储器与CPU的连接\"><a href=\"#存储器与CPU的连接\" class=\"headerlink\" title=\"存储器与CPU的连接\"></a>存储器与CPU的连接</h3><p>……<br>片选信号还与CPU的方寸控制信号$\\overline{MREQ}$有关（低电平有效），若CPU访问IO则此信号为高电平<br>MAR位数要看主存地址空间大小，而不能看实际上用了多少位</p>\n<h2 id=\"外部存储器\"><a href=\"#外部存储器\" class=\"headerlink\" title=\"外部存储器\"></a>外部存储器</h2><p>磁盘存储器是以磁盘为存储介质的存储器，优点：容量大，价格低；记录介质可重复使用；可以长期保存；非破坏性读出。缺点：存取速度慢；机械结构复杂；对工作环境要求高</p>\n<h3 id=\"磁盘存储器\"><a href=\"#磁盘存储器\" class=\"headerlink\" title=\"磁盘存储器\"></a>磁盘存储器</h3><ol>\n<li>磁盘存储器</li>\n</ol>\n<ul>\n<li>组成：磁盘驱动器，磁盘控制器，盘片<br><img data-src=\"/f15.jpg\"></li>\n<li>存储区域：&#x3D;&#x3D;扇区（也称块）是磁盘读写的最小单位&#x3D;&#x3D;，按块存取<ul>\n<li>磁头数(Heads)：一个记录面对应一个磁头</li>\n<li>柱面数(Cylinders)：表示每面盘片上的磁道数，不同记录面的相同位置的磁道构成一个柱面</li>\n<li>扇区数(Sectors)：每条磁道上有多少扇区</li>\n</ul>\n</li>\n<li>Disk Cache<ul>\n<li>在内存上的一片区域，用来缓冲被送到磁盘上的数据。优点：写磁盘时按簇进行，可以避免频繁地用小块数据写；中间结果数据写回之前可以被快速再次使用</li>\n</ul>\n</li>\n<li>磁记录原理<ul>\n<li>原理：当磁头和磁性记录介质有相对运动时，通过电磁转换完成读&#x2F;写操作。</li>\n<li>编码方法：按某种方案（规律），把一连串的二进制信息变换成存储介质磁层中一个磁化翻转状态的序列，并使读&#x2F;写控制电路容易、可靠地实现转换。</li>\n<li>磁记录方式：通常采用调频制（FM）和改进型调频制（MFM）的记录方式。</li>\n</ul>\n</li>\n<li>性能指标<ul>\n<li><p>磁盘的容量：一个磁盘所能存储的字节总数称为磁盘容量。磁盘容量有非格式化容量和格式化容量之分。<br>非格式化容量是指磁记录表面可以利用的磁化单元总数，非格式化容量 &#x3D; 记录面数 * 柱面数 * 每条磁道的磁化单元数<br>格式化容量是指按照某种特定的记录格式所能存储信息的总量，格式化容量 &#x3D; 记录面数 * 柱面数 * 每道扇区数 * 每个扇区的容量<br>&#x3D;&#x3D;格式化容量 &lt; 非格式化容量&#x3D;&#x3D;</p>\n</li>\n<li><p>记录密度:记录密度是指盘片单位面积上记录的二进制的信息量，通常以<code>道密度</code>、<code>位密度</code>和<code>面密度</code>表示。道密度是&#x3D;&#x3D;沿磁盘半径方向单位长度上的磁道数&#x3D;&#x3D;；位密度是&#x3D;&#x3D;磁道单位长度上能记录的二进制代码位数&#x3D;&#x3D;；面密度是位密度和道密度的乘积。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>&#x3D;&#x3D;磁盘所有磁道记录的信息量一定是相等的，并不是圆越大信息越多，故每个磁道的位密度都不同，越靠近圆心位密度越大&#x3D;&#x3D;</p>\n<ul>\n<li><p>平均存取时间：平均存取时间 &#x3D; 寻道时间（磁头移动到目的磁道）+ 旋转延迟时间（磁头定位到所在扇区）+ 传输时间（传输数据所花费的时间）<br>&#x3D;&#x3D;寻道时间通常取从最外道到最内道时间的一半，旋转延迟时间通常取旋转半周的时间&#x3D;&#x3D;</p>\n</li>\n<li><p>数据传输率：磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输率<br>假设磁盘转速为r（转&#x2F;秒），每条磁道容量为N个字节，则数据传输率为$D_r&#x3D;rN$</p>\n</li>\n<li><p>磁盘地址<br><img data-src=\"/f16.jpg\"></p>\n</li>\n<li><p>磁盘的工作原理<br>硬盘的主要操作是寻址、读盘、写盘。每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字。<br>硬盘属于机械式部件，其读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据。</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>RAID<br>将多个独立的物理磁盘组成一个独立的逻辑磁盘，数据分割交叉存储，并行访问。</li>\n</ol>\n<ul>\n<li>RAID0：无冗余和无校验的磁盘阵列。</li>\n<li>RAID1：镜像磁盘阵列。每份数据存两遍，成本太高</li>\n<li>RAID2：采用纠错的海明码的磁盘阵列。<br>逻辑上连续的几个bit物理上分散存储在各个盘中4bit信息位+3bit海明校验位——可纠正1bit错误<br>每个码字有 <code>m</code> 个信息位和 <code>r</code> 个冗余位，$ (m+r+1)≤2^r$<br>参考xyx学长的计网笔记：<br><img data-src=\"/f17.jpg\"></li>\n<li>RAID3：位交叉奇偶校验的磁盘阵列。前三个盘的奇偶校验位写在第四个盘上</li>\n<li>RAID4：块交叉奇偶校验的磁盘阵列。</li>\n<li>RAID5：无独立校验的奇偶校验磁盘阵列。在所有磁盘之间分条，并且每个数据块的奇偶校验块 (P) 写入到同一条带上<br>RAID1-RAID5数据不会损坏</li>\n</ul>\n<h3 id=\"固态硬盘-SSD\"><a href=\"#固态硬盘-SSD\" class=\"headerlink\" title=\"固态硬盘(SSD)\"></a>固态硬盘(SSD)</h3><ol>\n<li>特性<br>属于Flash memory, EEPROM<br>组成：闪存翻译层，存储介质<br><img data-src=\"/f18.jpg\"><br>&#x3D;&#x3D;数据以页为单位读写，以块为单位擦除&#x3D;&#x3D;只有整个块被擦除之后才能写这一页，若视图修改包含已有数据的页$P_i$，则这个快中所有含有有用数据的页必须被复制到新的空白的块中，才能对$P_i$进行写操作<br>SSD的优点：&#x3D;&#x3D;随机写很慢，随机读比机械磁盘块&#x3D;&#x3D;，没噪声，能耗低，抗震性好，安全性高</li>\n<li>Wear Leveling 磨损均衡<br>重复擦写块就会磨损坏，一般是几百次到几千次<br>(1) 动态磨损均衡：&#x3D;&#x3D;写入时&#x3D;&#x3D;优先选择擦除次数少的新闪存块，只在写入时触发，仅考虑可用空间（对于冷数据不包括在空间池中，减少了可以用的block数量）<br>(2) 静态磨损均衡：就算没有写入，SSD也会监测并自动进行数据分配，让老的闪存快以读为主，让新的块腾出空间，以写为主：将数据从写入&#x2F;擦除次数较低的block移动到其他block中，这样可以将低擦写次数的block释放出来，添加到可用可用空间池中，以便后续使用。仅覆盖单个闪存芯片单元</li>\n</ol>\n",
            "tags": [
                "存储系统"
            ]
        },
        {
            "id": "http://example.com/2025/06/19/SE/diagram/",
            "url": "http://example.com/2025/06/19/SE/diagram/",
            "title": "画图题",
            "date_published": "2025-06-18T16:00:00.000Z",
            "content_html": "<ol>\n<li>用例图 Use Case Diagram<br>Use-Cases: A collection of user scenarios that describe the thread of usage of a system<br>主要包含涉及的角色，角色对应的行为，第三方参与部分</li>\n</ol>\n<ul>\n<li>参与者：与系统交互的用户或其他软硬件系统，用小人形表示</li>\n<li>用例：系统中执行的一系列动作，用椭圆表示。</li>\n<li>关系参与者与用例、参与者之间、用例之间的联系。连线</li>\n<li>边界：一组用例描述的系统或子系统，用矩形框表示。</li>\n</ul>\n<p>+++primary example: SafeHome<br>;;;id3 题目<br>Our research indicates that the market for home security systems is growing at a rate of 40% per year. We would like to enter this market by building a &#x3D;&#x3D;microprocessor-based&#x3D;&#x3D; home security system that would protect against and&#x2F;or recognize a variety of &#x3D;&#x3D;undesirable situations&#x3D;&#x3D; such as illegal entry, fire, flooding, and others. The product will use appropriate &#x3D;&#x3D;sensors&#x3D;&#x3D; to detect each situation, can be programmed by the &#x3D;&#x3D;homeowner&#x3D;&#x3D;, and will automatically telephone a monitoring agency when a situation is detected.<br>;;;</p>\n<p>;;;id3 答案<br><img data-src=\"/useCase.jpg\"><br>我的理解是找到里面的人(onwer, monitoring agency, 然后可以加个administrator)，物件(sensor)，中间的框是个系统，然后里面的椭圆写上对应的交互行为，连上线，感觉比较主观<br>;;;<br>+++</p>\n<ol start=\"2\">\n<li><p>CRC Card<br>每个卡片应该包含：类名，类的描述信息，职责，合作类<br>+++primary example<br><img data-src=\"/CRC.jpg\"><br>+++</p>\n</li>\n<li><p>类图 class diagram<br>主要的信息：类名，属性(name: type)，方法(name(parameter): return type)<br>+++primary example<br>;;;id4 例子1<br><img data-src=\"/class.jpg\"><br>;;;<br>;;;id4 例子2<br><img data-src=\"/class2.jpg\"><br>;;;<br>+++</p>\n</li>\n<li><p>状态图 state diagram<br><strong>节点</strong>：开始状态，结束状态，状态<br><strong>边</strong>：行为<br>状态：圆角矩形 state name, state variables, state activities<br>转移：带有标记的箭头<br>初始状态：实心圆<br>终止状态：实心环<br>分支：菱形<br>+++primary example<br>;;;id5 状态图<br><img data-src=\"/state.png\"><br>;;;<br>;;;id5 状态图<br><img data-src=\"/state2.jpg\"><br>;;;<br>+++</p>\n</li>\n<li><p>时序图 sequence diagram<br>对象（参与者上面要画个人）、生命线（对象下面的虚线）、控制焦点、消息<br><img data-src=\"/seq.jpg\"><br>实心箭头表示同步消息：一个对象向另一个对象发出同步消息后，将处于阻塞状态，一直等到另一个对象的回应（图里面的请求是同步的）<br>简单箭头表示异步<br>:::warning<br>箭头的画法存疑<br>:::</p>\n</li>\n<li><p>数据流图 data flow diagram<br>外部实体（数据的原点和终点）：软件系统外部环境中的实体（包括人、组织或其他软件系统），用&#x3D;&#x3D;方框&#x3D;&#x3D;<br>加工Process：对数据进行处理的单元，比如内部的xx系统，用&#x3D;&#x3D;圆角矩形&#x3D;&#x3D;或椭圆<br>数据存储：数据库，用&#x3D;&#x3D;右侧开口的矩形或者左右开口的矩形&#x3D;&#x3D;<br>数据流：箭头方向即数据流动方向，数据流名标在数据流线上面<br>看例子：<br><img data-src=\"/dataflow.jpg\"></p>\n</li>\n<li><p>软件架构图 architecture<br>以前后端分离的系统为例（前端，后端，数据库）<br><img data-src=\"/arch.jpg\"><br>三个大框分别是客户端、服务器、数据库层<br>里面小框，前端就是Web app和移动app，后端就是各种系统，数据库就是各种数据库（表？）</p>\n</li>\n<li><p>泳道图 Swimlane Diagram<br>跨职能流程图。旨在展示工作流中每个步骤涉及的流程和职能部门。在表示use-case的同时，描述对活动负责的actor&#x2F;analysis class<br>最上面放实体，然后分成一列一列，其他的和流程图一样<br><img data-src=\"/swim.jpg\"></p>\n</li>\n</ol>\n",
            "tags": [
                "软件工程"
            ]
        },
        {
            "id": "http://example.com/2025/06/19/SE/note/",
            "url": "http://example.com/2025/06/19/SE/note/",
            "title": "SE note",
            "date_published": "2025-06-18T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch2-Software-Engineering\"><a href=\"#Ch2-Software-Engineering\" class=\"headerlink\" title=\"Ch2 Software Engineering\"></a>Ch2 Software Engineering</h1><ul>\n<li>Definition: The application of a &#x3D;&#x3D;systematic&#x3D;&#x3D;, &#x3D;&#x3D;disciplined&#x3D;&#x3D;, &#x3D;&#x3D;quantifiable（可量化）&#x3D;&#x3D; approach to the &#x3D;&#x3D;development&#x3D;&#x3D;, &#x3D;&#x3D;operation&#x3D;&#x3D;, and &#x3D;&#x3D;maintenance&#x3D;&#x3D; of software</li>\n<li>软件工程是一个多层次的技术体系(a layered technology)<ul>\n<li>从下往上是a “quality” focus, process model, methods, tools, 反映了构建高质量软件产品的逻辑流程</li>\n</ul>\n</li>\n<li>软件过程（The Software Process）中的两个重要概念：通用过程框架（Common Process Framework）和 伞形活动（Umbrella Activities）<ul>\n<li>通用过程框架（Common Process Framework）： 软件开发过程中的一些基本要素<ul>\n<li>工作任务（work tasks）：指在软件开发的不同阶段中需要完成的具体任务。</li>\n<li>工作产品（work products）：指在执行工作任务过程中产生的各种文档、代码等成果物。</li>\n<li>里程碑与交付物（milestones &amp; deliverables）：里程碑是项目进展的重要节点，而交付物是在这些节点上需要提交的成果。</li>\n<li>质量保证检查点（QA checkpoints）：在整个开发过程中设置的检查点，用于评估和确保软件产品的质量。</li>\n</ul>\n</li>\n<li>伞形活动（Umbrella Activities）：软件开发过程中需要执行的活动<ul>\n<li>项目管理（Project management）：负责项目的规划、组织、协调和控制，确保项目按计划进行。</li>\n<li>质量保证（Quality assurance）：通过一系列措施确保软件产品的质量符合预定标准。</li>\n<li>工作产品生产（Work product production）：涉及创建和维护软件开发过程中产生的各种工作产品。</li>\n<li>测量（Measurement）：收集和分析数据以评估项目的状态和进度。</li>\n<li>正式技术评审（Formal technical reviews）：对软件的技术设计和实现进行系统性的审查。</li>\n<li>配置管理（Configuration management）：管理软件开发过程中各种配置项的变化，确保版本的一致性和可追溯性。</li>\n<li>重用管理（Reusability management）：促进软件组件和模块的重用，提高开发效率和软件质量。</li>\n<li>风险管理（Risk management）：识别、评估和应对可能影响项目成功的各种风险。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Generic Process Framework</strong> 通用的软件开发过程框架<ul>\n<li><strong>Communication</strong>: 与客户协作并收集需求</li>\n<li><strong>Planning</strong>: establishes engineering work plan, describes technical risks, lists resource requirements, work products produced, and defines work schedule</li>\n<li><strong>Modeling</strong>: 创建模型以帮助开发者和客户理解需求和设计</li>\n<li><strong>Construction</strong>: code &amp; test</li>\n<li><strong>Deployment</strong>: 交付软件供客户评估和反馈</li>\n</ul>\n</li>\n<li><strong>Process Adaptation</strong> 过程适配: 根据项目的具体需求、限制条件和特点，对软件开发过程进行定制和调整<ul>\n<li>overall &#x3D;&#x3D;flow&#x3D;&#x3D; of activities, actions, and tasks and the interdependencies among them</li>\n<li>degree to which &#x3D;&#x3D;actions and tasks&#x3D;&#x3D; are defined within each framework activity</li>\n<li>degree to which &#x3D;&#x3D;work products&#x3D;&#x3D; are identified and required</li>\n<li>manner which &#x3D;&#x3D;quality assurance&#x3D;&#x3D; activities are applied</li>\n<li>manner in which &#x3D;&#x3D;project tracking and control&#x3D;&#x3D; activities are applied</li>\n<li>overall degree of &#x3D;&#x3D;detail and rigor&#x3D;&#x3D; with which the process is described</li>\n<li>degree to which the &#x3D;&#x3D;customer and other stakeholders&#x3D;&#x3D; are involved with the project</li>\n<li>level of autonomy given to the &#x3D;&#x3D;software team&#x3D;&#x3D;</li>\n<li>degree to which &#x3D;&#x3D;team organization and roles&#x3D;&#x3D; are prescribed</li>\n</ul>\n</li>\n<li>The Essence of Practice<ul>\n<li><strong>Understand the problem</strong> (communication and analysis).</li>\n<li><strong>Plan a solution</strong> (modeling and software design).</li>\n<li><strong>Carry out the plan</strong> (code generation).</li>\n<li><strong>Examine the result for accuracy</strong> (testing and quality assurance).</li>\n</ul>\n</li>\n<li>General Principles 通用原则：软件开发过程中应遵循的一些核心指导思想或基本原则<ul>\n<li>The reason it all exists — Provide Value to users</li>\n<li>KISS — Keep It Simple, Stupid!</li>\n<li>Maintain the Vision</li>\n<li>What you produce, others will consume</li>\n<li>Be open to the future</li>\n<li>Plan ahead for reuse</li>\n<li>Think!</li>\n</ul>\n</li>\n<li>Software Development Myths 软件开发管理中常见的误解（Myth）及其背后的现实情况（Reality）<ul>\n<li>Management myths<ul>\n<li>标准和流程的有效性依赖于团队的理解和接受程度。</li>\n<li>软件开发是一个高度协作和复杂的创造性过程，简单地增加人力并不能解决进度问题。</li>\n<li>外包项目同样需要良好的管理和沟通能力，不能因为外包就忽视了对项目的控制和监督</li>\n</ul>\n</li>\n<li>Customer myths<ul>\n<li>详细的需求分析和规划</li>\n<li>充分的沟通与确认</li>\n<li>合理的进度评估</li>\n</ul>\n</li>\n<li>Practitioner’s myths<ul>\n<li>错误：一旦我们编写好程序并使其正常运行，我们的工作就完成了</li>\n<li>过早进入编码阶段可能会导致更多的返工和调整，从而延长项目周期</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Ch3-Software-Process-Structure\"><a href=\"#Ch3-Software-Process-Structure\" class=\"headerlink\" title=\"Ch3 Software Process Structure\"></a>Ch3 Software Process Structure</h1><p>Umbrella Activities是贯穿整个软件开发过程的活动，Framework Activity是软件开发的核心阶段，如沟通、计划、建模、构建和部署，每个框架活动下都有具体的task set，每个task set中又包含多个具体的action</p>\n<ul>\n<li><p><strong>Process flow</strong> 过程流（对于之前提到的Generic Process Framework的五步）</p>\n<ol>\n<li>线性过程流（Linear process flow）</li>\n<li>迭代过程流（Iterative process flow）</li>\n<li>演化过程流（Evolutionary process flow）</li>\n<li>并行过程流（Parallel process flow）<br><img data-src=\"/f1.jpg\"></li>\n</ol>\n</li>\n<li><p><strong>Process Patterns</strong> 过程模式<br>Process patterns define a set of activities, actions, work tasks, work products and&#x2F;or related behaviors<br>提供了一种<code>template</code>用于定义模式<br><strong>Generic software pattern elements</strong>:</p>\n</li>\n<li><p>pattern name </p>\n</li>\n<li><p>Intent (objective of pattern) </p>\n</li>\n<li><p>Type (Task pattern, Stage pattern, Phase pattern)</p>\n</li>\n<li><p>Initial context</p>\n</li>\n<li><p>Solution</p>\n</li>\n<li><p>Resulting context</p>\n</li>\n<li><p>Related patterns</p>\n</li>\n<li><p>Known uses&#x2F;examples</p>\n</li>\n<li><p><strong>Process Assessment</strong><br>几种评估软件过程的方法：<br>SCAMPI (Standard CMMI Appraisal Method for Process Improvement)<br>SPICE (ISO&#x2F;IEC 15504)<br>CBA IPI (Capability Benchmarking Appraisal using the Integrated Process Improvement method)<br>ISO 9001:2000 for Software</p>\n</li>\n<li><p>The Capability Maturity Model Integration 能力成熟度模型集成（CMMI）</p>\n<ul>\n<li>Level 0: Incomplete </li>\n<li>Level 1: Performed </li>\n<li>Level 2: Managed</li>\n<li>Level 3: Defined</li>\n<li>Level 4: Quantitatively Managed 定量管理</li>\n<li>Level 5: Optimizing</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Ch4-Process-Models\"><a href=\"#Ch4-Process-Models\" class=\"headerlink\" title=\"Ch4 Process Models\"></a>Ch4 Process Models</h1><h2 id=\"Prescriptive-Models\"><a href=\"#Prescriptive-Models\" class=\"headerlink\" title=\"Prescriptive Models\"></a>Prescriptive Models</h2><p>Prescriptive(规范的) process models advocate an orderly approach to software engineering</p>\n<ul>\n<li>The Waterfall Model: A reasonable approach when requirements are well defined<br><img data-src=\"/4-1.jpg\"></li>\n<li>The V Model<br><img data-src=\"/4-2.jpg\"></li>\n<li>Incremental Process Models 增量过程模型<ul>\n<li>The Incremental Model 增量模型: 将整个系统划分为多个可交付的“增量”部分，每个增量都作为一个独立的小项目进行五步流程: A good approach when a working core product is required quickly<br> <img data-src=\"/4-3.jpg\"></li>\n<li>The Rapid Application Development (RAD) Model 快速应用开发模型: 短时间内交付功能完善的系统，communication和planning之后分成好几个team进行modeling和construction，最后合并deployment<br> <img data-src=\"/4-4.jpg\"></li>\n</ul>\n</li>\n<li>Evolutionary Process Models 进化式过程模型<ul>\n<li>Prototyping 原型化方法: 当客户有明确的需求但不清楚具体细节时，通过原型，客户可以直观地看到系统的雏形并提出修改意见；原型通常是“抛弃型”的，即在验证概念后会被丢弃，而不是直接作为最终产品的一部分<ul>\n<li>Prototype Model: Communication, Quick Plan, Modeling &amp; Quick Design, Construction of prototype, Deployment Delivery &amp; Feedback</li>\n</ul>\n</li>\n<li>The Spiral Model 螺旋模型: 螺旋模型将整个开发过程视为一个逐渐扩大的螺旋线，每个环代表一个开发阶段或迭代周期，在每一次迭代中都进行风险分析（Risk Analysis）<br> <img data-src=\"/4-5.jpg\"> </li>\n<li>The Concurrent Development Model 并行开发模型<ul>\n<li>并行开发模型定义了一系列<code>事件</code>，这些事件将触发每个活动、动作或任务<code>从一个状态到另一个状态的转换</code></li>\n<li>Especially good for client&#x2F;server applications</li>\n<li>并行开发模型定义了一个活动网络，而不是简单的线性事件序列</li>\n<li>需要在Flexibility, Extensibility, Speed of development 和 high quality 中权衡</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Specialized-Process-Models-专业化的软件过程模型\"><a href=\"#Specialized-Process-Models-专业化的软件过程模型\" class=\"headerlink\" title=\"Specialized Process Models 专业化的软件过程模型\"></a>Specialized Process Models 专业化的软件过程模型</h2><ol>\n<li>Component-Based Development （强调reuse）</li>\n<li>Formal methods （形式化方法强调使用数学手段来精确地描述需求）</li>\n<li>Aspect-Oriented Software Development （面向切面，切面指那些横跨多个模块或功能的通用关注点）</li>\n</ol>\n<h2 id=\"The-Unified-Process-统一过程\"><a href=\"#The-Unified-Process-统一过程\" class=\"headerlink\" title=\"The Unified Process 统一过程\"></a>The Unified Process 统一过程</h2><p>统一过程是一种“用例驱动、以架构为中心、迭代和增量”的软件开发过程<br>A &#x3D;&#x3D;“use-case driven, architecture-centric, iterative and incremental”&#x3D;&#x3D; software process closely aligned with the Unified Modeling Language (UML)<br><img data-src=\"/4-6.png\"><br>五个阶段: &#x3D;&#x3D;Inception, Elaboration, Construction, Transition, Production&#x3D;&#x3D;</p>\n<h3 id=\"统一过程（Unified-Process-UP）在各个阶段产生的工作产品（Work-Products）\"><a href=\"#统一过程（Unified-Process-UP）在各个阶段产生的工作产品（Work-Products）\" class=\"headerlink\" title=\"统一过程（Unified Process, UP）在各个阶段产生的工作产品（Work Products）\"></a>统一过程（Unified Process, UP）在各个阶段产生的工作产品（<code>Work Products</code>）</h3><ol>\n<li>Inception Phase（启动阶段）<br>Vision Document（愿景文档）：概述项目的总体目标、范围和预期结果。<br>Initial Use-case Model（初始用例模型）：描述系统的主要功能和用户交互场景。<br>Initial Project Glossary（初始项目术语表）：定义项目中使用的专业术语和缩写。<br>Initial Business Case（初始商业案例）：分析项目的商业价值和可行性。<br>Initial Risk Assessment（初始风险评估）：识别和评估项目可能面临的风险。<br>Project Plan Phases and Iterations（项目计划阶段和迭代）：制定项目的整体计划，包括阶段划分和迭代安排。<br>Business Model（业务模型）：描述项目的业务流程和商业模式。<br>Prototypes（原型）：创建系统的初步原型，用于验证需求和设计。</li>\n<li>Elaboration Phase（细化阶段）<br>Use-case Model（用例模型）：进一步完善和细化用例模型，明确系统功能。<br>Functional and Non-functional Requirements（功能性与非功能性需求）：详细描述系统需要满足的功能性和非功能性要求。<br>Analysis Model（分析模型）：基于需求分析建立的系统逻辑模型。<br>Software Architecture Description（软件架构描述）：定义系统的整体架构和关键组件。<br>Executable Architectural Prototype（可执行架构原型）：实现一个可运行的架构原型，验证架构的可行性和性能。<br>Preliminary Design Model（初步设计模型）：基于架构描述进行初步的设计。<br>Revise Risk List（修订风险列表）：根据新的信息和发现更新风险评估。<br>Project Plan Iteration Plan, Workflow, Milestones（项目计划迭代计划、工作流、里程碑）：细化项目计划，包括具体的迭代安排、工作流程和关键里程碑。<br>Preliminary User Manual（初步用户手册）：编写系统的初步使用说明。</li>\n<li>Construction Phase（构建阶段）<br>Design Model（设计模型）：完成详细的系统设计，包括模块设计和接口设计。<br>Software Components（软件组件）：开发和实现各个软件组件。<br>Integrated Software Increment（集成软件增量）：将各个组件集成在一起，形成可运行的软件增量。<br>Test Plan（测试计划）：制定详细的测试计划，包括测试策略和资源安排。<br>Test Cases（测试用例）：编写具体的测试用例，用于验证系统功能和质量。<br>Support Documentation User Installation Increment（支持文档用户安装增量）：编写用户安装和操作指南，帮助用户正确安装和使用系统。</li>\n<li>Transition Phase（过渡阶段）<br>Delivered Software Increment（交付的软件增量）：向用户交付经过测试和验证的软件增量。<br>Beta Test Reports（Beta测试报告）：收集和整理Beta测试期间的反馈和问题报告。<br>User Feedback（用户反馈）：收集用户的实际使用反馈，为后续改进提供依据。</li>\n<li>Production</li>\n</ol>\n<h3 id=\"个人软件过程（Personal-Software-Process-PSP）\"><a href=\"#个人软件过程（Personal-Software-Process-PSP）\" class=\"headerlink\" title=\"个人软件过程（Personal Software Process, PSP）\"></a>个人软件过程（Personal Software Process, PSP）</h3><p>Five Framework Activities:</p>\n<ol>\n<li>Planning</li>\n<li>High-Level Design</li>\n<li>High-Level Design Review</li>\n<li>Development</li>\n<li>Postmortem（事后分析）<br>Stresses the Need for Error Identification and Understanding</li>\n</ol>\n<h3 id=\"团队软件过程（Team-Software-Process-TSP）\"><a href=\"#团队软件过程（Team-Software-Process-TSP）\" class=\"headerlink\" title=\"团队软件过程（Team Software Process, TSP）\"></a>团队软件过程（Team Software Process, TSP）</h3><ol>\n<li>Each project is “launched” using a “script” that defines the tasks to be accomplished</li>\n<li>Teams are self-directed</li>\n<li>Measurement is encouraged</li>\n<li>Measures are analyzed with the intent of improving the team process</li>\n</ol>\n<h1 id=\"Ch5-Agile-Development-敏捷开发\"><a href=\"#Ch5-Agile-Development-敏捷开发\" class=\"headerlink\" title=\"Ch5 Agile Development 敏捷开发\"></a>Ch5 Agile Development 敏捷开发</h1><p>What is Agility?</p>\n<ul>\n<li>Effective (rapid and adaptive) response to change</li>\n<li>Effective communication among all stakeholders</li>\n<li>Drawing the customer onto the team</li>\n<li>Organizing a team so that it is in control of the work performed</li>\n<li>Rapid, incremental delivery of software<br>An Agile Process</li>\n<li>Is driven by customer descriptions of what is required (scenarios)</li>\n<li>Recognizes that plans are short-lived</li>\n<li>Develops software iteratively with a heavy emphasis on construction activities</li>\n<li>Delivers multiple ‘software increments’</li>\n<li>Adapts as changes occur</li>\n</ul>\n<p>Extreme Programming 极限编程(XP): &#x3D;&#x3D;planning, design, coding, testing&#x3D;&#x3D;<br>XP plan:</p>\n<ul>\n<li>begin with user stories</li>\n<li>assigns a cost</li>\n<li>Stories are grouped to for a deliverable increment</li>\n<li>commitment</li>\n<li>project velocity<br><img data-src=\"/5-1.png\"></li>\n</ul>\n<p>Industrial XP (IXP)<br>IXP incorporates six new practices: </p>\n<ul>\n<li>Readiness assessment 准备评估</li>\n<li>Project community 项目社区</li>\n<li>Project chartering 项目章程制定</li>\n<li>Test driven management 测试驱动管理</li>\n<li>Retrospectives 团队自省</li>\n<li>Continuous learning  持续学习</li>\n</ul>\n<p>Scrum 一种流行的敏捷开发框架</p>\n<ul>\n<li>Development work is partitioned into “packets”</li>\n<li>Testing and documentation are on-going (测试和文档贯穿开发流程)</li>\n<li>Work occurs in “sprints” and is derived from a “backlog” (Sprint 是 Scrum 的核心时间单位，通常为 1 到 4 周)</li>\n<li>Meetings are very short 高效沟通（三个问题：What did you do since the last meeting&#x2F; What do you plan to accomplish by the next team meeting&#x2F;What obstacles are you encountering）</li>\n<li>“demos” are delivered to the customer with the time-box allocated</li>\n</ul>\n<p>Dynamic Systems Development Method  - DSDM<br>帕累托原则（Pareto Principle），也称为 80&#x2F;20 法则<br>“80% 的价值来自 20% 的功能”，或者 “80% 的系统可以在 20% 的时间内交付”<br>DSDM 的核心理念之一就是：优先交付最有价值的功能</p>\n<p>Agile Modeling (<code>AM</code>) principals:</p>\n<ul>\n<li>Model with a purpose</li>\n<li>Use multiple models </li>\n<li>Travel light </li>\n<li>Content is more important than representation</li>\n<li>Know the models and the tools you use to create them</li>\n<li>Adapt locally</li>\n</ul>\n<p>Agile Unified Process (<code>AUP</code>) 敏捷统一流程：一个精简的软件开发过程<br>Each AUP iteration addresses these activities: </p>\n<ul>\n<li>Modeling</li>\n<li>Implementation</li>\n<li>Testing</li>\n<li>Deployment </li>\n<li>Configuration and project management </li>\n<li>Environment management</li>\n</ul>\n<h1 id=\"Ch6-Human-Aspects-of-Software-Engineering\"><a href=\"#Ch6-Human-Aspects-of-Software-Engineering\" class=\"headerlink\" title=\"Ch6 Human Aspects of Software Engineering\"></a>Ch6 Human Aspects of Software Engineering</h1><p>Traits of Successful Software Engineers: 责任感、对需求敏感、直言不讳、有弹性(Resilient under pressure)、公平意识、注重细节、务实(Pragmatic)<br>The Psychology Of Software Engineering 没看懂不管了<br>Effective Software Team Attributes</p>\n<ul>\n<li>Sense of purpose</li>\n<li>Sense of involvement</li>\n<li>Sense of trust</li>\n<li>Sense of improvement</li>\n<li>Diversity of team member skill sets<br>Avoid Team “Toxicity” 毒性<br>A frenzied work atmosphere, high frustication, Fragmented or poorly coordinated procedures(或者定义不当的模型), Unclear definition of roles, Continuous and repeated exposure to failure</li>\n</ul>\n<p>Factors Affecting Team Structure</p>\n<ul>\n<li>difficulty of the problem</li>\n<li>size of the resultant program(s)</li>\n<li>the time that the team will stay together</li>\n<li>the degree to which the problem can be modularized</li>\n<li>the required quality and reliability of the system</li>\n<li>the rigidity of the delivery date 交付日期是不是很死</li>\n<li>the degree of sociability required</li>\n</ul>\n<p>Organizational Paradigms 组织范式</p>\n<ul>\n<li>Closed paradigm</li>\n<li>Random paradigm</li>\n<li>Open paradigm</li>\n<li>Synchronous paradigm<table>\n<thead>\n<tr>\n<th>范式</th>\n<th>组织方式</th>\n<th>控制程度</th>\n<th>创新程度</th>\n<th>沟通频率</th>\n<th>适用项目类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Closed</strong></td>\n<td>层级权威</td>\n<td>高</td>\n<td>低</td>\n<td>自上而下</td>\n<td>传统行业、安全关键系统</td>\n</tr>\n<tr>\n<td><strong>Random</strong></td>\n<td>松散自由</td>\n<td>低</td>\n<td>高</td>\n<td>无固定模式</td>\n<td>初创项目、探索性任务</td>\n</tr>\n<tr>\n<td><strong>Open</strong></td>\n<td>半结构化</td>\n<td>中等</td>\n<td>高</td>\n<td>高频协作</td>\n<td>敏捷开发、创新型项目</td>\n</tr>\n<tr>\n<td><strong>Synchronous</strong></td>\n<td>模块化分工</td>\n<td>高</td>\n<td>中等</td>\n<td>极少</td>\n<td>分布式系统、大型项目</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<p>Generic Agile Teams（通用敏捷团队）</p>\n<ul>\n<li>individual competency coupled with group collaboration</li>\n<li>People trump process and politics can trump people</li>\n<li>self-organizing and have many structures</li>\n<li>Planning is kept to a minimum 不反对规划，但强调“轻量级规划”比如Sprint</li>\n</ul>\n<p>XP Team Values</p>\n<ul>\n<li>Communication</li>\n<li>Simplicity: design for immediate needs nor future needs</li>\n<li>Feedback</li>\n<li>Courage</li>\n<li>Respect</li>\n</ul>\n<p>Impact of Social Media </p>\n<p>Software Engineering using the Cloud</p>\n<p>协作工具：Services of collaborative development environments(CDEs)<br>Namespace, Calendar, Template, Metrics support(Metrics 应用于过程改进，而不是人员奖惩), Communication analysis, Artifact clustering归类</p>\n<p>Team Decisions Making Complications<br><img data-src=\"/6-1.jpg\"></p>\n<h1 id=\"Ch7-Principles-that-Guide-Practice\"><a href=\"#Ch7-Principles-that-Guide-Practice\" class=\"headerlink\" title=\"Ch7 Principles that Guide Practice\"></a>Ch7 Principles that Guide Practice</h1><p>Software development knowledgehave about a three year half-life, Software engineering principles 是永久的</p>\n<p>Principles that Guide Process:</p>\n<ol>\n<li>Be agile</li>\n<li>Focus on quality at every step</li>\n<li>Be ready to adapt</li>\n<li>Build an effective team</li>\n<li>Establish mechanisms for communication and coordination</li>\n<li>Manage change</li>\n<li>Assess risk</li>\n<li>Create work products that provide value for others</li>\n</ol>\n<p>Principles that Guide Practice:</p>\n<ol>\n<li>Divide and conquer</li>\n<li>Understand the use of abstraction</li>\n<li>Strive for consistency</li>\n<li>Focus on the transfer of information 注意接口的设计</li>\n<li>Build software that exhibits effective modularity</li>\n<li>Look for patterns</li>\n<li>When possible, represent the problem and its solution from a number of different perspectives</li>\n<li>Remember that someone will maintain the software</li>\n</ol>\n<p>Communication Principle： </p>\n<ol>\n<li>Listen</li>\n<li>Prepare before you communicate</li>\n<li>Someone should facilitate the activity</li>\n<li>Face-to-face communication is best</li>\n<li>Take notes and document decisions</li>\n<li>Strive for collaboration</li>\n<li>Stay focused, modularize your discussion</li>\n<li>If something is unclear, draw a picture</li>\n<li>不管怎样, Move on</li>\n<li>Nigotiation(谈判) works best when both parties win</li>\n</ol>\n<p>Planning Principles：<br>懒得写了考了我吃</p>\n<p>Modeling Principles： 创建两类模型</p>\n<ol>\n<li>Requirements models (also called analysis models) 需求模型</li>\n<li>Design models 设计模型</li>\n</ol>\n<p>Agile Modeling Principles 记不住，懒得写了再说</p>\n<p>Requirements Modeling Principles</p>\n<ol>\n<li>The information domain of a problem must be represented and understood  对问题领域内信息的全面了解是构建有效软件的基础</li>\n<li>The functions that the software performs must be defined  定义软件的功能，明确描述软件应提供的功能和服务</li>\n<li>The behavior of the software (as a consequence of external events) must be represented  定义软件的行为，如何响应外界事件或输入</li>\n<li>The models that depict information, function, and behavior must be partitioned in a manner that uncovers detail in a layered (or hierarchical) fashion  使用结构化的、分层次的方法来组织模型</li>\n<li>The analysis task should move from essential information toward implementation detail  先关注核心需求和架构设计，再细化到具体的实现方案</li>\n</ol>\n<p>Design Modeling Principles<br>太多了懒得看</p>\n<p>Living Modeling Principles<br>懒得看</p>\n<p>Construction Principles</p>\n<ul>\n<li>The construction activity encompasses a set of coding and testing tasks</li>\n<li><code>Coding principles and concepts</code> are closely aligned programming style, programming languages, and programming methods</li>\n<li><code>Testing principles and concepts</code> lead to the design of tests that systematically uncover different classes of errors and to do so with a minimum amount of time and effort</li>\n</ul>\n<p>…..一堆principle，看了也记不住，不看了</p>\n<h1 id=\"Ch8-Understanding-Requirements\"><a href=\"#Ch8-Understanding-Requirements\" class=\"headerlink\" title=\"Ch8 Understanding Requirements\"></a>Ch8 Understanding Requirements</h1><p>Requirements Engineering:</p>\n<ol>\n<li>Inception: ask a set of questions – basic understanding of the problem, the people who want a solution, the nature of the solution, the effectiveness of preliminary communication and collaboration</li>\n<li>Elicitation: elicit requirements</li>\n<li>Elaboration: create an analysis model</li>\n<li>Negotiation: agree on a deliverable system</li>\n<li>Specification: written document&#x2F;set of models&#x2F;formal mathematical&#x2F;use-cases&#x2F;prototype</li>\n<li>Validation: a review mechanism that looks for – errors in content or interpretation&#x2F;areas where clarification may be required&#x2F;missing information&#x2F;inconsistencies&#x2F;conflicting or unrealistic (unachievable) requirements</li>\n<li>Requirements management</li>\n</ol>\n<p>Elicitation Work Products:<br>feasibility, scope, stakeholders, description of environment, constraints, usage scenarios, prototypes</p>\n<p>Negotiating Requirements:</p>\n<ol>\n<li>Identify the key stakeholders</li>\n<li>Determine each of the stakeholders “win conditions”</li>\n<li>Negotiate</li>\n</ol>\n<p>Requirements Monitoring:</p>\n<ol>\n<li>Distributed debugging</li>\n<li>Run-time verification</li>\n<li>Run-time validation</li>\n<li>Business activity monitoring</li>\n<li>Evolution and co-design</li>\n</ol>\n<p>Validating Requirements:<br>consistent, 是否在level of abstraction规定了, 是否essential, unambiguous, 每个要求注明来源, requirements 之间是否 conflict, achievable, testable, properly reflect the information, function and behavior, partitioned方式, …</p>\n<p>Quality Function Deployment (QFD):</p>\n<ul>\n<li>Function deployment</li>\n<li>Information deployment</li>\n<li>Task deployment</li>\n<li>Value analysis</li>\n<li>identifies three types of requirements: Normal&#x2F;Expected&#x2F;Exciting</li>\n</ul>\n<p>Non-Functional Requirement (NFR): quality attribute, performance attribute, security attribute, or general system constraint</p>\n<ol>\n<li>The first phase is to create a matrix using each NFR</li>\n<li>The second phase is for the team to prioritize each NFR using a set of decision rules</li>\n</ol>\n<h1 id=\"Ch9-Requirements-Modeling：Scenario-Based-Methods-基于场景的需求建模方法\"><a href=\"#Ch9-Requirements-Modeling：Scenario-Based-Methods-基于场景的需求建模方法\" class=\"headerlink\" title=\"Ch9 Requirements Modeling：Scenario-Based Methods 基于场景的需求建模方法\"></a>Ch9 Requirements Modeling：Scenario-Based Methods 基于场景的需求建模方法</h1><p>需求分析的目标：</p>\n<ul>\n<li>描述客户所需的内容 Describe what the customer requires</li>\n<li>为软件设计提供基础 Establish a basis for the creation of a software design</li>\n<li>定义一组可以验证的需求 Define a set of requirements that can be validated<br>Rules of Thumb（基本原则）：</li>\n<li>The model should focus on requirements that are visible within the problem or business domain. The level of abstraction should be relatively high.</li>\n<li>Each element of the analysis model should add to an overall understanding of software requirements and provide insight into the information domain, function and behavior of the system.</li>\n<li>Delay consideration of infrastructure and other non-functional models until design.</li>\n<li>Minimize coupling throughout the system.</li>\n<li>Be certain that the analysis model provides value to all stakeholders.</li>\n<li>Keep the model as simple as it can be.</li>\n</ul>\n<p>system description -&gt; analysis model -&gt; design model</p>\n<p><img data-src=\"/9-1.jpg\"></p>\n<p>Domain Analysis（领域分析）：<br>Software domain analysis is the identification, analysis, and specification of common requirements from a specific application domain, typically for <code>reuse</code> on multiple projects within that application domain…</p>\n<p>Use-Case Diagram, Activity Diagrams, Swim Lane Diagrams</p>\n<p>In structured analysis, models focus on data flow and functional decomposition of the system;<br>In object-oriented analysis, models focus on the structure of the classes defined for a system along with their interactions</p>\n<p>Each primary scenario should be <code>reviewed</code> and <code>refined</code> to see ifalternative interactions are possible</p>\n<h1 id=\"Ch10-Requirements-Modeling-Class-Based-Methods\"><a href=\"#Ch10-Requirements-Modeling-Class-Based-Methods\" class=\"headerlink\" title=\"Ch10 Requirements Modeling: Class-Based Methods\"></a>Ch10 Requirements Modeling: Class-Based Methods</h1><p>Class-Based需求建模的方法：structured analysis(数据对象和数据的转换), object- oriented analysis(类和类的协作)<br>the broad categories used to classify operations: computation, data manipulation, event monitors<br>Class-Based Modeling: objects, operations, relationships, collaborations<br>类图<br>CRC Cards<br>见画图题</p>\n<h1 id=\"Ch11-Requirements-Modeling-Behavior-Patterns-and-Web-Mobile-Apps\"><a href=\"#Ch11-Requirements-Modeling-Behavior-Patterns-and-Web-Mobile-Apps\" class=\"headerlink\" title=\"Ch11 Requirements Modeling: Behavior, Patterns, and Web&#x2F;Mobile Apps\"></a>Ch11 Requirements Modeling: Behavior, Patterns, and Web&#x2F;Mobile Apps</h1><p>For purposes of behavior modeling a state is any observable mode of behavior<br>Analysis patterns are discovered, they are not explicitly created<br>行为建模: use-cases, events, sequences, state diagram, 审查<br>行为建模三种图：state diagram, sequence diagram, data-flow diagram<br>The state transition diagram indicates system reactions to external events.<br>events由系统外部的参与者触发</p>\n<h2 id=\"Requirements-Modeling-for-WebApps\"><a href=\"#Requirements-Modeling-for-WebApps\" class=\"headerlink\" title=\"Requirements Modeling for WebApps:\"></a>Requirements Modeling for WebApps:</h2><ul>\n<li>内容分析 Content Analysis：描述文本、图形和图像、视频、音频等。</li>\n<li>交互分析 Interaction Analysis：使用案例。</li>\n<li>功能分析 Functional Analysis：定义应用于WebApp内容的操作，暗示其他处理功能。</li>\n<li>配置分析 Configuration Analysis：环境和基础设施。</li>\n<li>导航分析 Navigation Analysis：关注总体要求。</li>\n</ul>\n<p>配置模型 Configuration Model</p>\n<ul>\n<li>服务器端 Server-side：必须指定服务器硬件和操作系统环境、考虑服务器端互操作性、指定适当的接口、通信协议及相关协作信息。</li>\n<li>客户端 Client-side：必须识别浏览器配置问题、定义测试要求。</li>\n</ul>\n<p>导航建模 Navigation Modeling</p>\n<ul>\n<li>考虑哪些元素应更容易到达（需要更少的导航步骤），优先级如何？</li>\n<li>如何处理导航错误？</li>\n<li>是否应该通过链接、基于搜索的访问或其他方式完成导航？</li>\n<li>是否应根据之前导航动作的上下文向用户展示某些元素？</li>\n<li>是否应维护用户的导航日志？<br> WebApps interaction model: use-cases, sequence diagrams, state diagrams, interface prototype</li>\n</ul>\n<h1 id=\"Ch12-Design-Concepts\"><a href=\"#Ch12-Design-Concepts\" class=\"headerlink\" title=\"Ch12 Design Concepts\"></a>Ch12 Design Concepts</h1><p>好的软件设计应该具备：坚固性 Firmness, 实用性 Commodity, 愉悦感 Delight<br>Software Engineering Design：设计原则与质量</p>\n<ul>\n<li>Data&#x2F;Class design</li>\n<li>Architectural design</li>\n<li>Interface design</li>\n<li>Component-level design<br>自上而下是金字塔，见下图</li>\n</ul>\n<p><img data-src=\"/12-1.jpg\"></p>\n<p>Analysis Model -&gt; Design Model（需求模型到设计模型）</p>\n<ul>\n<li>设计必须实施分析模型中包含的所有显式需求(explicit requirements)，并适应客户希望的所有隐式需求。</li>\n<li>设计应当是可读且易于理解(readable, understandable guide)的指南，帮助编写代码的人以及测试和支持软件的人。</li>\n<li>设计应该提供软件的完整画面(a complete picture)，从实现的角度解决数据、功能和行为领域的问题</li>\n</ul>\n<p>质量指南 Quality Guidelines</p>\n<ul>\n<li>设计应展示一种使用公认的架构风格创建的架构。</li>\n<li>设计应由展现良好设计特性的组件组成。</li>\n<li>设计可以逐步实现。</li>\n<li>设计应模块化，即将软件逻辑划分为元素或子系统。</li>\n<li>设计应包含数据、架构、接口和组件的不同表示形式</li>\n</ul>\n<p>设计原则 Design Principles</p>\n<ul>\n<li>设计过程不应有“隧道视野”，即应全面考虑各种因素。</li>\n<li>设计应可追溯到分析模型。</li>\n<li>设计不应重新发明轮子（即不应重复已有的解决方案）。</li>\n<li>设计应“最小化软件与现实世界中存在的问题之间的智力距离”。</li>\n<li>设计应统一且整合。</li>\n<li>设计应能够适应变化。</li>\n<li>设计应以温和的方式降级，即使遇到异常数据、事件或操作条件。</li>\n</ul>\n<p>OO Design Concepts: Design classes(<code>Entity classes</code>, <code>Boundary classes</code>, <code>Controller classes</code>), Inheritance, Messages, Polymorphism<br>:::warning<br>后面看不下去先不管了<br>:::</p>\n<h1 id=\"Ch13-Architectural-Design\"><a href=\"#Ch13-Architectural-Design\" class=\"headerlink\" title=\"Ch13 Architectural Design\"></a>Ch13 Architectural Design</h1><p>架构风格：</p>\n<ul>\n<li>Data-centered architectures</li>\n<li>Data flow architectures </li>\n<li>Call and return architectures</li>\n<li>Object-oriented architectures</li>\n<li>Layered architectures</li>\n</ul>\n<h1 id=\"Ch14-Component-Level-Design\"><a href=\"#Ch14-Component-Level-Design\" class=\"headerlink\" title=\"Ch14 Component-Level Design\"></a>Ch14 Component-Level Design</h1><p>Component: a modular, deployable, and replaceable part of a system<br>OO角度：一个组件包含一组协作类<br>传统角度：数据结构和接口<br>Basic Design Principles：OCP, LSP, DIP, ISP, REP, CCP, CRP</p>\n<ul>\n<li>Open-Closed Principle: 开放扩展，关闭修改</li>\n<li>Liskov Substitution Principle: 子类可被父类替换</li>\n<li>Dependency Inversion Principles: 依赖抽象，不要依赖具体实现</li>\n<li>Interface Segregation Principle: 多个特定于客户端的接口比一个通用接口更好</li>\n<li>Release Reuse Equivalency Principle: 发布的粒度是重用的粒度</li>\n<li>Common Closure Principle: 一起变化的类应该放在一起</li>\n<li>Common Reuse Principle: 不一起重用的类不应放在一起</li>\n</ul>\n<p>基本设计原则（Basic Design Principles）:</p>\n<ol>\n<li>命名约定 Components </li>\n<li>接口 Interfaces</li>\n<li>依赖关系和继承：建议从左到右建模依赖关系，从底向上（派生类）到底部（基类）建模继承关系</li>\n</ol>\n<p>设计指南（Design Guidelines）:<br>内聚性 Cohension</p>\n<ul>\n<li>the &#x3D;&#x3D;“single-mindedness”&#x3D;&#x3D; of a module</li>\n<li>OO view: – cohesion implies that a component or class encapsulates only attributes and operations that are closely related to one another and to the class or component itself</li>\n<li>Levels of cohesion： Functional – Layer – Communicational – Sequential – Procedural – Temporal – Utility<br>耦合度级别：内容耦合、公共耦合、控制耦合等 Coupling</li>\n<li>The degree to which a component is &#x3D;&#x3D;connected to other components and to the external world&#x3D;&#x3D;</li>\n<li>OO观点: 衡量classes are connected to one another的程度</li>\n<li>Level of coupling: Content – Common – Control – Stamp – Data – Routine call – Type use – Inclusion or import – External</li>\n</ul>\n<p>WebApps 组件设计：通常包含content design and functional design<br>……</p>\n<h1 id=\"Ch15-User-Interface-Design\"><a href=\"#Ch15-User-Interface-Design\" class=\"headerlink\" title=\"Ch15 User Interface Design\"></a>Ch15 User Interface Design</h1><p>Golden Rule：</p>\n<ol>\n<li>Place the user in control</li>\n<li>Reduce the user’s memory load</li>\n<li>Make the interface consistent<br>User Interface Design Model:<table>\n<thead>\n<tr>\n<th>模型名称</th>\n<th>中文解释</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>User Model</td>\n<td>用户模型</td>\n<td>描述用户是谁、他们的需求和行为</td>\n</tr>\n<tr>\n<td>Design Model</td>\n<td>设计模型</td>\n<td>将用户模型转化为界面设计方案</td>\n</tr>\n<tr>\n<td>Mental Model</td>\n<td>心理模型</td>\n<td>用户对界面的主观理解和预期</td>\n</tr>\n<tr>\n<td>Implementation Model</td>\n<td>实现模型</td>\n<td>开发者实际构建的界面及其交互逻辑</td>\n</tr>\n<tr>\n<td>User Interface Design Process: 螺旋模型</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<p>Interface Analysis<br>Interface Analysis旨在理解以下几点：people(user), task, content, environment</p>\n<h1 id=\"Ch16-Pattern-Based-Design\"><a href=\"#Ch16-Pattern-Based-Design\" class=\"headerlink\" title=\"Ch16 Pattern-Based Design\"></a>Ch16 Pattern-Based Design</h1><p>A design pattern is a three-part rule which expresses a relation between a certain &#x3D;&#x3D;context&#x3D;&#x3D;, a &#x3D;&#x3D;problem&#x3D;&#x3D;, and a &#x3D;&#x3D;solution&#x3D;&#x3D;.</p>\n<p>Describing a Pattern: By detailing various dimensions such as pattern name, problem, motivation, context, forces, solution, intent, collaborations, consequences, implementation, known uses, related patterns, etc. </p>\n<h1 id=\"Ch17-WebApp-Design\"><a href=\"#Ch17-WebApp-Design\" class=\"headerlink\" title=\"Ch17 WebApp Design\"></a>Ch17 WebApp Design</h1><p>two basic approaches to design: 1. artistic ideal of designers; 2. the requirements of customers</p>\n<p>Design &amp; WebApp Quality的几个关键：</p>\n<ol>\n<li>Security: 抵御攻击、排除未经授权的访问、保护用户隐私</li>\n<li>Availability: 确保系统在需要的时候可用 The measure of the percentage of time that a WebApp is available for use</li>\n<li>Scalability（可扩展性）: Can the WebApp and the systems with which it is interfaced handle significant variation in user or transaction volume 系统在用户数量或交易量增加时，仍能保持良好的性能和响应速度的能力</li>\n<li>Time to Market（上市时间）</li>\n</ol>\n<p>Quality Dimensions for End-Users:<br>对于用户而言</p>\n<ol>\n<li>Time: 网站更新的频率和程度</li>\n<li>Structural: 网站的结构、链接、图片正常显示、组件连接</li>\n<li>Content: 关键页面的内容、关键短语、关键页面的不同版本、动态生成页面的质量和一致性</li>\n<li>Accuracy and Consistency: </li>\n<li>Response Time and Latency: 响应、加载速度</li>\n<li>Performance: 站点连接速度、负载</li>\n</ol>\n<p>WebApp Design Goals：</p>\n<ol>\n<li>Consistency: Content, Graphic design (aesthetics), Architectural design, Interface design, Navigation mechanisms</li>\n<li>Identity: Web应用需要有一个清晰且与业务目标相匹配的品牌形象或身份</li>\n<li>Robustness: Web应用的内容和功能的质量和可靠性</li>\n<li>Navigability: Designed in a manner that is intuitive and predictable（以直观和可预测的方式设计）</li>\n<li>Visual appeal</li>\n<li>Compatibility 兼容性<br><img data-src=\"/17-1.jpg\"></li>\n</ol>\n<p>Interface Design需要回答: Where am I? What can I do now? Where have I been, where am I going?</p>\n<p>Interface Design Principles 太多了懒得写</p>\n<p>&#x3D;&#x3D;Aesthetic Design&#x3D;&#x3D;</p>\n<ul>\n<li>Don’t be afraid of white space.</li>\n<li>Emphasize content.</li>\n<li>Organize layout elements from top-left to bottom right.</li>\n<li>Group navigation, content, and function geographically within the page.</li>\n<li>Don’t extend your real estate with the scrolling bar.</li>\n<li>Consider resolution and browser window size when designing layout.</li>\n</ul>\n<p>Content Design</p>\n<p>Architecture Design<br>Content architecture focuses on &#x3D;&#x3D;the manner in which content objects (or composite objects such as Web pages) are structured&#x3D;&#x3D; for presentation and navigation.<br>WebApp architecture addresses &#x3D;&#x3D;the manner in which the application is structured&#x3D;&#x3D; to manage user interaction, handle internal processing tasks, effect navigation, and presentcontent.<br>Architecture design is conducted in parallel with <code>interface design</code>, <code>aesthetic design</code> and <code>content design</code></p>\n<p>MVC（Model-View-Controller）架构，一种广泛应用于软件工程中的设计模式<br>MVC将应用程序分为三个主要部分：模型（Model）、视图（View）和控制器（Controller）</p>\n<ul>\n<li>model: all application specific content and processing logic</li>\n<li>view: The view contains all interface specific functions and enables</li>\n<li>controller: The controller manages access to the model and the view and coordinates the &#x3D;&#x3D;flow of data&#x3D;&#x3D; between them</li>\n</ul>\n<p>Navigation Design<br>Navigation Syntax</p>\n<ol>\n<li>Individual navigation link（独立导航链接）<br>指单个用于跳转的元素，如文字链接、图标、按钮或开关。</li>\n<li>Horizontal navigation bar（水平导航栏）<br>水平排列的主要内容或功能分类链接。<br>通常包含4到7个选项，适合展示网站的核心栏目。</li>\n<li>Vertical navigation column（垂直导航列）<br>垂直排列的导航结构，常用于侧边栏。<br>可以列出主要内容类别或几乎所有的内容对象。</li>\n<li>Tabs（标签页）<br>类似浏览器的多标签页设计，是导航栏或列的一种变体。<br>每个标签代表一个内容区域或功能模块，点击切换。</li>\n<li>Site maps（站点地图）<br>提供整个Web应用内容与功能的完整目录，帮助用户全面了解和访问所有页面。</li>\n</ol>\n<p>Component-Level Design</p>\n<h1 id=\"Ch18-MobileApp-Design\"><a href=\"#Ch18-MobileApp-Design\" class=\"headerlink\" title=\"Ch18 MobileApp Design\"></a>Ch18 MobileApp Design</h1><p>MobileApp Design需要注意：</p>\n<ul>\n<li>Multiple hardware and software platforms</li>\n<li>Many development frameworks and programming languages</li>\n<li>Many app stores</li>\n<li>Short development cycles</li>\n<li>User interface limitations</li>\n<li>Complex camera&#x2F;sensor interaction</li>\n<li>Effective use of context</li>\n<li>Power management</li>\n<li>Security and privacy models&#x2F;policies</li>\n<li>Device limitations (computation and storage)</li>\n<li>Integration of external services</li>\n<li>Texting complexities</li>\n</ul>\n<p>MobileApp Development Process Model：</p>\n<ul>\n<li>Formulation</li>\n<li>Planning</li>\n<li>Analysis</li>\n<li>Engineering</li>\n<li>Implementation and testing</li>\n<li>User evaluation</li>\n</ul>\n<p>MobileApp Quality Checklist 略</p>\n<p>MobileApp User Interface Design Considerations</p>\n<ul>\n<li>Define user interface brand signatures</li>\n<li>Focus the portfolio of products</li>\n<li>Identify core user stories</li>\n<li>Optimize UI flows and elements</li>\n<li>Define scaling rules 适应屏幕尺寸</li>\n<li>Create user performance dashboard 收集和分析用户行为数据</li>\n<li>Rely on dedicated champion with user interface engineering skills 在项目中设立一名专门负责用户界面设计和开发的角色</li>\n</ul>\n<p>MobileApp Design Mistakes</p>\n<ul>\n<li>Kitchen sink 功能堆砌</li>\n<li>Inconsistency</li>\n<li>Overdesigning 过度设计</li>\n<li>Lack of speed</li>\n<li>Verbiage 过多、过于正式或复杂的文字描述</li>\n<li>Non-standard interaction</li>\n<li>Help-and–FAQ-itis 应用本身不好用，于是靠大量的帮助提示、FAQ、引导流程来弥补</li>\n</ul>\n<p>MobileApp Design Best Practices</p>\n<ul>\n<li>Identify the audience 识别目标用户</li>\n<li>Design for context of use 根据使用场景来设计</li>\n<li>Recognize line between simplicity is not laziness 简化 ≠ 懒惰</li>\n<li>Use the platform to its advantage</li>\n<li>Allow for discoverability of advanced functionality 让高级功能易于被发现</li>\n<li>Use clear and consistent labels</li>\n<li>Cleaver icons should never be developed at the expense of user understanding</li>\n<li>Long scrolling forms trump multiple screens 长滚动表单优于多页面跳转</li>\n</ul>\n<p>Assessing Mobile Interactive Development Environments</p>\n<ul>\n<li>General productivity features 指开发工具是否提供提高效率的功能</li>\n<li>Third-party SDK integration 是否支持主流的第三方服务和库（SDK）</li>\n<li>Post-compilation tools</li>\n<li>Over the air development support</li>\n<li>End-to-end mobile application development</li>\n<li>Documentation and tutorials</li>\n<li>Graphical user interface builders</li>\n</ul>\n<p>MobileApp Middleware 介于操作系统、网络服务与应用程序之间的一层软件，用于简化复杂的分布式系统之间的通信和数据管理</p>\n<ul>\n<li>Facilitates communication and coordination of distributed components</li>\n<li>Allows developers to rely on abstractions and hide mobile environment details</li>\n<li>Helps MobileApps to achieve context awareness as required</li>\n</ul>\n<h1 id=\"Ch19-Quality-Concepts\"><a href=\"#Ch19-Quality-Concepts\" class=\"headerlink\" title=\"Ch19 Quality Concepts\"></a>Ch19 Quality Concepts</h1><h1 id=\"Ch20-Review-Techniques\"><a href=\"#Ch20-Review-Techniques\" class=\"headerlink\" title=\"Ch20 Review Techniques\"></a>Ch20 Review Techniques</h1><p>Reviews: 由技术人员为技术人员进行的会议，是对软件工程过程中产生的工作产品的技术评估，是软件质量保证机制之一，并作为培训场所<br>Errors(软件发布前发现的问题) and defects(软件发布后发现的问题)</p>\n<p>Defect Amplification Model 描述了开发步骤中的错误如何从前一步骤传递到下一步骤以及如何被检测出来<br>缺陷放大模型<br><img data-src=\"/20-1.jpg\"><br>$$<br>E_{review} &#x3D; E_p + E_a + E_r<br>$$</p>\n<p>$$<br>Err_{tot} &#x3D; Err_{minor} + Err_{major}<br>$$</p>\n<p>$$<br>Defect\\ density &#x3D; Err_{tot} &#x2F; WPS<br>$$</p>\n",
            "tags": [
                "软件工程"
            ]
        },
        {
            "id": "http://example.com/2025/06/18/computer-science/compile-principles/ch11/",
            "url": "http://example.com/2025/06/18/computer-science/compile-principles/ch11/",
            "title": "Register Allocation",
            "date_published": "2025-06-17T16:00:00.000Z",
            "content_html": "<h1 id=\"Register-Allocation\"><a href=\"#Register-Allocation\" class=\"headerlink\" title=\"Register Allocation\"></a>Register Allocation</h1><p>目标：</p>\n<ul>\n<li>Map temporaries to registers</li>\n<li>Preserve program semantics</li>\n<li>Optimize performance</li>\n</ul>\n<h2 id=\"图着色算法\"><a href=\"#图着色算法\" class=\"headerlink\" title=\"图着色算法\"></a>图着色算法</h2><p>冲突图是一个无向图，冲突图中，每个节点是一个变量（寄存器分配的候选对象）。<br>如果两个变量在同一时刻是活跃的（live），它们就有冲突边（interference edge），表示它们不能被分配到同一个寄存器<br>冲突信息可以用矩阵或者图来表示</p>\n<h3 id=\"冲突图构建\"><a href=\"#冲突图构建\" class=\"headerlink\" title=\"冲突图构建\"></a>冲突图构建</h3><p>我们从一个中间代码的指令出发，根据live-out（就是out集合）添加冲突边：</p>\n<ol>\n<li>非 move 指令（不是a :&#x3D; b这种）<br>比如a :&#x3D; b1 + b2<br>对于每个bn和a之间都添加冲突边<br>比如下面这个例子：<br><img data-src=\"/f1.jpg\"><br>可以看到有ab ac同时live了，所以为a和b，a和c添加冲突边</li>\n<li>move指令<br>对于move指令，不添加冲突边：<br>比如对于第 2 条指令 d ← a，out[2] &#x3D; {a, e}，那么只对d和e添加冲突边，对d和a不添加<br>但如果move之后又对d重新赋值了，那么还是要添加上d和a之间的冲突边</li>\n</ol>\n<h3 id=\"冲突图着色\"><a href=\"#冲突图着色\" class=\"headerlink\" title=\"冲突图着色\"></a>冲突图着色</h3><p>Vertex Coloring: 给图中的顶点着色，使得图中没有边连接相同颜色的顶点<br>K-Coloring: 颜色数小于K</p>\n<h4 id=\"Kempe-简化\"><a href=\"#Kempe-简化\" class=\"headerlink\" title=\"Kempe 简化\"></a>Kempe 简化</h4><p>如果图中有一个节点 n 的度数 &lt; K（也就是它的冲突数少于寄存器数），那我们可以“临时删掉”这个节点，并递归给剩下的图上色。之后再把这个节点加回来，它一定可以找到一个合法颜色。</p>\n<p>如果图中所有节点的度数都 ≥ K，那就可能要进入溢出（spill）处理<br>算法步骤：</p>\n<ol>\n<li>build: 画冲突图</li>\n<li>simplify the nodes with insignificant degree: 选取degree &lt; k的节点，压栈</li>\n<li>select (or color) while rebuilding the graph: 出栈，分配颜色<br>A vertex such that its degree &lt; k is always k-colorable<br>Remove such vertices and push them to a stack until the graph becomes empty<br>移除顶点的同时移除相关边</li>\n</ol>\n<h4 id=\"Coalescing\"><a href=\"#Coalescing\" class=\"headerlink\" title=\"Coalescing\"></a>Coalescing</h4><p>遵循两种策略：</p>\n<ul>\n<li><strong>Briggs Criteria</strong>: 如果将节点 <code>a</code> 和 <code>b</code> 合并后得到的新节点 <code>ab</code>，其相邻节点中degree &gt;&#x3D; K 的节点（significant-degree neighbors）的数量 小于 K，则可以合并</li>\n<li><strong>George Criteria</strong>: 如果对节点 <code>a</code> 和 <code>b</code>，对于 <code>a</code> 的每一个邻居 <code>t</code>， 满足二者其中之一，就能合并：<ul>\n<li><code>t</code> 本来就和 <code>b</code> 有冲突</li>\n<li><code>t</code>的degree &lt; K</li>\n</ul>\n</li>\n</ul>\n<p>整体流程：<br><img data-src=\"/f2.jpg\"></p>\n<ul>\n<li>为什么要simplify non-move-related node: 保留move-related的后续可以合并</li>\n<li>freeze: 当我们遇到两个变量 a ← b 有 move 指令，但现在还不能安全合并，我们又不想立刻 spill，于是我们“冻结”这条 move 指令：不再试图合并 a 和 b，而是让其中一个变成非 move 相关（non-move-related），进入 Simplify 阶段继续处理</li>\n<li>spill规则：优先移除不被经常使用、degree大的节点<ul>\n<li>实际溢出的priority计算，对于节点a：<br>$$<br>priority(t) &#x3D; \\frac{(use + def outside loop) + loop_num * (use + def inside loop)}{D}<br>$$</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "Register Allocation"
            ]
        },
        {
            "id": "http://example.com/2025/06/18/computer-science/compile-principles/ch10/",
            "url": "http://example.com/2025/06/18/computer-science/compile-principles/ch10/",
            "title": "Liveness Analysis",
            "date_published": "2025-06-17T16:00:00.000Z",
            "content_html": "<h1 id=\"Liveness-Analysis-活跃变量分析\"><a href=\"#Liveness-Analysis-活跃变量分析\" class=\"headerlink\" title=\"Liveness Analysis 活跃变量分析\"></a>Liveness Analysis 活跃变量分析</h1><p>判断在程序执行的某个点上，一个变量的值是否可能在未来被使用，是寄存器分配、死代码消除的基础</p>\n<h2 id=\"Compiler-Optimizations\"><a href=\"#Compiler-Optimizations\" class=\"headerlink\" title=\"Compiler Optimizations\"></a>Compiler Optimizations</h2><ul>\n<li>Local: 基于basic blocks</li>\n<li>Intraprocedural (or “global’): 基本块的控制流转移</li>\n<li>Interprocedural (or “whole-program”): Operate on &gt; 1 procedure, up to whole program; Sometimes, at link time (LTO, link time optimization)</li>\n</ul>\n<p>两步：</p>\n<ul>\n<li>Analyze program to gather “facts”</li>\n<li>Apply transformation (e.g., optimizations)</li>\n</ul>\n<h2 id=\"Dataflow-Analysis\"><a href=\"#Dataflow-Analysis\" class=\"headerlink\" title=\"Dataflow Analysis\"></a>Dataflow Analysis</h2><p>Control Flow Graph: A directed graph 数据流图<br>– Nodes represent statements<br>– Edges represent control flow</p>\n<p>CFG的简化：基本块<br><img data-src=\"/f1.jpg\"></p>\n<h3 id=\"变量的活跃性：\"><a href=\"#变量的活跃性：\" class=\"headerlink\" title=\"变量的活跃性：\"></a>变量的活跃性：</h3><p>变量x在语句s处（执行s之前）处于活动状态，当且仅当满足以下三个条件：</p>\n<ol>\n<li>存在一个使用x的语句s’；</li>\n<li>存在从s到s’的路径；</li>\n<li>这条路径上没有对x进行任何赋值操作</li>\n</ol>\n<p>通过分析liveness，我们可以实现：</p>\n<ol>\n<li>Register Allocation</li>\n<li>Code Optimizations：Remove unused assignments</li>\n<li>IR Construction： Optimize the construction of SSA</li>\n<li>Security&#x2F;Reliability: Detect the use of uninitialized variables</li>\n</ol>\n<h2 id=\"Dataflow-Equations-for-Liveness-构建数据流方程\"><a href=\"#Dataflow-Equations-for-Liveness-构建数据流方程\" class=\"headerlink\" title=\"Dataflow Equations for Liveness 构建数据流方程\"></a>Dataflow Equations for Liveness 构建数据流方程</h2><p>A CFG node has</p>\n<ul>\n<li>out-edges: lead to successor nodes</li>\n<li>in-edges: come from predecessor nodes</li>\n<li>pred[n]: the predecessors of node n       前驱</li>\n<li>succ[n]: the successors of node n     后继</li>\n</ul>\n<p>几个定义：</p>\n<ul>\n<li>use[n]: 在节点n被读取或使用(x &#x3D; a + b的a和b, if(a &lt; b)的a和b, return c的c)</li>\n<li>def[n]: 在节点n被定义(x &#x3D; a + b的x)</li>\n<li>in[n]: 在节点n之前，所有活跃变量的集合</li>\n<li>out[n]: 在节点n之后，所有活跃变量的集合<br>三条活跃性规则：</li>\n</ul>\n<ol>\n<li>if $a \\in in[n]$ then for $\\all m \\in pred[n]$ we have $a \\in out[m]$</li>\n<li>if $a \\in use[n]$ then $a \\in in[n]$</li>\n<li>if $a \\in out[n]$ and $a \\notin def[n]$ then $a \\in in[n]$</li>\n</ol>\n<p>得到以下两个数据流方程：<br>$$<br>out[n] &#x3D; \\cup_{s \\in succ[n]} in[s]<br>$$<br> 一个节点在n的出口处活跃当且仅当在它后继的入口处是活跃的（活跃性的反向传播）<br>$$<br>in[n] &#x3D; use[n] \\cup (out[n] - def[n])<br>$$</p>\n<h2 id=\"求解数据流方程\"><a href=\"#求解数据流方程\" class=\"headerlink\" title=\"求解数据流方程\"></a>求解数据流方程</h2><p>有了上面的两个数据流方程，就可以求解数据流方程了<br>算法：</p>\n<figure class=\"highlight plaintext\"><figcaption><span>pseudo</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for each n</span><br><span class=\"line\">    in[n] ←&#123;&#125;; out[n] ←&#123;&#125;</span><br><span class=\"line\">repeat</span><br><span class=\"line\">    for each n</span><br><span class=\"line\">        in′[n] ← in[n]; out′[n] ← out[n]</span><br><span class=\"line\">        in[n] ← use[n] ∪ (out[n] − def[n])</span><br><span class=\"line\">        out[n] ← ⋃( ∈()**[+] in[s]</span><br><span class=\"line\">until in′[n] = in[n] and out′[n] = out[n] for all n</span><br></pre></td></tr></table></figure>\n<ol>\n<li>将所有节点的 <code>in</code> 和 <code>out</code> 集合初始化为空集。</li>\n<li>写出<code>use[n]</code>和<code>def[n]</code></li>\n<li>用数据流方程更新<code>in</code>和<code>out</code>集合</li>\n<li>直到<code>in</code>和<code>out</code>集合不再改变为止<br>例：<br><img data-src=\"/f2.jpg\"><br>对于这个CFG<br>每一次迭代如图：<br><img data-src=\"/f3.jpg\"></li>\n</ol>\n<h2 id=\"Improvements\"><a href=\"#Improvements\" class=\"headerlink\" title=\"Improvements\"></a>Improvements</h2><h3 id=\"Use-Basic-Block\"><a href=\"#Use-Basic-Block\" class=\"headerlink\" title=\"Use Basic Block\"></a>Use Basic Block</h3><p>后面有点懒得看，先放着</p>\n<h2 id=\"集合的表示方法\"><a href=\"#集合的表示方法\" class=\"headerlink\" title=\"集合的表示方法\"></a>集合的表示方法</h2><p>对于in, out, use, def集合的表示和操作对性能有很大影响</p>\n<h3 id=\"Bit-Arrays\"><a href=\"#Bit-Arrays\" class=\"headerlink\" title=\"Bit Arrays\"></a>Bit Arrays</h3><p>有点像bit map，适用于稠密集合（1比较多的，如果0太多就浪费了）</p>\n<h3 id=\"Sorted-Lists\"><a href=\"#Sorted-Lists\" class=\"headerlink\" title=\"Sorted Lists\"></a>Sorted Lists</h3><p>适合稀疏集合（用一个链表存集合中的变量, Sorted by variable name&#x2F;ID）</p>\n",
            "tags": [
                "Liveness Analysis"
            ]
        },
        {
            "id": "http://example.com/2025/06/17/computer-science/compile-principles/ch8/",
            "url": "http://example.com/2025/06/17/computer-science/compile-principles/ch8/",
            "title": "Basic Blocks & Traces",
            "date_published": "2025-06-16T16:00:00.000Z",
            "content_html": "<h1 id=\"Basic-Blocks-and-Traces\"><a href=\"#Basic-Blocks-and-Traces\" class=\"headerlink\" title=\"Basic Blocks and Traces\"></a>Basic Blocks and Traces</h1><h2 id=\"Canonical-Form\"><a href=\"#Canonical-Form\" class=\"headerlink\" title=\"Canonical Form\"></a>Canonical Form</h2><p>IR存在一些与机器语言不能完全对应的情况，和与编译优化分析相冲突的情况。</p>\n<ul>\n<li>CJUMP能够转移到t或者f，但是真正的机器语言在条件为假的时候直接下降至下一条指令（条件为真才跳转）</li>\n<li>在表达式中使用ESEQ不太方便，会使子树不同的计算顺序产生不同的计算结果</li>\n<li>CALL调用CALL作为参数的时候会有寄存器冲突、语句副作用（修改全局变量、改变堆内存, etc.）等问题</li>\n</ul>\n<p>三种方法：</p>\n<ol>\n<li>Linearize: Transform trees into a list of canonical<br>trees without SEQ or ESEQ nodes</li>\n<li>Basic blocks: Group statements into sequences with<br>no internal jumps&#x2F;labels</li>\n<li>Trace schedule: Order basic blocks so every CJUMP is followed by its false label</li>\n</ol>\n<h3 id=\"线性化\"><a href=\"#线性化\" class=\"headerlink\" title=\"线性化\"></a>线性化</h3><p>&#x3D;&#x3D;规范树（Canonical Tree）定义：&#x3D;&#x3D;</p>\n<ol>\n<li>无SEQ或ESEQ</li>\n<li>每一个CALL的父亲不是EXP(…)就是MOVE(TEMP t, …)</li>\n</ol>\n<h4 id=\"消除ESEQ\"><a href=\"#消除ESEQ\" class=\"headerlink\" title=\"消除ESEQ\"></a>消除ESEQ</h4><h5 id=\"规则\"><a href=\"#规则\" class=\"headerlink\" title=\"规则\"></a>规则</h5><p>合并副作用，提升ESEQ：</p>\n<ul>\n<li>ESEQ(s1, ESEQ(s2,e)) &#x3D;&gt; ESEQ(SEQ(s1,s2),e)</li>\n<li>BINOP(op, ESEQ(s, e1), e2) ⇒ ESEQ(s, BINOP(op, e1, e2))</li>\n<li>MEM(ESEQ(s, e1)) ⇒ ESEQ(s, MEM(e1))</li>\n<li>JUMP(ESEQ(s, e1)) ⇒ SEQ(s, JUMP(e1))</li>\n<li>CJUMP(op, ESEQ(s, e1), e2, l1, l2) ⇒ SEQ(s, CJUMP(op, e1, e2, l1, l2))</li>\n</ul>\n<h5 id=\"Commutativity（重点）\"><a href=\"#Commutativity（重点）\" class=\"headerlink\" title=\"Commutativity（重点）\"></a>Commutativity（重点）</h5><p>当<code>ESEQ</code>出现在<code>BINOP</code>的右操作数，即$BINOP(op, e1, ESEQ(s, e2))$时，我们不能再像之前那样简单地把<code>s</code>提升到整个<code>BINOP</code>之前，因为<code>e1</code>的求值在<code>e2</code>之前，否则可能影响<code>e1</code>的计算结果</p>\n<p>Commutativity：交换性</p>\n<ul>\n<li>Commuting: s不影响e1的结果<ul>\n<li>rule: $BINOP(op, e1, ESEQ(s, e2)) &#x3D; ESEQ(s, BINOP(op, e1, e2))$</li>\n</ul>\n</li>\n<li>Non-commuting: s会影响e1的结果，把e1的结果显算出来放到临时变量t里，再提升s<ul>\n<li>rule: $BINOP(op, ESEQ(s, e1), e2) &#x3D; ESEQ(MOVE(TEMP t, e1), ESEQ(s, BINOP(op, TEMP t, e2)))$</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"将CALL移到顶层\"><a href=\"#将CALL移到顶层\" class=\"headerlink\" title=\"将CALL移到顶层\"></a>将CALL移到顶层</h4><p>方法：立即将每一个返回值赋给一个新的临时寄存器<br>$$<br>CALL(fun, args) ⇒ ESEQ(MOVE(TEMP t, CALL(fun, args)), TEMP t)<br>$$</p>\n<h4 id=\"消除SEQ\"><a href=\"#消除SEQ\" class=\"headerlink\" title=\"消除SEQ\"></a>消除SEQ</h4><p>$$<br>SEQ(SEQ(a, b), c) &#x3D; SEQ(a, SEQ(b, c))<br>$$<br>把SEQ变成一个线性语句表：$SEQ(s_1, SEQ(s_2, …, SEQ(s_{n-1}, s_n) …))$<br>就可以认为是由语句组成的简单列表$s_1, s_2, …, s_n$</p>\n<h3 id=\"处理CJUMP\"><a href=\"#处理CJUMP\" class=\"headerlink\" title=\"处理CJUMP\"></a>处理CJUMP</h3><p>重排CJUMP，使得每个$CJUMP(op, e_1, e_2, l_t, l_f)后面都紧跟着$LABEL(l_f)$<br>分两步：1. 取一列canonical tree由它们形成basic block 2. 对basic block进行排序形成trace</p>\n<h4 id=\"Basic-Block\"><a href=\"#Basic-Block\" class=\"headerlink\" title=\"Basic Block\"></a>Basic Block</h4><p>一个基本块是一段连续的指令序列，即:</p>\n<ul>\n<li>第一个语句是一个<code>LABEL</code></li>\n<li>最后一个语句是<code>JUMP</code>或<code>CJUMP</code></li>\n<li>没有其他的<code>LABEL</code>, <code>JUMP</code>或<code>CJUMP</code><br>划分方法：</li>\n</ul>\n<ol>\n<li>每一个<code>LABEL</code>都对应一个基本块的开始</li>\n<li>每一个<code>JUMP</code>或<code>CJUMP</code>都对应一个基本块的结束</li>\n<li>如果遇到<code>LABEL1</code> -&gt; <code>LABEL2</code>,就在<code>LABEL2</code>前面加一个<code>JUMP</code>到<code>LABEL2</code></li>\n<li>如果遇到开头没有<code>LABEL</code>的，则加一个<code>LABEL</code>（比如程序的开头）</li>\n<li>出口处理：添加一个LABEL <code>done</code>表示出口处理的开始，并把$JUMP done$放最后一个block末尾</li>\n</ol>\n<h4 id=\"Trace\"><a href=\"#Trace\" class=\"headerlink\" title=\"Trace\"></a>Trace</h4><p>现在我们可以按任意顺序来安排这些基本块，并且程序执行的结果仍是相同的——因为无论怎么排序，每个基本块的末尾都能转移到一个正确的位置。我们可以利用这一点来选择适当的基本块排列顺序，以满足每个<code>CJUMP</code>之后都跟随它的false标号这一条件。<br>与此同时，我们也可以安排基本块使得无条件转移<code>JUMP</code>之后直接跟随的是它们的目标标号。这样便可以删除这些无条件转移，从而使编译生成的程序的执行速度更快。</p>\n<p>把basic block排成trace的方法也很简单：&#x3D;&#x3D;从每个基本块开始，追踪JUMP链，标记遇到的每一个未标记的基本快并添加到当前trace中，最终到达一个其后继都标记过的块，就是结束块。之后再选则一个未标记的基本块开始，重复上述过程。&#x3D;&#x3D;</p>\n<p>因为轨迹调度不可能覆盖所有情况，所以：</p>\n<ol>\n<li>如果CJUMP 后跟 true label: 条件取反，交换 true&#x2F;false，改成：<br>$$<br>CJUMP(!cond, lf, lt)<br>$$</li>\n<li>CJUMP 后跟的不是 true 也不是 false: 创建中间 label，插入 JUMP<br>$$<br>CJUMP(cond, lt, lf) &#x3D;&gt; CJUMP(cond, lt, l’f) LABEL l’f   JUMP NAME(lf)<br>$$</li>\n</ol>\n<h4 id=\"最优轨迹-Optimal-Trace\"><a href=\"#最优轨迹-Optimal-Trace\" class=\"headerlink\" title=\"最优轨迹(Optimal Trace)\"></a>最优轨迹(Optimal Trace)</h4><p>对于basic block可能有不同的trace划分方法</p>\n<ul>\n<li>Hot Path Prioritization（优先热路径）: 优先将**运行频率高的基本块（hot blocks）**合并在同一条轨迹（trace）里，减少跳转，提高局部性。<br>+++info example<br>假设 if-else 中 if 分支占 90% 执行概率，else 只有 10%：</li>\n</ul>\n<figure class=\"highlight c\"><figcaption><span>tiger</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> x &gt; <span class=\"number\">0</span> then</span><br><span class=\"line\">    a := a + <span class=\"number\">1</span>   -- 热路径</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    a := a - <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>生成时应把 x &gt; 0 为真的路径（包括 CJUMP 的 false 分支）安排成 fall-through，避免跳转开销出现在热路径上。<br>+++</p>\n<ul>\n<li>Locality Enhancement（增强局部性）: 把逻辑上相关联的代码块放得更近一些，让它们在内存中“邻近”。<ul>\n<li>原因：<ul>\n<li>更好地利用 CPU cache、预取机制。</li>\n<li>避免指令 cache miss 导致性能下降。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>比如：将循环体和循环条件代码块排在一起（而不是让条件跳到远处），从而保持指令流顺序性。</p>\n<ul>\n<li>Jump Minimization（最小化跳转）: 尽量减少无条件跳转（JUMP）和不必要的条件跳转（CJUMP），尤其在常走路径上，\t减少分支预测失败。</li>\n</ul>\n<p><img data-src=\"/f1.jpg\"><br>哪个划分比较好？<br>根据3，c比a好；</p>\n",
            "tags": [
                "Basic Blocks and Traces"
            ]
        },
        {
            "id": "http://example.com/2025/06/17/computer-science/compile-principles/ch9/",
            "url": "http://example.com/2025/06/17/computer-science/compile-principles/ch9/",
            "title": "指令选择",
            "date_published": "2025-06-16T16:00:00.000Z",
            "content_html": "<h1 id=\"指令选择\"><a href=\"#指令选择\" class=\"headerlink\" title=\"指令选择\"></a>指令选择</h1><p>找出实现一个给定的IR Tree的恰当机器指令序列。Mapping IR into abstract assembly code</p>\n<ul>\n<li>Abstract assembly &#x3D; assembly with infinite registers<ul>\n<li>Invent new temporaries for intermediate results</li>\n<li>Map to actual registers later<br>Tree pattern, 也叫tile<br>本质上是pattern matching, 我们使用tree covering 来实现</li>\n</ul>\n</li>\n</ul>\n<p>我们<code>Jouette</code>体系将树模式映射为指令:</p>\n<ul>\n<li>寄存器中可以存储数据或地址，每条指令可以访问任意寄存器</li>\n<li>寄存器r0的值永远是0</li>\n<li>每条指令的latency都是一周期（除了MOVEM的周期是m）</li>\n<li>每个周期执行一条指令</li>\n</ul>\n<p><img data-src=\"/f2.jpg\"><br><img data-src=\"/f1.jpg\"><br>将IR与后端的机器指令都转换为树结构。这样就把指令选择问题转换为机器指令树覆盖全IR Tree的问题。<br>一棵树可以有多种tiling方式</p>\n<h2 id=\"Optimal-Tiling-Optimum-Tiling\"><a href=\"#Optimal-Tiling-Optimum-Tiling\" class=\"headerlink\" title=\"Optimal Tiling &amp; Optimum Tiling\"></a>Optimal Tiling &amp; Optimum Tiling</h2><ul>\n<li>Optimum Tiling：使得tiling数最少，是&#x3D;&#x3D;全局最优&#x3D;&#x3D;</li>\n<li>Optimal Tiling：No two adjacent tiles can be combined into a single tile of lower cost，是&#x3D;&#x3D;局部最优&#x3D;&#x3D;<br>一个optimum tiling必定是optimal tiling<br><img data-src=\"/f3.jpg\"></li>\n</ul>\n<h2 id=\"Algorithms-for-Instruction-Selection\"><a href=\"#Algorithms-for-Instruction-Selection\" class=\"headerlink\" title=\"Algorithms for Instruction Selection\"></a>Algorithms for Instruction Selection</h2><h3 id=\"Maximal-Munch-Find-an-optimal-tiling\"><a href=\"#Maximal-Munch-Find-an-optimal-tiling\" class=\"headerlink\" title=\"Maximal Munch: Find an optimal tiling\"></a>Maximal Munch: Find an optimal tiling</h3><p>最大匹配：贪心算法、自顶向下<br>方法：从IR树的根节点开始，用&#x3D;&#x3D;最大的&#x3D;&#x3D;tile覆盖当前节点（包含最多节点的），然后在子树中重复此过程</p>\n<h3 id=\"DP\"><a href=\"#DP\" class=\"headerlink\" title=\"DP\"></a>DP</h3><p>动态规划：自底向上<br>方法：</p>\n<ol>\n<li>递归计算每个子树的最优平铺成本</li>\n<li>对于每个节点，考虑所有可能的匹配平铺</li>\n<li>对于每个匹配平铺，计算其成本如下：cost &#x3D; tile_cost + sum（costs_of_children）</li>\n<li>选择成本最低的平铺</li>\n</ol>\n<ul>\n<li>对于$CONST i$，它的代价为1( ADD r1, r0, i)</li>\n<li>对于这棵树，有三种匹配方法<br><img data-src=\"/f4.jpg\"><br><img data-src=\"/f5.jpg\"><br>因为2&lt;3，所以我们从cost&#x3D;2的两个任选一个<br>接下来对于MEM，用的都是LOAD，代价都是1，2&lt;3所以选cost&#x3D;2的</li>\n</ul>\n<figure class=\"highlight c\"><figcaption><span>指令发射</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function <span class=\"title function_\">Emission</span><span class=\"params\">(node n)</span>:</span><br><span class=\"line\">    For each leaf l_i of the tile selected at node n:</span><br><span class=\"line\">        <span class=\"title function_\">Emission</span><span class=\"params\">(l_i)</span> </span><br><span class=\"line\">    Emit the instruction matched at node n</span><br></pre></td></tr></table></figure>\n<h3 id=\"最大匹配-vs-动态规划\"><a href=\"#最大匹配-vs-动态规划\" class=\"headerlink\" title=\"最大匹配 vs 动态规划\"></a>最大匹配 vs 动态规划</h3><ul>\n<li><strong>T</strong> - tile的总种类数  </li>\n<li><strong>K</strong> - 一个matching tile平均覆盖的节点数  </li>\n<li><strong>K’</strong> - 需要检查的最大tile尺寸（即最大的瓦片包含的节点数）  </li>\n<li><strong>T’</strong> - 每个树节点平均能匹配上的tile数量  </li>\n<li><strong>N</strong> - 输入的中间表示IR Tree中的总节点数</li>\n</ul>\n<p>两种算法的运行时间复杂度：</p>\n<ul>\n<li><p><strong>最大匹配（Maximal Munch）</strong> - 其时间复杂度与<br>$$<br>\\frac{(K’ + T’) * K}{K} * N &#x3D; (K’ + T’) * N<br>$$<br>成正比</p>\n</li>\n<li><p><strong>动态规划（Dynamic Programming）</strong> - 其时间复杂度与<br>$$<br>(K’ + T’) * N<br>$$<br>成正比</p>\n</li>\n</ul>\n<h2 id=\"Tree-Grammar-树文法\"><a href=\"#Tree-Grammar-树文法\" class=\"headerlink\" title=\"Tree Grammar 树文法\"></a>Tree Grammar 树文法</h2><p>问题：对于具有复杂指令集和多种寄存器类型及寻址模式的机器，难以使用简单的tree pattern和tiling算法。<br>用一种文法来描述tiles，代替手写过程式匹配代码，支持自动化的指令选择，增强了可移植性<br>图没看懂，后面再回来研究</p>\n",
            "tags": [
                "指令选择"
            ]
        },
        {
            "id": "http://example.com/2025/06/16/AI/week10-11/",
            "url": "http://example.com/2025/06/16/AI/week10-11/",
            "title": "Week10-11",
            "date_published": "2025-06-15T16:00:00.000Z",
            "content_html": "<h1 id=\"深度学习\"><a href=\"#深度学习\" class=\"headerlink\" title=\"深度学习\"></a>深度学习</h1><h2 id=\"前馈神经网络\"><a href=\"#前馈神经网络\" class=\"headerlink\" title=\"前馈神经网络\"></a>前馈神经网络</h2><ul>\n<li>神经元</li>\n<li>感知机（多一个激活函数）</li>\n<li>激活函数: .RelU, Sigmoid, Softmax, tanh..</li>\n<li>损失函数: MSE, Cross Entropy…s</li>\n<li>参数优化: BP, 梯度下降<br>具体懒得写了，都说烂了<br>记一下这几个激活函数的形状和应用: tanh和sigmoid大多用于二分类，RelU一般用在隐藏层，Softmax用在多分类而且概率和为1</li>\n</ul>\n<h2 id=\"CNN\"><a href=\"#CNN\" class=\"headerlink\" title=\"CNN\"></a>CNN</h2><ul>\n<li><p>了解卷积操作和操作之后的结果</p>\n</li>\n<li><p>池化操作（最大池化、平均池化）<br>卷积层负责提取图像中的局部特征；<br>池化层用来大幅降低参数量级(降维)；<br>激活函数负责非线性化；<br>全连接层类似传统神经网络的部分，用来输出想要的结果</p>\n</li>\n<li><p>神经网络正则化：为了缓解神经网络在训练过程中出现的过拟合问题，需要采取一些正则化技术来提升神经网络的泛化能力(generalization)</p>\n<ul>\n<li>Dropout：在训练神经网络过程中，每次参数更新时随机丢掉一部分神经元来减少神经网络复杂度，防止过拟合<br> <img data-src=\"/f1.jpg\"></li>\n<li>Batch-Normalization（批归一化）:通过规范化的手段，把神经网络每层中任意神经元的输入值分布改变到均值为0、方差为1的标准正态分布。防止梯度消失，收敛更快</li>\n<li>L1-Norm &amp; L2-Norm</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"循环神经网络（RNN）\"><a href=\"#循环神经网络（RNN）\" class=\"headerlink\" title=\"循环神经网络（RNN）\"></a>循环神经网络（RNN）</h2><p>RNN对具有序列特性的数据非常有效，它能挖掘数据中的时序信息以及语义信息</p>\n<p>为了解决&#x3D;&#x3D;梯度消失问题&#x3D;&#x3D;，长短时记忆模型（Long Short-Term Memory，LSTM）被提出<br>LSTM：<br>与简单的循环神经网络结构不同，长短时记忆网络（Long Short-Term Memory，LSTM）中引入了&#x3D;&#x3D;内部记忆单元&#x3D;&#x3D;（internal memory cell）和&#x3D;&#x3D;门&#x3D;&#x3D;（gates）两种结构来对当前时刻输入信息以及前序时刻所生成信息进行整合和传递。</p>\n<ul>\n<li>输入门(input gate)、遗忘门(forget gate)和输出门(output gate)三种gate</li>\n</ul>\n<p>门控循环单元（GRU）是一种对LSTM简化的深度学习模型。与长短时记忆网络相比，GRU不再使用记忆单元来传递信息，仅使用隐藏状态来进行信息的传递。相比于长短时记忆网络来说，GRU有更高的计算速度。</p>\n<h3 id=\"注意力机制\"><a href=\"#注意力机制\" class=\"headerlink\" title=\"注意力机制\"></a>注意力机制</h3><p>注意力机制对不同信息的关注程度（重要程度）由权值来体现，注意力机制可以视为&#x3D;&#x3D;查询矩阵(Query)&#x3D;&#x3D;&#x3D;&#x3D;、键(key)&#x3D;&#x3D;以及&#x3D;&#x3D;加权平均值&#x3D;&#x3D;构成了多层感知机(Multilayer Perceptron, MLP)</p>\n<h2 id=\"深度生成学习（deep-generative-learning-model）\"><a href=\"#深度生成学习（deep-generative-learning-model）\" class=\"headerlink\" title=\"深度生成学习（deep generative learning model）\"></a>深度生成学习（deep generative learning model）</h2><p>判别模型vs生成模型<br>变分自编码器 (variational auto-encoder, VAE) 、 自回归模型 (Autoregressivemodels)与生成对抗网络（generative adversarial network，GAN）等</p>\n",
            "tags": [
                "人工智能"
            ]
        },
        {
            "id": "http://example.com/2025/06/16/AI/week14-15/",
            "url": "http://example.com/2025/06/16/AI/week14-15/",
            "title": "Week14-15",
            "date_published": "2025-06-15T16:00:00.000Z",
            "content_html": "<h1 id=\"人工智能博弈\"><a href=\"#人工智能博弈\" class=\"headerlink\" title=\"人工智能博弈\"></a>人工智能博弈</h1><h2 id=\"博弈论\"><a href=\"#博弈论\" class=\"headerlink\" title=\"博弈论\"></a>博弈论</h2><p>博弈的要素：</p>\n<ul>\n<li>player</li>\n<li>strategy</li>\n<li>payoff</li>\n<li>rule</li>\n</ul>\n<h2 id=\"博弈策略求解\"><a href=\"#博弈策略求解\" class=\"headerlink\" title=\"博弈策略求解\"></a>博弈策略求解</h2><h3 id=\"遗憾最小化算法（Regret-Minimization）\"><a href=\"#遗憾最小化算法（Regret-Minimization）\" class=\"headerlink\" title=\"遗憾最小化算法（Regret Minimization）\"></a>遗憾最小化算法（Regret Minimization）</h3><p>下一步选择策略$\\Sigma_i$的概率P:<br>$$<br>P(\\sigma_i^{T+1}) &#x3D; \\begin{cases}<br>\\frac{\\text{Regret}<em>i^{T,+}(\\sigma_i)}{\\sum</em>{\\sigma_i’ \\in \\Sigma_i} \\text{Regret}<em>i^{T,+}(\\sigma_i’)} &amp; \\text{if } \\sum</em>{\\sigma_i’ \\in \\Sigma_i} \\text{Regret}_i^{T,+}(\\sigma_i’) &gt; 0 \\<br>\\frac{1}{|\\Sigma_i|} &amp; \\text{otherwise}<br>\\end{cases}<br>$$<br>为什么不直接选遗憾最大的：防止对手发现自己所采取的策略<br>+++info 例子</p>\n<ul>\n<li>假设两个玩家A和B进行石头-剪刀-布（Rock-Paper-Scissors, RPS）的游戏，获胜玩家收益为1分，失败玩家收益为-1分，平局则两个玩家收益均为零分。</li>\n<li>第一局时，若玩家A出石头（R），玩家B出布（P），则此时玩家A的收益 $\\mu_A(R, P) &#x3D; -1$，玩家B的收益为 $\\mu_B(P, R) &#x3D; 1$。</li>\n<li>对于玩家A来说，在玩家B出布（P）这个策略情况下，如果玩家A选择出布（P）或者剪刀（S），则玩家A对应的收益值 $\\mu_A(P, P) &#x3D; 0$ 或者 $\\mu_A(S, P) &#x3D; 1$。</li>\n<li>所以第一局之后，玩家A没有出布的遗憾值为 $\\mu_A(P, P) - \\mu_A(R, P) &#x3D; 0 - (-1) &#x3D; 1$，没有出剪刀的遗憾值为 $\\mu_A(S, P) - \\mu_A(R, P) &#x3D; 1 - (-1) &#x3D; 2$。</li>\n<li>所以在第二局中，玩家A选择石头、剪刀和布这三个策略的概率分别为 0、$\\frac{2}{3}$、$\\frac{1}{3}$。因此，玩家A趋向于在第二局中选择出剪刀这个策略。</li>\n<li>第二局中，玩家A选择剪刀和玩家B选择石头情况下，第二轮石头、剪刀、布的Regret分别为1，0，2，把前两轮的regret加起来计算概率，得到出石头、剪刀、布的概率分别为$\\frac{1}{6}$、$\\frac{2}{6}$、$\\frac{3}{6}$。<br>+++</li>\n</ul>\n<h3 id=\"双边匹配算法\"><a href=\"#双边匹配算法\" class=\"headerlink\" title=\"双边匹配算法\"></a>双边匹配算法</h3><p><img data-src=\"/f2.jpg\"><br>在第一轮中，4名男性分别向自己最喜欢的女性表白，而收到3人表白的女性A选择了自己最喜欢的男性3，另一个收到表白的女性B选择了男性4；在第二轮中，尚未匹配的男性1和男性2继续向自己第二喜欢的对象表白，收到表白的女性B选择了自己更喜欢的男性2而放弃了男性4；同理，继续三轮表白和选择，所有人都找到了自己的伴侣，且所有匹配都是稳定的。可以看出，使用G-S算法得到了稳定匹配的结果。</p>\n<h3 id=\"单边匹配算法-最大交易圈\"><a href=\"#单边匹配算法-最大交易圈\" class=\"headerlink\" title=\"单边匹配算法-最大交易圈\"></a>单边匹配算法-最大交易圈</h3><p><img data-src=\"/f3.jpg\"></p>\n<ol>\n<li>每个人指向最喜欢的物，每个物指向占有它的人</li>\n<li>如果有圈，就把打成交易的人和物和相关边都删掉</li>\n<li>继续<br><img data-src=\"/f4.jpg\"></li>\n</ol>\n",
            "tags": [
                "人工智能"
            ]
        },
        {
            "id": "http://example.com/2025/06/16/AI/week12-13/",
            "url": "http://example.com/2025/06/16/AI/week12-13/",
            "title": "Week12-13",
            "date_published": "2025-06-15T16:00:00.000Z",
            "content_html": "<h1 id=\"强化学习\"><a href=\"#强化学习\" class=\"headerlink\" title=\"强化学习\"></a>强化学习</h1><p>根据环境所提供的奖罚反馈来学习所处状态可施加的最佳行动，在“探索（未知空间）-利用（已有经验）（exploration vs. exploitation）”之间寻找平衡，完成某个序列化任务，具备自我学习能力</p>\n<ul>\n<li>智能体（agent）：智能体是强化学习算法的主体，它能够根据经验做出主观判断并执行动作，是整个智能系统的核心。</li>\n<li>环境（environment）：智能体以外的一切统称为环境，环境在与智能体的交互中，能被智能体所采取的动作影响，同时环境也能向智能体反馈状态和奖励。虽说智能体以外的一切都可视为环境，但在设计算法时常常会排除不相关的因素建立一个理想的环境模型来对算法功能进行模拟。</li>\n<li>状态（state）：状态可以理解为智能体对环境的一种理解和编码，通常包含了对智能体所采取决策产生影响的信息。</li>\n<li>动作（action）：动作是智能体对环境产生影响的方式，这里说的动作常常指概念上的动作，如果是在设计机器人时还需考虑动作的执行机构。</li>\n<li>策略（policy）：策略是智能体在所处状态下去执行某个动作的依据，即给定一个状态，智能体可根据一个策略来选择应该采取的动作。</li>\n<li>奖励（reward）：奖励是智能体序贯式采取一系列动作后从环境获得的收益。注意奖励概念是现实中奖励和惩罚的统合，一般用正值来代表实际奖励，用负值来代表实际惩罚。<br><img data-src=\"/f1.jpg\"></li>\n</ul>\n<p>强化学习的特点</p>\n<ul>\n<li>&#x3D;&#x3D;基于评估&#x3D;&#x3D;：强化学习利用环境评估当前策略，以此为依据进行优化</li>\n<li>&#x3D;&#x3D;交互性&#x3D;&#x3D;：强化学习的数据在与环境的交互中产生</li>\n<li>&#x3D;&#x3D;序列决策过程&#x3D;&#x3D;：智能主体在与环境的交互中需要作出一系列的决策，这些决策往往是前后关联的</li>\n</ul>\n<h2 id=\"离散马尔可夫过程（Discrete-Markov-Process）\"><a href=\"#离散马尔可夫过程（Discrete-Markov-Process）\" class=\"headerlink\" title=\"离散马尔可夫过程（Discrete Markov Process）\"></a>离散马尔可夫过程（Discrete Markov Process）</h2><p>满足马尔可夫性的离散随机过程<br>用数学归纳法，推出t+1时刻状态仅与t时刻状态有关（一阶马尔可夫链）<br>强化学习是一种机器学习方法，通过与环境的交互来学习最优策略。下面我将通过具体的例子来解释这些公式和概念。</p>\n<h3 id=\"马尔可夫奖励过程\"><a href=\"#马尔可夫奖励过程\" class=\"headerlink\" title=\"马尔可夫奖励过程\"></a>马尔可夫奖励过程</h3><p>$$<br>G_t &#x3D; R_{t+1} + \\gamma R_{t+2} + \\gamma^2 R_{t+3} + \\ldots<br>$$<br>这个公式表示从时间步 t开始的累积回报 $G_t$，其中 $R_{t+i}$ 是在时间步 $t+i$ 获得的即时奖励，$\\gamma$ 是折扣因子（范围在 [0, 1] 之间），用于减少未来奖励对当前决策的影响。</p>\n<p>例: 假在一个迷宫中寻找宝藏，每走一步都有可能获得或失去一些分数（奖励）。如果你在第 1 步获得 10 分，在第 2 步获得 5 分，在第 3 步获得 2 分，且折扣因子 $\\gamma &#x3D; 0.9$，那么从第 0 步开始的累积回报 $G_0$ 就是：<br>$$<br>G_0 &#x3D; 10 + 0.9 \\times 5 + 0.9^2 \\times 2 &#x3D; 10 + 4.5 + 1.62 &#x3D; 16.12<br>$$</p>\n<p>强化学习的求解方法：</p>\n<ul>\n<li>基于价值（1.策略优化 2.策略评估）</li>\n<li>基于策略</li>\n<li>基于模型</li>\n</ul>\n<h3 id=\"策略学习\"><a href=\"#策略学习\" class=\"headerlink\" title=\"策略学习\"></a>策略学习</h3><p>价值函数 (value function):<br>$$<br>V_\\pi(s) &#x3D; E_\\pi[G_t | S_t &#x3D; s]<br>$$</p>\n<p>在状态 s 下，按照策略 $\\pi$ 行动后在未来所获得的回报的期望值。</p>\n<p>动作-价值函数 (action-value function):<br>$$<br>q_\\pi(s, a) &#x3D; E_\\pi[G_t | S_t &#x3D; s, A_t &#x3D; a]<br>$$</p>\n<p>在状态 s 下采取动作 a，按照策略 $\\pi 行动后在未来获得的回报值。</p>\n<p>例: 继续迷宫的例子，假设在某个位置（状态 s有两个选择：向左走（动作 $a_1$ 或向右走（动作 $a_2$）。根据历史数据，向左走的平均回报是 8 分，向右走的平均回报是 12 分。那么在这个状态下，动作-价值函数 $q_\\pi(s, a_1) &#x3D; 8$，$q_\\pi(s, a_2) &#x3D; 12$。</p>\n<h3 id=\"贝尔曼方程\"><a href=\"#贝尔曼方程\" class=\"headerlink\" title=\"贝尔曼方程\"></a>贝尔曼方程</h3><p>价值函数的贝尔曼方程:<br>$$<br>V_\\pi(s) &#x3D; \\sum_a \\pi(s, a) q_\\pi(s, a)<br>$$<br>在状态 s 下，采取各个动作的概率加权平均的动作-价值函数。</p>\n<p>动作-价值函数的贝尔曼方程:<br>$$<br>q_\\pi(s, a) &#x3D; \\sum_{s’} P(s’ | s, a) [R(s, a, s’) + \\gamma V_\\pi(s’)]<br>$$<br>在状态s采取动作a的概率*（采取a进入s’得到的回报+处于s’可以得到的回报）。</p>\n<h3 id=\"策略评估算法步骤\"><a href=\"#策略评估算法步骤\" class=\"headerlink\" title=\"策略评估算法步骤\"></a>策略评估算法步骤</h3><h4 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h4><ol>\n<li>初始化 $V_\\pi$ 函数：首先需要对所有状态 s 的价值函数 $V_\\pi(s)$ 进行初始化，通常可以设置为0或者任意合理的初始值。</li>\n<li>循环迭代：<ul>\n<li>对于每一个状态 $s \\in S$，根据当前的策略 $\\pi$ 和已知的状态转移概率 $Pr(s’|s, a)$，以及即时奖励 $R(s, a, s’)$，更新该状态的价值函数 $V_\\pi(s)$。</li>\n<li>更新公式如下：<br>$$<br>V_\\pi(s) \\leftarrow \\sum_{a \\in A} \\pi(a|s) \\sum_{s’ \\in S} Pr(s’|s, a) [R(s, a, s’) + \\gamma V_\\pi(s’)]<br>$$</li>\n</ul>\n</li>\n<li>直到收敛：重复上述迭代过程，直到价值函数 $V_\\pi(s)$ 在所有状态上都几乎不再发生变化，即达到收敛状态。这表明我们已经找到了在当前策略 $\\pi$ 下各个状态的稳定价值。<br>&#x3D;&#x3D;当前状态的价值是由后续状态的价值通过贝尔曼方程传播回来的&#x3D;&#x3D;</li>\n</ol>\n<p>策略评估：动态规划、蒙特卡洛采样、时序差分</p>\n<h4 id=\"蒙特卡洛采样\"><a href=\"#蒙特卡洛采样\" class=\"headerlink\" title=\"蒙特卡洛采样\"></a>蒙特卡洛采样</h4><p>通过随机采样来估计期望值</p>\n<ol>\n<li>选择起始状态：从状态空间 S 中选择不同的起始状态。</li>\n<li>按照当前策略采样轨迹：从每个起始状态出发，按照当前策略 $\\pi$ 生成若干条完整的轨迹（episode）。这些轨迹构成了集合 D。</li>\n<li>计算反馈：对于每条轨迹中的每个状态 s，记录该状态出现时对应的回报 $G_i$ 。</li>\n<li>平均回报：对所有轨迹中状态 s 出现时的回报进行平均，得到该状态的价值 $V_\\pi(s)$。<br>假设我们有 k 条轨迹，每条轨迹中状态 s 出现时对应的回报分别为$G_1, G_2, \\ldots, G_k$，那么该状态的价值 $V_\\pi(s)$ 可以通过以下公式计算：<br>$$<br>V_\\pi(s) &#x3D; \\frac{1}{k} \\sum_{i&#x3D;1}^k G_i<br>$$</li>\n</ol>\n<h4 id=\"时序差分-TD\"><a href=\"#时序差分-TD\" class=\"headerlink\" title=\"时序差分(TD)\"></a>时序差分(TD)</h4><p>时序差分算法通过在每个时间步 t 上更新状态价值函数 $V_\\pi(s_t)$，而不是在每个状态 $s_t$ 上进行批量更新。<br>$$<br>V_\\pi(s) \\leftarrow V_\\pi(s) + \\alpha [R(s, a, s’) + \\gamma V_\\pi(s’) - V_\\pi(s)]<br>$$<br>其中：</p>\n<ul>\n<li>$\\alpha$ 是学习率，通常取较小的值，如0.1。</li>\n<li>$R(s, a, s’)$ 是即时奖励</li>\n<li>$V_\\pi(s’)$ 是状态 $s’$ 的价值函数</li>\n<li>$\\gamma$ 是折扣因子，通常取较小的值，如0.9。</li>\n</ul>\n<h4 id=\"Q-learning\"><a href=\"#Q-learning\" class=\"headerlink\" title=\"Q-learning\"></a>Q-learning</h4><h4 id=\"DQN\"><a href=\"#DQN\" class=\"headerlink\" title=\"DQN\"></a>DQN</h4>",
            "tags": [
                "人工智能"
            ]
        },
        {
            "id": "http://example.com/2025/06/16/computer-science/compile-principles/ch7/",
            "url": "http://example.com/2025/06/16/computer-science/compile-principles/ch7/",
            "title": "IR",
            "date_published": "2025-06-15T16:00:00.000Z",
            "content_html": "<h1 id=\"IR\"><a href=\"#IR\" class=\"headerlink\" title=\"IR\"></a>IR</h1><p>Intermediate Representation<br>解决高级语言和目标机器汇编语言之间的转化<br>为什么需要IR:</p>\n<ul>\n<li>更模块化、可迁移</li>\n<li>分层分析和优化<br>IR可以有好多层：IR1-&gt;IR2-&gt;…-&gt;IRn<br>+++info 编译流程划分<br>前端：源代码-&gt;词法分析-&gt;语法分析-&gt;语义分析（IR之前的都是）<br>中端：基于IR的分析与变换（可能生成新IR，可以做一些机器无关优化比如循环展开等）<br>后端：指令选择-&gt;寄存器分配-&gt;指令调度-&gt;机器码（IR之后的）<br>+++</li>\n</ul>\n<h2 id=\"Three-Address-Code\"><a href=\"#Three-Address-Code\" class=\"headerlink\" title=\"Three-Address Code\"></a>Three-Address Code</h2><p>最多有三个操作数<br>x &#x3D; y op z<br>“地址”可以具有如下形式</p>\n<ul>\n<li>源程序中的名字(name)</li>\n<li>常量 (constant)</li>\n<li>临时变量(temporary)<br><img data-src=\"/f1.jpg\"><br>最常见的实现方法是将三地址代码作为四元组实现<br>+++info example<br>t1&#x3D;x&gt;0                  (gt, x, 0, t1)<br>if_false t1 goto L1     (if_f, t1, L1, _)<br>fact&#x3D;1                  (asn, 1, fact, _)<br>label L2                (lab, L2, _, _)<br>+++</li>\n</ul>\n<h2 id=\"IR-Tree\"><a href=\"#IR-Tree\" class=\"headerlink\" title=\"IR Tree\"></a>IR Tree</h2><p>两大类节点：</p>\n<ol>\n<li>表达式Exp</li>\n<li>语句Stmt<br>文法：<br><img data-src=\"/f2.jpg\"><br>表达式：<table>\n<thead>\n<tr>\n<th>Node</th>\n<th>Description</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CONST(i)</td>\n<td>整数常量i</td>\n<td>CONST(42) → the value 42</td>\n</tr>\n<tr>\n<td>NAME(n)</td>\n<td>符号常量n，通常是一个label，值是label的地址</td>\n<td>NAME(L1) → address of label L1</td>\n</tr>\n<tr>\n<td>TEMP(t)</td>\n<td>临时变量t (like register)</td>\n<td>TEMP(t123) → contents of temporary t123</td>\n</tr>\n<tr>\n<td>BINOP(o,e1,e2)</td>\n<td>对e1和e2执行二元操作o</td>\n<td>BINOP(PLUS,TEMP(t1),CONST(1)) → t1+1</td>\n</tr>\n<tr>\n<td>MEM(e)</td>\n<td>Memory access</td>\n<td>MEM(CONST(100)) → contents at address 100</td>\n</tr>\n<tr>\n<td>CALL(f,l)</td>\n<td>Function call, l是参数列表</td>\n<td>CALL(NAME(print),[TEMP(t1)]) → call print(t1)</td>\n</tr>\n<tr>\n<td>ESEQ(s,e)</td>\n<td>先执行语句s，再求值表达式e并返回e的结果</td>\n<td>ESEQ(MOVE(TEMP(t),CONST(1)),TEMP(t)) → (t&#x3D;1; t)</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<p>语句：</p>\n<table>\n<thead>\n<tr>\n<th>Node</th>\n<th>Description</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>MOVE(TEMP t, e)</td>\n<td>将表达式e的值赋给临时变量t</td>\n<td>MOVE(TEMP(t1), CONST(42)) → t1 &#x3D; 42</td>\n</tr>\n<tr>\n<td>MOVE(MEM(e1), e2)</td>\n<td>将表达式e2的值存储到由e1指定的内存地址中</td>\n<td>MOVE(MEM(TEMP(t1)), CONST(42)) → *t1 &#x3D; 42</td>\n</tr>\n<tr>\n<td>EXP(e)</td>\n<td>计算表达式e的值但不返回结果，通常用于有副作用的操作（如函数调用）</td>\n<td>EXP(CALL(NAME(print), …)) → 调用print()函数以产生效果</td>\n</tr>\n<tr>\n<td>JUMP(e, labs)</td>\n<td>无条件跳转到由e指定的地址</td>\n<td>JUMP(NAME(L1), [L1]) → goto L1</td>\n</tr>\n<tr>\n<td>CJUMP(o,e1,e2,t,f)</td>\n<td>条件跳转，根据操作o对e1和e2的结果决定跳转到t或f</td>\n<td>CJUMP(LT, TEMP(t1), CONST(0), L1, L2) → 如果t1 &lt; 0则跳转到L1，否则跳转到L2</td>\n</tr>\n<tr>\n<td>SEQ(s1, s2)</td>\n<td>语句序列，先执行s1再执行s2</td>\n<td>SEQ(MOVE(…), JUMP(…)) → 先赋值再跳转</td>\n</tr>\n<tr>\n<td>LABEL(n)</td>\n<td>定义一个标签</td>\n<td>LABEL(L1) → L1:</td>\n</tr>\n</tbody></table>\n<p>例子：<br><img data-src=\"/f3.jpg\"><br>ADD那个地方写成BINOP的写法也可以</p>\n<h2 id=\"翻译AST成IR-Tree\"><a href=\"#翻译AST成IR-Tree\" class=\"headerlink\" title=\"翻译AST成IR Tree\"></a>翻译AST成IR Tree</h2><p>把AST表达式分为三类：</p>\n<ul>\n<li>Ex: 有结果的AST表达式比如a+b</li>\n<li>Nx：无结果的语句的比如print</li>\n<li>Cx：条件语句，值为bool的AST表达式</li>\n</ul>\n<h3 id=\"translate-Exp\"><a href=\"#translate-Exp\" class=\"headerlink\" title=\"translate Exp\"></a>translate Exp</h3><ol>\n<li>翻译简单变量：<br>在函数中访问一个局部变量实际上是访问它在当前栈帧中的位置，所以访问一个距离fp的offset为k的局部变量v，其IR Tree表示为:<br>$$<br>MEM(BINOP(PLUS, TEMP fp, CONST k))<br>$$<br><img data-src=\"/f4.jpg\"><br>如果通过static link访问一个变量，就要嵌套好几层MEM和BINOP<br>比如这个访问嵌套两层外面的x<br>最内层使用 CONST(8)：是因为需要从 inner 函数的帧指针 FP 开始，偏移 8 字节来访问静态链，该静态链指向 middle 函数的帧。<br>中间层和最外层使用 CONST(0)：是因为它们分别通过静态链直接访问 outer 函数的帧和变量 x，不需要额外的偏移<br><img data-src=\"/f5.jpg\"><br>:::danger<br>这个地方为什么内层是8中层是0存疑<br>:::</li>\n</ol>\n<p>左值和右值：&#x3D;左右的<br>MEM(addr)可以是左值也可以是右值</p>\n<ul>\n<li>Scalar L-value(Tiger): 一个地址</li>\n<li>Structured L-value(Pascal&#x2F;C): 一块内存</li>\n</ul>\n<ol start=\"2\">\n<li>翻译算术运算</li>\n</ol>\n<ul>\n<li>二元: BINOP(op, e1, e2)</li>\n<li>一元: <ul>\n<li>-x &#x3D;&#x3D;&gt; BINOP(MINUS, CONST(0), e_x)</li>\n<li>~x &#x3D;&#x3D;&gt; BINOP(XOR, e_x, CONST(-1))</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li>数组访问<br>$$<br>MEM(BINOP(PLUS, MEM(e_a), BINOP(MUL, e_i, CONST(W))))<br>$$</li>\n</ol>\n<ul>\n<li><code>e_a</code> 是表示变量 <code>a</code> 的表达式，通常是&#x3D;&#x3D; <code>MEM(+(TEMP(fp), CONST(k_a)))</code>&#x3D;&#x3D;</li>\n<li><code>MEM(e_a)</code>：&#x3D;&#x3D;获取存储在变量 <code>a</code> 中的值，即数组基地址&#x3D;&#x3D;</li>\n<li><code>e_i</code> 是计算索引 <code>i</code> 的表达式</li>\n<li><code>BINOP(MUL, e_i, CONST(W))</code>：计算偏移<br><img data-src=\"/f6.jpg\"></li>\n</ul>\n<p>记录字段r.f访问:<br>$$<br>MEM(BINOP(PLUS, MEM(e_r), BINOP(MUL, n, CONST(W))))<br>$$</p>\n<ol start=\"4\">\n<li>翻译控制流<br>对于if e1 op e2 then stmt1 else stmt2翻译成</li>\n</ol>\n<figure class=\"highlight c\"><figcaption><span>IR</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 6个SEQ</span></span><br><span class=\"line\">SEQ(</span><br><span class=\"line\">    CJUMP(op, e1, e2, t, f),</span><br><span class=\"line\">    SEQ(</span><br><span class=\"line\">        LABEL(t),</span><br><span class=\"line\">        SEQ(</span><br><span class=\"line\">            stm1,</span><br><span class=\"line\">            SEQ(</span><br><span class=\"line\">                JUMP(NAME(end)),</span><br><span class=\"line\">                SEQ(</span><br><span class=\"line\">                    LABEL(f),</span><br><span class=\"line\">                    SEQ(stm2, LABEL(end))</span><br><span class=\"line\">                )</span><br><span class=\"line\">            )</span><br><span class=\"line\">        )</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>Tiger的逻辑运算符&amp;(and)和|(or)需要实现短路求值：只计算必要的操作数<br>每个Cx是一个Label</p>\n<ul>\n<li>逻辑与 (a &amp; b)的短路规则：<ul>\n<li>计算a<br>  -若a为假，直接得到假结果（不计算b）<br>  -若a为真，继续计算b，最终结果即为b的值</li>\n</ul>\n</li>\n<li>逻辑或 (a | b)的短路规则：<br>  -计算a<br>  -若a为真，直接得到真结果（不计算b）<ul>\n<li>若a为假，继续计算b，最终结果即为b的值</li>\n</ul>\n</li>\n</ul>\n<ol start=\"5\">\n<li>循环语句</li>\n</ol>\n<figure class=\"highlight c\"><figcaption><span>tiger</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> a &gt; <span class=\"number\">0</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">a := a - <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>翻译成</p>\n<figure class=\"highlight c\"><figcaption><span>IR</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SEQ(LABEL test, </span><br><span class=\"line\">    SEQ(CJUMP(GT, TEMP a, CONST <span class=\"number\">0</span>, body, done), </span><br><span class=\"line\">        SEQ(LABEL body, </span><br><span class=\"line\">            SEQ(MOVE(TEMP a, BINOP(MINUS, TEMP a, CONST <span class=\"number\">1</span>)), </span><br><span class=\"line\">                SEQ(JUMP(NAME(test), [test]), </span><br><span class=\"line\">                    LABEL done)))))</span><br></pre></td></tr></table></figure>\n<p>break翻译为直接跳转到done<br>for循环我懒得写了，也是一个道理<br>和汇编差不多意思</p>\n<ol start=\"6\">\n<li>翻译函数<br>$$<br>CALL(NAME(l_f), [sl, a_1, …, a_n])<br>$$<br>sl是static link。</li>\n</ol>\n<h3 id=\"translate-Declaration\"><a href=\"#translate-Declaration\" class=\"headerlink\" title=\"translate Declaration\"></a>translate Declaration</h3><ul>\n<li>Variable declaration</li>\n<li>Type declaration</li>\n<li>Function declaration</li>\n</ul>\n<ol>\n<li>翻译变量声明</li>\n</ol>\n<figure class=\"highlight c\"><figcaption><span>tiger</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let</span><br><span class=\"line\">    var x := <span class=\"number\">10</span></span><br><span class=\"line\">    var y := x + <span class=\"number\">5</span></span><br><span class=\"line\">in </span><br><span class=\"line\">    x + y</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><figcaption><span>IR</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ESEQ( </span><br><span class=\"line\">    SEQ( </span><br><span class=\"line\">        MOVE(MEM(+(FP, CONST(x_offset))), CONST(<span class=\"number\">10</span>)), </span><br><span class=\"line\">        MOVE(MEM(+(FP, CONST(y_offset))), </span><br><span class=\"line\">        BINOP(PLUS, </span><br><span class=\"line\">        MEM(+(FP, CONST(x_offset))), </span><br><span class=\"line\">        CONST(<span class=\"number\">5</span>))) </span><br><span class=\"line\">    ), </span><br><span class=\"line\">    BINOP(PLUS, </span><br><span class=\"line\">    MEM(+(FP, CONST(x_offset))), </span><br><span class=\"line\">    MEM(+(FP, CONST(y_offset)))) </span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>let body in e end翻译成ESEQ(body, e)<br>变量定义翻译成 MEM(+(FP, CONST(offset)))<br>初始化翻译成 MOVE(MEM(+(FP, CONST(offset))), CONST(value))</p>\n<ol start=\"2\">\n<li><p>类型声明<br>No need to generate any IR tree code</p>\n</li>\n<li><p>函数声明<br> – Prologue（序言）<br> – Body（函数体）<br> – Epilogue（尾声）</p>\n</li>\n</ol>\n<ul>\n<li>Prologue<ul>\n<li>pseudo-instructions to announce the beginning of a function</li>\n<li>定义函数标签用于跳转&#x2F;调用</li>\n<li>修改栈指针（SP），为新栈帧分配空间，一般是$SP :&#x3D; SP - frame_size$</li>\n<li>保存被调用者需要保存的寄存器（callee-save），如 $s0-$s7；保存返回地址（RA）</li>\n<li>保存函数参数到栈中（尤其是传值调用时）；保存静态链（static link）</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "中间代码"
            ]
        },
        {
            "id": "http://example.com/2025/06/15/AI/week8-9/",
            "url": "http://example.com/2025/06/15/AI/week8-9/",
            "title": "Week8-9",
            "date_published": "2025-06-14T16:00:00.000Z",
            "content_html": "<h1 id=\"K-Means\"><a href=\"#K-Means\" class=\"headerlink\" title=\"K-Means\"></a>K-Means</h1><p>问题描述：如何将n个数据依据其相似度大小将它们分别聚类到k个集合，使得每个数据仅属于一个聚类集合。</p>\n<ul>\n<li>初始化质心：随机选择k个数据点作为初始质心$c_1, c_2, …, c_k$。</li>\n<li>分配数据点：对于每个数据点$x_i$，计算它与所有质心的距离，并将其分配到距离最近的质心所在的簇中</li>\n<li>更新质心：对于每个簇，计算该簇内所有数据点的平均值，将该平均值作为新的质心。</li>\n<li>迭代过程：重复执行分配和更新步骤，直到质心不再发生变化或达到预设的最大迭代次数。</li>\n</ul>\n<h1 id=\"主成分分析-PCA\"><a href=\"#主成分分析-PCA\" class=\"headerlink\" title=\"主成分分析(PCA)\"></a>主成分分析(PCA)</h1><ul>\n<li>输入：n个d维样本数据所构成的矩阵$\\mathbf{X}$，降维后的维数l</li>\n<li>输出：映射矩阵$\\mathbf{W} &#x3D; {\\mathbf{w}_1, \\mathbf{w}_2, …, \\mathbf{w}_l}$<br>算法步骤：</li>\n</ul>\n<ol>\n<li><p>对于每个样本数据$\\mathbf{x}_i$进行中心化处理：<br>$$<br>\\mathbf{x}_i’ &#x3D; \\mathbf{x}<em>i - \\mu, \\quad \\mu &#x3D; \\frac{1}{n}\\sum</em>{j&#x3D;1}^{n} \\mathbf{x}_j<br>$$</p>\n</li>\n<li><p>计算原始样本数据的协方差矩阵：<br>$$<br>\\Sigma &#x3D; \\frac{1}{n-1} \\mathbf{X}^T \\mathbf{X}<br>$$</p>\n</li>\n<li><p>对协方差矩阵$\\Sigma$进行特征值分解，对所得特征根按其值大到小排序$\\lambda_1 \\geq \\lambda_2 \\geq \\cdots \\geq \\lambda_d$</p>\n</li>\n<li><p>取前$l$个最大特征根所对应特征向量$\\mathbf{w}_1, \\mathbf{w}_2, …, \\mathbf{w}_l$组成映射矩阵$\\mathbf{W}$</p>\n</li>\n<li><p>将每个样本数据$\\mathbf{x}<em>i$按照如下方法降维：<br>$$<br>(\\mathbf{x}<em>i)</em>{1 \\times d} (\\mathbf{W})</em>{d \\times l} &#x3D; 1 \\times l<br>$$<br>区分：</p>\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>PCA</th>\n<th>LDA</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>类型</strong></td>\n<td>无监督</td>\n<td>有监督</td>\n</tr>\n<tr>\n<td><strong>目标</strong></td>\n<td>最大化方差，保留主要分布信息</td>\n<td>最大化类间距离，最小化类内距离</td>\n</tr>\n<tr>\n<td><strong>是否使用类别信息</strong></td>\n<td>? 不使用</td>\n<td>? 使用</td>\n</tr>\n<tr>\n<td><strong>适用任务</strong></td>\n<td>数据压缩、可视化、去噪</td>\n<td>分类任务的特征提取</td>\n</tr>\n<tr>\n<td><strong>降维后维度上限</strong></td>\n<td>可任意，但一般小于原维度</td>\n<td>最多降到 $k-1$ 维（$k$ 是类别数）</td>\n</tr>\n<tr>\n<td><strong>数学基础</strong></td>\n<td>协方差矩阵的特征值分解</td>\n<td>类间&#x2F;类内散度矩阵的广义特征值分解</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<ul>\n<li>其他降维方法：<ul>\n<li>非负矩阵分解 （non-negative matrix factorization, NMF）</li>\n<li>多维尺度法（Metric multidimensional scaling, MDS）</li>\n<li>局部线性嵌入（Locally Linear Embedding，LLE）</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"特征人脸方法\"><a href=\"#特征人脸方法\" class=\"headerlink\" title=\"特征人脸方法\"></a>特征人脸方法</h1><p>输入时将每幅人脸图像转换成列向量<br><img data-src=\"/f1.jpg\"><br>算法描述</p>\n<ul>\n<li>输入：$n$个1024维人脸样本数据所构成的矩阵$\\mathbf{X}$，降维后的维数$l$</li>\n<li>输出：映射矩阵$\\mathbf{W} &#x3D; {\\mathbf{w}_1, \\mathbf{w}_2, …, \\mathbf{w}_l}$（其中每个$\\mathbf{w}_j (1 \\leq j \\leq l)$是一个特征人脸）<br>算法步骤</li>\n</ul>\n<ol>\n<li><p>中心化处理：</p>\n<ul>\n<li>对每个人脸样本数据$x_i$进行中心化处理：<br>$$<br>x_i’ &#x3D; x_i - \\mu, \\quad \\mu &#x3D; \\frac{1}{n}\\sum_{j&#x3D;1}^{n} x_j<br>$$</li>\n</ul>\n</li>\n<li><p>计算协方差矩阵：</p>\n<ul>\n<li>计算原始人脸样本数据的协方差矩阵：<br>$$<br>\\Sigma &#x3D; \\frac{1}{n-1} \\mathbf{X}^T \\mathbf{X}<br>$$</li>\n</ul>\n</li>\n<li><p>特征值分解：</p>\n<ul>\n<li>对协方差矩阵$\\Sigma$进行特征值分解，对所得特征根按从大到小排序：<br>$$<br>\\lambda_1 \\geq \\lambda_2 \\geq \\cdots \\geq \\lambda_d<br>$$</li>\n</ul>\n</li>\n<li><p>构建映射矩阵：</p>\n<ul>\n<li>取前$l$个最大特征根所对应特征向量$\\mathbf{w}_1, \\mathbf{w}_2, …, \\mathbf{w}_l$组成映射矩阵$\\mathbf{W}$。</li>\n</ul>\n</li>\n<li><p>数据降维：</p>\n<ul>\n<li>将每个人脸图像$x_i$按照如下方法降维：<br>$$<br>(\\mathbf{x}<em>i)</em>{1 \\times d} (\\mathbf{W})_{d \\times l} &#x3D; 1 \\times l<br>$$<br>（其实用的是pca，多的一步就是输入的时候把32*32的图摊开成1024*1的列向量而已）</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"潜在语义分析（Latent-Semantic-Analysis-LSA）\"><a href=\"#潜在语义分析（Latent-Semantic-Analysis-LSA）\" class=\"headerlink\" title=\"潜在语义分析（Latent Semantic Analysis, LSA）\"></a>潜在语义分析（Latent Semantic Analysis, LSA）</h1><p>步骤</p>\n<ol>\n<li><p>构建单词-文档矩阵：</p>\n<ul>\n<li>构建一个单词-文档矩阵$A$，其中每个元素$a_{ij}$表示第$i$个单词在第$j$个文档中的频率（通常使用词频-逆文档频率TF-IDF进行加权）。</li>\n</ul>\n</li>\n<li><p>奇异值分解（SVD）：</p>\n<ul>\n<li>对单词-文档矩阵$A$进行奇异值分解，即$A &#x3D; U \\Sigma V^T$，其中$U$和$V$分别是左奇异向量和右奇异向量组成的矩阵，$\\Sigma$是对角矩阵，其对角线上的元素是$A$的奇异值（按降序排列）。</li>\n</ul>\n</li>\n<li><p>选择前$k$个最大奇异值及对应的奇异向量：</p>\n<ul>\n<li>选取前$k$个最大的奇异值及其对应的奇异向量，形成低秩逼近矩阵$A_k &#x3D; U_k \\Sigma_k V_k^T$。这里$k$的选择取决于保留多少原始信息量，通常根据累积能量准则或经验确定。</li>\n</ul>\n</li>\n<li><p>重建矩阵并挖掘语义关系：</p>\n<ul>\n<li>使用$A_k$代替原始矩阵$A$，可以计算任意两个文档之间的相似度（如皮尔逊相关系数），从而发现文档-文档之间的关联关系。</li>\n<li>同样地，也可以用于探索单词-单词、单词-文档间的隐含关系。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"期望最大化算法（Expectation-Maximization-Algorithm-EM）\"><a href=\"#期望最大化算法（Expectation-Maximization-Algorithm-EM）\" class=\"headerlink\" title=\"期望最大化算法（Expectation-Maximization Algorithm, EM）\"></a>期望最大化算法（Expectation-Maximization Algorithm, EM）</h1><p>EM算法是一种迭代方法，主要用于含有隐变量的概率模型参数估计问题。它分为&#x3D;&#x3D;E步（求期望）&#x3D;&#x3D;和&#x3D;&#x3D;M步（最大化）&#x3D;&#x3D;，通过迭代方式逼近模型参数的最大似然估计值。</p>\n<p>步骤</p>\n<ol>\n<li><p>初始化模型参数：</p>\n<ul>\n<li>首先为模型参数设定初始值（例如高斯混合模型中的均值、方差等）。</li>\n</ul>\n</li>\n<li><p>E步（Expectation Step）：计算隐变量</p>\n<ul>\n<li>基于当前的模型参数，计算隐变量的后验概率分布。对于每一个样本$x_i$和可能的隐变量$z_i$，计算$p(z_i|x_i, \\theta)$，其中$\\theta$表示当前的模型参数。</li>\n</ul>\n</li>\n<li><p>M步（Maximization Step）：最大化似然函数和更新模型参数</p>\n<ul>\n<li>根据观测数据$x_i$、隐变量$z_i$的后验概率分布，重新估计模型参数$\\theta$，以最大化完整数据的对数似然函数$\\log p(x,z|\\theta)$的期望。</li>\n</ul>\n</li>\n<li><p>重复E步和M步：</p>\n<ul>\n<li>不断重复执行E步和M步，直到模型参数收敛或者达到预定的迭代次数为止。</li>\n</ul>\n</li>\n</ol>\n<p>具体的没看懂，等我懂了再说</p>\n",
            "tags": [
                "人工智能"
            ]
        },
        {
            "id": "http://example.com/2025/06/15/computer-science/compile-principles/ch6/",
            "url": "http://example.com/2025/06/15/computer-science/compile-principles/ch6/",
            "title": "活动记录",
            "date_published": "2025-06-14T16:00:00.000Z",
            "content_html": "<h1 id=\"Activation-Record-Stack-Frame\"><a href=\"#Activation-Record-Stack-Frame\" class=\"headerlink\" title=\"Activation Record&#x2F;Stack Frame\"></a>Activation Record&#x2F;Stack Frame</h1><p>函数的栈帧是栈上用来放函数的局部变量、参数、返回地址以及其他临时变量的区域<br>stack一般从高地址向低地址，heap从低地址向高地址<br>layout:<br><img data-src=\"/f1.jpg\"></p>\n<ul>\n<li>incoming arguments: 存储caller传递给callee的参数</li>\n<li>frame pointer: 帧指针，用来访问incoming arguments，从低向高是argument 1, argument 2, …</li>\n<li>local variables: 存储函数的局部变量（还有一些保存在寄存器里）</li>\n<li>return address: 存储需要返回caller的哪里；non-leaf过程会把return address写入栈帧里面</li>\n<li>temporaries: 存储临时变量，复杂表达式拆出来的中间变量放的地方</li>\n<li>saved registers</li>\n<li>outgoing arguments: 存储当前函数要传递给别的函数的参数</li>\n<li>stack pointer: 栈指针，从低向高</li>\n</ul>\n<h2 id=\"函数调用流程：\"><a href=\"#函数调用流程：\" class=\"headerlink\" title=\"函数调用流程：\"></a>函数调用流程：</h2><ul>\n<li>g调用f的时候</li>\n</ul>\n<ol>\n<li>进入f的时候，保存旧的FP(g的FP)</li>\n<li>把FP设置为原来的SP，把SP &#x3D; SP - frame size<br><img data-src=\"/f2.jpg\"></li>\n</ol>\n<ul>\n<li>f返回的时候</li>\n</ul>\n<ol>\n<li>让SP &#x3D; FP(恢复g的SP)</li>\n<li>从内存中读出g的FP恢复回去</li>\n</ol>\n<p>如果栈帧大小固定就只需要FP不需要SP了，因为FP &#x3D; SP + frame size</p>\n<h2 id=\"saved-register\"><a href=\"#saved-register\" class=\"headerlink\" title=\"saved register\"></a>saved register</h2><p>函数g调用f的时候，用到了寄存器r，调用f的时候要把r保存在saved register中，等调用结束再恢复回去</p>\n<ul>\n<li>caller-saved register: 函数调用的时候用到的寄存器，调用结束后可以恢复</li>\n<li>callee-saved register: 函数调用的时候用不到的寄存器，调用结束后不能恢复<br>&#x3D;&#x3D;FP是由callee保存和恢复的&#x3D;&#x3D;</li>\n</ul>\n<h2 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h2><p>一般约定把前k(4 or 6)个参数放在寄存器传递，剩下的参数放在栈中传递<br>四种传参方法：</p>\n<ol>\n<li>不给叶过程 (leaf procedure) 分配栈帧<br>叶过程是指不调用其他过程的过程。在这种情况下，可以不为叶过程分配栈帧</li>\n<li>过程间寄存器分配 (interprocedural register allocation)<br>这种方法需要先分析代码中全部的函数，然后再根据分析结果来分配寄存器。<br>假设有一个程序包含多个函数，通过全局分析发现某些变量在多个函数之间频繁使用，可以为其分配固定的寄存器，避免频繁的内存读写</li>\n<li>若变量 x 不再被使用，可以直接写其寄存器，不需要再保存 x 到栈帧中<br>当一个变量在当前作用域内不再被使用时，可以直接将其值写入寄存器，而无需保存到栈帧中</li>\n</ol>\n<figure class=\"highlight c\"><figcaption><span>example</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">exampleFunction</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> y = x * <span class=\"number\">2</span>;  <span class=\"comment\">// 使用x后，x不再被使用</span></span><br><span class=\"line\">    <span class=\"comment\">// 直接将y的值写入寄存器，无需保存x到栈帧中</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Result: %d\\n&quot;</span>, y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>寄存器窗口技术 (register windows)<br>在每次函数调用时，系统会自动切换到一组新的寄存器，称为寄存器窗口。这样，每个函数都可以独立地使用自己的寄存器，而不会影响其他函数的寄存器状态。</li>\n</ol>\n<figure class=\"highlight c\"><figcaption><span>example</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">functionA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用寄存器窗口A</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">functionB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用寄存器窗口B</span></span><br><span class=\"line\">    functionA();  <span class=\"comment\">// 调用functionA时，自动切换到寄存器窗口A</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Frame-Resident-Variables\"><a href=\"#Frame-Resident-Variables\" class=\"headerlink\" title=\"Frame-Resident Variables\"></a>Frame-Resident Variables</h2><p>什么情况下要把变量写入栈帧里面？、</p>\n<ol>\n<li>the varibles will be passed by reference 变量传地址&#x2F;引用</li>\n<li>变量被嵌套在函数内部的函数访问（不绝对）</li>\n<li>变量太大了没法直接放寄存器</li>\n<li>变量是一个数组</li>\n<li>传递参数</li>\n<li>有太多局部变量和临时变量放不下了</li>\n</ol>\n<ul>\n<li>escape 逃逸：如果一个变量需要传地址&#x2F;取地址&#x2F;被过程内部嵌套的函数访问，那么这个变量就会逃逸。</li>\n</ul>\n<h2 id=\"static-links\"><a href=\"#static-links\" class=\"headerlink\" title=\"static links\"></a>static links</h2><p>在嵌套的函数声明中，内层函数是有可能用到外层函数的局部变量的。</p>\n<ul>\n<li>static links是指向上一层嵌套层级的栈帧的指针。内层嵌套函数调用外层定义的变量的时候需要用到static links，否则无法寻址。<br><img data-src=\"/f3.jpg\"><br><img data-src=\"/f4.jpg\"><br>只有调用自身的时候才传递自己的static link作为static link，其他的都是把外层函数的fp作为static link<br>如果要访问外层变量，就顺着static一层一层查上去直到找到了为止。<br>其他访问方法：</li>\n<li>嵌套层次显示表(display)<br>建立一个全局数组，位置i包含一个指针，指向最近一次进入的，其静态嵌套深度是i的过程的栈帧<br><img data-src=\"/f5.jpg\"><br>先给它们标上嵌套深度<br>直接把链表变成数组了，需要用到一个变量，就查看当前变量的嵌套深度i然后直接找那个数组i位置的座位fp地址来找</li>\n<li>lambda lifting<br>g调用f时，g中每一个实际（或被嵌套在f内的任意函数）访问了的变量，都将作为额外的参数传递给f<br>把内部的函数，从内往外进行改写，改写函数的参数实现lambda lifting<br><img data-src=\"/f6.jpg\"></li>\n</ul>\n<h2 id=\"tiger编译器的栈帧\"><a href=\"#tiger编译器的栈帧\" class=\"headerlink\" title=\"tiger编译器的栈帧\"></a>tiger编译器的栈帧</h2><p>tiger不支持高阶函数<br>看不完了。。再说吧</p>\n",
            "tags": [
                "活动记录"
            ]
        },
        {
            "id": "http://example.com/2025/06/12/AI/week6-7/",
            "url": "http://example.com/2025/06/12/AI/week6-7/",
            "title": "Week6-7",
            "date_published": "2025-06-11T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch4-机器学习\"><a href=\"#Ch4-机器学习\" class=\"headerlink\" title=\"Ch4 机器学习\"></a>Ch4 机器学习</h1><h2 id=\"监督学习\"><a href=\"#监督学习\" class=\"headerlink\" title=\"监督学习\"></a>监督学习</h2><ul>\n<li>标注数据</li>\n<li>学习模型</li>\n<li>损失函数<br>典型的损失函数<br><img data-src=\"/figure2.png\"></li>\n</ul>\n<p>经验风险(empirical risk )</p>\n<ul>\n<li>训练集中数据产生的损失。</li>\n<li>经验风险越小说明学习模型对训练数据拟合程度越好。</li>\n</ul>\n<p>期望风险(expected risk):</p>\n<ul>\n<li>当测试集中存在无穷多数据时产生的损失。</li>\n<li>期望风险越小，学习所得模型越好。</li>\n</ul>\n<p>经验风险最小化</p>\n<p>$$\\min_{f \\in \\Phi} \\frac{1}{n} \\sum_{i&#x3D;1}^{n} Loss(y_i, f(x_i))$$</p>\n<p>期望风险最小化</p>\n<p>$$\\min_{f \\in \\Phi} \\int_{x \\times y} Loss(y, f(x)) P(x, y) dx dy$$</p>\n<p>模型泛化能力与经验风险、期望风险的关系</p>\n<table>\n<thead>\n<tr>\n<th>经验风险小（训练集上表现好）</th>\n<th>期望风险小（测试集上表现好）</th>\n<th>泛化能力强</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>经验风险小（训练集上表现好）</td>\n<td>期望风险大（测试集上表现不好）</td>\n<td>过学习（模型过于复杂）</td>\n</tr>\n<tr>\n<td>经验风险大（训练集上表现不好）</td>\n<td>期望风险大（测试集上表现不好）</td>\n<td>欠学习</td>\n</tr>\n<tr>\n<td>经验风险大（训练集上表现不好）</td>\n<td>期望风险小（测试集上表现好）</td>\n<td>“神仙算法”或“黄粱美梦”</td>\n</tr>\n</tbody></table>\n<p>结构风险最小化 (structural risk minimization)</p>\n<p>为了防止过拟合，在经验风险上加上表示模型复杂度的正则化项 (regularizer) 或惩罚项 (penalty term):</p>\n<p>$$\\min_{f \\in \\Phi} \\frac{1}{n} \\sum_{i&#x3D;1}^{n} Loss(y_i, f(x_i)) + \\lambda J(f)$$</p>\n<ul>\n<li>经验风险: $\\frac{1}{n} \\sum_{i&#x3D;1}^{n} Loss(y_i, f(x_i))$</li>\n<li>模型复杂度: $\\lambda J(f)$</li>\n</ul>\n<p>监督学习方法又可以分为 生成方法 (generative approach) 和 判别方法(discriminative approach)。所学到的模型分别称为生成模型(generative model)和判别模型(discriminative model)<br><img data-src=\"/figure1.png\"></p>\n<h1 id=\"回归分析\"><a href=\"#回归分析\" class=\"headerlink\" title=\"回归分析\"></a>回归分析</h1><h2 id=\"线性回归\"><a href=\"#线性回归\" class=\"headerlink\" title=\"线性回归\"></a>线性回归</h2><ul>\n<li>一元线性回归</li>\n</ul>\n<p>$$y_i &#x3D; ax_i + b \\quad (1 \\leq i \\leq n)$$</p>\n<p>$$a &#x3D; \\frac{\\sum_{i&#x3D;1}^{n} x_i y_i - n \\bar{x} \\bar{y}}{\\sum_{i&#x3D;1}^{n} x_i^2 - n \\bar{x}^2}$$</p>\n<p>$$b &#x3D; \\bar{y} - a \\bar{x}$$</p>\n<ul>\n<li><p>多元线性回归<br>$$f(x_i) &#x3D; a_0 + \\sum_{j&#x3D;1}^{D} a_j x_{i,j} &#x3D; a_0 + \\mathbf{a}^T \\mathbf{x}_i$$<br>a是要求的参数，x是输入的数据，f是预测值。<br>为了方便，使用矩阵来表示所有的训练数据和数据标签。<br>$$X &#x3D; [x_1, …, x_m], \\quad y &#x3D; [y_1, …, y_m]$$<br>最小化均方误差得到：<br>$$a &#x3D; (XX^T)^{-1}X^Ty$$</p>\n</li>\n<li><p>逻辑斯蒂回归&#x2F;对数几率回归<br>线性回归一个明显的问题是对离群点导致模型建模不稳定，使结果有偏，为了缓解这个问题（特别是在二分类场景中）带来的影响，可考虑逻辑斯蒂回归<br>逻辑斯蒂回归就是在回归模型中引入 sigmoid函数的一种非线性回归模型</p>\n</li>\n</ul>\n<h2 id=\"逻辑斯蒂回归-Logistic-Regression\"><a href=\"#逻辑斯蒂回归-Logistic-Regression\" class=\"headerlink\" title=\"逻辑斯蒂回归 (Logistic Regression)\"></a>逻辑斯蒂回归 (Logistic Regression)</h2><p>逻辑斯蒂回归（logistic regression）就是在回归模型中引入 sigmoid 函数的一种非线性回归模型。Logistic 回归模型可如下表示：</p>\n<p>$$ y &#x3D; \\frac{1}{1 + e^{-z}} &#x3D; \\frac{1}{1 + e^{-(w^T x + b)}} $$<br>其中 $y \\in (0, 1)$，$z &#x3D; w^T x + b$。<br>这里 $\\frac{1}{1 + e^{-z}}$ 是 sigmoid 函数，$x \\in \\mathbb{R}^d$ 是输入数据，$w \\in \\mathbb{R}^d$ 和 $b \\in \\mathbb{R}$ 是回归函数的参数。</p>\n<p>逻辑斯蒂回归多用于&#x3D;&#x3D;二分类&#x3D;&#x3D;问题<br>Sigmoid 函数将任意实数映射到区间(0,1)，这正好符合“概率”的取值范围，所以函数的输出y可以被解释为输入数据x属于正例的概率<br>因此我们可以将输出 y 解释为：</p>\n<blockquote>\n<p>在给定输入特征 x 的条件下，该样本属于正类（例如类别 1）的概率。<br>即：<br>$$<br>y &#x3D; P(y &#x3D; 1 \\mid x)<br>$$<br>如果 $P(y&#x3D;1|x)$ 表示给定输入 $x$ 属于正类的概率，则 $1 - P(y&#x3D;1|x)$ 表示属于负类的概率。<br>$\\frac{P(y&#x3D;1|x)}{1 - P(y&#x3D;1|x)}$ 就是正类相对于负类的优势比。所以&gt;1就归为正类，反之就是负类。</p>\n</blockquote>\n<p>$$<br>\\log \\frac{P(y&#x3D;1|x)}{P(y&#x3D;0|x)} &#x3D; {w^T x + b} &gt; \\log{1} &#x3D; 0<br>$$<br>从这里可以看出，logistic回归本质上是一个线性模型。在预测时，可以计算线性函数$w^T x + b$取值是否大于0来判断输入数据x的类别归属</p>\n<p>为了找到最优参数w和b，我们使用最大似然估计，假设每个样本独立同分布，则<br>……<br>公式懒得敲了，</p>\n<p>为什么基于相关性的方法可能会导致模型的不可解释性和不稳定性</p>\n<ul>\n<li>因果特征和非因果特征</li>\n<li>Making V⊥Y: 最终目标是让非因果特征 V 与输出 Y 独立，即消除虚假相关性，使得模型更加稳定和可解释</li>\n</ul>\n<h1 id=\"决策树\"><a href=\"#决策树\" class=\"headerlink\" title=\"决策树\"></a>决策树</h1><p>决策树是一种通过树形结构来进行分类的方法</p>\n<ul>\n<li>信息熵（entropy）是度量样本集合纯度最常用的一种指标<br>假设有一个K个信息（类别），其组成了集合样本D，记第k个信息（类别）发生的概率为$p_k (1 \\leq k \\leq K)$。如下定义这K个信息的信息熵：</li>\n</ul>\n<p>$$Ent(D) &#x3D; -\\sum_{k&#x3D;1}^{K} p_k \\log_2 p_k$$</p>\n<p>&#x3D;&#x3D;$Ent(D)$值越小，表示D包含的信息越确定，也称D的纯度越高。&#x3D;&#x3D;所有$p_k$累加起来的和为1。</p>\n<ul>\n<li>信息增益:衡量使用某个属性进行划分后，数据集不确定性减少的程度<br>得到信息熵后可以进一步计算信息增益：<br>$$Gain(D, A) &#x3D; Ent(D) - \\sum_{i&#x3D;1}^{n} \\frac{|D_i|}{|D|} Ent(D_i)$$<br><img data-src=\"/f3.png\"><br><img data-src=\"/f4.png\"><br>ID3决策树学习算法[Quinlan, 1986]以信息增益为准则来选择划分属性<br>目标：通过不断划分，使得每个子集尽可能“纯净”，即子集内的样本属于同一类</li>\n</ul>\n<p>信息熵（和上面的一样的）<br>$$<br>info &#x3D; -\\sum_{i&#x3D;1}^{n} \\frac{|D_i|}{|D|} \\log_2 \\frac{|D_i|}{|D|}<br>$$</p>\n<p>增益率（Gain-ratio）：</p>\n<p>$$<br>Gain-ratio &#x3D; \\frac{Gain(D, A)}{info}<br>$$<br>存在的问题：增益率准则对可取数目较少的属性有所偏好</p>\n<p>另一种计算更简的度量指标是如下的 Gini 指数（基尼指数）：</p>\n<p>$$<br>Gini(D) &#x3D; 1 - \\sum_{k&#x3D;1}^{K} p_k^2<br>$$</p>\n<p>相对于信息熵的计算 $E(D) &#x3D; -\\sum_{k&#x3D;1}^{K} p_k \\log_2 p_k$，不用计算对数 log，计算更为简易。</p>\n<h2 id=\"连续属性离散化\"><a href=\"#连续属性离散化\" class=\"headerlink\" title=\"连续属性离散化\"></a>连续属性离散化</h2><ol>\n<li><p>确定连续属性的取值范围，确定划分点集合<br>考虑包含 n-1 个元素的候选划分点集合：<br>$$<br>T_a &#x3D; \\left{ \\frac{a^i + a^{i+1}}{2} ,\\middle|, 1 \\leq i \\leq n - 1 \\right}<br>$$<br>这里的每个候选划分点是相邻两个取值的中点，即区间 $[a^i, a^{i+1})$ 的中位点 $\\frac{a^i + a^{i+1}}{2}$</p>\n</li>\n<li><p>计算信息增益<br>$$<br>\\text{Gain}(D, a, t) &#x3D; \\text{Ent}(D) - \\sum_{\\lambda \\in {-, +}} \\frac{|D_t^\\lambda|}{|D|} \\cdot \\text{Ent}(D_t^\\lambda)<br>$$<br>计算每个划分点的信息增益率，选择信息增益最大的划分点</p>\n</li>\n</ol>\n<p>+++info example<br>;;;id3 example<br>给定数据点及其对应的类别标签如下：</p>\n<ul>\n<li>$a_1 &#x3D; 1$ -&gt; 类别为 0</li>\n<li>$a_2 &#x3D; 3$ -&gt; 类别为 1</li>\n<li>$a_3 &#x3D; 5$ -&gt; 类别为 0</li>\n<li>$a_4 &#x3D; 7$ -&gt; 类别为 1</li>\n<li>$a_5 &#x3D; 9$ -&gt; 类别为 0</li>\n</ul>\n<p>因此，我们的数据集 $D$ 是 ${1, 3, 5, 7, 9}$，对应的类别标签分别为 ${0, 1, 0, 1, 0}$。</p>\n<p>第一步：计算原始数据集的信息熵</p>\n<p>$$<br>Ent(D) &#x3D; -\\left( p_0 \\log_2 p_0 + p_1 \\log_2 p_1 \\right)<br>$$</p>\n<p>其中，$p_0 &#x3D; \\frac{3}{5}$，$p_1 &#x3D; \\frac{2}{5}$，则：</p>\n<p>$$<br>Ent(D) &#x3D; -\\left( \\frac{3}{5} \\log_2 \\frac{3}{5} + \\frac{2}{5} \\log_2 \\frac{2}{5} \\right) \\approx 0.971<br>$$</p>\n<p>第二步：确定候选划分点集合</p>\n<p>根据公式 $T_a &#x3D; \\left{ \\frac{a^i + a^{i+1}}{2} ,\\middle|, 1 \\leq i \\leq n - 1 \\right}$，我们得到候选划分点集合：</p>\n<p>$$<br>T_a &#x3D; {2, 4, 6, 8}<br>$$</p>\n<p>第三步：计算每个候选划分点的信息增益</p>\n<p>以划分点 $t &#x3D; 4$ 为例：</p>\n<ul>\n<li>$D_t^{-} &#x3D; {1, 3}$，类别为 ${0, 1}$</li>\n<li>$D_t^{+} &#x3D; {5, 7, 9}$，类别为 ${0, 1, 0}$</li>\n</ul>\n<p>计算这两个子集的熵：</p>\n<ul>\n<li>$$Ent(D_t^{-}) &#x3D; -\\left( \\frac{1}{2} \\log_2 \\frac{1}{2} + \\frac{1}{2} \\log_2 \\frac{1}{2} \\right) &#x3D; 1$$</li>\n<li>$$Ent(D_t^{+}) &#x3D; -\\left( \\frac{2}{3} \\log_2 \\frac{2}{3} + \\frac{1}{3} \\log_2 \\frac{1}{3} \\right) \\approx 0.918$$</li>\n</ul>\n<p>计算信息增益：</p>\n<p>$$<br>Gain(D, a, t&#x3D;4) &#x3D; Ent(D) - \\left( \\frac{|D_t^{-}|}{|D|} \\cdot Ent(D_t^{-}) + \\frac{|D_t^{+}|}{|D|} \\cdot Ent(D_t^{+}) \\right)<br>$$</p>\n<p>代入数值：</p>\n<p>$$<br>Gain(D, a, t&#x3D;4) &#x3D; 0.971 - \\left( \\frac{2}{5} \\cdot 1 + \\frac{3}{5} \\cdot 0.918 \\right) \\approx 0.029<br>$$</p>\n<p>重复上述过程，对所有划分点 $t &#x3D; 2, 4, 6, 8$ 进行类似计算，并选择使 $Gain(D, a, t)$ 最大的那个作为最优划分点。<br>;;;<br>+++</p>\n<h1 id=\"线性区别分析-LDA-FDA\"><a href=\"#线性区别分析-LDA-FDA\" class=\"headerlink\" title=\"线性区别分析 (LDA&#x2F;FDA)\"></a>线性区别分析 (LDA&#x2F;FDA)</h1><p>线性判别分析(linear discriminant analysis， LDA)是一种基于监督学习的降维方法，也称为Fisher线性判别分析(fisher’s discriminant analysis，FDA),对于一组具有标签信息的高维数据样本，LDA利用其类别信息，将其线性投影到一个低维空间上，在低维空间中同一类别样本尽可能靠近，不同类别样本尽可能彼此远离。</p>\n<ol>\n<li>计算数据样本集中每个类别样本的均值</li>\n<li>计算类内散度矩阵$S_w$和类间散度矩阵$S_b$</li>\n<li>根据$S_w^{-1}S_bW&#x3D;\\lambda W$来求解$S_w^{-1}S_b$所对应前$r$个最大特征值所对应特征向量$(w_1,w_2,…,w_r)$，构成矩阵W</li>\n<li>通过矩阵$W$将每个样本映射到低维空间，实现特征降维。</li>\n</ol>\n<p>具体不想看，考到就给了</p>\n<h1 id=\"Ada-Boosting\"><a href=\"#Ada-Boosting\" class=\"headerlink\" title=\"Ada Boosting\"></a>Ada Boosting</h1><p>。。看不懂懒得看</p>\n<h1 id=\"支持向量机\"><a href=\"#支持向量机\" class=\"headerlink\" title=\"支持向量机\"></a>支持向量机</h1><h1 id=\"生成学习模型\"><a href=\"#生成学习模型\" class=\"headerlink\" title=\"生成学习模型\"></a>生成学习模型</h1>",
            "tags": [
                "人工智能"
            ]
        },
        {
            "id": "http://example.com/2025/06/11/AI/week4-5/",
            "url": "http://example.com/2025/06/11/AI/week4-5/",
            "title": "Week4-5",
            "date_published": "2025-06-10T16:00:00.000Z",
            "content_html": "<p>#Ch3 搜索算法</p>\n<h2 id=\"无信息搜索\"><a href=\"#无信息搜索\" class=\"headerlink\" title=\"无信息搜索\"></a>无信息搜索</h2><p>BFS DFS 略</p>\n<h2 id=\"启发式搜索\"><a href=\"#启发式搜索\" class=\"headerlink\" title=\"启发式搜索\"></a>启发式搜索</h2><ul>\n<li>贪婪优先搜索<ul>\n<li>每次取最短的；缺点：不一定是最优的</li>\n<li>时间和空间复杂度均为 $O(b_m)$，b是搜索树分支因子，m是最大深度<br><img data-src=\"/figure1.png\"><br>:::info<br>每次取当前节点的下一个节点到终点中直线距离最短的<br>:::</li>\n</ul>\n</li>\n<li>A*算法<ul>\n<li>评价函数：f(n) &#x3D; g(n) + h(n)</li>\n<li>代价函数 g(n) 表示从起始结点到结点n的开销代价值</li>\n<li>启发函数 h(n) 表示从结点n到目标结点路径中所估算的最小开销代价值。</li>\n<li>评价函数 f(n) 可视为经过结点n、具有最小开销代价值的路径。<ul>\n<li>在最短路径问题中，g(?)为当前选择的路径的实际距离，即从上一个节点到下一个节点的实际距离，?(?)为下一个节点到目标城市的直线距离。每一次搜索，下一个节点选择与此刻城市连接的所有节点中，g(?)+?(?)最小的城市节点。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>:::info<br>取（当前节点到下一节点的距离+下一节点到目标城市的距离）最短的<br>:::<br>A*算法的完备性和最优性取决于搜索问题和启发函数的性质<br>一个良好的启发函数需要满足:可容性（admissible）;一致性（consistency）<br>如果启发函数是可容的，那么树搜索的A*算法满足最优性(最优性:搜索算法是否能保证找到的第一个解是最优解)<br>满足一致性条件的启发函数一定满足可容性条件，反之不一定</p>\n<h2 id=\"对抗搜索\"><a href=\"#对抗搜索\" class=\"headerlink\" title=\"对抗搜索\"></a>对抗搜索</h2><ul>\n<li><p>最小最大搜索（minimax）</p>\n<ul>\n<li>最小最大搜索是一个在你和对手轮流行动的情况下，为你自己寻找最优策略的算法。</li>\n<li>算法：略</li>\n<li>时间复杂度：$O(b^m)$</li>\n<li>空间复杂度：$O(bm)$</li>\n</ul>\n</li>\n<li><p>\\alpha-\\beta剪枝</p>\n<ul>\n<li>Minimax 会穷举整个博弈树，但我们可以用剪枝技巧跳过一些无用分支，让它跑得更快</li>\n<li>max层的下界取下一层（上界）里面最大的；min层的上界取下一层（下界）里面最小的<br>懒得写直接看例子：<br><img data-src=\"/figure2.png\"><br> Alpha-Beta 剪枝算法什么时候扩展的结点数量最少？</li>\n<li>每一层最左端结点的所有孩子结点均被访问，其他节点仅有最左端孩子结点被访问、其他孩子结点被剪枝。<br> 如果一个节点导致了其兄弟节点被剪枝，可知其孩子节点必然被扩展。</li>\n<li>最优效率下时间复杂度：$O(b^{m&#x2F;2})$  (或者m+1);最差的就是完全没剪枝和minimax一样</li>\n</ul>\n</li>\n<li><p>蒙特卡洛树搜索</p>\n<ul>\n<li>选择(UCB)、扩展、模拟(随机)、反向传播</li>\n<li>悔值函数<br>:::info<br>没完全懂，后面再回来研究<br>:::</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "人工智能"
            ]
        },
        {
            "id": "http://example.com/2025/05/20/AI/week1/",
            "url": "http://example.com/2025/05/20/AI/week1/",
            "title": "Week1",
            "date_published": "2025-05-19T16:00:00.000Z",
            "content_html": "<blockquote>\n<p>2025-2026春夏人工智能课程笔记</p>\n</blockquote>\n<h1 id=\"Ch1-绪论\"><a href=\"#Ch1-绪论\" class=\"headerlink\" title=\"Ch1 绪论\"></a>Ch1 绪论</h1><ul>\n<li>人工智能求解：<ul>\n<li>以符号主义为核心的逻辑推理：将概念（如命题等）符号化，从若干判断（前提）出发得到新判断（结论）</li>\n<li>以问题求解为核心的探寻搜索:探寻搜索依据已有信息来寻找满足约束条件的待求解问题的答案</li>\n<li>以数据驱动为核心的机器学习:从数据中发现数据所承载语义（如概念）的内在模式</li>\n<li>以行为主义为核心的强化学习:根据环境所提供的奖罚反馈来学习所处状态可施加的最佳行动，在“探索（未知空间）-利用（已有经验）（exploration vs. exploitation）”之间寻找平衡，完成某个序列化任务，具备自我学习能力</li>\n<li>以博弈对抗为核心的群体智能:从“数据拟合”优化解的求取向“均衡解”的求取迈进</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "人工智能"
            ]
        },
        {
            "id": "http://example.com/2025/05/20/AI/week2-3/",
            "url": "http://example.com/2025/05/20/AI/week2-3/",
            "title": "Week2-3",
            "date_published": "2025-05-19T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch2-知识表达与推理\"><a href=\"#Ch2-知识表达与推理\" class=\"headerlink\" title=\"Ch2 知识表达与推理\"></a>Ch2 知识表达与推理</h1><h2 id=\"命题逻辑\"><a href=\"#命题逻辑\" class=\"headerlink\" title=\"命题逻辑\"></a>命题逻辑</h2><p><img data-src=\"/img1.png\"><br>真值表：<br><img data-src=\"/img2.png\"></p>\n<blockquote>\n<p>“条件”命题联结词中前提为假时命题结论永远为真，bi-conditional只有两个都是true或者都是false才是true<br>逻辑等价：给定命题p和命题q，如果&#x3D;&#x3D;p和q在所有情况下都具有同样真假结果&#x3D;&#x3D;，那么p和q在逻辑上等价，一般用 $\\equiv$ 来表示，即p $\\equiv$ q。<br>判断逻辑等价：画真值表<br>逻辑等价式：<br><img data-src=\"/img3.jpg\"><br><img data-src=\"/img4.png\"></p>\n</blockquote>\n<ul>\n<li>normal form<ul>\n<li>有限个简单合取式构成的析取式称为析取(or)范式</li>\n<li>由有限个简单析取式构成的合取式称为合取(and)范式</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"谓词逻辑\"><a href=\"#谓词逻辑\" class=\"headerlink\" title=\"谓词逻辑\"></a>谓词逻辑</h2><ul>\n<li>全称量词与存在量词</li>\n<li>约束变元、自由变元<br>:::info<br>在约束变元相同的情况下，量词的运算满足分配律：全称量词对析取没有分配律、存在量词对合取没有分配律<br>:::<br>$$\\begin{aligned}<br>(\\forall x)(A(x) \\lor B(x)) \\equiv (\\forall x)A(x) \\lor (\\forall x)B(x) 不成立<br>\\end{aligned}$$</li>\n</ul>\n<p>$$\\begin{aligned}<br>(\\forall x)(A(x) \\land B(x)) \\equiv (\\forall x)A(x) \\land (\\forall x)B(x) 成立<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>(\\exists x)(A(x) \\lor B(x)) \\equiv (\\exists x)A(x) \\lor (\\exists x)B(x) 成立<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>(\\exists x)(A(x) \\land B(x)) \\equiv (\\exists x)A(x) \\land (\\exists x)B(x) 不成立<br>\\end{aligned}$$<br>:::info<br>当公式中存在多个量词时，若多个量词都是全称量词或者都是存在量词，则量词的位置可以互换；若多个量词中既有全称量词又有存在量词，则量词的位置不可以随意互换<br>:::<br>$$\\begin{aligned}<br>(\\forall x)(\\forall y)A(x, y) \\equiv (\\forall y)(\\forall x)A(x, y)<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>(\\exists x)(\\exists y)A(x, y) \\equiv (\\exists y)(\\exists x)A(x, y)<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>(\\forall x)(\\forall y)A(x, y) \\equiv (\\exists y)(\\forall x)A(x, y)<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>(\\forall x)(\\forall y)A(x, y) \\equiv (\\exists x)(\\forall y)A(x, y)<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>(\\exists y)(\\forall x)A(x, y) \\equiv (\\forall x)(\\exists y)A(x, y)<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>(\\exists x)(\\forall y)A(x, y) \\equiv (\\forall y)(\\exists x)A(x, y)<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>(\\forall x)(\\exists y)A(x, y) \\equiv (\\exists y)(\\exists x)A(x, y)<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>(\\forall y)(\\exists x)A(x, y) \\equiv (\\exists x)(\\exists y)A(x, y)<br>\\end{aligned}$$</p>\n<ul>\n<li>利用谓词逻辑进行推理<ul>\n<li>全称量词消去： $(\\forall x) A(x) \\equiv A(y)$</li>\n<li>全称量词引入： $A(y) \\equiv (\\forall x) A(x)$</li>\n<li>存在量词消去： $(\\exists x) A(x) \\equiv A(c)$</li>\n<li>存在量词引入： $A(c) \\equiv (\\exists x) A(x)$</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"知识图谱推理\"><a href=\"#知识图谱推理\" class=\"headerlink\" title=\"知识图谱推理\"></a>知识图谱推理</h2><ul>\n<li>知识图谱可视为包含多种关系的图。在图中，每个节点是一个实体（如人名、地名、事件和活动等），任意两个节点之间的边表示这两个节点之间存在的关系。</li>\n<li>可将知识图谱中任意两个相连节点及其连接边表示成一个三元组（triplet）,即 (left_node, relation, right_node)<br>两类代表性方法：</li>\n<li>归纳逻辑程序设计 (inductive logic programming，ILP)算法</li>\n<li>路径排序算法（path ranking algorithm, PRA）</li>\n</ul>\n<p>ILP: 一阶归纳学习FOIL（First Order Inductive Learner）<br>推理手段: 正例集合 + 反例集合 + 背景知识样例 ⟹ 目标谓词作为结论的推理规则<br><img data-src=\"/img5.png\"><br>懒得写了，看ppt吧<br><img data-src=\"/img6.png\"><br>推理规则覆盖所有正例且不覆盖任何反例的时候算法结束</p>\n<p>PRA: 路径排序算法<br><img data-src=\"/img7.png\"><br>(4)的意思是看两个实体能不能通过(3)的关系从第一个走到第二个。<br>后面的1表示正例，-1表示负例。</p>\n<h2 id=\"概率图推理\"><a href=\"#概率图推理\" class=\"headerlink\" title=\"概率图推理\"></a>概率图推理</h2><p>贝叶斯网络<br><img data-src=\"/img14.png\"><br>要会算</p>\n<p>马尔科夫逻辑网络</p>\n<h2 id=\"因果推理\"><a href=\"#因果推理\" class=\"headerlink\" title=\"因果推理\"></a>因果推理</h2><p>因果定义：变量X是变量Y的原因，当且仅当保持其它所有变量不变的情况下，改变X的值能导致Y的值发生变化。<br>因果效应：因变量X改变一个单位时，果变量Y的变化程度</p>\n<p>因果图是有向无环图</p>\n<p>结构因果模型：结构因果模型由两组变量集合U和V以及一组函数f组成。其中，f是根据模型中其他变量取值而给V中每一个变量赋值的函数<br>结构因果模型中的原因：如果变量X出现在给变量X赋值的函数中，如$Y &#x3D; f(X) + \\epsilon$，则X是Y的直接原因<br>因果图中的联合概率分布：直接看图<br><img data-src=\"/img8.png\"><br>因果图的基本结构：</p>\n<ul>\n<li>链结构<br>  - <img data-src=\"/img9.png\"><br>  - 对于变量X和Y，若X和Y之间只有一条单向的路径，变量Z是截断(intercept)该路径的集合中的任一变量，则在给定Z时，X和Y条件独立。</li>\n</ul>\n<p>$$<br>P(X, Y | Z) &#x3D; P(X | Z)P(Y | Z)<br>$$</p>\n<ul>\n<li>分连结构<br>  - <img data-src=\"/img10.png\"></li>\n</ul>\n<p>$$<br>P(X, Y | Z) &#x3D; \\frac {P(X, Y, Z)}{P(Z)} &#x3D; \\frac {P(X | Z)P(Y | Z)P(Z)}{P(Z)} &#x3D; P(X | Z)P(Y | Z)<br>$$</p>\n<ul>\n<li>汇联结构<br>  - <img data-src=\"/img11.jpg\"></li>\n</ul>\n<p>$$<br>P(X, Y | Z) &#x3D; \\frac{P(X, Y, Z)} {P(Z)} &#x3D; \\frac {P(X, Y, Z)}{P(Z)} &#x3D; \\frac {P(X)P(Y)P(Z&#x2F;X, Y)}{P(Z)} \\neq P(X | Z)P(Y | Z)<br>$$</p>\n<h3 id=\"D-分离-directional-separation-d-separation-，可用于判断任意两个节点的相关性和独立性\"><a href=\"#D-分离-directional-separation-d-separation-，可用于判断任意两个节点的相关性和独立性\" class=\"headerlink\" title=\"D-分离(directional separation, d-separation)，可用于判断任意两个节点的相关性和独立性\"></a>D-分离(directional separation, d-separation)，可用于判断任意两个节点的相关性和独立性</h3><ul>\n<li>限定集：已知或观察到的变量集合（给定的变量集合）</li>\n<li>路径p被限定集Z阻塞(block)当且仅当：<ul>\n<li>(1) 路径p含有链结构A → B → C或分连结构A ← B → C且中间节点B在Z中，或</li>\n<li>(2) 路径p含有汇连结构A → B ← C且汇连节点B及其后代都不在Z中。</li>\n<li>若Z阻塞了节点X和节点Y之间的每一条路径，则称给定Z时，X和Y是D-分离，即给定Z时，X和Y条件独立</li>\n<li>&#x3D;&#x3D;链式、分连中间节点在，汇联中间节点和后代不在则D-分离&#x3D;&#x3D;</li>\n</ul>\n</li>\n</ul>\n<p>因果定义：变量X是变量Y的原因，当且仅当保持其它所有变量不变的情况下，改变X的值能导致Y的值发生变化。<br>因果效应：因变量X改变一个单位时，果变量Y的变化程度因果推理的两个关键因素：</p>\n<ul>\n<li>改变因变量T</li>\n<li>保证其它变量不变<br>干预：干预(intervention)指的是固定(fix)系统中的变量，然后改变系统，观察其他变量的变化。<br>为了与X自然取值x时进行区分，在对X进行干预时，引入“do算子”(do-calculus)，记作do(X &#x3D; x)。<br>因此，P(Y &#x3D; y|X &#x3D; x)表示的是当发现X &#x3D; x时，Y&#x3D; y的概率；而P(Y &#x3D; y|do(X &#x3D;x))表示的是对X进行干预，固定其值为x时，Y &#x3D; y的概率。<br>用统计学的术语来说，P(Y &#x3D; y|X &#x3D; x)反映的是在取值为x的个体X上，Y的总体分布；而P(Y &#x3D; y|do(X &#x3D;x))反映的是如果将每一个X取值都固定为x时，Y的总体分布。</li>\n</ul>\n<p>因果效应差&#x2F;平均因果效应 (ACE)  懒得写了看图吧<br><img data-src=\"/img12.png\"><br><img data-src=\"/img13.png\"><br>计算因果效应的关键在于计算操纵概率(manipulatedprobability) $P_m$<br>调整公式：<br>$$<br>P(Y &#x3D; y \\mid do(X &#x3D; x)) &#x3D; \\sum_z P(Y &#x3D; y \\mid X &#x3D; x, Z &#x3D; z) \\cdot P(Z &#x3D; z)<br>$$<br>对于Z的每一个取值z，计算X和Y的条件概率并取均值<br>+++info example<br>;;;id3 例题<br>假设我们研究以下变量：</p>\n<ul>\n<li>X：是否服药  <ul>\n<li>$X &#x3D; 1$：服药  </li>\n<li>$X &#x3D; 0$：不服药</li>\n</ul>\n</li>\n<li>Y：是否康复  <ul>\n<li>$Y &#x3D; 1$：康复  </li>\n<li>$Y &#x3D; 0$：未康复</li>\n</ul>\n</li>\n<li>Z：性别  <ul>\n<li>$Z &#x3D; 0$：男  </li>\n<li>$Z &#x3D; 1$：女<br>我们知道性别会影响：</li>\n</ul>\n</li>\n<li>是否选择服药（比如男性更倾向于尝试新药）</li>\n<li>康复率（比如女性可能有更强的免疫力）<br>因此，性别 Z 是一个混杂变量，需要在分析中进行控制。<br>已知：<table>\n<thead>\n<tr>\n<th>Z（性别）</th>\n<th>P(Z)</th>\n<th>P(Y&#x3D;1 | X&#x3D;1, Z)</th>\n<th>P(Y&#x3D;1 | X&#x3D;0, Z)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>男（0）</td>\n<td>0.6</td>\n<td>0.7</td>\n<td>0.4</td>\n</tr>\n<tr>\n<td>女（1）</td>\n<td>0.4</td>\n<td>0.5</td>\n<td>0.3</td>\n</tr>\n<tr>\n<td>我们想知道：</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>如果强制所有人都服药（即 $do(X&#x3D;1)$），整体康复率是多少？</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>也就是要计算：</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>$$</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>P(Y&#x3D;1 \\mid do(X&#x3D;1))</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>$$</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>;;;</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>;;;id3 答案</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>根据调整公式：</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<p>$$<br>P(Y&#x3D;1 \\mid do(X&#x3D;1)) &#x3D; \\sum_z P(Y&#x3D;1 \\mid X&#x3D;1, Z&#x3D;z) \\cdot P(Z&#x3D;z)<br>$$</p>\n<p>代入数据计算</p>\n<p>$$<br>P(Y&#x3D;1 \\mid do(X&#x3D;1)) &#x3D; P(Y&#x3D;1 \\mid X&#x3D;1, Z&#x3D;0) \\cdot P(Z&#x3D;0) + P(Y&#x3D;1 \\mid X&#x3D;1, Z&#x3D;1) \\cdot P(Z&#x3D;1)<br>$$</p>\n<p>$$<br>&#x3D; 0.7 \\times 0.6 + 0.5 \\times 0.4 &#x3D; 0.42 + 0.2 &#x3D; 0.62<br>$$<br>+++</p>\n<p>(因果效应)给定因果图G，PA表示X的父节点集合，则X对Y的因果效应为<br>$$<br>P(Y&#x3D;y \\mid do(X&#x3D;x)) &#x3D; \\sum_z P(Y&#x3D;y \\mid X&#x3D;x, PA&#x3D;z) \\cdot P(PA&#x3D;z)<br>$$<br>后门调整：<br>不写了</p>\n",
            "tags": [
                "人工智能"
            ]
        },
        {
            "id": "http://example.com/2025/05/14/computer-science/computer-organization/ch2/",
            "url": "http://example.com/2025/05/14/computer-science/computer-organization/ch2/",
            "title": "Ch2",
            "date_published": "2025-05-13T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch2-数据的表示和运算\"><a href=\"#Ch2-数据的表示和运算\" class=\"headerlink\" title=\"Ch2 数据的表示和运算\"></a>Ch2 数据的表示和运算</h1><h2 id=\"2-1-进位计数制及其相互转换\"><a href=\"#2-1-进位计数制及其相互转换\" class=\"headerlink\" title=\"2.1 进位计数制及其相互转换\"></a>2.1 进位计数制及其相互转换</h2><h3 id=\"2-1-1\"><a href=\"#2-1-1\" class=\"headerlink\" title=\"2.1.1\"></a>2.1.1</h3><ul>\n<li>十进制二进制八进制十六进制转换<ul>\n<li>略</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-1-2-定点数的编码表示\"><a href=\"#2-1-2-定点数的编码表示\" class=\"headerlink\" title=\"2.1.2 定点数的编码表示\"></a>2.1.2 定点数的编码表示</h3><ul>\n<li>定点数一般表示定点小数和定点整数，小数是符号位.xxx，整数是符号位xxxx.0</li>\n<li><blockquote>\n<p>感觉不是什么重要的东西，浮点数表示比较重要</p>\n</blockquote>\n</li>\n<li>原码，反码，补码<ul>\n<li>正数的原码反码补码相同</li>\n<li>原码表示的范围为 $-2^n+1 ~ 2^n-1$</li>\n<li>补码表示的范围为 $-2^n ~ 2^n-1$</li>\n<li>负数的原码是1+绝对值，反码是1+绝对值取反，补码是反码+1</li>\n</ul>\n</li>\n<li>移码：用来表示浮点数的阶码，只能表示整数<ul>\n<li>一般用移码表示浮点数的阶码，用补码表示定点整数<br>$$ [x]_移 &#x3D; 2^n + x $$<br>移码就是在真值x前面加一个offset，比如取offset为2^7，就在补码的第8位加上1</li>\n<li>比如正数10101，移码是10010101，负数-10101的补码是11101011，所以移码是01101011</li>\n<li>移码的作用是&#x3D;&#x3D;保持数据原有的大小顺序&#x3D;&#x3D;，移码大真值大，移码小真值小，所以可以直观地进行比较<br>:::warning<br>相同位数的补码和移码表示具有相同的数据表示范围，区别只是表示方法不同<br>补码与移码只差一个符号位。同一个数的补码和移码表示，其数值部分相同，而符号位相反。<br>:::</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-1-3-整数表示\"><a href=\"#2-1-3-整数表示\" class=\"headerlink\" title=\"2.1.3 整数表示\"></a>2.1.3 整数表示</h3><p>略</p>\n<h3 id=\"2-1-4\"><a href=\"#2-1-4\" class=\"headerlink\" title=\"2.1.4\"></a>2.1.4</h3><p>c中的强制转换<br>short转成unsigned short直接把二进制看成unsigned short，比如-1变成65535<br>int变成short直接截断<br>小字长转大字长不会改变值，如果是unsigned就会在前面补0，如果是有符号数就在前面补符号位<br>short转unsigned int，先对short进行符号扩展到int，再把它当做unsigned int，如果是unsigned short转int，就进行零扩展再看成int……</p>\n<p>一些题目<br>+++info example<br>;;;id3 t1<br>若$[x]_补 &#x3D; 1,x_1x_2x_3x_4x_5x_6$,其中$x_i$取0或1，若要x&gt;-32，应当满足：<br>C. $x_1$为1，$x_2…x_6$中至少有一位为1<br>1100000是-32，要比-32大所以绝对值要小，所以数值部分要大，所以$x_1$必须是1,后面随便有个1就行<br>;;;<br>;;;id3 t2<br>设x为正数，$[x]_补 &#x3D; 1,x_1x_2x_3x_4x_5$,若要x&lt;-16，应当满足：<br>C. $x_1$必须为0，其它任意<br>110000是-16，要小于-16所以数值部分绝对值要小，所以只要$x_1$为0就比-16小<br>;;;<br>;;;id3 t3<br>一个8位的二进制整数由2个“0”和6个“1”组成，采用补码或者移码表示，则<br>若采用移码表示，偏置值为127，则此整数最小为-64（偏置为127需要在补码加上1111111，&#x3D;&#x3D;要让数值最小，应该把1放低位&#x3D;&#x3D;，所以移码是00111111，补码是10111111是-64）</p>\n<blockquote>\n<p>：前面说过，移码大真值大，移码小真值小，所以要让数值最小把1放低位就行了</p>\n</blockquote>\n<p>若采用补码表示，则此整数最小为-97（10011111&#x3D;-97）<br>;;;<br>;;;id3 比较大小的方法<br>对于无符号数，数值大的数就大<br>对于有符号数的原码和反码比较大小：先看正负然后看数值，反码数值转成原码再比<br>对于补码比较大小，正数正常比较，负数数值部分越小，绝对值越大（前面1更多的数的绝对值越小，所以11111111是-1）<br>;;;<br>+++</p>\n<h2 id=\"2-2-运算方法和运算电路\"><a href=\"#2-2-运算方法和运算电路\" class=\"headerlink\" title=\"2.2 运算方法和运算电路\"></a>2.2 运算方法和运算电路</h2><h3 id=\"2-2-1-基本运算部件\"><a href=\"#2-2-1-基本运算部件\" class=\"headerlink\" title=\"2.2.1 基本运算部件\"></a>2.2.1 基本运算部件</h3><h4 id=\"一位全加器\"><a href=\"#一位全加器\" class=\"headerlink\" title=\"一位全加器\"></a>一位全加器</h4><ul>\n<li>用真值表实现的：进位C，和S<table>\n<thead>\n<tr>\n<th align=\"center\">A</th>\n<th align=\"center\">B</th>\n<th align=\"center\">Cin</th>\n<th align=\"center\">Cout</th>\n<th align=\"center\">S</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n</tr>\n</tbody></table>\n<ul>\n<li>可以用卡诺图或者直接理解(王道不写还好我本来就会，差点忘了。。。)<br><img data-src=\"/img2.jpg\"><br>$$<br>\\begin{aligned}<br>S &amp;&#x3D; \\overline{A} , \\overline{B} , C_i + \\overline{A} , B , \\overline{C_i} + A , \\overline{B} , \\overline{C_i} + A , B , C_i \\<br>&amp;&#x3D; A \\oplus B \\oplus C_i<br>\\end{aligned}<br>$$<br>$$<br>\\begin{aligned}<br>Co &amp;&#x3D; AB + A \\overline{B} C_i + \\overline{A} B C_i \\<br>&amp;&#x3D; AB + (A \\oplus B) \\cdot C_i<br>\\end{aligned}<br>$$</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"串行进位加法器\"><a href=\"#串行进位加法器\" class=\"headerlink\" title=\"串行进位加法器\"></a>串行进位加法器</h4><ul>\n<li>把n个一位全加器连起来<br><img data-src=\"/img3.png\"><br>Carry Propagation &amp; Delay</li>\n</ul>\n<h4 id=\"并行进位加法器\"><a href=\"#并行进位加法器\" class=\"headerlink\" title=\"并行进位加法器\"></a>并行进位加法器</h4><p>对Cin进行look ahead</p>\n<p><img data-src=\"/img4.png\"></p>\n<p>前面提到：<br>$$<br>\\begin{aligned}<br>Co &amp;&#x3D; AB + A \\overline{B} C_i + \\overline{A} B C_i \\<br>   &amp;&#x3D; AB + (A \\oplus B) \\cdot C_i<br>\\end{aligned}<br>$$<br>下一位的Cin等于上一位的Cout，所以可以进行look ahead，这里让<br>$$<br>\\begin{aligned}<br>G_i &amp;&#x3D; A_iB_i<br>\\end{aligned}<br>$$<br>$$<br>\\begin{aligned}<br>P_i &amp;&#x3D; A_i \\oplus B_i<br>\\end{aligned}<br>$$<br>所以<br>$$<br>\\begin{aligned}<br>C_{i+1} &amp;&#x3D; G_i + P_iC_i<br>\\end{aligned}<br>$$<br>$$<br>\\begin{aligned}<br>S_i &amp;&#x3D; P_i \\oplus C_i<br>\\end{aligned}<br>$$<br>就能得到超前进位的效果</p>\n<h4 id=\"带标志加法器\"><a href=\"#带标志加法器\" class=\"headerlink\" title=\"带标志加法器\"></a>带标志加法器</h4><p><img data-src=\"/img5.jpg\"></p>\n<ul>\n<li>溢出标志 $OF &#x3D; C_n  \\oplus C_{n-1}$，只能判断有符号数是否溢出<br>-两个正数加起来变成负数或者两个负数加起来变成正数，就会溢出<table>\n<thead>\n<tr>\n<th align=\"center\">A</th>\n<th align=\"center\">B</th>\n<th align=\"center\">$C_{n-1}$</th>\n<th align=\"center\">F</th>\n<th align=\"center\">$C_n$</th>\n<th align=\"center\">OF</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<blockquote>\n<p>第二行A&#x3D;0, B&#x3D;0, F&#x3D;1，正+正&#x3D;负<br>  第七行A&#x3D;0, B&#x3D;1, F&#x3D;0，负+负&#x3D;正<br>  所以OF&#x3D;1，表示有溢出<br>  观察发现$OF &#x3D; C_{n-1}  \\oplus C_n$</p>\n</blockquote>\n<ul>\n<li>符号标志 $SF &#x3D; F_{n-1}$，输出的最高位决定有符号数的正负</li>\n<li>进位&#x2F;借位标志：用于判断无符号数的加减运算是否溢出<ul>\n<li>$CF &#x3D; Cin \\oplus Cout$</li>\n<li>此处的Cin和Cout表示最开始的输入和最后的输出，还没理解</li>\n</ul>\n</li>\n<li>零标志 当且仅当所有F&#x3D;0时为1，否则为0（把所有F作或非）<br>具体可以看这篇：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhYmJ5X19fXy9hcnRpY2xlL2RldGFpbHMvODA4MjU1NDk=\">https://blog.csdn.net/gabby____/article/details/80825549</span></li>\n</ul>\n<h4 id=\"ALU\"><a href=\"#ALU\" class=\"headerlink\" title=\"ALU\"></a>ALU</h4><p>略</p>\n<h3 id=\"2-2-2-定点数的移位运算\"><a href=\"#2-2-2-定点数的移位运算\" class=\"headerlink\" title=\"2.2.2 定点数的移位运算\"></a>2.2.2 定点数的移位运算</h3><ul>\n<li>左移一位*2，右移一位&#x2F;2</li>\n<li>逻辑移位：移完直接补0<ul>\n<li>无符号数若高位的1移出，则发生溢出</li>\n</ul>\n</li>\n<li>算数移位：有符号数右移时，补符号位，左移直接移，如果高位和符号位不同，则发生溢出</li>\n</ul>\n<h3 id=\"定点数的加减运算\"><a href=\"#定点数的加减运算\" class=\"headerlink\" title=\"定点数的加减运算\"></a>定点数的加减运算</h3><p>补码相加减，略<br>主要是溢出判断：符号相同的数相加或者符号相异的数相减会发生溢出</p>\n<ul>\n<li>一位符号位（参考前面OF）</li>\n<li>双符号位（模4补码）<ul>\n<li>符号位左边那一位表示正确的符号，0为正，1为负；右边那一位如果和左边的相同，如 “00”表示正且无溢出，”11”表示负且无溢出。如果右边那一位与左边那一位不一样，则表示有溢出</li>\n<li>溢出逻辑判断：若V为0则无溢出，V为1则溢出</li>\n<li>&#x3D;&#x3D;存储的时候，模4补码只需要一位符号位&#x3D;&#x3D;，因为任何一个正确的数值它的两个符号位是相同的。它只是把两个模4补码的数送往ALU进行运算的时候，把符号位同时送入ALU的双符号位中，即&#x3D;&#x3D;只在ALU中采用双符号位&#x3D;&#x3D;<br>$$<br>V &#x3D; S_{s1} \\oplus S_{s2}<br>$$<br>例子看这篇写的挺清楚：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1bl9ib3lfYm95X3N1bi9hcnRpY2xlL2RldGFpbHMvODc5MTcwMjA=\">https://blog.csdn.net/sun_boy_boy_sun/article/details/87917020</span><br>总之两位不同则有溢出</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"定点数的乘除运算\"><a href=\"#定点数的乘除运算\" class=\"headerlink\" title=\"定点数的乘除运算\"></a>定点数的乘除运算</h3><p>略，列竖式即可</p>\n<h3 id=\"浮点数的表示与运算\"><a href=\"#浮点数的表示与运算\" class=\"headerlink\" title=\"浮点数的表示与运算\"></a>浮点数的表示与运算</h3><ol>\n<li>浮点数的表示格式<br>$$<br>N &#x3D; (-1)^s \\cdot M \\cdot R^E<br>$$<br>s符号，M尾数，E阶码，R基数</li>\n<li>浮点数的表示范围<br>范围关于原点对称，运算结果大于最大正数时成为正上溢，小遇绝对值最大负数是成为负上溢，统称上溢。运算结果在0-最小整数之间成为正下溢，负数同理，统称下溢（原因是精度不够）</li>\n<li>浮点数的规格化</li>\n</ol>\n",
            "tags": [
                "数据的表示与运算"
            ]
        },
        {
            "id": "http://example.com/2025/05/13/computer-science/computer-network/ch1/",
            "url": "http://example.com/2025/05/13/computer-science/computer-network/ch1/",
            "title": "Ch1",
            "date_published": "2025-05-12T16:00:00.000Z",
            "content_html": "",
            "tags": [
                "计算机网络"
            ]
        },
        {
            "id": "http://example.com/2025/05/13/computer-science/computer-organization/ch1/",
            "url": "http://example.com/2025/05/13/computer-science/computer-organization/ch1/",
            "title": "Ch1",
            "date_published": "2025-05-12T16:00:00.000Z",
            "content_html": "<blockquote>\n<p>王道计组考研复习笔记<br>怕学完忘了写个笔记保留一下顺便加深印象x<br>王道书写得好烂、、</p>\n</blockquote>\n<h1 id=\"Ch1-计算机系统概述\"><a href=\"#Ch1-计算机系统概述\" class=\"headerlink\" title=\"Ch1 计算机系统概述\"></a>Ch1 计算机系统概述</h1><h2 id=\"1-1-计算机发展历程\"><a href=\"#1-1-计算机发展历程\" class=\"headerlink\" title=\"1.1 计算机发展历程\"></a>1.1 计算机发展历程</h2><ul>\n<li>四代计算机：电子管-&gt;晶体管-&gt;集成电路-&gt;超大规模集成电路</li>\n<li>摩尔定律：集成电路上可以容纳的晶体管数目在大约每经过18个月到24个月便会增加一倍</li>\n</ul>\n<h2 id=\"1-2-计算机系统层次结构\"><a href=\"#1-2-计算机系统层次结构\" class=\"headerlink\" title=\"1.2 计算机系统层次结构\"></a>1.2 计算机系统层次结构</h2><ul>\n<li>计算机系统：硬件+软件</li>\n<li>对于某一功能，既能用软件实现又能用硬件实现，称为软、硬件在逻辑功能上是等价的</li>\n</ul>\n<h3 id=\"1-2-2-硬件\"><a href=\"#1-2-2-硬件\" class=\"headerlink\" title=\"1.2.2 硬件\"></a>1.2.2 硬件</h3><ul>\n<li>冯·诺依曼机的特点：<ul>\n<li>采用“存储程序”的工作方式</li>\n<li>冯·诺依曼计算机由五大部件组成：运算器、控制器、存储器、输入设备和输出设备</li>\n<li>指令和数据以同等地位存储在存储器中</li>\n<li>指令和数据均用二进制代码表示</li>\n<li>指令由操作码和地址码组成</li>\n<li><img data-src=\"/img1.png\"></li>\n</ul>\n</li>\n<li>计算机的功能部件：<ul>\n<li>输入设备</li>\n<li>输出设备</li>\n<li>存储器：主存+外存<ul>\n<li>CPU能直接访问的是主存</li>\n<li><img data-src=\"/img2.jpg\"></li>\n<li>MAR位10位则最多有$2^{10}$个存储单元</li>\n<li>在现代计算机中MAR和MDR存在CPU中</li>\n</ul>\n</li>\n<li>运算器：进行算术运算和逻辑运算<ul>\n<li>核心是ALU：通用寄存器有&#x3D;&#x3D;累加器(ACC)，乘商寄存器(MQ)，操作数寄存器(X)&#x3D;&#x3D;，变址寄存器(IX)，基址寄存器(BR)等，前三个必备</li>\n<li>程序状态寄存器(PSW)</li>\n<li><img data-src=\"/img3.jpg\"></li>\n</ul>\n</li>\n<li>控制器：由PC, IR和control unit组成<ul>\n<li>: RISCV控制器</li>\n<li><img data-src=\"/img4.png\"></li>\n</ul>\n</li>\n<li>CPU由运算器、控制器和cache组成</li>\n<li>总线有地址总线、数据总线、控制总线</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-2-3-软件\"><a href=\"#1-2-3-软件\" class=\"headerlink\" title=\"1.2.3 软件\"></a>1.2.3 软件</h3><ul>\n<li>组成：系统软件(OS, DBMS, 编译器, …)+应用软件</li>\n<li>语言：汇编语言、机器语言、高级语言<ul>\n<li>汇编器：把汇编语言翻译成机器语言</li>\n<li>编译器：把高级语言翻译成汇编语言或机器语言</li>\n<li>解释器：把高级语言翻译成&#x3D;&#x3D;机器语言&#x3D;&#x3D;(比如python)<br>  +++info example<br>  ;;;id3 题目<br>  :chestnut:<br>  将高级语言源程序转换为机器级目标代码文件的程序是 []。<br>  A. 汇编程序<br>  B. 链接程序<br>  C. 编译程序<br>  D. 解释程序<br>  ;;;<br>  ;;;id3 答案<br>  C. 编译程序<br>  因为解释程序不生成目标代码，编译器可以把高级语言翻译成汇编语言或者直接翻译成机器语言<br>  ;;;<br>  +++</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-2-4-计算机系统的层次结构\"><a href=\"#1-2-4-计算机系统的层次结构\" class=\"headerlink\" title=\"1.2.4 计算机系统的层次结构\"></a>1.2.4 计算机系统的层次结构</h3><ul>\n<li>看看就好</li>\n<li><img data-src=\"/img5.png\"></li>\n</ul>\n<h3 id=\"1-2-5-计算机系统的工作原理\"><a href=\"#1-2-5-计算机系统的工作原理\" class=\"headerlink\" title=\"1.2.5 计算机系统的工作原理\"></a>1.2.5 计算机系统的工作原理</h3><ul>\n<li>程序执行前，需要把所含的指令和数据一起放入主存中</li>\n<li>五个阶段：IF-ID-EX-MEM-WB</li>\n<li>c程序怎么变成可执行文件的：直接看图<ul>\n<li><img data-src=\"/img6.png\"></li>\n<li>汇编器把指令打包成可重定位目标代码文件：使用相对地址和符号引用来表示各个代码段之间的关系（代码段、数据段、符号表、重定位表…）使得代码或数据能在内存中任意位置加载或运行</li>\n</ul>\n</li>\n<li>指令执行过程：后面几章会具体讲</li>\n</ul>\n<h2 id=\"1-3-计算机的性能指标\"><a href=\"#1-3-计算机的性能指标\" class=\"headerlink\" title=\"1.3 计算机的性能指标\"></a>1.3 计算机的性能指标</h2><h3 id=\"1-3-1-主要性能指标\"><a href=\"#1-3-1-主要性能指标\" class=\"headerlink\" title=\"1.3.1 主要性能指标\"></a>1.3.1 主要性能指标</h3><ul>\n<li>字长：一次整数运算所能处理的二进制数据的位数<br> :::info<br> 机器字长、指令字长和存储字长<br> :::</li>\n<li>带宽<code>bandwidth</code>：总线一次能并行传送信息的位数</li>\n<li>主存容量</li>\n<li>运算速度<ul>\n<li>吞吐量<code>throughput</code>：一次输入数据所对应的输出数据个数</li>\n<li>响应时间<code>Response (Execution) time</code></li>\n<li>主频</li>\n<li>clock cycle time( &#x3D; 1&#x2F;CPU frequency)</li>\n<li>MIPS: million instructions per second</li>\n<li>FLOPS: floating-point operations per second<blockquote>\n<p>CPI: clock cycles per instruction(IPC: CPI的倒数)</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<p>$$ \\begin{aligned}<br>    \\text{CPU execution time} &amp;&#x3D; \\text{CPU clock cycles} \\times \\text{Clock cycle time} \\<br>    &amp;&#x3D; \\frac{\\text{CPU clock cycles}}{\\text{Clock rate}}<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>    \\text{CPU clock cycles} &amp;&#x3D; \\text{Instructions count} \\times \\text{Average cycles per instruction}<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>    \\text{CPU execution time} &amp;&#x3D; \\text{CPU clock cycles} \\times \\text{Clock cycle time} \\<br>    &amp;&#x3D; \\frac{\\text{CPU clock cycles}}{\\text{Clock rate}}<br>\\end{aligned} $$</p>\n<p>$$ \\begin{aligned}<br>     \\text{performance} &amp;&#x3D; \\frac{1}{\\text{CPU execution time}}<br>\\end{aligned}$$</p>\n<p>“Processor X is n times fast than Y” is<br>$$ \\begin{aligned}<br>    \\text{n} &amp;&#x3D; \\frac{\\text{CPU execution time of Y}}{\\text{CPU execution time of X}}<br>\\end{aligned}$$</p>\n<p>IPS: instructions per second<br>$$ \\begin{aligned}<br>    \\text{IPS} &amp;&#x3D; \\frac{\\text{CPU frequency}}{\\text{CPI}}<br>        &amp;&#x3D; \\frac{1}{\\text{CPU clock cycles} \\times \\text{CPU execution time}}<br>\\end{aligned}$$</p>\n<ul>\n<li>其他公式，，，用到再说吧</li>\n<li>兼容：软件或硬件的通用性</li>\n</ul>\n<blockquote>\n<p>在用于科学计算的计算机中，标志系统性能最有用的参数是浮点数运算相关的</p>\n<ul>\n<li>MFLOPS 10^6</li>\n<li>GFLOPS 10^9</li>\n<li>TFLOPS 10^12</li>\n<li>PFLOPS 10^15</li>\n<li>EFLOPS 10^18</li>\n<li>ZFLOPS 10^21</li>\n</ul>\n</blockquote>\n",
            "tags": [
                "计算机组成"
            ]
        },
        {
            "id": "http://example.com/2025/03/30/computer-science/compile-principles/ch5/",
            "url": "http://example.com/2025/03/30/computer-science/compile-principles/ch5/",
            "title": "语义分析",
            "date_published": "2025-03-29T16:00:00.000Z",
            "content_html": "<h1 id=\"语义分析\"><a href=\"#语义分析\" class=\"headerlink\" title=\"语义分析\"></a>语义分析</h1><blockquote>\n<p>绑定，类型检查</p>\n</blockquote>\n<h2 id=\"symbol-table\"><a href=\"#symbol-table\" class=\"headerlink\" title=\"symbol table\"></a>symbol table</h2><ul>\n<li><p>Imperative style: 命令式风格</p>\n<ul>\n<li>Modify $\\sigma_1$ until it becomes $\\sigma_2$. </li>\n<li>While $\\sigma_2$ exists, we cannot look things up in $\\sigma_1$. </li>\n<li>When done with $\\sigma_2$, can undo the modification to get $\\sigma_1$ back again.<br>+++info 方法：<br>Hashing<br>插入：找到哈希值然后插入链表的表头<br>查找：找到哈希值然后遍历链表<br>pop: 找到哈希值然后把链表表头删掉  table[hash(key)] &#x3D; table[hash(key)].next<br>+++</li>\n</ul>\n</li>\n<li><p>Functional style: 函数式风格</p>\n<ul>\n<li>To keep $\\sigma_1$ in pristine condition while creating create $\\sigma_2$ and $\\sigma_3$<br>+++info 方法：<br>如果依旧用哈希，每次要复制一遍哈希表，开销太大了，不现实<br><img data-src=\"/f2.jpg\"><br>所以用persistent BST<br><img data-src=\"/f1.jpg\"><br>先遍历二叉搜索树找到要插入的位置，然后对于插入节点把它从根节点到它全都复制一遍然后插入<br>+++</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Tiger编译器中的符号\"><a href=\"#Tiger编译器中的符号\" class=\"headerlink\" title=\"Tiger编译器中的符号\"></a>Tiger编译器中的符号</h2><p>对链表进行lookup的时候每一次都要进行string compare，开销是很大的。所以使用新的数据结构将符号对象关联到一个整数上，因此对于任意给定字符串的所有不同出现，都会被转换成同一个符号对象。<br>Symbol的实现：通过hash函数将字符串映射到一个symbol对象上<br>SymbolTable的实现：beginScope()和endScope()的实现</p>\n<ul>\n<li>beginScope()：添加一个marksym</li>\n<li>endScope()：从符号表中不断pop直到marksym</li>\n<li>引入一个 辅助栈(Auxiliary stack) 来维护<ul>\n<li>符号入栈时，会将binding联动地插入对应bucket的链表头</li>\n<li>弹出栈顶符号时，对应bucket的链表头也会联动地被移除</li>\n<li>beginScope: 压入一个特殊标记到辅助栈中</li>\n<li>endScope: 一直弹出符号直到弹出了一个特殊标记</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"类型检查\"><a href=\"#类型检查\" class=\"headerlink\" title=\"类型检查\"></a>类型检查</h2><h3 id=\"哪些类型表达式是合法-非法的\"><a href=\"#哪些类型表达式是合法-非法的\" class=\"headerlink\" title=\"哪些类型表达式是合法&#x2F;非法的\"></a>哪些类型表达式是合法&#x2F;非法的</h3><p>Tiger的类型系统：</p>\n<ul>\n<li>两种primitive type: int, string</li>\n<li>两种constructed type: records, arrays</li>\n</ul>\n<p>文法</p>\n<ol>\n<li>typec → type type-id &#x3D; ty<ul>\n<li>这表示定义一个类型。<code>typec</code> 是一个类型定义的开始，它由关键字 <code>type</code>、一个类型标识符 <code>type-id</code> 和一个等号 <code>=</code> 后跟类型定义 <code>ty</code> 组成。</li>\n</ul>\n</li>\n<li>ty → type-id<ul>\n<li>这表示类型 <code>ty</code> 可以直接是一个已定义的类型标识符 <code>type-id</code>。</li>\n</ul>\n</li>\n<li>ty → ‘{’ tyfields ‘}’<ul>\n<li>这表示类型 <code>ty</code> 可以是一个记录（record），由花括号 <code>&#123;&#125;</code> 包围的一系列字段 <code>tyfields</code> 定义。</li>\n</ul>\n</li>\n<li>ty → array of type-id<ul>\n<li>这表示类型 <code>ty</code> 可以是一个数组，由关键字 <code>array of</code> 后跟一个类型标识符 <code>type-id</code> 定义。</li>\n</ul>\n</li>\n<li>tyfields → ε<ul>\n<li>这表示字段列表 <code>tyfields</code> 可以为空（ε 表示空串）。</li>\n</ul>\n</li>\n<li>tyfields → id: type-id {, id:type-id}<ul>\n<li>这表示字段列表 <code>tyfields</code> 由一个或多个字段组成，每个字段由一个标识符 <code>id</code> 和冒号 <code>:</code> 后跟一个类型标识符 <code>type-id</code> 定义，多个字段之间用逗号 <code>,</code> 分隔。</li>\n</ul>\n</li>\n</ol>\n<p>示例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let type a = &#123;x: int; y: int&#125;</span><br><span class=\"line\">    type b = a</span><br><span class=\"line\">    var i : a := ...</span><br><span class=\"line\">    var j : b := ...</span><br><span class=\"line\">in i := j</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"类型等价\"><a href=\"#类型等价\" class=\"headerlink\" title=\"类型等价\"></a>类型等价</h3><ul>\n<li>Name equivalence (NE): 必须声明是同一个类型才是同一类型</li>\n<li>Structure equivalence (SE): 如果两个类型的结构完全相同（即它们由相同的构造器以相同的顺序组成），那么它们就被认为是等价的，即使它们的名字不同</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type A = &#123;x: int; y: int&#125;</span><br><span class=\"line\">type B = &#123;x: int; y: int&#125; </span><br></pre></td></tr></table></figure>\n<p>Tiger用的是NE<br>在Tiger编程语言中，存在两个独立的命名空间：一个用于类型（Types），另一个用于函数和变量（Functions and Variables）。所以类型和函数&#x2F;变量可以存在相同的名字，但是函数和变量不能存在相同的名字。<br>所以需要两个env</p>\n<ul>\n<li>Type env<ul>\n<li>symbol -&gt; Ty_ty</li>\n</ul>\n</li>\n<li>Value env<ul>\n<li>对于变量，symbol -&gt; Ty_ty</li>\n<li>对于函数，symbol -&gt; struct{Ty_tyList formals, Ty_ty results}</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"类型检查的rule\"><a href=\"#类型检查的rule\" class=\"headerlink\" title=\"类型检查的rule\"></a>类型检查的rule</h3><p>类型检查分为两部分:</p>\n<ul>\n<li>Type-checking expressions: 对于每个表达式，根据当前的Type和Value环境来确定其类型，并检查是否符合语言的类型规则</li>\n<li>Type-checking declarations: 在Tiger语言中声明只可能在let语句中出现<br>好像就是讲了transExp, transDec, transVar，AST递归检查每个节点的类型然后一层一层往上传再检查</li>\n</ul>\n",
            "tags": [
                "语义分析"
            ]
        },
        {
            "id": "http://example.com/2025/03/29/computer-science/compile-principles/ch4/",
            "url": "http://example.com/2025/03/29/computer-science/compile-principles/ch4/",
            "title": "抽象语法",
            "date_published": "2025-03-28T16:00:00.000Z",
            "content_html": "",
            "tags": [
                "抽象语法"
            ]
        },
        {
            "id": "http://example.com/2025/03/23/computer-science/compile-principles/ch3/",
            "url": "http://example.com/2025/03/23/computer-science/compile-principles/ch3/",
            "title": "语法分析",
            "date_published": "2025-03-22T16:00:00.000Z",
            "content_html": "<h1 id=\"语法分析\"><a href=\"#语法分析\" class=\"headerlink\" title=\"语法分析\"></a>语法分析</h1><h2 id=\"CFG\"><a href=\"#CFG\" class=\"headerlink\" title=\"CFG\"></a>CFG</h2><p>见计算理论<br>Parse tree</p>\n<h3 id=\"Ambiguous-grammars\"><a href=\"#Ambiguous-grammars\" class=\"headerlink\" title=\"Ambiguous grammars\"></a>Ambiguous grammars</h3><h2 id><a href=\"#\" class=\"headerlink\" title></a></h2>",
            "tags": [
                "语法分析"
            ]
        },
        {
            "id": "http://example.com/2025/03/22/computer-science/compile-principles/ch2/",
            "url": "http://example.com/2025/03/22/computer-science/compile-principles/ch2/",
            "title": "词法分析",
            "date_published": "2025-03-21T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch2-词法分析\"><a href=\"#Ch2-词法分析\" class=\"headerlink\" title=\"Ch2 词法分析\"></a>Ch2 词法分析</h1><blockquote>\n<p>把input分解成一个个token</p>\n</blockquote>\n<h2 id=\"Regular-Expression\"><a href=\"#Regular-Expression\" class=\"headerlink\" title=\"Regular Expression\"></a>Regular Expression</h2><ul>\n<li>Language: a set of strings</li>\n<li>String: a finite sequence of characters<blockquote>\n<p>Regular Experssion Notations:<br><img data-src=\"/image-1.png\"></p>\n</blockquote>\n</li>\n</ul>\n<p>:::info<br>DFA, NFA相关 见计算理论<br>:::</p>\n<h2 id=\"RE转NFA\"><a href=\"#RE转NFA\" class=\"headerlink\" title=\"RE转NFA\"></a>RE转NFA</h2><p>:::info 方法：</p>\n<ol>\n<li>画出初始态和终态</li>\n<li>分裂规则：<br><img data-src=\"/image-2.jpg\"><br>:::</li>\n</ol>\n<h2 id=\"NFA转DFA\"><a href=\"#NFA转DFA\" class=\"headerlink\" title=\"NFA转DFA\"></a>NFA转DFA</h2><p>从初始状态的闭包开始，每次根据\\epsilon和当前状态的闭包，得到下一个状态的闭包，直到得到终态的闭包。</p>\n<p>+++info example<br>;;;id3 题目<br>:chestnut:<br>把这个NFA转成等价的DFA<br><img data-src=\"/image-3.png\"><br>;;;<br>;;;id3 答案<br>初态的闭包是1、2、6，1、2、6经过a可以转移到3、7，因为有\\epsilon转移，所以3、7的闭包是3、4、7、8，同理3、4、7、8经过b可以到5、8，由于8是终态，把所有包含8的圆圈画成终态的环。<br><img data-src=\"/image-4.png\"><br>;;;<br>+++</p>\n<h2 id=\"最小化DFA\"><a href=\"#最小化DFA\" class=\"headerlink\" title=\"最小化DFA\"></a>最小化DFA</h2><p>含义：</p>\n<ol>\n<li>没有多余状态：</li>\n</ol>\n<ul>\n<li>从这个状态没有通路到达终态</li>\n<li>从开始状态出发，任何输入串也不能到达的那个状态</li>\n</ul>\n<ol start=\"2\">\n<li>没有两个状态相互等价<br>:::info 方法：</li>\n<li>多余状态直接删除<br><img data-src=\"/image-5.png\"></li>\n<li>合并等价状态</li>\n</ol>\n<ul>\n<li>将状态分为终态和非终态两个集合</li>\n<li>遍历每个集合，如果经过转换到达的状态都在当前集合里，则不用分，否则划分子集，直到划分不了为止</li>\n<li>:chestnut: 例子</li>\n<li><img data-src=\"/image-6.png\"><br>:::</li>\n</ul>\n",
            "tags": [
                "词法分析"
            ]
        },
        {
            "id": "http://example.com/2025/03/21/computer-science/compile-principles/ch1/",
            "url": "http://example.com/2025/03/21/computer-science/compile-principles/ch1/",
            "title": "Introduction",
            "date_published": "2025-03-20T16:00:00.000Z",
            "content_html": "<blockquote>\n<p>ZJU 2025春夏编译原理 学习笔记</p>\n<p>主要基于虎书（<em>Modern Compiler Implementation in C</em>, Andrew W. Appel）和好多老师的ppt（ldm, yps），还有lzx的智云</p>\n</blockquote>\n<h1 id=\"CH1-Introduction\"><a href=\"#CH1-Introduction\" class=\"headerlink\" title=\"CH1 Introduction\"></a>CH1 Introduction</h1><ul>\n<li>Two Important Concepts<ul>\n<li>Phases（阶段）</li>\n<li>Interfaces（接口）</li>\n</ul>\n</li>\n</ul>\n<p>方框里的是phase，中间的是interface<br><img data-src=\"/image.png\"><br>各个阶段的描述<br><img data-src=\"/image-1.png\"><img data-src=\"/image-2.png\"></p>\n",
            "tags": [
                "编译原理"
            ]
        }
    ]
}