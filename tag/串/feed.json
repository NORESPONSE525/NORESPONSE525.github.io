{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog • All posts by \"串\" tag",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/10/05/computer-science/DS/ch4/",
            "url": "http://example.com/2025/10/05/computer-science/DS/ch4/",
            "title": "ch4",
            "date_published": "2025-10-04T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch4\"><a href=\"#Ch4\" class=\"headerlink\" title=\"Ch4\"></a>Ch4</h1><h2 id=\"模式匹配\"><a href=\"#模式匹配\" class=\"headerlink\" title=\"模式匹配\"></a>模式匹配</h2><p>i: 主串当前待比较的字符位置<br>j: 模式串当前待比较的字符位置</p>\n<p>字符串模式匹配，在主串中找到与模式串相同的子串</p>\n<h3 id=\"暴力算法\"><a href=\"#暴力算法\" class=\"headerlink\" title=\"暴力算法\"></a>暴力算法</h3><p>遍历主串，从每个和第一个字符相同的位置开始，继续比较后继字符<br>时间复杂度：$O(mn)$（主串长度n，模式串长度m）</p>\n<h3 id=\"KMP算法\"><a href=\"#KMP算法\" class=\"headerlink\" title=\"KMP算法\"></a>KMP算法</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVBENHkxbzduZC8/c3BtX2lkX2Zyb209MzMzLjEzODcuaG9tZXBhZ2UudmlkZW9fY2FyZC5jbGljayZ2ZF9zb3VyY2U9MWE3ZDhmNTk2ZjNkZmU0MGZlZTM0Yzg1OGVkNDdlNzM=\">https://www.bilibili.com/video/BV1PD4y1o7nd/?spm_id_from=333.1387.homepage.video_card.click&amp;vd_source=1a7d8f596f3dfe40fee34c858ed47e73</span><br>这个讲得好<br>:::danger<br>KMP算法中i永远不递减<br>:::</p>\n<p>前缀：除了最后一个字符外所有的头部子串<br>后缀：除了第一个字符外所有的尾部子串</p>\n<ul>\n<li>PM数组<br>方法：算出所有前缀的前缀和后缀的最长公共子串的长度，并保存在数组中（PM，部分匹配值）<br>从头开始，右滑位数 &#x3D; 已匹配的字符数 - 对应的部分匹配值（最后一个匹配的字符的PM）<br>&#x3D;&#x3D;时间复杂度：$O(m+n)$&#x3D;&#x3D;</li>\n<li>next数组<br>next数组代表匹配的时候子串中可以跳过匹配的字符个数</li>\n</ul>\n<p>$$ next[j] &#x3D; PM[j-1] + 1 $$<br>将模式串的PM表右移一位并整体+1，左边空缺用0来填充，右边溢出舍去<br>:::info<br>在上面方法中，串的编号是从1开始的<br>:::<br>当模式串在位置 j 与主串不匹配时，模式串应该向右滑动的位数 &#x3D; j - next[j-1]</p>\n<ul>\n<li>next数组的一般公式</li>\n</ul>\n<ol>\n<li>第1个是0，第2个是1</li>\n<li>当前位置前面的串的相等的最长的前缀和后缀的长度+1</li>\n<li>前缀后缀都不相等，填1</li>\n</ol>\n<p>直接看代码</p>\n<figure class=\"highlight c++\"><figcaption><span>KMP</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">get_next</span><span class=\"params\">(SString T, <span class=\"type\">int</span> nexxt[])</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">1</span>, j = <span class=\"number\">0</span>;   <span class=\"comment\">//i指向当前要计算next[i]的位置，j表示上一个最长前后缀长度</span></span><br><span class=\"line\">    next[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt; T.length)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j == <span class=\"number\">0</span> || T.ch[i] == T.ch[j])&#123;</span><br><span class=\"line\">            ++i;</span><br><span class=\"line\">            ++j;</span><br><span class=\"line\">            next[i] = j;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            j = next[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>next[0]是不用的</p>\n<p>KMP匹配算法</p>\n<figure class=\"highlight c++\"><figcaption><span>KMP</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">index_KMP</span><span class=\"params\">(SString S, SString T, <span class=\"type\">int</span> next[])</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">1</span>, j = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt;= S.length &amp;&amp; j &lt;= T.length)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j == <span class=\"number\">0</span> || S.ch[i] == T.ch[j])&#123;   <span class=\"comment\">//表示模式串已经回退到不能再回退的位置,此时必须让主串指针i前进一步，模式串从第一个字符重新开始匹配</span></span><br><span class=\"line\">            ++i;</span><br><span class=\"line\">            ++j;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            j = next[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(j &gt; T.length) <span class=\"keyword\">return</span> i - T.length;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>nextval数组<br>如果$p_j$和$p_{next[j]}$相等，让next[j]的值等于next[next[j]]，一直递归下去<br>如果跳转后的位置字符和当前字符相同，那就直接跳到更前面的位置（即 nextval[j]），避免无效比较</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>nextval</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">get_nextval</span><span class=\"params\">(SString T, <span class=\"type\">int</span> nextval[])</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">1</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    nextval[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt; T.length)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j == <span class=\"number\">0</span> || T.ch[i] == T.ch[j])&#123;</span><br><span class=\"line\">            ++i;</span><br><span class=\"line\">            ++j;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(T.ch[i] != T.ch[j])</span><br><span class=\"line\">                nextval[i] = j;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> nextval[i] = nextval[j];</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            j = nextval[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "串"
            ]
        }
    ]
}