{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog • All posts by \"串\" tag",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/10/05/computer-science/DS/ch4/",
            "url": "http://example.com/2025/10/05/computer-science/DS/ch4/",
            "title": "ch4",
            "date_published": "2025-10-04T16:00:00.000Z",
            "content_html": "<h1 id=\"ch4\"><a class=\"markdownIt-Anchor\" href=\"#ch4\">#</a> Ch4</h1>\n<h2 id=\"模式匹配\"><a class=\"markdownIt-Anchor\" href=\"#模式匹配\">#</a> 模式匹配</h2>\n<p>i: 主串当前待比较的字符位置<br>\n j: 模式串当前待比较的字符位置</p>\n<p>字符串模式匹配，在主串中找到与模式串相同的子串</p>\n<h3 id=\"暴力算法\"><a class=\"markdownIt-Anchor\" href=\"#暴力算法\">#</a> 暴力算法</h3>\n<p>遍历主串，从每个和第一个字符相同的位置开始，继续比较后继字符<br>\n时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(mn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>（主串长度 n，模式串长度 m）</p>\n<h3 id=\"kmp算法\"><a class=\"markdownIt-Anchor\" href=\"#kmp算法\">#</a> KMP 算法</h3>\n<p>前缀：除了最后一个字符外所有的头部子串<br>\n后缀：除了第一个字符外所有的尾部子串</p>\n<ul>\n<li>PM 数组<br>\n方法：算出所有前缀的前缀和后缀的最长公共子串，并保存在数组中（PM，部分匹配值）<br>\n从头开始，右滑位数 = 已匹配的字符数 - 对应的部分匹配值（最后一个匹配的字符的 PM）<br>\n<mark>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(m+n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></mark></li>\n<li>next 数组</li>\n</ul>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>P</mi><mi>M</mi><mo stretchy=\"false\">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">next[j] = PM[j-1] + 1 \n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span></span></p>\n<p>将模式串的 PM 表右移一位并整体 + 1，左边空缺用 0 来填充，右边溢出舍去</p>\n<div class=\"note info\">\n<p>在上面方法中，串的编号是从 1 开始的</p>\n</div>\n<p>当模式串在位置 j 与主串不匹配时，模式串应该向右滑动的位数 = j - next [j-1]</p>\n",
            "tags": [
                "串"
            ]
        }
    ]
}