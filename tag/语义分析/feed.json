{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog • All posts by \"语义分析\" tag",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/03/30/computer-science/compile-principles/ch5/",
            "url": "http://example.com/2025/03/30/computer-science/compile-principles/ch5/",
            "title": "语义分析",
            "date_published": "2025-03-29T16:00:00.000Z",
            "content_html": "<h1 id=\"语义分析\"><a href=\"#语义分析\" class=\"headerlink\" title=\"语义分析\"></a>语义分析</h1><blockquote>\n<p>绑定，类型检查</p>\n</blockquote>\n<h2 id=\"symbol-table\"><a href=\"#symbol-table\" class=\"headerlink\" title=\"symbol table\"></a>symbol table</h2><ul>\n<li><p>Imperative style: 命令式风格</p>\n<ul>\n<li>Modify $\\sigma_1$ until it becomes $\\sigma_2$. </li>\n<li>While $\\sigma_2$ exists, we cannot look things up in $\\sigma_1$. </li>\n<li>When done with $\\sigma_2$, can undo the modification to get $\\sigma_1$ back again.<br>+++info 方法：<br>Hashing<br>插入：找到哈希值然后插入链表的表头<br>查找：找到哈希值然后遍历链表<br>pop: 找到哈希值然后把链表表头删掉  table[hash(key)] &#x3D; table[hash(key)].next<br>+++</li>\n</ul>\n</li>\n<li><p>Functional style: 函数式风格</p>\n<ul>\n<li>To keep $\\sigma_1$ in pristine condition while creating create $\\sigma_2$ and $\\sigma_3$<br>+++info 方法：<br>如果依旧用哈希，每次要复制一遍哈希表，开销太大了，不现实<br><img data-src=\"/f2.jpg\"><br>所以用persistent BST<br><img data-src=\"/f1.jpg\"><br>先遍历二叉搜索树找到要插入的位置，然后对于插入节点把它从根节点到它全都复制一遍然后插入<br>+++</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Tiger编译器中的符号\"><a href=\"#Tiger编译器中的符号\" class=\"headerlink\" title=\"Tiger编译器中的符号\"></a>Tiger编译器中的符号</h2><p>对链表进行lookup的时候每一次都要进行string compare，开销是很大的。所以使用新的数据结构将符号对象关联到一个整数上，因此对于任意给定字符串的所有不同出现，都会被转换成同一个符号对象。<br>Symbol的实现：通过hash函数将字符串映射到一个symbol对象上<br>SymbolTable的实现：beginScope()和endScope()的实现</p>\n<ul>\n<li>beginScope()：添加一个marksym</li>\n<li>endScope()：从符号表中不断pop直到marksym</li>\n<li>引入一个 辅助栈(Auxiliary stack) 来维护<ul>\n<li>符号入栈时，会将binding联动地插入对应bucket的链表头</li>\n<li>弹出栈顶符号时，对应bucket的链表头也会联动地被移除</li>\n<li>beginScope: 压入一个特殊标记到辅助栈中</li>\n<li>endScope: 一直弹出符号直到弹出了一个特殊标记</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"类型检查\"><a href=\"#类型检查\" class=\"headerlink\" title=\"类型检查\"></a>类型检查</h2><h3 id=\"哪些类型表达式是合法-非法的\"><a href=\"#哪些类型表达式是合法-非法的\" class=\"headerlink\" title=\"哪些类型表达式是合法&#x2F;非法的\"></a>哪些类型表达式是合法&#x2F;非法的</h3><p>Tiger的类型系统：</p>\n<ul>\n<li>两种primitive type: int, string</li>\n<li>两种constructed type: records, arrays</li>\n</ul>\n<p>文法</p>\n<ol>\n<li>typec → type type-id &#x3D; ty<ul>\n<li>这表示定义一个类型。<code>typec</code> 是一个类型定义的开始，它由关键字 <code>type</code>、一个类型标识符 <code>type-id</code> 和一个等号 <code>=</code> 后跟类型定义 <code>ty</code> 组成。</li>\n</ul>\n</li>\n<li>ty → type-id<ul>\n<li>这表示类型 <code>ty</code> 可以直接是一个已定义的类型标识符 <code>type-id</code>。</li>\n</ul>\n</li>\n<li>ty → ‘{’ tyfields ‘}’<ul>\n<li>这表示类型 <code>ty</code> 可以是一个记录（record），由花括号 <code>&#123;&#125;</code> 包围的一系列字段 <code>tyfields</code> 定义。</li>\n</ul>\n</li>\n<li>ty → array of type-id<ul>\n<li>这表示类型 <code>ty</code> 可以是一个数组，由关键字 <code>array of</code> 后跟一个类型标识符 <code>type-id</code> 定义。</li>\n</ul>\n</li>\n<li>tyfields → ε<ul>\n<li>这表示字段列表 <code>tyfields</code> 可以为空（ε 表示空串）。</li>\n</ul>\n</li>\n<li>tyfields → id: type-id {, id:type-id}<ul>\n<li>这表示字段列表 <code>tyfields</code> 由一个或多个字段组成，每个字段由一个标识符 <code>id</code> 和冒号 <code>:</code> 后跟一个类型标识符 <code>type-id</code> 定义，多个字段之间用逗号 <code>,</code> 分隔。</li>\n</ul>\n</li>\n</ol>\n<p>示例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let type a = &#123;x: int; y: int&#125;</span><br><span class=\"line\">    type b = a</span><br><span class=\"line\">    var i : a := ...</span><br><span class=\"line\">    var j : b := ...</span><br><span class=\"line\">in i := j</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"类型等价\"><a href=\"#类型等价\" class=\"headerlink\" title=\"类型等价\"></a>类型等价</h3><ul>\n<li>Name equivalence (NE): 必须声明是同一个类型才是同一类型</li>\n<li>Structure equivalence (SE): 如果两个类型的结构完全相同（即它们由相同的构造器以相同的顺序组成），那么它们就被认为是等价的，即使它们的名字不同</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type A = &#123;x: int; y: int&#125;</span><br><span class=\"line\">type B = &#123;x: int; y: int&#125; </span><br></pre></td></tr></table></figure>\n<p>Tiger用的是NE<br>在Tiger编程语言中，存在两个独立的命名空间：一个用于类型（Types），另一个用于函数和变量（Functions and Variables）。所以类型和函数&#x2F;变量可以存在相同的名字，但是函数和变量不能存在相同的名字。<br>所以需要两个env</p>\n<ul>\n<li>Type env<ul>\n<li>symbol -&gt; Ty_ty</li>\n</ul>\n</li>\n<li>Value env<ul>\n<li>对于变量，symbol -&gt; Ty_ty</li>\n<li>对于函数，symbol -&gt; struct{Ty_tyList formals, Ty_ty results}</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"类型检查的rule\"><a href=\"#类型检查的rule\" class=\"headerlink\" title=\"类型检查的rule\"></a>类型检查的rule</h3><p>类型检查分为两部分:</p>\n<ul>\n<li>Type-checking expressions: 对于每个表达式，根据当前的Type和Value环境来确定其类型，并检查是否符合语言的类型规则</li>\n<li>Type-checking declarations: 在Tiger语言中声明只可能在let语句中出现<br>好像就是讲了transExp, transDec, transVar，AST递归检查每个节点的类型然后一层一层往上传再检查</li>\n</ul>\n",
            "tags": [
                "语义分析"
            ]
        }
    ]
}