{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog • All posts by \"活动记录\" tag",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/06/15/computer-science/compile-principles/ch6/",
            "url": "http://example.com/2025/06/15/computer-science/compile-principles/ch6/",
            "title": "Ch6",
            "date_published": "2025-06-14T16:00:00.000Z",
            "content_html": "<h1 id=\"Activation-Record-Stack-Frame\"><a href=\"#Activation-Record-Stack-Frame\" class=\"headerlink\" title=\"Activation Record&#x2F;Stack Frame\"></a>Activation Record&#x2F;Stack Frame</h1><p>函数的栈帧是栈上用来放函数的局部变量、参数、返回地址以及其他临时变量的区域<br>stack一般从高地址向低地址，heap从低地址向高地址<br>layout:<br><img data-src=\"/f1.jpg\"></p>\n<ul>\n<li>incoming arguments: 存储caller传递给callee的参数</li>\n<li>frame pointer: 帧指针，用来访问incoming arguments，从低向高是argument 1, argument 2, …</li>\n<li>local variables: 存储函数的局部变量（还有一些保存在寄存器里）</li>\n<li>return address: 存储需要返回caller的哪里；non-leaf过程会把return address写入栈帧里面</li>\n<li>temporaries: 存储临时变量，复杂表达式拆出来的中间变量放的地方</li>\n<li>saved registers</li>\n<li>outgoing arguments: 存储当前函数要传递给别的函数的参数</li>\n<li>stack pointer: 栈指针，从低向高</li>\n</ul>\n<h2 id=\"函数调用流程：\"><a href=\"#函数调用流程：\" class=\"headerlink\" title=\"函数调用流程：\"></a>函数调用流程：</h2><ul>\n<li>g调用f的时候</li>\n</ul>\n<ol>\n<li>进入f的时候，保存旧的FP(g的FP)</li>\n<li>把FP设置为原来的SP，把SP &#x3D; SP - frame size<br><img data-src=\"/f2.jpg\"></li>\n</ol>\n<ul>\n<li>f返回的时候</li>\n</ul>\n<ol>\n<li>让SP &#x3D; FP(恢复g的SP)</li>\n<li>从内存中读出g的FP恢复回去</li>\n</ol>\n<p>如果栈帧大小固定就只需要FP不需要SP了，因为FP &#x3D; SP + frame size</p>\n<h2 id=\"saved-register\"><a href=\"#saved-register\" class=\"headerlink\" title=\"saved register\"></a>saved register</h2><p>函数g调用f的时候，用到了寄存器r，调用f的时候要把r保存在saved register中，等调用结束再恢复回去</p>\n<ul>\n<li>caller-saved register: 函数调用的时候用到的寄存器，调用结束后可以恢复</li>\n<li>callee-saved register: 函数调用的时候用不到的寄存器，调用结束后不能恢复<br>&#x3D;&#x3D;FP是由callee保存和恢复的&#x3D;&#x3D;</li>\n</ul>\n<h2 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h2><p>一般约定把前k(4 or 6)个参数放在寄存器传递，剩下的参数放在栈中传递<br>四种传参方法：</p>\n<ol>\n<li>不给叶过程 (leaf procedure) 分配栈帧<br>叶过程是指不调用其他过程的过程。在这种情况下，可以不为叶过程分配栈帧</li>\n<li>过程间寄存器分配 (interprocedural register allocation)<br>这种方法需要先分析代码中全部的函数，然后再根据分析结果来分配寄存器。<br>假设有一个程序包含多个函数，通过全局分析发现某些变量在多个函数之间频繁使用，可以为其分配固定的寄存器，避免频繁的内存读写</li>\n<li>若变量 x 不再被使用，可以直接写其寄存器，不需要再保存 x 到栈帧中<br>当一个变量在当前作用域内不再被使用时，可以直接将其值写入寄存器，而无需保存到栈帧中</li>\n</ol>\n<figure class=\"highlight c\"><figcaption><span>example</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">exampleFunction</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> y = x * <span class=\"number\">2</span>;  <span class=\"comment\">// 使用x后，x不再被使用</span></span><br><span class=\"line\">    <span class=\"comment\">// 直接将y的值写入寄存器，无需保存x到栈帧中</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Result: %d\\n&quot;</span>, y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>寄存器窗口技术 (register windows)<br>在每次函数调用时，系统会自动切换到一组新的寄存器，称为寄存器窗口。这样，每个函数都可以独立地使用自己的寄存器，而不会影响其他函数的寄存器状态。</li>\n</ol>\n<figure class=\"highlight c\"><figcaption><span>example</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">functionA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用寄存器窗口A</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">functionB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用寄存器窗口B</span></span><br><span class=\"line\">    functionA();  <span class=\"comment\">// 调用functionA时，自动切换到寄存器窗口A</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Frame-Resident-Variables\"><a href=\"#Frame-Resident-Variables\" class=\"headerlink\" title=\"Frame-Resident Variables\"></a>Frame-Resident Variables</h2><p>什么情况下要把变量写入栈帧里面？、</p>\n<ol>\n<li>the varibles will be passed by reference 变量传地址&#x2F;引用</li>\n<li>变量被嵌套在函数内部的函数访问（不绝对）</li>\n<li>变量太大了没法直接放寄存器</li>\n<li>变量是一个数组</li>\n<li>传递参数</li>\n<li>有太多局部变量和临时变量放不下了</li>\n</ol>\n<ul>\n<li>escape 逃逸：如果一个变量需要传地址&#x2F;取地址&#x2F;被过程内部嵌套的函数访问，那么这个变量就会逃逸。</li>\n</ul>\n<h2 id=\"static-links\"><a href=\"#static-links\" class=\"headerlink\" title=\"static links\"></a>static links</h2><p>在嵌套的函数声明中，内层函数是有可能用到外层函数的局部变量的。</p>\n<ul>\n<li>static links是指向上一层嵌套层级的栈帧的指针。内层嵌套函数调用外层定义的变量的时候需要用到static links，否则无法寻址。<br><img data-src=\"/f3.jpg\"><br><img data-src=\"/f4.jpg\"><br>只有调用自身的时候才传递自己的static link作为static link，其他的都是把外层函数的fp作为static link<br>如果要访问外层变量，就顺着static一层一层查上去直到找到了为止。<br>其他访问方法：</li>\n<li>嵌套层次显示表(display)<br>建立一个全局数组，位置i包含一个指针，指向最近一次进入的，其静态嵌套深度是i的过程的栈帧<br><img data-src=\"/f5.jpg\"><br>先给它们标上嵌套深度<br>直接把链表变成数组了，需要用到一个变量，就查看当前变量的嵌套深度i然后直接找那个数组i位置的座位fp地址来找</li>\n<li>lambda lifting<br>g调用f时，g中每一个实际（或被嵌套在f内的任意函数）访问了的变量，都将作为额外的参数传递给f<br>把内部的函数，从内往外进行改写，改写函数的参数实现lambda lifting<br><img data-src=\"/f6.jpg\"></li>\n</ul>\n<h2 id=\"tiger编译器的栈帧\"><a href=\"#tiger编译器的栈帧\" class=\"headerlink\" title=\"tiger编译器的栈帧\"></a>tiger编译器的栈帧</h2><p>tiger不支持高阶函数<br>看不完了。。再说吧</p>\n",
            "tags": [
                "活动记录"
            ]
        }
    ]
}