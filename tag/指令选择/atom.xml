<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>NoResponse&#39;s Blog • Posts by &#34;指令选择&#34; tag</title>
    <link href="http://example.com" />
    <updated>2025-06-16T16:00:00.000Z</updated>
    <category term="人工智能" />
    <category term="软件工程" />
    <category term="自监督学习" />
    <category term="操作系统" />
    <category term="线性表" />
    <category term="数据结构" />
    <category term="编译原理" />
    <category term="Register Allocation" />
    <category term="语法分析" />
    <category term="词法分析" />
    <category term="Liveness Analysis" />
    <category term="抽象语法" />
    <category term="语义分析" />
    <category term="活动记录" />
    <category term="中间代码" />
    <category term="指令选择" />
    <category term="Basic Blocks and Traces" />
    <category term="计算机组成" />
    <category term="计算机网络" />
    <category term="数据的表示与运算" />
    <category term="存储系统" />
    <category term="总线" />
    <category term="CPU" />
    <category term="I/O" />
    <category term="指令系统" />
    <category term="错题" />
    <entry>
        <id>http://example.com/2025/06/17/computer-science/compile-principles/ch9/</id>
        <title>指令选择</title>
        <link rel="alternate" href="http://example.com/2025/06/17/computer-science/compile-principles/ch9/"/>
        <content type="html">&lt;h1 id=&#34;指令选择&#34;&gt;&lt;a href=&#34;#指令选择&#34; class=&#34;headerlink&#34; title=&#34;指令选择&#34;&gt;&lt;/a&gt;指令选择&lt;/h1&gt;&lt;p&gt;找出实现一个给定的IR Tree的恰当机器指令序列。Mapping IR into abstract assembly code&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Abstract assembly &amp;#x3D; assembly with infinite registers&lt;ul&gt;
&lt;li&gt;Invent new temporaries for intermediate results&lt;/li&gt;
&lt;li&gt;Map to actual registers later&lt;br&gt;Tree pattern, 也叫tile&lt;br&gt;本质上是pattern matching, 我们使用tree covering 来实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们&lt;code&gt;Jouette&lt;/code&gt;体系将树模式映射为指令:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;寄存器中可以存储数据或地址，每条指令可以访问任意寄存器&lt;/li&gt;
&lt;li&gt;寄存器r0的值永远是0&lt;/li&gt;
&lt;li&gt;每条指令的latency都是一周期（除了MOVEM的周期是m）&lt;/li&gt;
&lt;li&gt;每个周期执行一条指令&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;/f2.jpg&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/f1.jpg&#34;&gt;&lt;br&gt;将IR与后端的机器指令都转换为树结构。这样就把指令选择问题转换为机器指令树覆盖全IR Tree的问题。&lt;br&gt;一棵树可以有多种tiling方式&lt;/p&gt;
&lt;h2 id=&#34;Optimal-Tiling-Optimum-Tiling&#34;&gt;&lt;a href=&#34;#Optimal-Tiling-Optimum-Tiling&#34; class=&#34;headerlink&#34; title=&#34;Optimal Tiling &amp;amp; Optimum Tiling&#34;&gt;&lt;/a&gt;Optimal Tiling &amp;amp; Optimum Tiling&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Optimum Tiling：使得tiling数最少，是&amp;#x3D;&amp;#x3D;全局最优&amp;#x3D;&amp;#x3D;&lt;/li&gt;
&lt;li&gt;Optimal Tiling：No two adjacent tiles can be combined into a single tile of lower cost，是&amp;#x3D;&amp;#x3D;局部最优&amp;#x3D;&amp;#x3D;&lt;br&gt;一个optimum tiling必定是optimal tiling&lt;br&gt;&lt;img data-src=&#34;/f3.jpg&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Algorithms-for-Instruction-Selection&#34;&gt;&lt;a href=&#34;#Algorithms-for-Instruction-Selection&#34; class=&#34;headerlink&#34; title=&#34;Algorithms for Instruction Selection&#34;&gt;&lt;/a&gt;Algorithms for Instruction Selection&lt;/h2&gt;&lt;h3 id=&#34;Maximal-Munch-Find-an-optimal-tiling&#34;&gt;&lt;a href=&#34;#Maximal-Munch-Find-an-optimal-tiling&#34; class=&#34;headerlink&#34; title=&#34;Maximal Munch: Find an optimal tiling&#34;&gt;&lt;/a&gt;Maximal Munch: Find an optimal tiling&lt;/h3&gt;&lt;p&gt;最大匹配：贪心算法、自顶向下&lt;br&gt;方法：从IR树的根节点开始，用&amp;#x3D;&amp;#x3D;最大的&amp;#x3D;&amp;#x3D;tile覆盖当前节点（包含最多节点的），然后在子树中重复此过程&lt;/p&gt;
&lt;h3 id=&#34;DP&#34;&gt;&lt;a href=&#34;#DP&#34; class=&#34;headerlink&#34; title=&#34;DP&#34;&gt;&lt;/a&gt;DP&lt;/h3&gt;&lt;p&gt;动态规划：自底向上&lt;br&gt;方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;递归计算每个子树的最优平铺成本&lt;/li&gt;
&lt;li&gt;对于每个节点，考虑所有可能的匹配平铺&lt;/li&gt;
&lt;li&gt;对于每个匹配平铺，计算其成本如下：cost &amp;#x3D; tile_cost + sum（costs_of_children）&lt;/li&gt;
&lt;li&gt;选择成本最低的平铺&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;对于$CONST i$，它的代价为1( ADD r1, r0, i)&lt;/li&gt;
&lt;li&gt;对于这棵树，有三种匹配方法&lt;br&gt;&lt;img data-src=&#34;/f4.jpg&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/f5.jpg&#34;&gt;&lt;br&gt;因为2&amp;lt;3，所以我们从cost&amp;#x3D;2的两个任选一个&lt;br&gt;接下来对于MEM，用的都是LOAD，代价都是1，2&amp;lt;3所以选cost&amp;#x3D;2的&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;指令发射&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;function &lt;span class=&#34;title function_&#34;&gt;Emission&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(node n)&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    For each leaf l_i of the tile selected at node n:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;title function_&#34;&gt;Emission&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(l_i)&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    Emit the instruction matched at node n&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;最大匹配-vs-动态规划&#34;&gt;&lt;a href=&#34;#最大匹配-vs-动态规划&#34; class=&#34;headerlink&#34; title=&#34;最大匹配 vs 动态规划&#34;&gt;&lt;/a&gt;最大匹配 vs 动态规划&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;T&lt;/strong&gt; - tile的总种类数  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;K&lt;/strong&gt; - 一个matching tile平均覆盖的节点数  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;K’&lt;/strong&gt; - 需要检查的最大tile尺寸（即最大的瓦片包含的节点数）  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;T’&lt;/strong&gt; - 每个树节点平均能匹配上的tile数量  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;N&lt;/strong&gt; - 输入的中间表示IR Tree中的总节点数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两种算法的运行时间复杂度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;最大匹配（Maximal Munch）&lt;/strong&gt; - 其时间复杂度与&lt;br&gt;$$&lt;br&gt;\frac{(K’ + T’) * K}{K} * N &amp;#x3D; (K’ + T’) * N&lt;br&gt;$$&lt;br&gt;成正比&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;动态规划（Dynamic Programming）&lt;/strong&gt; - 其时间复杂度与&lt;br&gt;$$&lt;br&gt;(K’ + T’) * N&lt;br&gt;$$&lt;br&gt;成正比&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Tree-Grammar-树文法&#34;&gt;&lt;a href=&#34;#Tree-Grammar-树文法&#34; class=&#34;headerlink&#34; title=&#34;Tree Grammar 树文法&#34;&gt;&lt;/a&gt;Tree Grammar 树文法&lt;/h2&gt;&lt;p&gt;问题：对于具有复杂指令集和多种寄存器类型及寻址模式的机器，难以使用简单的tree pattern和tiling算法。&lt;br&gt;用一种文法来描述tiles，代替手写过程式匹配代码，支持自动化的指令选择，增强了可移植性&lt;br&gt;图没看懂，后面再回来研究&lt;/p&gt;
</content>
        <category term="指令选择" />
        <updated>2025-06-16T16:00:00.000Z</updated>
    </entry>
</feed>
