{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog • All posts by \"指令选择\" tag",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/06/17/computer-science/compile-principles/ch9/",
            "url": "http://example.com/2025/06/17/computer-science/compile-principles/ch9/",
            "title": "指令选择",
            "date_published": "2025-06-16T16:00:00.000Z",
            "content_html": "<h1 id=\"指令选择\"><a href=\"#指令选择\" class=\"headerlink\" title=\"指令选择\"></a>指令选择</h1><p>找出实现一个给定的IR Tree的恰当机器指令序列。Mapping IR into abstract assembly code</p>\n<ul>\n<li>Abstract assembly &#x3D; assembly with infinite registers<ul>\n<li>Invent new temporaries for intermediate results</li>\n<li>Map to actual registers later<br>Tree pattern, 也叫tile<br>本质上是pattern matching, 我们使用tree covering 来实现</li>\n</ul>\n</li>\n</ul>\n<p>我们<code>Jouette</code>体系将树模式映射为指令:</p>\n<ul>\n<li>寄存器中可以存储数据或地址，每条指令可以访问任意寄存器</li>\n<li>寄存器r0的值永远是0</li>\n<li>每条指令的latency都是一周期（除了MOVEM的周期是m）</li>\n<li>每个周期执行一条指令</li>\n</ul>\n<p><img data-src=\"/f2.jpg\"><br><img data-src=\"/f1.jpg\"><br>将IR与后端的机器指令都转换为树结构。这样就把指令选择问题转换为机器指令树覆盖全IR Tree的问题。<br>一棵树可以有多种tiling方式</p>\n<h2 id=\"Optimal-Tiling-Optimum-Tiling\"><a href=\"#Optimal-Tiling-Optimum-Tiling\" class=\"headerlink\" title=\"Optimal Tiling &amp; Optimum Tiling\"></a>Optimal Tiling &amp; Optimum Tiling</h2><ul>\n<li>Optimum Tiling：使得tiling数最少，是&#x3D;&#x3D;全局最优&#x3D;&#x3D;</li>\n<li>Optimal Tiling：No two adjacent tiles can be combined into a single tile of lower cost，是&#x3D;&#x3D;局部最优&#x3D;&#x3D;<br>一个optimum tiling必定是optimal tiling<br><img data-src=\"/f3.jpg\"></li>\n</ul>\n<h2 id=\"Algorithms-for-Instruction-Selection\"><a href=\"#Algorithms-for-Instruction-Selection\" class=\"headerlink\" title=\"Algorithms for Instruction Selection\"></a>Algorithms for Instruction Selection</h2><h3 id=\"Maximal-Munch-Find-an-optimal-tiling\"><a href=\"#Maximal-Munch-Find-an-optimal-tiling\" class=\"headerlink\" title=\"Maximal Munch: Find an optimal tiling\"></a>Maximal Munch: Find an optimal tiling</h3><p>最大匹配：贪心算法、自顶向下<br>方法：从IR树的根节点开始，用&#x3D;&#x3D;最大的&#x3D;&#x3D;tile覆盖当前节点（包含最多节点的），然后在子树中重复此过程</p>\n<h3 id=\"DP\"><a href=\"#DP\" class=\"headerlink\" title=\"DP\"></a>DP</h3><p>动态规划：自底向上<br>方法：</p>\n<ol>\n<li>递归计算每个子树的最优平铺成本</li>\n<li>对于每个节点，考虑所有可能的匹配平铺</li>\n<li>对于每个匹配平铺，计算其成本如下：cost &#x3D; tile_cost + sum（costs_of_children）</li>\n<li>选择成本最低的平铺</li>\n</ol>\n<ul>\n<li>对于$CONST i$，它的代价为1( ADD r1, r0, i)</li>\n<li>对于这棵树，有三种匹配方法<br><img data-src=\"/f4.jpg\"><br><img data-src=\"/f5.jpg\"><br>因为2&lt;3，所以我们从cost&#x3D;2的两个任选一个<br>接下来对于MEM，用的都是LOAD，代价都是1，2&lt;3所以选cost&#x3D;2的</li>\n</ul>\n<figure class=\"highlight c\"><figcaption><span>指令发射</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function <span class=\"title function_\">Emission</span><span class=\"params\">(node n)</span>:</span><br><span class=\"line\">    For each leaf l_i of the tile selected at node n:</span><br><span class=\"line\">        <span class=\"title function_\">Emission</span><span class=\"params\">(l_i)</span> </span><br><span class=\"line\">    Emit the instruction matched at node n</span><br></pre></td></tr></table></figure>\n<h3 id=\"最大匹配-vs-动态规划\"><a href=\"#最大匹配-vs-动态规划\" class=\"headerlink\" title=\"最大匹配 vs 动态规划\"></a>最大匹配 vs 动态规划</h3><ul>\n<li><strong>T</strong> - tile的总种类数  </li>\n<li><strong>K</strong> - 一个matching tile平均覆盖的节点数  </li>\n<li><strong>K’</strong> - 需要检查的最大tile尺寸（即最大的瓦片包含的节点数）  </li>\n<li><strong>T’</strong> - 每个树节点平均能匹配上的tile数量  </li>\n<li><strong>N</strong> - 输入的中间表示IR Tree中的总节点数</li>\n</ul>\n<p>两种算法的运行时间复杂度：</p>\n<ul>\n<li><p><strong>最大匹配（Maximal Munch）</strong> - 其时间复杂度与<br>$$<br>\\frac{(K’ + T’) * K}{K} * N &#x3D; (K’ + T’) * N<br>$$<br>成正比</p>\n</li>\n<li><p><strong>动态规划（Dynamic Programming）</strong> - 其时间复杂度与<br>$$<br>(K’ + T’) * N<br>$$<br>成正比</p>\n</li>\n</ul>\n<h2 id=\"Tree-Grammar-树文法\"><a href=\"#Tree-Grammar-树文法\" class=\"headerlink\" title=\"Tree Grammar 树文法\"></a>Tree Grammar 树文法</h2><p>问题：对于具有复杂指令集和多种寄存器类型及寻址模式的机器，难以使用简单的tree pattern和tiling算法。<br>用一种文法来描述tiles，代替手写过程式匹配代码，支持自动化的指令选择，增强了可移植性<br>图没看懂，后面再回来研究</p>\n",
            "tags": [
                "指令选择"
            ]
        }
    ]
}