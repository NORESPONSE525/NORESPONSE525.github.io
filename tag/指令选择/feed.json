{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog • All posts by \"指令选择\" tag",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/06/17/computer-science/compile-principles/ch9/",
            "url": "http://example.com/2025/06/17/computer-science/compile-principles/ch9/",
            "title": "指令选择",
            "date_published": "2025-06-16T16:00:00.000Z",
            "content_html": "<h1 id=\"指令选择\"><a class=\"markdownIt-Anchor\" href=\"#指令选择\">#</a> 指令选择</h1>\n<p>找出实现一个给定的 IR Tree 的恰当机器指令序列。Mapping IR into abstract assembly code</p>\n<ul>\n<li>Abstract assembly = assembly with infinite registers\n<ul>\n<li>Invent new temporaries for intermediate results</li>\n<li>Map to actual registers later<br>\nTree pattern, 也叫 tile<br>\n 本质上是 pattern matching, 我们使用 tree covering 来实现</li>\n</ul>\n</li>\n</ul>\n<p>我们 <code>Jouette</code>  体系将树模式映射为指令:</p>\n<ul>\n<li>寄存器中可以存储数据或地址，每条指令可以访问任意寄存器</li>\n<li>寄存器 r0 的值永远是 0</li>\n<li>每条指令的 latency 都是一周期（除了 MOVEM 的周期是 m）</li>\n<li>每个周期执行一条指令</li>\n</ul>\n<p><img data-src=\"f2.jpg\" alt><br>\n<img data-src=\"f1.jpg\" alt><br>\n将 IR 与后端的机器指令都转换为树结构。这样就把指令选择问题转换为机器指令树覆盖全 IR Tree 的问题。<br>\n一棵树可以有多种 tiling 方式</p>\n<h2 id=\"optimal-tiling-optimum-tiling\"><a class=\"markdownIt-Anchor\" href=\"#optimal-tiling-optimum-tiling\">#</a> Optimal Tiling &amp; Optimum Tiling</h2>\n<ul>\n<li>Optimum Tiling：使得 tiling 数最少，是<mark>全局最优</mark></li>\n<li>Optimal Tiling：No two adjacent tiles can be combined into a single tile of lower cost，是<mark>局部最优</mark><br>\n一个 optimum tiling 必定是 optimal tiling<br>\n<img data-src=\"f3.jpg\" alt></li>\n</ul>\n<h2 id=\"algorithms-for-instruction-selection\"><a class=\"markdownIt-Anchor\" href=\"#algorithms-for-instruction-selection\">#</a> Algorithms for Instruction Selection</h2>\n<h3 id=\"maximal-munch-find-an-optimal-tiling\"><a class=\"markdownIt-Anchor\" href=\"#maximal-munch-find-an-optimal-tiling\">#</a> Maximal Munch: Find an optimal tiling</h3>\n<p>最大匹配：贪心算法、自顶向下<br>\n方法：从 IR 树的根节点开始，用<mark>最大的</mark> tile 覆盖当前节点（包含最多节点的），然后在子树中重复此过程</p>\n<h3 id=\"dp\"><a class=\"markdownIt-Anchor\" href=\"#dp\">#</a> DP</h3>\n<p>动态规划：自底向上<br>\n方法：</p>\n<ol>\n<li>递归计算每个子树的最优平铺成本</li>\n<li>对于每个节点，考虑所有可能的匹配平铺</li>\n<li>对于每个匹配平铺，计算其成本如下：cost = tile_cost + sum（costs_of_children）</li>\n<li>选择成本最低的平铺</li>\n</ol>\n<ul>\n<li>对于<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mi>O</mi><mi>N</mi><mi>S</mi><mi>T</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">CONST i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\">i</span></span></span></span>，它的代价为 1 (ADD r1, r0, i)</li>\n<li>对于这棵树，有三种匹配方法<br>\n<img data-src=\"f4.jpg\" alt><br>\n<img data-src=\"f5.jpg\" alt><br>\n因为 2&lt;3，所以我们从 cost=2 的两个任选一个<br>\n接下来对于 MEM，用的都是 LOAD，代价都是 1，2&lt;3 所以选 cost=2 的</li>\n</ul>\n<figure class=\"highlight c\"><figcaption><span>指令发射</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function <span class=\"title function_\">Emission</span><span class=\"params\">(node n)</span>:</span><br><span class=\"line\">    For each leaf l_i of the tile selected at node n:</span><br><span class=\"line\">        <span class=\"title function_\">Emission</span><span class=\"params\">(l_i)</span> </span><br><span class=\"line\">    Emit the instruction matched at node n</span><br></pre></td></tr></table></figure>\n<h3 id=\"最大匹配-vs-动态规划\"><a class=\"markdownIt-Anchor\" href=\"#最大匹配-vs-动态规划\">#</a> 最大匹配 vs 动态规划</h3>\n<ul>\n<li><strong>T</strong> - tile 的总种类数</li>\n<li><strong>K</strong> - 一个 matching tile 平均覆盖的节点数</li>\n<li><strong>K’</strong> - 需要检查的最大 tile 尺寸（即最大的瓦片包含的节点数）</li>\n<li><strong>T’</strong> - 每个树节点平均能匹配上的 tile 数量</li>\n<li><strong>N</strong> - 输入的中间表示 IR Tree 中的总节点数</li>\n</ul>\n<p>两种算法的运行时间复杂度：</p>\n<ul>\n<li><strong>最大匹配（Maximal Munch）</strong> - 其时间复杂度与</li>\n</ul>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mo stretchy=\"false\">(</mo><msup><mi>K</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>+</mo><msup><mi>T</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">)</mo><mo>∗</mo><mi>K</mi></mrow><mi>K</mi></mfrac><mo>∗</mo><mi>N</mi><mo>=</mo><mo stretchy=\"false\">(</mo><msup><mi>K</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>+</mo><msup><mi>T</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">)</mo><mo>∗</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">\\frac{(K&#x27; + T&#x27;) * K}{K} * N = (K&#x27; + T&#x27;) * N\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.114892em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.428892em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.051892em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.801892em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.051892em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.801892em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span></p>\n<p>成正比</p>\n<ul>\n<li><strong>动态规划（Dynamic Programming）</strong> - 其时间复杂度与</li>\n</ul>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mo stretchy=\"false\">(</mo><msup><mi>K</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>+</mo><msup><mi>T</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">)</mo><mo>∗</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">(K&#x27; + T&#x27;) * N\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.051892em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.801892em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.051892em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.801892em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span></p>\n<p>成正比</p>\n<h2 id=\"tree-grammar-树文法\"><a class=\"markdownIt-Anchor\" href=\"#tree-grammar-树文法\">#</a> Tree Grammar 树文法</h2>\n<p>问题：对于具有复杂指令集和多种寄存器类型及寻址模式的机器，难以使用简单的 tree pattern 和 tiling 算法。<br>\n用一种文法来描述 tiles，代替手写过程式匹配代码，支持自动化的指令选择，增强了可移植性<br>\n图没看懂，后面再回来研究</p>\n",
            "tags": [
                "指令选择"
            ]
        }
    ]
}