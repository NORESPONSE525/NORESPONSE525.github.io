{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog • All posts by \"图论\" tag",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/10/11/computer-science/DS/ch6/",
            "url": "http://example.com/2025/10/11/computer-science/DS/ch6/",
            "title": "ch6",
            "date_published": "2025-10-10T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch6\"><a href=\"#Ch6\" class=\"headerlink\" title=\"Ch6\"></a>Ch6</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>$$<br>G &#x3D; (V, E)<br>$$<br>图的顶点至少要有一个，边可以没有<br>顶点数：$|V|$<br>边数：$|E|$</p>\n<ul>\n<li>有向图、无向图</li>\n<li>简单图（不存在重复边、不存在到自身的边）、多重图</li>\n<li>度、入度、出度<br>$$<br>TD(v) &#x3D; ID(v) + OD(v)<br>$$</li>\n<li>有向图所有顶点的入度和出度之和相等，且等于边数</li>\n<li>路径、路径长度、回路</li>\n<li>简单路径、简单回路（顶点不重复出现）</li>\n<li>距离（从u到v的最短路径的长度，若不存在路径则为无穷大）</li>\n<li>子图：由某几个顶点和某几条边组成的图</li>\n<li>连通、连通图和连通分量<br>&#x3D;&#x3D;无向图中&#x3D;&#x3D;从v到w有路径存在，则v和w是连通的<br>若图中任意两个顶点都连通，则该图是<code>连通图</code>，否则是非连通图<br>无向图中的极大连通子图称为<code>连通分量</code><blockquote>\n<p>有$n$个顶点的连通图中，至少存在$n-1$条边（边数小于$n-1$一定是非连通图）<br>$n$个顶点的非连通图，最多有$n-2$条边</p>\n</blockquote>\n</li>\n<li>强连通图、强连通分量<br>在&#x3D;&#x3D;有向图中&#x3D;&#x3D;，若有一对顶点v和w，从v到w有路径，从w到v有路径，则v和w是强连通的<br>若图中任意两个顶点都强连通，则该图是<code>强连通图</code>，否则是非强连通图<br>有向图中的极大强连通子图称为<code>强连通分量</code><blockquote>\n<p>一个有向图有$n$个顶点，如果它是强连通图，则至少有$n$条边（环路）</p>\n</blockquote>\n</li>\n<li>生成树、生成森林<br>连通图的生成树是包含所有顶点的极小连通子图（若有$n$个顶点则生成树有$n-1$条边）<blockquote>\n<p>极大连通子图vs极小连通子图<br>极大连通子图要求连通且包含尽可能多的顶点和边，极小联通子图要求保持连通且边数最少</p>\n</blockquote>\n</li>\n<li>边的权、网和带权路径长度<br>带权图中，边有权值。路径上所有边的权值之和称为带权路径长度</li>\n<li>完全图（也称简单完全图）<br>无向图，有$n$个顶点，有$n(n-1)&#x2F;2$条边的，称为完全（无向）图（顶点两两之间都有边）<br>有向图，有$n$个顶点，有$n(n-1)$条边的，称为完全（有向）图</li>\n<li>稠密图、稀疏图<br>当$|E| &lt; |V|log_2{|v|}$时，可以视为稀疏图</li>\n<li>有向树<br>一个顶点入度为0，其他顶点入度均为1的有向图，称为有向树</li>\n</ul>\n<h2 id=\"图的存储及基本操作\"><a href=\"#图的存储及基本操作\" class=\"headerlink\" title=\"图的存储及基本操作\"></a>图的存储及基本操作</h2><h3 id=\"邻接矩阵法\"><a href=\"#邻接矩阵法\" class=\"headerlink\" title=\"邻接矩阵法\"></a>邻接矩阵法</h3><p>$$<br>A[i][j] &#x3D;<br>\\begin{cases}<br>1, &amp; \\text{如果顶点 } i \\text{ 和顶点 } j \\text{ 之间有边} \\<br>0, &amp; \\text{否则}<br>\\end{cases}<br>$$<br>带权图：<br>$$<br>A[i][j] &#x3D;<br>\\begin{cases}<br>w_{ij}, &amp; \\text{如果顶点 } i \\text{ 和 } j \\text{ 之间有边，权重为 } w_{ij} \\<br>0 \\text{ 或 } \\infty, &amp; \\text{如果没有边}<br>\\end{cases}<br>$$</p>\n<figure class=\"highlight c++\"><figcaption><span>邻接矩阵</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxVertexNum 100</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">char</span> VertexType;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> EdgeType;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    VertexType vex[MaxVertexNum];   <span class=\"comment\">// 顶点表</span></span><br><span class=\"line\">    EdgeType edge[MaxVertexNum][MaxVertexNum];  <span class=\"comment\">// 邻接矩阵</span></span><br><span class=\"line\">    <span class=\"type\">int</span> vexnum, edgnum;</span><br><span class=\"line\">&#125;MGraph;</span><br></pre></td></tr></table></figure>\n<p>无向图的邻接矩阵一定是对称的，所以只需要存上三角（或下三角）就行</p>\n<blockquote>\n<p>对于无向图，邻接矩阵第$i$行非零元素的个数即为顶点$i$的度<br>对于有向图，邻接矩阵第$i$行非零元素的个数即为顶点$i$的出度，第$i$列非零元素的个数即为顶点$i$的入度<br>邻接矩阵适合稠密图</p>\n</blockquote>\n<h3 id=\"邻接表法\"><a href=\"#邻接表法\" class=\"headerlink\" title=\"邻接表法\"></a>邻接表法</h3><p>稀疏图适合用邻接表存储<br><img data-src=\"/f1.jpg\"></p>\n<figure class=\"highlight c++\"><figcaption><span>邻接表</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxVertexNum 100</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">ArcNode</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> adjvex;  <span class=\"comment\">// 邻接点</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">ArcNode</span> *nextarc;</span><br><span class=\"line\">&#125;ArcNode;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">VNode</span> &#123;</span><br><span class=\"line\">    VertexType data;</span><br><span class=\"line\">    ArcNode *firstarc;</span><br><span class=\"line\">&#125;VNode, AdjList[MaxVertexNum];</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    AdjList vertices;</span><br><span class=\"line\">    <span class=\"type\">int</span> vexnum, arcnum;</span><br><span class=\"line\">&#125;ALGraph;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>对于无向图，所需要的空间为$O(|V|+2|E|)$；若为有向图，空间为$O(|V|+|E|)$</p>\n</blockquote>\n<h3 id=\"十字链表\"><a href=\"#十字链表\" class=\"headerlink\" title=\"十字链表\"></a>十字链表</h3><p>&#x3D;&#x3D;有向图&#x3D;&#x3D;的一种链式存储结构<br>每条弧、顶点都用结点表示<br>顶点结点<br><code>firstIn</code>表示进入这个结点的第一个弧节点，<code>firstOut</code>表示出去这个结点的第一个弧节点<br><img data-src=\"/f2.png\"><br><img data-src=\"/f4.png\"><br>弧结点<br><code>tailVexh</code>和<code>headVex</code>存放弧尾和弧头在顶点数组的编号。<code>hLink</code>则表示指向弧头相同的下一条弧，<code>tLink</code>则表示指向弧尾相同的下一条弧<br><img data-src=\"/f3.png\"><br>:::danger<br>王道这里的弧头指的是箭头的头部，弧尾指的是箭头的尾部，王道这一部分不知道哪个天才写的，纯误导人，直接看英语就行了<br>:::</p>\n<p>+++primary 示例<br><img data-src=\"/f5.png\"><br><img data-src=\"/f6.png\"><br>+++</p>\n<h3 id=\"邻接多重表\"><a href=\"#邻接多重表\" class=\"headerlink\" title=\"邻接多重表\"></a>邻接多重表</h3><p>无向图的一种链式存储结构<br>边结点：<br>| ivex | ilink | jvex | jlink | (info) |<br>顶点结点：<br>| data | firstedge |<br>和十字链表差不多意思，只不过这个是无向图<br><img data-src=\"/f7.jpg\"></p>\n<h3 id=\"图的基本操作\"><a href=\"#图的基本操作\" class=\"headerlink\" title=\"图的基本操作\"></a>图的基本操作</h3><h2 id=\"图的遍历\"><a href=\"#图的遍历\" class=\"headerlink\" title=\"图的遍历\"></a>图的遍历</h2><ol>\n<li>BFS<br>用队列实现，入队的时候visit，出队的时候检查邻接点</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>BFS邻接表实现</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">BFS</span><span class=\"params\">(ALGraph G, <span class=\"type\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">visit</span>(i);</span><br><span class=\"line\">    visited[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"built_in\">EnQueue</span>(Q, i);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!<span class=\"built_in\">IsEmpty</span>(Q))&#123;</span><br><span class=\"line\">        <span class=\"built_in\">Dequeue</span>(Q, v);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> p=G.vertices[v].firstarc; p; p=p-&gt;nextarc)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!visited[p-&gt;adjvex])&#123;</span><br><span class=\"line\">                <span class=\"built_in\">visit</span>(p-&gt;adjvex);</span><br><span class=\"line\">                visited[p-&gt;adjvex] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"built_in\">EnQueue</span>(Q, p-&gt;adjvex);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度：$O(|V|+|E|)$</p>\n<figure class=\"highlight c++\"><figcaption><span>BFS邻接矩阵实现</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">DFS</span><span class=\"params\">(MGraph G, <span class=\"type\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">visit</span>(i);</span><br><span class=\"line\">    visited[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"built_in\">EnQueue</span>(Q, i);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!<span class=\"built_in\">IsEmpty</span>(Q))&#123;</span><br><span class=\"line\">        <span class=\"built_in\">Dequeue</span>(Q, v);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;G.vexnum; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(G.edge[v][j] &amp;&amp; !visited[j])&#123;</span><br><span class=\"line\">                <span class=\"built_in\">visit</span>(j);</span><br><span class=\"line\">                visited[j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"built_in\">EnQueue</span>(Q, j);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度：$O(|V|^2)$</p>\n<ul>\n<li>BFS求<code>u</code>到<code>v</code>的最短距离<br>在BFS基础上添加一个数组<code>d</code>，记录从<code>u</code>到<code>v</code>的最短距离；增加一个数组<code>pre</code>记录路径</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>BFS求最短路径</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">BFS_MIN_Distance</span><span class=\"params\">(ALGraph G, <span class=\"type\">int</span> u, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class=\"line\">        d[i] = INF;</span><br><span class=\"line\">        pre[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        visited[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">visit</span>(u);</span><br><span class=\"line\">    visited[u] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    d[u] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    pre[u] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">EnQueue</span>(Q, u);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!<span class=\"built_in\">IsEmpty</span>(Q)) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> v;</span><br><span class=\"line\">        <span class=\"built_in\">Dequeue</span>(Q, v);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (anto p = G.vertices[v].firstarc; p; p = p-&gt;nextarc) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> w = p-&gt;adjvex;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!visited[w]) &#123;</span><br><span class=\"line\">                visited[w] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"built_in\">visit</span>(w);</span><br><span class=\"line\">                d[w] = d[v] + <span class=\"number\">1</span>;  <span class=\"comment\">// 距离 = 前驱距离 + 1</span></span><br><span class=\"line\">                pre[w] = v;       <span class=\"comment\">// 记录前驱</span></span><br><span class=\"line\">                <span class=\"built_in\">EnQueue</span>(Q, w);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<ol start=\"2\">\n<li>DFS<br>用栈实现</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>DFS邻接表实现</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">DFS</span><span class=\"params\">(ALGraph G, <span class=\"type\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">visit</span>(i);</span><br><span class=\"line\">    visited[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> p=G.vertices[i].firstarc; p; p=p-&gt;nextarc)&#123;</span><br><span class=\"line\">        j = p-&gt;adjvex;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!visited[j])&#123;</span><br><span class=\"line\">            <span class=\"built_in\">DFS</span>(G, j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度：$O(|V|+|E|)$</p>\n<figure class=\"highlight c++\"><figcaption><span>DFS邻接矩阵实现</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">DFS</span><span class=\"params\">(MGraph G, <span class=\"type\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">visit</span>(i);</span><br><span class=\"line\">    visited[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;G.vexnum; j++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(G.edge[i][j] &amp;&amp; !visited[j])&#123;</span><br><span class=\"line\">            <span class=\"built_in\">DFS</span>(G, j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度：$O(|V|^2)$<br>如果是非连通图，则需要多次调用DFS（再扫描一次visit数组，找到未访问的顶点然后继续调用DFS）</p>\n<h2 id=\"图的应用\"><a href=\"#图的应用\" class=\"headerlink\" title=\"图的应用\"></a>图的应用</h2><h3 id=\"最小生成树-MST\"><a href=\"#最小生成树-MST\" class=\"headerlink\" title=\"最小生成树 MST\"></a>最小生成树 MST</h3><p>最小生成树：从连通无向图中找出一棵树（包含所有n个节点和n-1条边），同时边的权重之和要最小</p>\n<ol>\n<li>Prim算法<br>随便取一个根节点记作visited，不断寻找visited节点和unvisited节点之间权重最小的边<br>初始的时候只有一个结点，&#x3D;&#x3D;从顶点开始每次找到和已有的结点距离最小的边&#x3D;&#x3D;，加入树中，直到树中顶点数等于顶点数（每次要保证树是连通的且没有回路）<br>时间复杂度：$O(|V|^2)$，适用于求稠密图的最小生成树</li>\n<li>Kruskal算法<br>每次找到距离最短的边，加入树中，直到所有顶点都在一个连通分量上<br>1）创建一个队列，将边按权重排序，最小的在最上面；（2）从顶端不断dequeue，如果符合不在同一棵树里就接受那条边</li>\n</ol>\n<h3 id=\"最短路径\"><a href=\"#最短路径\" class=\"headerlink\" title=\"最短路径\"></a>最短路径</h3><ol>\n<li><p>Dijkstra算法<br>有权图的单源最短路算法<br>求从源点到其他点的最短路径：每次选距离最近的点，更新源点到其他点的最短距离<br>一开始和其他点的距离全都初始化为<code>INF</code>，和自己的距离为0，每次在unvisited的结点中找距离最小的visit，然后看这个结点的邻接点，新的距离比旧距离小则更新<br>画一个表，分别是是否visit、编号、距离和路径，每次取unvisited里最小的</p>\n</li>\n<li><p>Floyd算法<br>多源最短路算法，求所有顶点之间的最短路径<br>递归产生一个n阶方阵序列<br>直接看例子：<br><img data-src=\"/f9.jpg\"><br>路径就是加起来的两个值的路径</p>\n</li>\n</ol>\n<h3 id=\"有向无环图描述表达式\"><a href=\"#有向无环图描述表达式\" class=\"headerlink\" title=\"有向无环图描述表达式\"></a>有向无环图描述表达式</h3><p>有向图中不存在环，则称为有向无环图，DAG<br><img data-src=\"/f10.jpg\"><br>先用树表示，然后把能合并的合并到一起，得到一个有向无环图<br>+++primary<br><img data-src=\"/f11.png\"><br><img data-src=\"/f12.png\"><br><img data-src=\"/f13.png\"><br>+++</p>\n<h3 id=\"拓扑排序\"><a href=\"#拓扑排序\" class=\"headerlink\" title=\"拓扑排序\"></a>拓扑排序</h3><p>AOV图顶点表示活动，边表示活动间的依赖关系</p>\n<ul>\n<li>拓扑排序<br>当且仅当一个有向图为有向无环图（directed acyclic graph，或称DAG）时，才能得到对应于该图的拓扑排序。每一个有向无环图都至少存在一种拓扑排序。</li>\n</ul>\n<p>方法：不断寻找入度为0的节点pop出去，删除该节点和相关的边<br>采用邻接表时，时间复杂度为$O(|V|+|E|)$，采用邻接矩阵时，时间复杂度为$O(|V|^2)$<br>序列不唯一<br><img data-src=\"/f14.png\"></p>\n<ul>\n<li><p>逆拓扑排序<br><img data-src=\"/f15.png\"><br>每次删除出度为0的顶点，并把该顶点的邻接点出度减1<br>序列不唯一</p>\n</li>\n<li><p>用dfs实现拓扑排序<br><img data-src=\"/f16.jpg\"></p>\n</li>\n</ul>\n<h3 id=\"AOE网\"><a href=\"#AOE网\" class=\"headerlink\" title=\"AOE网\"></a>AOE网</h3><p>边表示活动，顶点表示事件</p>\n<ol>\n<li>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始;</li>\n<li>只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生（所以事件的最早开始时间要取最大的）</li>\n</ol>\n<blockquote>\n<p>求事件的最早开始时间和最晚完成时间<br><img data-src=\"/f17.png\"><br>V代表事件，a代表活动</p>\n</blockquote>\n<p>先求事件（V）：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>V1</th>\n<th>V2</th>\n<th>V3</th>\n<th>V4</th>\n<th>V5</th>\n<th>V6</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>最早开始时间</td>\n<td>0</td>\n<td>3</td>\n<td>2</td>\n<td>6</td>\n<td>6</td>\n<td>8</td>\n</tr>\n<tr>\n<td>最晚完成时间</td>\n<td>0</td>\n<td>4</td>\n<td>2</td>\n<td>6</td>\n<td>7</td>\n<td>8</td>\n</tr>\n</tbody></table>\n<p>最早开始时间&#x3D;&#x3D;从前往后取最大的&#x3D;&#x3D;（V1填0，V4有V1-&gt;V2-&gt;V4和V1-&gt;V3-&gt;V4两条，取大的是6）<br>最晚完成时间&#x3D;&#x3D;从后往前推(用最早开始时间 - a），取最小的&#x3D;&#x3D;（V6填8，V5&#x3D;V6-1，V3有V6-&gt;V3和V6-&gt;V4-&gt;V3两条，取最小的V4-4&#x3D;2）</p>\n<p>&#x3D;&#x3D;最早开始时间 &#x3D; 最晚完成时间 —— 关键路径&#x3D;&#x3D;</p>\n<p>活动（A）：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>a1</th>\n<th>a2</th>\n<th>a3</th>\n<th>a4</th>\n<th>a5</th>\n<th>a6</th>\n<th>a7</th>\n<th>a8</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>最早开始时间</td>\n<td>0</td>\n<td>0</td>\n<td>3</td>\n<td>3</td>\n<td>2</td>\n<td>2</td>\n<td>6</td>\n<td>6</td>\n</tr>\n<tr>\n<td>最晚完成时间</td>\n<td>1</td>\n<td>0</td>\n<td>4</td>\n<td>4</td>\n<td>2</td>\n<td>5</td>\n<td>6</td>\n<td>7</td>\n</tr>\n</tbody></table>\n<p>最早开始时间取箭头的出发点的最早开始时间，最晚完成时间取箭头指向的点的最晚完成时间 - a</p>\n<p>&#x3D;&#x3D;最早开始时间 &#x3D; 最晚完成时间 —— 关键活动&#x3D;&#x3D;</p>\n<h3 id=\"各种时间复杂度\"><a href=\"#各种时间复杂度\" class=\"headerlink\" title=\"各种时间复杂度\"></a>各种时间复杂度</h3><p><img data-src=\"/f18.jpg\"></p>\n",
            "tags": [
                "图论"
            ]
        }
    ]
}