<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>NoResponse&#39;s Blog • Posts by &#34;图论&#34; tag</title>
    <link href="http://example.com" />
    <updated>2025-10-10T16:00:00.000Z</updated>
    <category term="人工智能" />
    <category term="软件工程" />
    <category term="自监督学习" />
    <category term="容器" />
    <category term="杂项" />
    <category term="面经" />
    <category term="ctest" />
    <category term="gtest" />
    <category term="test coverage" />
    <category term="C++" />
    <category term="Amortized Analysis" />
    <category term="数据结构" />
    <category term="栈、队列和数组" />
    <category term="线性表" />
    <category term="串" />
    <category term="树与二叉树" />
    <category term="查找" />
    <category term="图论" />
    <category term="排序" />
    <category term="计算机网络" />
    <category term="操作系统" />
    <category term="fds" />
    <category term="编译原理" />
    <category term="Liveness Analysis" />
    <category term="Register Allocation" />
    <category term="语法分析" />
    <category term="词法分析" />
    <category term="抽象语法" />
    <category term="活动记录" />
    <category term="语义分析" />
    <category term="中间代码" />
    <category term="Basic Blocks and Traces" />
    <category term="指令选择" />
    <category term="数据的表示与运算" />
    <category term="计算机组成" />
    <category term="指令系统" />
    <category term="CPU" />
    <category term="存储系统" />
    <category term="总线" />
    <category term="I/O" />
    <category term="错题" />
    <entry>
        <id>http://example.com/2025/10/11/computer-science/DS/ch6/</id>
        <title>ch6</title>
        <link rel="alternate" href="http://example.com/2025/10/11/computer-science/DS/ch6/"/>
        <content type="html">&lt;h1 id=&#34;Ch6&#34;&gt;&lt;a href=&#34;#Ch6&#34; class=&#34;headerlink&#34; title=&#34;Ch6&#34;&gt;&lt;/a&gt;Ch6&lt;/h1&gt;&lt;h2 id=&#34;概念&#34;&gt;&lt;a href=&#34;#概念&#34; class=&#34;headerlink&#34; title=&#34;概念&#34;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;$$&lt;br&gt;G &amp;#x3D; (V, E)&lt;br&gt;$$&lt;br&gt;图的顶点至少要有一个，边可以没有&lt;br&gt;顶点数：$|V|$&lt;br&gt;边数：$|E|$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有向图、无向图&lt;/li&gt;
&lt;li&gt;简单图（不存在重复边、不存在到自身的边）、多重图&lt;/li&gt;
&lt;li&gt;度、入度、出度&lt;br&gt;$$&lt;br&gt;TD(v) &amp;#x3D; ID(v) + OD(v)&lt;br&gt;$$&lt;/li&gt;
&lt;li&gt;有向图所有顶点的入度和出度之和相等，且等于边数&lt;/li&gt;
&lt;li&gt;路径、路径长度、回路&lt;/li&gt;
&lt;li&gt;简单路径、简单回路（顶点不重复出现）&lt;/li&gt;
&lt;li&gt;距离（从u到v的最短路径的长度，若不存在路径则为无穷大）&lt;/li&gt;
&lt;li&gt;子图：由某几个顶点和某几条边组成的图&lt;/li&gt;
&lt;li&gt;连通、连通图和连通分量&lt;br&gt;&amp;#x3D;&amp;#x3D;无向图中&amp;#x3D;&amp;#x3D;从v到w有路径存在，则v和w是连通的&lt;br&gt;若图中任意两个顶点都连通，则该图是&lt;code&gt;连通图&lt;/code&gt;，否则是非连通图&lt;br&gt;无向图中的极大连通子图称为&lt;code&gt;连通分量&lt;/code&gt;&lt;blockquote&gt;
&lt;p&gt;有$n$个顶点的连通图中，至少存在$n-1$条边（边数小于$n-1$一定是非连通图）&lt;br&gt;$n$个顶点的非连通图，最多有$n-2$条边&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;强连通图、强连通分量&lt;br&gt;在&amp;#x3D;&amp;#x3D;有向图中&amp;#x3D;&amp;#x3D;，若有一对顶点v和w，从v到w有路径，从w到v有路径，则v和w是强连通的&lt;br&gt;若图中任意两个顶点都强连通，则该图是&lt;code&gt;强连通图&lt;/code&gt;，否则是非强连通图&lt;br&gt;有向图中的极大强连通子图称为&lt;code&gt;强连通分量&lt;/code&gt;&lt;blockquote&gt;
&lt;p&gt;一个有向图有$n$个顶点，如果它是强连通图，则至少有$n$条边（环路）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;生成树、生成森林&lt;br&gt;连通图的生成树是包含所有顶点的极小连通子图（若有$n$个顶点则生成树有$n-1$条边）&lt;blockquote&gt;
&lt;p&gt;极大连通子图vs极小连通子图&lt;br&gt;极大连通子图要求连通且包含尽可能多的顶点和边，极小联通子图要求保持连通且边数最少&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;边的权、网和带权路径长度&lt;br&gt;带权图中，边有权值。路径上所有边的权值之和称为带权路径长度&lt;/li&gt;
&lt;li&gt;完全图（也称简单完全图）&lt;br&gt;无向图，有$n$个顶点，有$n(n-1)&amp;#x2F;2$条边的，称为完全（无向）图（顶点两两之间都有边）&lt;br&gt;有向图，有$n$个顶点，有$n(n-1)$条边的，称为完全（有向）图&lt;/li&gt;
&lt;li&gt;稠密图、稀疏图&lt;br&gt;当$|E| &amp;lt; |V|log_2{|v|}$时，可以视为稀疏图&lt;/li&gt;
&lt;li&gt;有向树&lt;br&gt;一个顶点入度为0，其他顶点入度均为1的有向图，称为有向树&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;图的存储及基本操作&#34;&gt;&lt;a href=&#34;#图的存储及基本操作&#34; class=&#34;headerlink&#34; title=&#34;图的存储及基本操作&#34;&gt;&lt;/a&gt;图的存储及基本操作&lt;/h2&gt;&lt;h3 id=&#34;邻接矩阵法&#34;&gt;&lt;a href=&#34;#邻接矩阵法&#34; class=&#34;headerlink&#34; title=&#34;邻接矩阵法&#34;&gt;&lt;/a&gt;邻接矩阵法&lt;/h3&gt;&lt;p&gt;$$&lt;br&gt;A[i][j] &amp;#x3D;&lt;br&gt;\begin{cases}&lt;br&gt;1, &amp;amp; \text{如果顶点 } i \text{ 和顶点 } j \text{ 之间有边} \&lt;br&gt;0, &amp;amp; \text{否则}&lt;br&gt;\end{cases}&lt;br&gt;$$&lt;br&gt;带权图：&lt;br&gt;$$&lt;br&gt;A[i][j] &amp;#x3D;&lt;br&gt;\begin{cases}&lt;br&gt;w_{ij}, &amp;amp; \text{如果顶点 } i \text{ 和 } j \text{ 之间有边，权重为 } w_{ij} \&lt;br&gt;0 \text{ 或 } \infty, &amp;amp; \text{如果没有边}&lt;br&gt;\end{cases}&lt;br&gt;$$&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;figcaption&gt;&lt;span&gt;邻接矩阵&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;#&lt;span class=&#34;keyword&#34;&gt;define&lt;/span&gt; MaxVertexNum 100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; VertexType;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; EdgeType;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    VertexType vex[MaxVertexNum];   &lt;span class=&#34;comment&#34;&gt;// 顶点表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    EdgeType edge[MaxVertexNum][MaxVertexNum];  &lt;span class=&#34;comment&#34;&gt;// 邻接矩阵&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; vexnum, edgnum;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;MGraph;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;无向图的邻接矩阵一定是对称的，所以只需要存上三角（或下三角）就行&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于无向图，邻接矩阵第$i$行非零元素的个数即为顶点$i$的度&lt;br&gt;对于有向图，邻接矩阵第$i$行非零元素的个数即为顶点$i$的出度，第$i$列非零元素的个数即为顶点$i$的入度&lt;br&gt;邻接矩阵适合稠密图&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;邻接表法&#34;&gt;&lt;a href=&#34;#邻接表法&#34; class=&#34;headerlink&#34; title=&#34;邻接表法&#34;&gt;&lt;/a&gt;邻接表法&lt;/h3&gt;&lt;p&gt;稀疏图适合用邻接表存储&lt;br&gt;&lt;img data-src=&#34;/f1.jpg&#34;&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;figcaption&gt;&lt;span&gt;邻接表&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;#&lt;span class=&#34;keyword&#34;&gt;define&lt;/span&gt; MaxVertexNum 100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;ArcNode&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; adjvex;  &lt;span class=&#34;comment&#34;&gt;// 邻接点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;ArcNode&lt;/span&gt; *nextarc;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;ArcNode;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;VNode&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    VertexType data;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    ArcNode *firstarc;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;VNode, AdjList[MaxVertexNum];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    AdjList vertices;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; vexnum, arcnum;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;ALGraph;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;对于无向图，所需要的空间为$O(|V|+2|E|)$；若为有向图，空间为$O(|V|+|E|)$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;十字链表&#34;&gt;&lt;a href=&#34;#十字链表&#34; class=&#34;headerlink&#34; title=&#34;十字链表&#34;&gt;&lt;/a&gt;十字链表&lt;/h3&gt;&lt;p&gt;&amp;#x3D;&amp;#x3D;有向图&amp;#x3D;&amp;#x3D;的一种链式存储结构&lt;br&gt;每条弧、顶点都用结点表示&lt;br&gt;顶点结点&lt;br&gt;&lt;code&gt;firstIn&lt;/code&gt;表示进入这个结点的第一个弧节点，&lt;code&gt;firstOut&lt;/code&gt;表示出去这个结点的第一个弧节点&lt;br&gt;&lt;img data-src=&#34;/f2.png&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/f4.png&#34;&gt;&lt;br&gt;弧结点&lt;br&gt;&lt;code&gt;tailVexh&lt;/code&gt;和&lt;code&gt;headVex&lt;/code&gt;存放弧尾和弧头在顶点数组的编号。&lt;code&gt;hLink&lt;/code&gt;则表示指向弧头相同的下一条弧，&lt;code&gt;tLink&lt;/code&gt;则表示指向弧尾相同的下一条弧&lt;br&gt;&lt;img data-src=&#34;/f3.png&#34;&gt;&lt;br&gt;:::danger&lt;br&gt;王道这里的弧头指的是箭头的头部，弧尾指的是箭头的尾部，王道这一部分不知道哪个天才写的，纯误导人，直接看英语就行了&lt;br&gt;:::&lt;/p&gt;
&lt;p&gt;+++primary 示例&lt;br&gt;&lt;img data-src=&#34;/f5.png&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/f6.png&#34;&gt;&lt;br&gt;+++&lt;/p&gt;
&lt;h3 id=&#34;邻接多重表&#34;&gt;&lt;a href=&#34;#邻接多重表&#34; class=&#34;headerlink&#34; title=&#34;邻接多重表&#34;&gt;&lt;/a&gt;邻接多重表&lt;/h3&gt;&lt;p&gt;无向图的一种链式存储结构&lt;br&gt;边结点：&lt;br&gt;| ivex | ilink | jvex | jlink | (info) |&lt;br&gt;顶点结点：&lt;br&gt;| data | firstedge |&lt;br&gt;和十字链表差不多意思，只不过这个是无向图&lt;br&gt;&lt;img data-src=&#34;/f7.jpg&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;图的基本操作&#34;&gt;&lt;a href=&#34;#图的基本操作&#34; class=&#34;headerlink&#34; title=&#34;图的基本操作&#34;&gt;&lt;/a&gt;图的基本操作&lt;/h3&gt;&lt;h2 id=&#34;图的遍历&#34;&gt;&lt;a href=&#34;#图的遍历&#34; class=&#34;headerlink&#34; title=&#34;图的遍历&#34;&gt;&lt;/a&gt;图的遍历&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;BFS&lt;br&gt;用队列实现，入队的时候visit，出队的时候检查邻接点&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;figcaption&gt;&lt;span&gt;BFS邻接表实现&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;BFS&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(ALGraph G, &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; i)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;visit&lt;/span&gt;(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    visited[i] = &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;EnQueue&lt;/span&gt;(Q, i);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt;(!&lt;span class=&#34;built_in&#34;&gt;IsEmpty&lt;/span&gt;(Q))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;built_in&#34;&gt;Dequeue&lt;/span&gt;(Q, v);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt;(&lt;span class=&#34;keyword&#34;&gt;auto&lt;/span&gt; p=G.vertices[v].firstarc; p; p=p-&amp;gt;nextarc)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt;(!visited[p-&amp;gt;adjvex])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;built_in&#34;&gt;visit&lt;/span&gt;(p-&amp;gt;adjvex);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                visited[p-&amp;gt;adjvex] = &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;built_in&#34;&gt;EnQueue&lt;/span&gt;(Q, p-&amp;gt;adjvex);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;时间复杂度：$O(|V|+|E|)$&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;figcaption&gt;&lt;span&gt;BFS邻接矩阵实现&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;DFS&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(MGraph G, &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; i)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;visit&lt;/span&gt;(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    visited[i] = &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;EnQueue&lt;/span&gt;(Q, i);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt;(!&lt;span class=&#34;built_in&#34;&gt;IsEmpty&lt;/span&gt;(Q))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;built_in&#34;&gt;Dequeue&lt;/span&gt;(Q, v);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; j=&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; j&amp;lt;G.vexnum; j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt;(G.edge[v][j] &amp;amp;&amp;amp; !visited[j])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;built_in&#34;&gt;visit&lt;/span&gt;(j);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                visited[j] = &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;built_in&#34;&gt;EnQueue&lt;/span&gt;(Q, j);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;时间复杂度：$O(|V|^2)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BFS求&lt;code&gt;u&lt;/code&gt;到&lt;code&gt;v&lt;/code&gt;的最短距离&lt;br&gt;在BFS基础上添加一个数组&lt;code&gt;d&lt;/code&gt;，记录从&lt;code&gt;u&lt;/code&gt;到&lt;code&gt;v&lt;/code&gt;的最短距离；增加一个数组&lt;code&gt;pre&lt;/code&gt;记录路径&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;figcaption&gt;&lt;span&gt;BFS求最短路径&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;BFS_MIN_Distance&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(ALGraph G, &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; u, &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; target)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; i = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; i &amp;lt; G.vexnum; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        d[i] = INF;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        pre[i] = &lt;span class=&#34;number&#34;&gt;-1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        visited[i] = &lt;span class=&#34;literal&#34;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;visit&lt;/span&gt;(u);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    visited[u] = &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    d[u] = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    pre[u] = &lt;span class=&#34;number&#34;&gt;-1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;EnQueue&lt;/span&gt;(Q, u);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt; (!&lt;span class=&#34;built_in&#34;&gt;IsEmpty&lt;/span&gt;(Q)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; v;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;built_in&#34;&gt;Dequeue&lt;/span&gt;(Q, v);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (anto p = G.vertices[v].firstarc; p; p = p-&amp;gt;nextarc) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; w = p-&amp;gt;adjvex;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (!visited[w]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                visited[w] = &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;built_in&#34;&gt;visit&lt;/span&gt;(w);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                d[w] = d[v] + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;  &lt;span class=&#34;comment&#34;&gt;// 距离 = 前驱距离 + 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                pre[w] = v;       &lt;span class=&#34;comment&#34;&gt;// 记录前驱&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;built_in&#34;&gt;EnQueue&lt;/span&gt;(Q, w);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;


&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;DFS&lt;br&gt;用栈实现&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;figcaption&gt;&lt;span&gt;DFS邻接表实现&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;DFS&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(ALGraph G, &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; i)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;visit&lt;/span&gt;(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    visited[i] = &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt;(&lt;span class=&#34;keyword&#34;&gt;auto&lt;/span&gt; p=G.vertices[i].firstarc; p; p=p-&amp;gt;nextarc)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        j = p-&amp;gt;adjvex;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt;(!visited[j])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;built_in&#34;&gt;DFS&lt;/span&gt;(G, j);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;时间复杂度：$O(|V|+|E|)$&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;figcaption&gt;&lt;span&gt;DFS邻接矩阵实现&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;DFS&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(MGraph G, &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; i)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;visit&lt;/span&gt;(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    visited[i] = &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; j=&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; j&amp;lt;G.vexnum; j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt;(G.edge[i][j] &amp;amp;&amp;amp; !visited[j])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;built_in&#34;&gt;DFS&lt;/span&gt;(G, j);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;时间复杂度：$O(|V|^2)$&lt;br&gt;如果是非连通图，则需要多次调用DFS（再扫描一次visit数组，找到未访问的顶点然后继续调用DFS）&lt;/p&gt;
&lt;h2 id=&#34;图的应用&#34;&gt;&lt;a href=&#34;#图的应用&#34; class=&#34;headerlink&#34; title=&#34;图的应用&#34;&gt;&lt;/a&gt;图的应用&lt;/h2&gt;&lt;h3 id=&#34;最小生成树-MST&#34;&gt;&lt;a href=&#34;#最小生成树-MST&#34; class=&#34;headerlink&#34; title=&#34;最小生成树 MST&#34;&gt;&lt;/a&gt;最小生成树 MST&lt;/h3&gt;&lt;p&gt;最小生成树：从连通无向图中找出一棵树（包含所有n个节点和n-1条边），同时边的权重之和要最小&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Prim算法&lt;br&gt;随便取一个根节点记作visited，不断寻找visited节点和unvisited节点之间权重最小的边&lt;br&gt;初始的时候只有一个结点，&amp;#x3D;&amp;#x3D;从顶点开始每次找到和已有的结点距离最小的边&amp;#x3D;&amp;#x3D;，加入树中，直到树中顶点数等于顶点数（每次要保证树是连通的且没有回路）&lt;br&gt;时间复杂度：$O(|V|^2)$，适用于求稠密图的最小生成树&lt;/li&gt;
&lt;li&gt;Kruskal算法&lt;br&gt;每次找到距离最短的边，加入树中，直到所有顶点都在一个连通分量上&lt;br&gt;1）创建一个队列，将边按权重排序，最小的在最上面；（2）从顶端不断dequeue，如果符合不在同一棵树里就接受那条边&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;最短路径&#34;&gt;&lt;a href=&#34;#最短路径&#34; class=&#34;headerlink&#34; title=&#34;最短路径&#34;&gt;&lt;/a&gt;最短路径&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Dijkstra算法&lt;br&gt;有权图的单源最短路算法&lt;br&gt;求从源点到其他点的最短路径：每次选距离最近的点，更新源点到其他点的最短距离&lt;br&gt;一开始和其他点的距离全都初始化为&lt;code&gt;INF&lt;/code&gt;，和自己的距离为0，每次在unvisited的结点中找距离最小的visit，然后看这个结点的邻接点，新的距离比旧距离小则更新&lt;br&gt;画一个表，分别是是否visit、编号、距离和路径，每次取unvisited里最小的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Floyd算法&lt;br&gt;多源最短路算法，求所有顶点之间的最短路径&lt;br&gt;递归产生一个n阶方阵序列&lt;br&gt;直接看例子：&lt;br&gt;&lt;img data-src=&#34;/f9.jpg&#34;&gt;&lt;br&gt;路径就是加起来的两个值的路径&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;有向无环图描述表达式&#34;&gt;&lt;a href=&#34;#有向无环图描述表达式&#34; class=&#34;headerlink&#34; title=&#34;有向无环图描述表达式&#34;&gt;&lt;/a&gt;有向无环图描述表达式&lt;/h3&gt;&lt;p&gt;有向图中不存在环，则称为有向无环图，DAG&lt;br&gt;&lt;img data-src=&#34;/f10.jpg&#34;&gt;&lt;br&gt;先用树表示，然后把能合并的合并到一起，得到一个有向无环图&lt;br&gt;+++primary&lt;br&gt;&lt;img data-src=&#34;/f11.png&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/f12.png&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/f13.png&#34;&gt;&lt;br&gt;+++&lt;/p&gt;
&lt;h3 id=&#34;拓扑排序&#34;&gt;&lt;a href=&#34;#拓扑排序&#34; class=&#34;headerlink&#34; title=&#34;拓扑排序&#34;&gt;&lt;/a&gt;拓扑排序&lt;/h3&gt;&lt;p&gt;AOV图顶点表示活动，边表示活动间的依赖关系&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拓扑排序&lt;br&gt;当且仅当一个有向图为有向无环图（directed acyclic graph，或称DAG）时，才能得到对应于该图的拓扑排序。每一个有向无环图都至少存在一种拓扑排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方法：不断寻找入度为0的节点pop出去，删除该节点和相关的边&lt;br&gt;采用邻接表时，时间复杂度为$O(|V|+|E|)$，采用邻接矩阵时，时间复杂度为$O(|V|^2)$&lt;br&gt;序列不唯一&lt;br&gt;&lt;img data-src=&#34;/f14.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;逆拓扑排序&lt;br&gt;&lt;img data-src=&#34;/f15.png&#34;&gt;&lt;br&gt;每次删除出度为0的顶点，并把该顶点的邻接点出度减1&lt;br&gt;序列不唯一&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用dfs实现拓扑排序&lt;br&gt;&lt;img data-src=&#34;/f16.jpg&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;AOE网&#34;&gt;&lt;a href=&#34;#AOE网&#34; class=&#34;headerlink&#34; title=&#34;AOE网&#34;&gt;&lt;/a&gt;AOE网&lt;/h3&gt;&lt;p&gt;边表示活动，顶点表示事件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始;&lt;/li&gt;
&lt;li&gt;只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生（所以事件的最早开始时间要取最大的）&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;求事件的最早开始时间和最晚完成时间&lt;br&gt;&lt;img data-src=&#34;/f17.png&#34;&gt;&lt;br&gt;V代表事件，a代表活动&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先求事件（V）：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;V1&lt;/th&gt;
&lt;th&gt;V2&lt;/th&gt;
&lt;th&gt;V3&lt;/th&gt;
&lt;th&gt;V4&lt;/th&gt;
&lt;th&gt;V5&lt;/th&gt;
&lt;th&gt;V6&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;最早开始时间&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;最晚完成时间&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;最早开始时间&amp;#x3D;&amp;#x3D;从前往后取最大的&amp;#x3D;&amp;#x3D;（V1填0，V4有V1-&amp;gt;V2-&amp;gt;V4和V1-&amp;gt;V3-&amp;gt;V4两条，取大的是6）&lt;br&gt;最晚完成时间&amp;#x3D;&amp;#x3D;从后往前推(用最早开始时间 - a），取最小的&amp;#x3D;&amp;#x3D;（V6填8，V5&amp;#x3D;V6-1，V3有V6-&amp;gt;V3和V6-&amp;gt;V4-&amp;gt;V3两条，取最小的V4-4&amp;#x3D;2）&lt;/p&gt;
&lt;p&gt;&amp;#x3D;&amp;#x3D;最早开始时间 &amp;#x3D; 最晚完成时间 —— 关键路径&amp;#x3D;&amp;#x3D;&lt;/p&gt;
&lt;p&gt;活动（A）：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;a1&lt;/th&gt;
&lt;th&gt;a2&lt;/th&gt;
&lt;th&gt;a3&lt;/th&gt;
&lt;th&gt;a4&lt;/th&gt;
&lt;th&gt;a5&lt;/th&gt;
&lt;th&gt;a6&lt;/th&gt;
&lt;th&gt;a7&lt;/th&gt;
&lt;th&gt;a8&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;最早开始时间&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;最晚完成时间&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;最早开始时间取箭头的出发点的最早开始时间，最晚完成时间取箭头指向的点的最晚完成时间 - a&lt;/p&gt;
&lt;p&gt;&amp;#x3D;&amp;#x3D;最早开始时间 &amp;#x3D; 最晚完成时间 —— 关键活动&amp;#x3D;&amp;#x3D;&lt;/p&gt;
&lt;h3 id=&#34;各种时间复杂度&#34;&gt;&lt;a href=&#34;#各种时间复杂度&#34; class=&#34;headerlink&#34; title=&#34;各种时间复杂度&#34;&gt;&lt;/a&gt;各种时间复杂度&lt;/h3&gt;&lt;p&gt;&lt;img data-src=&#34;/f18.jpg&#34;&gt;&lt;/p&gt;
</content>
        <category term="图论" />
        <updated>2025-10-10T16:00:00.000Z</updated>
    </entry>
</feed>
