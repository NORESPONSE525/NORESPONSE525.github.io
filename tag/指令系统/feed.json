{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog • All posts by \"指令系统\" tag",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/08/01/computer-science/computer-organization/ch4/",
            "url": "http://example.com/2025/08/01/computer-science/computer-organization/ch4/",
            "title": "Ch4",
            "date_published": "2025-07-31T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch4-指令系统\"><a href=\"#Ch4-指令系统\" class=\"headerlink\" title=\"Ch4 指令系统\"></a>Ch4 指令系统</h1><h2 id=\"指令系统\"><a href=\"#指令系统\" class=\"headerlink\" title=\"指令系统\"></a>指令系统</h2><h3 id=\"ISA（王道叫它指令集体系结构）\"><a href=\"#ISA（王道叫它指令集体系结构）\" class=\"headerlink\" title=\"ISA（王道叫它指令集体系结构）\"></a>ISA（王道叫它指令集体系结构）</h3><p>指令系统 vs ISA</p>\n<p>ISA完整地定义了软件和硬件之间的接口，规定了：</p>\n<ul>\n<li>指令格式（指令寻址方式，操作类型，操作数）</li>\n<li>操作数的类型、寻址方式、大端小端存放（大端：高位放在低地址；小端：低位放在低地址）</li>\n<li>程序可访问的寄存器编号、个数和位数，存储空间大小和编址方式</li>\n<li>指令执行过程的控制方式（PC, condition code, …）</li>\n</ul>\n<h3 id=\"指令的基本格式\"><a href=\"#指令的基本格式\" class=\"headerlink\" title=\"指令的基本格式\"></a>指令的基本格式</h3><p>操作码+地址码<br>主存一般是按字节编址，所以指令字长通常为字节的整数倍</p>\n<ol>\n<li><p>零地址指令<br>NOP, HLT<br>不需要操作数。<br>零地址的运算类指令仅用在堆栈计算机中（操作数直接从栈顶弹出）</p>\n</li>\n<li><p>一地址指令<br>OP, A1<br>OP(A1) -&gt; A1<br>加1，减1，取反，求补，移位等<br>可能有一个操作数或者两个操作数</p>\n<blockquote>\n<p>隐含约定目的地址的双操作数指令，地址码指明一个操作数，另一个操作数来自隐含寻址</p>\n</blockquote>\n</li>\n<li><p>二地址指令<br>OP, A1, A2<br>(A1)OP(A2) -&gt; A1</p>\n</li>\n<li><p>三地址指令<br>OP, A1, A2, A3<br>(A1)OP(A2) -&gt; A3</p>\n</li>\n<li><p>四地址指令<br>OP, A1, A2, A3, A4<br>(A1)OP(A2) -&gt; A3, A4 &#x3D; 下一条将要执行指令的地址</p>\n</li>\n</ol>\n<h3 id=\"定长操作码指令格式\"><a href=\"#定长操作码指令格式\" class=\"headerlink\" title=\"定长操作码指令格式\"></a>定长操作码指令格式</h3><p>n位opcode最多能表示2^n条指令<br>指令字长：单字长(PC &#x3D; PC + 1)、双字长(PC &#x3D; PC + 2)…</p>\n<h3 id=\"扩展操作码指令格式\"><a href=\"#扩展操作码指令格式\" class=\"headerlink\" title=\"扩展操作码指令格式\"></a>扩展操作码指令格式</h3><p>才去可变长度操作码，分散地放在指令字的不同位置上<br>要求：</p>\n<ol>\n<li>不允许短码是长码的前缀</li>\n<li>各指令的操作码不能重复<br><img data-src=\"/f1.jpg\"><br>RISC-V指令集</li>\n</ol>\n<h3 id=\"指令的操作类型\"><a href=\"#指令的操作类型\" class=\"headerlink\" title=\"指令的操作类型\"></a>指令的操作类型</h3><ol>\n<li>数据传送</li>\n</ol>\n<ul>\n<li>MOV: 寄存器到寄存器</li>\n<li>LOAD: 从内存读到寄存器</li>\n<li>STORE: 从寄存器写入内存</li>\n<li>PUSH</li>\n<li>POP</li>\n</ul>\n<ol start=\"2\">\n<li><p>算术和逻辑运算<br>ADD, SUB, MUL, DIV, MOD, AND, OR, XOR, NOT, XOR, INC(加一), DEC(减一)</p>\n</li>\n<li><p>移位<br>算术移位，逻辑移位，循环移位</p>\n</li>\n<li><p>转移<br>JMP, BRANCH, CALL, RET, TRAP（中断隐指令是硬件实现的，只有TRAP是软指令）</p>\n</li>\n<li><p>I&#x2F;O操作</p>\n</li>\n</ol>\n<h2 id=\"指令的寻址方式\"><a href=\"#指令的寻址方式\" class=\"headerlink\" title=\"指令的寻址方式\"></a>指令的寻址方式</h2><h3 id=\"指令寻址与数据寻址\"><a href=\"#指令寻址与数据寻址\" class=\"headerlink\" title=\"指令寻址与数据寻址\"></a>指令寻址与数据寻址</h3><ol>\n<li>指令寻址</li>\n</ol>\n<ul>\n<li>顺序： PC &#x3D; PC + 1</li>\n<li>跳转： 绝对转移(PC &#x3D; 跳转地址) ,相对转移(PC &#x3D; PC + offset)</li>\n</ul>\n<ol start=\"2\">\n<li>数据寻址<br>格式：操作码 寻址特征 形式地址A</li>\n</ol>\n<ul>\n<li>立即寻址(addi, …)</li>\n<li>直接寻址（A直接表示地址）</li>\n<li>寄存器寻址(add, …)</li>\n<li>寄存器间接寻址(lw r1 offset(r2), …)</li>\n</ul>\n<h3 id=\"常见的数据寻址方式\"><a href=\"#常见的数据寻址方式\" class=\"headerlink\" title=\"常见的数据寻址方式\"></a>常见的数据寻址方式</h3><ol>\n<li>隐含寻址<br>比如单地址的第二个操作数由ACC提供: Intel 8080的<code>ADD A</code>指令会将寄存器A的内容与指定的操作数（放在ACC内）相加，并将结果存储回累加器中<br>优点是缩短指令字长；缺点是需要增加存储操作数或隐含地址的硬件</li>\n<li>立即（数）寻址<br>比如riscv的<code>addi x5, x6, #1</code><br>优点是不用访存速度快，缺点是立即数位数有限</li>\n<li>直接寻址<br><code>OP #A</code></li>\n</ol>\n<p>比如lc3的<code>LD R1, LABEL1</code>翻译成汇编是<code>LD R1, x3100</code>表示<code>R1 &lt;- MEM[x3100]</code><br>形式地址A就是操作数的真实地址EA<br>优点是简单，缺点是寻址范围受A的位数限制<br>4. 间接寻址<br>EA &#x3D; (A)<br>指令中给出的地址是包含实际地址的内存位置或寄存器<br>比如lc3的<code>LDI R1, LABEL1</code>翻译成汇编是<code>LDI R1, x3100</code>表示<code>R1 &lt;- MEM[MEM[x3100]]</code><br>5. 寄存器寻址<br>EA &#x3D; (Ri)<br><code>ADD R1, R2, R3</code><br>6. 寄存器间接寻址<br>EA &#x3D; (Ri)<br>比如<code>LW R1, offset(R2)</code><br>7. 相对寻址<br>相对PC寻址<br>EA &#x3D; (PC) + A<br>比如branch<br>8. 基址寻址<br>EA &#x3D; (BR) + A<br>面向操作系统，优点是扩大寻址范围，有利于躲到程序设计；缺点是偏移量(A)的位数较短<br>9. 变址寻址<br>EA &#x3D; (IX) + A<br>比如用来访问数组</p>\n<blockquote>\n<p>偏址寻址：相对寻址、基址寻址、变址寻址</p>\n<ol start=\"10\">\n<li>堆栈寻址有一个堆栈指针SP，堆栈分为硬堆栈，软堆栈。寄存器堆栈是硬堆栈，内存是软堆栈。采用无操作数指令<br><img data-src=\"/f2.jpg\"></li>\n</ol>\n</blockquote>\n<h2 id=\"程序的机器级代码表示\"><a href=\"#程序的机器级代码表示\" class=\"headerlink\" title=\"程序的机器级代码表示\"></a>程序的机器级代码表示</h2><p>x86汇编</p>\n<h3 id=\"常用汇编指令介绍\"><a href=\"#常用汇编指令介绍\" class=\"headerlink\" title=\"常用汇编指令介绍\"></a>常用汇编指令介绍</h3><ol>\n<li>相关寄存器<br>x86架构有8个32位的通用寄存器：EAX、EBX、ECX、EDX、ESI、EDI、EBP、ESP<br><img data-src=\"/f3.jpg\"><br><img data-src=\"/f4.jpg\"><br><img data-src=\"/f5.jpg\"></li>\n<li>汇编指令格式<br>x86汇编指令格式有两种：AT&amp;T格式和Intel格式</li>\n</ol>\n<ul>\n<li>AT&amp;T只能小写，Intel大小写都行</li>\n<li>AT&amp;T第一个操作数是源操作数，第二个是目的操作数；Intel第一个操作数是目的操作数，第二个是源操作数</li>\n<li>AT&amp;T寄存器前缀%，立即数前缀$；Intel格式寄存器和立即数不需要加前缀</li>\n<li>内存寻址：AT&amp;T格式为(addr)，Intel格式为[addr]</li>\n<li>处理复杂寻址方式时，AT&amp;T格式为disp(base, index, scale)，表示偏移量，基址寄存器，变址寄存器，比例因子，表示的操作数为M[R[base]+R[index]*scale + disp];</li>\n<li>指定数据长度时，AT&amp;T用b, w, l; Intel用byte ptr, word ptr, dword ptr(一个word是16位，一个dword是32位)<br><img data-src=\"/f6.jpg\"><br><img data-src=\"/f7.jpg\"></li>\n</ul>\n<ol start=\"3\">\n<li>常用指令</li>\n</ol>\n<ul>\n<li><reg>表示任意寄存器，后面跟数字指定其位数</reg></li>\n<li><mem>内存地址</mem></li>\n<li><con>后面跟数字表示几位常数<br>常见的指令：</con></li>\n<li>数据传送指令<ul>\n<li>mov<ul>\n<li>mov <reg>, <reg></reg></reg></li>\n<li>mov <reg>, <mem></mem></reg></li>\n<li>mov <mem>, <reg></reg></mem></li>\n<li>mov <reg>, <con></con></reg></li>\n<li>mov <mem>, <con></con></mem></li>\n</ul>\n</li>\n<li>push(ESP指向栈顶空的位置，push之前ESP &#x3D; ESP - 4)&#x3D;&#x3D;栈中元素固定为32位&#x3D;&#x3D;<ul>\n<li>push &lt;reg32</li>\n<li>push <mem></mem></li>\n<li>push <con32></con32></li>\n</ul>\n</li>\n<li>pop(pop之后ESP &#x3D; ESP + 4)<ul>\n<li>pop <reg32></reg32></li>\n<li>pop <mem></mem></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>算术和逻辑运算<ul>\n<li>add&#x2F;sub(把两个操作数相加&#x2F;减，结果放回目的操作数)<ul>\n<li>add eax, 10    # eax &#x3D; eax + 10</li>\n<li>add byte ptr [var], 10    # 10与var指向的内存地址的一字节值相加，结果放回var指向的内存中</li>\n</ul>\n</li>\n<li>inc&#x2F;dec(把操作数自加1&#x2F;自减1)<ul>\n<li>dec eax    # eax &#x3D; eax - 1</li>\n<li>inc dword ptr [var]    # var指向的32位值自加1，结果放回var指向的32位内存中</li>\n</ul>\n</li>\n<li>imul(有符号数整数乘法, mul是无符号数乘法)目的操作数必须是寄存器，溢出时<code>OF = 1</code><ul>\n<li>imul <reg32>, <reg32></reg32></reg32></li>\n<li>imul <reg32>, <mem></mem></reg32></li>\n<li>imul <reg32>, <reg32>, <con></con></reg32></reg32></li>\n<li>imul <reg32>, <mem>, <con></con></mem></reg32></li>\n</ul>\n</li>\n<li>idiv(有符号数整数除法，&#x3D;&#x3D;只有一个操作数为除数，被除数有64位放在 <code>edx:eax</code> 中，操作结果商放到<code>eax</code>，余数放到<code>edx</code>&#x3D;&#x3D;)<ul>\n<li>idiv <reg32></reg32></li>\n<li>idiv <mem></mem></li>\n</ul>\n</li>\n<li>and&#x2F;or&#x2F;xor<ul>\n<li>and&#x2F;or&#x2F;xor <reg>, <reg></reg></reg></li>\n<li>and&#x2F;or&#x2F;xor <reg>, <mem></mem></reg></li>\n<li>and&#x2F;or&#x2F;xor <mem>, <reg></reg></mem></li>\n<li>and&#x2F;or&#x2F;xor <reg>, <con></con></reg></li>\n<li>and&#x2F;or&#x2F;xor <mem>, <con></con></mem></li>\n</ul>\n</li>\n<li>not(按位取反)<ul>\n<li>not <reg></reg></li>\n<li>not <mem></mem></li>\n</ul>\n</li>\n<li>neg(取负)<ul>\n<li>neg <reg></reg></li>\n<li>neg <mem></mem></li>\n</ul>\n</li>\n<li>shl&#x2F;shr(逻辑左移&#x2F;右移)<ul>\n<li>shl <reg>, <con8></con8></reg></li>\n<li>shl <mem>, <con8></con8></mem></li>\n<li>shr <reg>, <reg8></reg8></reg></li>\n<li>shr <mem>, <reg8></reg8></mem></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>控制流<ul>\n<li>jmp<ul>\n<li>jmp <label></label></li>\n</ul>\n</li>\n<li>jcondition<ul>\n<li>je <label></label></li>\n<li>jz <label></label></li>\n<li>jne <label></label></li>\n<li>jg <label></label></li>\n<li>jge <label></label></li>\n<li>jl <label></label></li>\n<li>jle <label></label></li>\n</ul>\n</li>\n<li>cmp&#x2F;test(cmp相当于相减，test相当于按位与，不保存操作结果仅设置条件码用于跳转指令)<ul>\n<li>cmp&#x2F;test <reg>, <reg></reg></reg></li>\n<li>cmp&#x2F;test <reg>, <mem></mem></reg></li>\n<li>cmp&#x2F;test <mem>, <reg></reg></mem></li>\n<li>cmp&#x2F;test <reg>, <con></con></reg></li>\n</ul>\n</li>\n<li>call&#x2F;ret(call将返回地址入栈然后跳转，ret弹出返回地址并跳转)<ul>\n<li>call <label></label></li>\n<li>ret</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"选择语句的机器级表示\"><a href=\"#选择语句的机器级表示\" class=\"headerlink\" title=\"选择语句的机器级表示\"></a>选择语句的机器级表示</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(test_exp)</span><br><span class=\"line\">    then_stmt</span><br><span class=\"line\">else</span><br><span class=\"line\">    else_stmt</span><br></pre></td></tr></table></figure>\n<p>翻译成</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(!t)</span><br><span class=\"line\">    goto false;</span><br><span class=\"line\">then_stmt;   </span><br><span class=\"line\">goto done;</span><br><span class=\"line\">false:  else_stmt;</span><br><span class=\"line\">done:</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"循环语句的机器级表示\"><a href=\"#循环语句的机器级表示\" class=\"headerlink\" title=\"循环语句的机器级表示\"></a>循环语句的机器级表示</h3><ol>\n<li>do-while</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">do</span><br><span class=\"line\">  body_stmt</span><br><span class=\"line\">  while(test_exp);</span><br></pre></td></tr></table></figure>\n<p>翻译成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loop:   body_stmt;</span><br><span class=\"line\">  t = test_exp;</span><br><span class=\"line\">  if(t)</span><br><span class=\"line\">    goto loop;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>while</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while(test_exp)</span><br><span class=\"line\">  body_stmt;</span><br></pre></td></tr></table></figure>\n<p>翻译成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t = test_exp;</span><br><span class=\"line\">if(!t)</span><br><span class=\"line\">  goto done;</span><br><span class=\"line\">loop:</span><br><span class=\"line\">  body_stmt;</span><br><span class=\"line\">  t = test_exp;</span><br><span class=\"line\">  if(t)</span><br><span class=\"line\">    goto loop;</span><br><span class=\"line\">done:</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>for</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(init_exp; test_exp; update_exp)</span><br><span class=\"line\">  body_stmt;</span><br></pre></td></tr></table></figure>\n<p>翻译成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init_exp;</span><br><span class=\"line\">t = test_exp;</span><br><span class=\"line\">if(!t)</span><br><span class=\"line\">  goto done;</span><br><span class=\"line\">loop:</span><br><span class=\"line\">  body_stmt;</span><br><span class=\"line\">  update_exp;</span><br><span class=\"line\">  t = test_exp;</span><br><span class=\"line\">  if(t)</span><br><span class=\"line\">    goto loop;</span><br><span class=\"line\">done:</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"过程调用的机器级表示\"><a href=\"#过程调用的机器级表示\" class=\"headerlink\" title=\"过程调用的机器级表示\"></a>过程调用的机器级表示</h3><ol>\n<li>caller将实参放到callee能访问的地方（寄存器放不下放栈里）</li>\n<li>caller保存返回地址（通过call指令实现）</li>\n<li>callee保存caller通用寄存器的内容，并为自己的非静态局部变量分配空间</li>\n<li>执行callee</li>\n<li>恢复caller的寄存器内容，将返回值放到caller能访问的地方（寄存器、栈），释放局部变量</li>\n<li>callee取出返回地址，恢复PC（ret实现）<blockquote>\n<p>EAX, ECX, EDX是caller saved register<br>通常用于传递参数、存储临时变量或返回值，所以call的时候内容可能会变，要先保存再调用。比如返回值一般保存在EAX<br>EBX, ESI, EDI是callee saved register<br>这些寄存器的值在函数调用后应保持不变，所以由callee保存，ret的时候要恢复</p>\n</blockquote>\n</li>\n</ol>\n<p>每个过程有自己的栈帧，<code>EBP</code>保存栈帧的基址，<code>ESP</code>指向栈顶位置，<code>EBP</code>的值不变，当前栈帧的范围在<code>EBP</code>和<code>ESP</code>之间（详见编译原理<code>activated record</code>）<br><img data-src=\"/f8.jpg\"><br>前三行的意思是新开一个栈帧，分配了24字节的栈帧空间。<code>push epb</code>实际上就是把static link压栈。<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ub3Jlc3BvbnNlNTI1LmdpdGh1Yi5pby8yMDI1LzA2LzE1L2NvbXB1dGVyLXNjaWVuY2UvY29tcGlsZS1wcmluY2lwbGVzL2NoNi8jJUU1JTg3JUJEJUU2JTk1JUIwJUU4JUIwJTgzJUU3JTk0JUE4JUU2JUI1JTgxJUU3JUE4JThC\">详见编译原理笔记</span><br>执行<code>call</code>之后，<code>call</code>会先将返回地址压栈，然后跳转到<code>add</code>的起始地址，为<code>add</code>创建栈帧。<code>add</code>的返回值存放在<code>EAX</code>中。<br>执行<code>ret</code>之前需要释放当前栈帧，恢复caller的栈帧。因此<code>leave</code>相当于<code>mov esp, ebp</code> <code>pop ebp</code></p>\n<h2 id=\"CISC和RISC的基本概念\"><a href=\"#CISC和RISC的基本概念\" class=\"headerlink\" title=\"CISC和RISC的基本概念\"></a>CISC和RISC的基本概念</h2><p>复杂指令系统计算机(CISC)：比如x86<br>精简指令系统计算机(RISC)：ARM, MIPS…</p>\n<h3 id=\"CISC\"><a href=\"#CISC\" class=\"headerlink\" title=\"CISC\"></a>CISC</h3><ul>\n<li>指令系统复杂庞大，指令数目多</li>\n<li>指令长度不固定，格式多，寻址方式多</li>\n<li>可以访存的指令不受限制（比如x86的add可以直接把reg和mem相加，但是riscv的只能reg和reg或者reg和imm）</li>\n<li>各种指令使用频度相差很大</li>\n<li>各种指令执行时间相差很大，大多指令需要多个时钟周期</li>\n<li>控制器大多采用微程序控制，无法采用硬连线控制</li>\n<li>难以用优化编译生成高效的目标代码程序</li>\n</ul>\n<h3 id=\"RISC\"><a href=\"#RISC\" class=\"headerlink\" title=\"RISC\"></a>RISC</h3><ul>\n<li>选取使用频率最高的一些简单指令，复杂指令的功能由简单指令的组合来实现</li>\n<li>指令长度固定，指令格式种类少，寻址方式种类少</li>\n<li>只有LOAD&#x2F;STORE访存，其余指令的操作只能访问寄存器&#x2F;imm</li>\n<li>CPU中通用寄存器数量相当多</li>\n<li>采用流水线技术，大部分指令在一个时钟周期内完成</li>\n<li>硬布线控制为主，不用或少用微程序控制</li>\n<li>重视编译优化<br>CISC兼容性好，大多RISC不能和老机器兼容，但具有更强的实用性。CISC可以提供更多的功能</li>\n</ul>\n<h3 id=\"CISC和RISC的比较\"><a href=\"#CISC和RISC的比较\" class=\"headerlink\" title=\"CISC和RISC的比较\"></a>CISC和RISC的比较</h3><p>和CISC相比，RISC的优点：</p>\n<ul>\n<li>RISC更能充分利用VLSI（超大规模集成电路）芯片的面积（减少了控制逻辑）</li>\n<li>RISC更能提高运算速度</li>\n<li>RISC便于设计，可以降低成本，提高可靠性</li>\n<li>有利于编译优化<br><img data-src=\"/f9.jpg\"></li>\n</ul>\n",
            "tags": [
                "指令系统"
            ]
        }
    ]
}