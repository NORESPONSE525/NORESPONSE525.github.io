{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog • All posts by \"指令系统\" tag",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/08/01/computer-science/computer-organization/ch4/",
            "url": "http://example.com/2025/08/01/computer-science/computer-organization/ch4/",
            "title": "Ch4",
            "date_published": "2025-07-31T16:00:00.000Z",
            "content_html": "<h1 id=\"ch4-指令系统\"><a class=\"markdownIt-Anchor\" href=\"#ch4-指令系统\">#</a> Ch4 指令系统</h1>\n<h2 id=\"指令系统\"><a class=\"markdownIt-Anchor\" href=\"#指令系统\">#</a> 指令系统</h2>\n<h3 id=\"isa王道叫它指令集体系结构\"><a class=\"markdownIt-Anchor\" href=\"#isa王道叫它指令集体系结构\">#</a> ISA（王道叫它指令集体系结构）</h3>\n<p>指令系统 vs ISA</p>\n<p>ISA 完整地定义了软件和硬件之间的接口，规定了：</p>\n<ul>\n<li>指令格式（指令寻址方式，操作类型，操作数）</li>\n<li>操作数的类型、寻址方式、大端小端存放（大端：高位放在低地址；小端：低位放在低地址）</li>\n<li>程序可访问的寄存器编号、个数和位数，存储空间大小和编址方式</li>\n<li>指令执行过程的控制方式（PC, condition code, …）</li>\n</ul>\n<h3 id=\"指令的基本格式\"><a class=\"markdownIt-Anchor\" href=\"#指令的基本格式\">#</a> 指令的基本格式</h3>\n<p>操作码 + 地址码<br>\n主存一般是按字节编址，所以指令字长通常为字节的整数倍</p>\n<ol>\n<li>\n<p>零地址指令<br>\n NOP, HLT<br>\n 不需要操作数。<br>\n零地址的运算类指令仅用在堆栈计算机中（操作数直接从栈顶弹出）</p>\n</li>\n<li>\n<p>一地址指令<br>\n OP, A1<br>\nOP(A1) -&gt; A1<br>\n 加 1，减 1，取反，求补，移位等<br>\n可能有一个操作数或者两个操作数</p>\n</li>\n</ol>\n<blockquote>\n<p>隐含约定目的地址的双操作数指令，地址码指明一个操作数，另一个操作数来自隐含寻址</p>\n</blockquote>\n<ol start=\"3\">\n<li>\n<p>二地址指令<br>\n OP, A1, A2<br>\n(A1)OP(A2) -&gt; A1</p>\n</li>\n<li>\n<p>三地址指令<br>\n OP, A1, A2, A3<br>\n(A1)OP(A2) -&gt; A3</p>\n</li>\n<li>\n<p>四地址指令<br>\n OP, A1, A2, A3, A4<br>\n (A1) OP (A2) -&gt; A3, A4 = 下一条将要执行指令的地址</p>\n</li>\n</ol>\n<h3 id=\"定长操作码指令格式\"><a class=\"markdownIt-Anchor\" href=\"#定长操作码指令格式\">#</a> 定长操作码指令格式</h3>\n<p>n 位 opcode 最多能表示 2^n 条指令<br>\n指令字长：单字长 (PC = PC + 1)、双字长 (PC = PC + 2)…</p>\n<h3 id=\"扩展操作码指令格式\"><a class=\"markdownIt-Anchor\" href=\"#扩展操作码指令格式\">#</a> 扩展操作码指令格式</h3>\n<p>才去可变长度操作码，分散地放在指令字的不同位置上<br>\n要求：</p>\n<ol>\n<li>不允许短码是长码的前缀</li>\n<li>各指令的操作码不能重复<br>\n<img data-src=\"f1.jpg\" alt><br>\n RISC-V 指令集</li>\n</ol>\n<h3 id=\"指令的操作类型\"><a class=\"markdownIt-Anchor\" href=\"#指令的操作类型\">#</a> 指令的操作类型</h3>\n<ol>\n<li>数据传送</li>\n</ol>\n<ul>\n<li>MOV: 寄存器到寄存器</li>\n<li>LOAD: 从内存读到寄存器</li>\n<li>STORE: 从寄存器写入内存</li>\n<li>PUSH</li>\n<li>POP</li>\n</ul>\n<ol start=\"2\">\n<li>\n<p>算术和逻辑运算<br>\n ADD, SUB, MUL, DIV, MOD, AND, OR, XOR, NOT, XOR, INC (加一), DEC (减一)</p>\n</li>\n<li>\n<p>移位<br>\n算术移位，逻辑移位，循环移位</p>\n</li>\n<li>\n<p>转移<br>\n JMP, BRANCH, CALL, RET, TRAP（中断隐指令是硬件实现的，只有 TRAP 是软指令）</p>\n</li>\n<li>\n<p>I/O 操作</p>\n</li>\n</ol>\n<h2 id=\"指令的寻址方式\"><a class=\"markdownIt-Anchor\" href=\"#指令的寻址方式\">#</a> 指令的寻址方式</h2>\n<h3 id=\"指令寻址与数据寻址\"><a class=\"markdownIt-Anchor\" href=\"#指令寻址与数据寻址\">#</a> 指令寻址与数据寻址</h3>\n<ol>\n<li>指令寻址</li>\n</ol>\n<ul>\n<li>顺序： PC = PC + 1</li>\n<li>跳转： 绝对转移 (PC = 跳转地址) , 相对转移 (PC = PC + offset)</li>\n</ul>\n<ol start=\"2\">\n<li>数据寻址<br>\n格式：操作码 寻址特征 形式地址 A</li>\n</ol>\n<ul>\n<li>立即寻址 (addi, …)</li>\n<li>直接寻址（A 直接表示地址）</li>\n<li>寄存器寻址 (add, …)</li>\n<li>寄存器间接寻址 (lw r1 offset (r2), …)</li>\n</ul>\n<h3 id=\"常见的数据寻址方式\"><a class=\"markdownIt-Anchor\" href=\"#常见的数据寻址方式\">#</a> 常见的数据寻址方式</h3>\n<ol>\n<li>隐含寻址<br>\n比如单地址的第二个操作数由 ACC 提供: Intel 8080 的 <code>ADD A</code>  指令会将寄存器 A 的内容与指定的操作数（放在 ACC 内）相加，并将结果存储回累加器中<br>\n优点是缩短指令字长；缺点是需要增加存储操作数或隐含地址的硬件</li>\n<li>立即（数）寻址<br>\n比如 riscv 的 <code>addi x5, x6, #1</code> <br>\n 优点是不用访存速度快，缺点是立即数位数有限</li>\n<li>直接寻址<br>\n <code>OP #A</code> <br>\n 比如 lc3 的 <code>LD R1, LABEL1</code>  翻译成汇编是 <code>LD R1, x3100</code>  表示 <code>R1 &lt;- MEM[x3100]</code> <br>\n 形式地址 A 就是操作数的真实地址 EA<br>\n 优点是简单，缺点是寻址范围受 A 的位数限制</li>\n<li>间接寻址<br>\n EA = (A)<br>\n 指令中给出的地址是包含实际地址的内存位置或寄存器<br>\n比如 lc3 的 <code>LDI R1, LABEL1</code>  翻译成汇编是 <code>LDI R1, x3100</code>  表示 <code>R1 &lt;- MEM[MEM[x3100]]</code></li>\n<li>寄存器寻址<br>\n EA = (Ri)<br>\n <code>ADD R1, R2, R3</code></li>\n<li>寄存器间接寻址<br>\n EA = (Ri)<br>\n 比如 <code>LW R1, offset(R2)</code></li>\n<li>相对寻址<br>\n相对 PC 寻址<br>\n EA = (PC) + A<br>\n 比如 branch</li>\n<li>基址寻址<br>\n EA = (BR) + A<br>\n 面向操作系统，优点是扩大寻址范围，有利于躲到程序设计；缺点是偏移量 (A) 的位数较短</li>\n<li>变址寻址<br>\n EA = (IX) + A<br>\n 比如用来访问数组</li>\n</ol>\n<blockquote>\n<p>偏址寻址：相对寻址、基址寻址、变址寻址</p>\n</blockquote>\n<ol start=\"10\">\n<li>堆栈寻址有一个堆栈指针 SP，堆栈分为硬堆栈，软堆栈。寄存器堆栈是硬堆栈，内存是软堆栈。采用无操作数指令<br>\n<img data-src=\"f2.jpg\" alt></li>\n</ol>\n<h2 id=\"程序的机器级代码表示\"><a class=\"markdownIt-Anchor\" href=\"#程序的机器级代码表示\">#</a> 程序的机器级代码表示</h2>\n<p>x86 汇编</p>\n<h3 id=\"常用汇编指令介绍\"><a class=\"markdownIt-Anchor\" href=\"#常用汇编指令介绍\">#</a> 常用汇编指令介绍</h3>\n<ol>\n<li>相关寄存器<br>\n x86 架构有 8 个 32 位的通用寄存器：EAX、EBX、ECX、EDX、ESI、EDI、EBP、ESP<br>\n<img data-src=\"f3.jpg\" alt><br>\n<img data-src=\"f4.jpg\" alt><br>\n<img data-src=\"f5.jpg\" alt></li>\n<li>汇编指令格式<br>\n x86 汇编指令格式有两种：AT&amp;T 格式和 Intel 格式</li>\n</ol>\n<ul>\n<li>AT&amp;T 只能小写，Intel 大小写都行</li>\n<li>AT&amp;T 第一个操作数是源操作数，第二个是目的操作数；Intel 第一个操作数是目的操作数，第二个是源操作数</li>\n<li>AT&amp;T 寄存器前缀 %，立即数前缀 $；Intel 格式寄存器和立即数不需要加前缀</li>\n<li>内存寻址：AT&amp;T 格式为 (addr)，Intel 格式为 [addr]</li>\n<li>处理复杂寻址方式时，AT&amp;T 格式为 disp (base, index, scale)，表示偏移量，基址寄存器，变址寄存器，比例因子，表示的操作数为 M [R [base]+R [index]*scale + disp];</li>\n<li>指定数据长度时，AT&amp;T 用 b, w, l; Intel 用 byte ptr, word ptr, dword ptr (一个 word 是 16 位，一个 dword 是 32 位)<br>\n<img data-src=\"f6.jpg\" alt><br>\n<img data-src=\"f7.jpg\" alt></li>\n</ul>\n<ol start=\"3\">\n<li>常用指令</li>\n</ol>\n<ul>\n<li><reg>表示任意寄存器，后面跟数字指定其位数</reg></li>\n<li><mem>内存地址</mem></li>\n<li><con>后面跟数字表示几位常数<br>\n常见的指令：</con></li>\n<li>数据传送指令\n<ul>\n<li>mov\n<ul>\n<li>mov <reg>, <reg></reg></reg></li>\n<li>mov <reg>, <mem></mem></reg></li>\n<li>mov <mem>, <reg></reg></mem></li>\n<li>mov <reg>, <con></con></reg></li>\n<li>mov <mem>, <con></con></mem></li>\n</ul>\n</li>\n<li>push (ESP 指向栈顶空的位置，push 之前 ESP = ESP - 4)<mark> 栈中元素固定为 32 位</mark>\n<ul>\n<li>push &lt;reg32</li>\n<li>push <mem></mem></li>\n<li>push <con32></con32></li>\n</ul>\n</li>\n<li>pop (pop 之后 ESP = ESP + 4)\n<ul>\n<li>pop <reg32></reg32></li>\n<li>pop <mem></mem></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>算术和逻辑运算\n<ul>\n<li>add/sub (把两个操作数相加 / 减，结果放回目的操作数)\n<ul>\n<li>add eax, 10    # eax = eax + 10</li>\n<li>add byte ptr [var], 10    # 10 与 var 指向的内存地址的一字节值相加，结果放回 var 指向的内存中</li>\n</ul>\n</li>\n<li>inc/dec (把操作数自加 1 / 自减 1)\n<ul>\n<li>dec eax    # eax = eax - 1</li>\n<li>inc dword ptr [var]    # var 指向的 32 位值自加 1，结果放回 var 指向的 32 位内存中</li>\n</ul>\n</li>\n<li>imul (有符号数整数乘法，mul 是无符号数乘法) 目的操作数必须是寄存器，溢出时 <code>OF = 1</code>\n<ul>\n<li>imul <reg32>, <reg32></reg32></reg32></li>\n<li>imul <reg32>, <mem></mem></reg32></li>\n<li>imul <reg32>, <reg32>, <con></con></reg32></reg32></li>\n<li>imul <reg32>, <mem>, <con></con></mem></reg32></li>\n</ul>\n</li>\n<li>idiv (有符号数整数除法，<mark>只有一个操作数为除数，被除数有 64 位放在  <code>edx:eax</code>  中，操作结果商放到 <code>eax</code> ，余数放到 <code>edx</code> </mark>)\n<ul>\n<li>idiv <reg32></reg32></li>\n<li>idiv <mem></mem></li>\n</ul>\n</li>\n<li>and/or/xor\n<ul>\n<li>and/or/xor <reg>, <reg></reg></reg></li>\n<li>and/or/xor <reg>, <mem></mem></reg></li>\n<li>and/or/xor <mem>, <reg></reg></mem></li>\n<li>and/or/xor <reg>, <con></con></reg></li>\n<li>and/or/xor <mem>, <con></con></mem></li>\n</ul>\n</li>\n<li>not (按位取反)\n<ul>\n<li>not <reg></reg></li>\n<li>not <mem></mem></li>\n</ul>\n</li>\n<li>neg (取负)\n<ul>\n<li>neg <reg></reg></li>\n<li>neg <mem></mem></li>\n</ul>\n</li>\n<li>shl/shr (逻辑左移 / 右移)\n<ul>\n<li>shl <reg>, <con8></con8></reg></li>\n<li>shl <mem>, <con8></con8></mem></li>\n<li>shr <reg>, <reg8></reg8></reg></li>\n<li>shr <mem>, <reg8></reg8></mem></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>控制流\n<ul>\n<li>jmp\n<ul>\n<li>jmp <label></label></li>\n</ul>\n</li>\n<li>jcondition\n<ul>\n<li>je <label></label></li>\n<li>jz <label></label></li>\n<li>jne <label></label></li>\n<li>jg <label></label></li>\n<li>jge <label></label></li>\n<li>jl <label></label></li>\n<li>jle <label></label></li>\n</ul>\n</li>\n<li>cmp/test (cmp 相当于相减，test 相当于按位与，不保存操作结果仅设置条件码用于跳转指令)\n<ul>\n<li>cmp/test <reg>, <reg></reg></reg></li>\n<li>cmp/test <reg>, <mem></mem></reg></li>\n<li>cmp/test <mem>, <reg></reg></mem></li>\n<li>cmp/test <reg>, <con></con></reg></li>\n</ul>\n</li>\n<li>call/ret (call 将返回地址入栈然后跳转，ret 弹出返回地址并跳转)\n<ul>\n<li>call <label></label></li>\n<li>ret</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"选择语句的机器级表示\"><a class=\"markdownIt-Anchor\" href=\"#选择语句的机器级表示\">#</a> 选择语句的机器级表示</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(test_exp)</span><br><span class=\"line\">    then_stmt</span><br><span class=\"line\">else</span><br><span class=\"line\">    else_stmt</span><br></pre></td></tr></table></figure>\n<p>翻译成</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(!t)</span><br><span class=\"line\">    goto false;</span><br><span class=\"line\">then_stmt;   </span><br><span class=\"line\">goto done;</span><br><span class=\"line\">false:  else_stmt;</span><br><span class=\"line\">done:</span><br></pre></td></tr></table></figure>\n<h3 id=\"循环语句的机器级表示\"><a class=\"markdownIt-Anchor\" href=\"#循环语句的机器级表示\">#</a> 循环语句的机器级表示</h3>\n<ol>\n<li>do-while</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">do</span><br><span class=\"line\">  body_stmt</span><br><span class=\"line\">  while(test_exp);</span><br></pre></td></tr></table></figure>\n<p>翻译成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loop:   body_stmt;</span><br><span class=\"line\">  t = test_exp;</span><br><span class=\"line\">  if(t)</span><br><span class=\"line\">    goto loop;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>while</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while(test_exp)</span><br><span class=\"line\">  body_stmt;</span><br></pre></td></tr></table></figure>\n<p>翻译成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t = test_exp;</span><br><span class=\"line\">if(!t)</span><br><span class=\"line\">  goto done;</span><br><span class=\"line\">loop:</span><br><span class=\"line\">  body_stmt;</span><br><span class=\"line\">  t = test_exp;</span><br><span class=\"line\">  if(t)</span><br><span class=\"line\">    goto loop;</span><br><span class=\"line\">done:</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>for</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(init_exp; test_exp; update_exp)</span><br><span class=\"line\">  body_stmt;</span><br></pre></td></tr></table></figure>\n<p>翻译成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init_exp;</span><br><span class=\"line\">t = test_exp;</span><br><span class=\"line\">if(!t)</span><br><span class=\"line\">  goto done;</span><br><span class=\"line\">loop:</span><br><span class=\"line\">  body_stmt;</span><br><span class=\"line\">  update_exp;</span><br><span class=\"line\">  t = test_exp;</span><br><span class=\"line\">  if(t)</span><br><span class=\"line\">    goto loop;</span><br><span class=\"line\">done:</span><br></pre></td></tr></table></figure>\n<h3 id=\"过程调用的机器级表示\"><a class=\"markdownIt-Anchor\" href=\"#过程调用的机器级表示\">#</a> 过程调用的机器级表示</h3>\n<ol>\n<li>caller 将实参放到 callee 能访问的地方（寄存器放不下放栈里）</li>\n<li>caller 保存返回地址（通过 call 指令实现）</li>\n<li>callee 保存 caller 通用寄存器的内容，并为自己的非静态局部变量分配空间</li>\n<li>执行 callee</li>\n<li>恢复 caller 的寄存器内容，将返回值放到 caller 能访问的地方（寄存器、栈），释放局部变量</li>\n<li>callee 取出返回地址，恢复 PC（ret 实现）</li>\n</ol>\n<blockquote>\n<p>EAX, ECX, EDX 是 caller saved register<br>\n 通常用于传递参数、存储临时变量或返回值，所以 call 的时候内容可能会变，要先保存再调用。比如返回值一般保存在 EAX<br>\nEBX, ESI, EDI 是 callee saved register<br>\n 这些寄存器的值在函数调用后应保持不变，所以由 callee 保存，ret 的时候要恢复</p>\n</blockquote>\n<p>每个过程有自己的栈帧， <code>EBP</code>  保存栈帧的基址， <code>ESP</code>  指向栈顶位置， <code>EBP</code>  的值不变，当前栈帧的范围在 <code>EBP</code>  和 <code>ESP</code>  之间（详见编译原理 <code>activated record</code> ）<br>\n<img data-src=\"f8.jpg\" alt><br>\n前三行的意思是新开一个栈帧，分配了 24 字节的栈帧空间。 <code>push epb</code>  实际上就是把 static link 压栈。<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ub3Jlc3BvbnNlNTI1LmdpdGh1Yi5pby8yMDI1LzA2LzE1L2NvbXB1dGVyLXNjaWVuY2UvY29tcGlsZS1wcmluY2lwbGVzL2NoNi8jJUU1JTg3JUJEJUU2JTk1JUIwJUU4JUIwJTgzJUU3JTk0JUE4JUU2JUI1JTgxJUU3JUE4JThC\">详见编译原理笔记</span><br>\n执行 <code>call</code>  之后， <code>call</code>  会先将返回地址压栈，然后跳转到 <code>add</code>  的起始地址，为 <code>add</code>  创建栈帧。 <code>add</code>  的返回值存放在 <code>EAX</code>  中。<br>\n执行 <code>ret</code>  之前需要释放当前栈帧，恢复 caller 的栈帧。因此 <code>leave</code>  相当于 <code>mov esp, ebp</code>   <code>pop ebp</code></p>\n<h2 id=\"cisc和risc的基本概念\"><a class=\"markdownIt-Anchor\" href=\"#cisc和risc的基本概念\">#</a> CISC 和 RISC 的基本概念</h2>\n<p>复杂指令系统计算机 (CISC)：比如 x86<br>\n 精简指令系统计算机 (RISC)：ARM, MIPS…</p>\n<h3 id=\"cisc\"><a class=\"markdownIt-Anchor\" href=\"#cisc\">#</a> CISC</h3>\n<ul>\n<li>指令系统复杂庞大，指令数目多</li>\n<li>指令长度不固定，格式多，寻址方式多</li>\n<li>可以访存的指令不受限制（比如 x86 的 add 可以直接把 reg 和 mem 相加，但是 riscv 的只能 reg 和 reg 或者 reg 和 imm）</li>\n<li>各种指令使用频度相差很大</li>\n<li>各种指令执行时间相差很大，大多指令需要多个时钟周期</li>\n<li>控制器大多采用微程序控制，无法采用硬连线控制</li>\n<li>难以用优化编译生成高效的目标代码程序</li>\n</ul>\n<h3 id=\"risc\"><a class=\"markdownIt-Anchor\" href=\"#risc\">#</a> RISC</h3>\n<ul>\n<li>选取使用频率最高的一些简单指令，复杂指令的功能由简单指令的组合来实现</li>\n<li>指令长度固定，指令格式种类少，寻址方式种类少</li>\n<li>只有 LOAD/STORE 访存，其余指令的操作只能访问寄存器 /imm</li>\n<li>CPU 中通用寄存器数量相当多</li>\n<li>采用流水线技术，大部分指令在一个时钟周期内完成</li>\n<li>硬布线控制为主，不用或少用微程序控制</li>\n<li>重视编译优化<br>\n CISC 兼容性好，大多 RISC 不能和老机器兼容，但具有更强的实用性。CISC 可以提供更多的功能</li>\n</ul>\n<h3 id=\"cisc和risc的比较\"><a class=\"markdownIt-Anchor\" href=\"#cisc和risc的比较\">#</a> CISC 和 RISC 的比较</h3>\n<p>和 CISC 相比，RISC 的优点：</p>\n<ul>\n<li>RISC 更能充分利用 VLSI（超大规模集成电路）芯片的面积（减少了控制逻辑）</li>\n<li>RISC 更能提高运算速度</li>\n<li>RISC 便于设计，可以降低成本，提高可靠性</li>\n<li>有利于编译优化<br>\n<img data-src=\"f9.jpg\" alt></li>\n</ul>\n",
            "tags": [
                "指令系统"
            ]
        }
    ]
}