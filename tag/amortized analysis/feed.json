{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog • All posts by \"amortized analysis\" tag",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/09/15/computer-science/DS/Amortized%20Analysis/",
            "url": "http://example.com/2025/09/15/computer-science/DS/Amortized%20Analysis/",
            "title": "Amortized Analysis",
            "date_published": "2025-09-14T16:00:00.000Z",
            "content_html": "<ol>\n<li><p>Aggregate analysis<br>a sequence of $n$ operations takes worst-case time $T(n)$ int total. In the worst-case, the average cost, or amortized cost, per operation is $T(n)&#x2F;n$.</p>\n<blockquote>\n<p>example: stack with MultiPop(int k, Stack S)</p>\n</blockquote>\n</li>\n<li><p>Accounting method<br>When an operation’s amortized cost is $\\hat{c_i}$ exceeds its actural cost $c_i$, we assign the dirrerence to specific objects in the data structure as credit. Credit can pay for the later operations whose amortized cost is less than their actual cost.<br>实际成本优于均摊成本，把差额分配给数据结构中的特定对象，表示为credit, credit可以帮助支付后续操作的费用，这些操作的摊还成本小于实际成本<br>For all sequences of $n$ operations, we must assure:<br>$$<br>\\sum_{i&#x3D;1}^n \\hat{c_i} \\geq \\sum_{i&#x3D;1}^n c_i<br>$$</p>\n</li>\n</ol>\n<ul>\n<li><p>当某次操作的 <strong>摊还代价 &gt; 实际代价</strong>（(\\hat{c}_i &gt; c_i)），<br>多出来的部分 (\\hat{c}_i - c_i) 被存为 <strong>credit（信用）</strong>，附着在数据结构的某些对象上。</p>\n</li>\n<li><p>当后续某次操作 <strong>实际代价 &gt; 摊还代价</strong>（(c_j &gt; \\hat{c}_j)），<br>就用之前存下的 credit 来“支付”超出的部分。</p>\n</li>\n</ul>\n<p>但有一个<strong>硬性约束</strong>：  </p>\n<blockquote>\n<p><strong>任何时候都不能透支 credit！</strong><br>也就是说，在任何前缀操作 (1..k) 中，累计的 credit 必须 ≥ 0。</p>\n</blockquote>\n<p>这等价于要求：<br>$$<br>\\forall k,\\quad \\sum_{i&#x3D;1}^k \\hat{c}<em>i \\geq \\sum</em>{i&#x3D;1}^k c_i<br>$$<br>特别地，对整个序列（(k &#x3D; n)）就有：<br>$$<br>\\sum_{i&#x3D;1}^n \\hat{c}<em>i \\geq \\sum</em>{i&#x3D;1}^n c_i<br>$$<br><img data-src=\"/1202-1.png\"><br>不同操作的摊还代价可能会不同，</p>\n<ol start=\"3\">\n<li>Potential method<br><img data-src=\"/12-5-1.png\"></li>\n</ol>\n<p>+++info<br>;;;id3 例子<br>2-5 Consider the following buffer management problem. Initially the buffer size (the number of blocks) is one. Each block can accommodate exactly one item. As soon as a new item arrives, check if there is an available block. If yes, put the item into the block, induced a cost of one. Otherwise, the buffer size is doubled, and then the item is able to put into. Moreover, the old items have to be moved into the new buffer so it costs <em>k</em>+1 to make this insertion, where <em>k</em> is the number of old items. Clearly, if there are <em>N</em> items, the worst-case cost for one insertion can be Ω(<em>N</em>). To show that the average cost is <em>O</em>(1), let us turn to the amortized analysis. To simplify the problem, assume that the buffer is full after all the <em>N</em> items are placed. Which of the following potential functions works?</p>\n<p>A. The number of items currently in the buffer</p>\n<p>B. The opposite number of items currently in the buffer</p>\n<p>C. The number of available blocks currently in the buffer</p>\n<p>D. The opposite number of available blocks in the buffer<br>;;;</p>\n<p>;;;<br>D.&#x3D;&#x3D;势能函数需要保证摊还成本都为常数，一个一个试只能选D&#x3D;&#x3D;<br><img data-src=\"/hw.png\"><br>;;;<br>+++</p>\n",
            "tags": [
                "Amortized Analysis"
            ]
        }
    ]
}