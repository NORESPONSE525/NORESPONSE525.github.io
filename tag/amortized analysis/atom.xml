<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>NoResponse&#39;s Blog • Posts by &#34;amortized analysis&#34; tag</title>
    <link href="http://example.com" />
    <updated>2025-09-14T16:00:00.000Z</updated>
    <category term="人工智能" />
    <category term="软件工程" />
    <category term="自监督学习" />
    <category term="容器" />
    <category term="杂项" />
    <category term="面经" />
    <category term="ctest" />
    <category term="gtest" />
    <category term="test coverage" />
    <category term="C++" />
    <category term="Amortized Analysis" />
    <category term="数据结构" />
    <category term="栈、队列和数组" />
    <category term="线性表" />
    <category term="串" />
    <category term="树与二叉树" />
    <category term="查找" />
    <category term="图论" />
    <category term="排序" />
    <category term="计算机网络" />
    <category term="操作系统" />
    <category term="fds" />
    <category term="编译原理" />
    <category term="Liveness Analysis" />
    <category term="Register Allocation" />
    <category term="语法分析" />
    <category term="词法分析" />
    <category term="抽象语法" />
    <category term="活动记录" />
    <category term="语义分析" />
    <category term="中间代码" />
    <category term="Basic Blocks and Traces" />
    <category term="指令选择" />
    <category term="数据的表示与运算" />
    <category term="计算机组成" />
    <category term="指令系统" />
    <category term="CPU" />
    <category term="存储系统" />
    <category term="总线" />
    <category term="I/O" />
    <category term="错题" />
    <entry>
        <id>http://example.com/2025/09/15/computer-science/DS/Amortized%20Analysis/</id>
        <title>Amortized Analysis</title>
        <link rel="alternate" href="http://example.com/2025/09/15/computer-science/DS/Amortized%20Analysis/"/>
        <content type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Aggregate analysis&lt;br&gt;a sequence of $n$ operations takes worst-case time $T(n)$ int total. In the worst-case, the average cost, or amortized cost, per operation is $T(n)&amp;#x2F;n$.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;example: stack with MultiPop(int k, Stack S)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Accounting method&lt;br&gt;When an operation’s amortized cost is $\hat{c_i}$ exceeds its actural cost $c_i$, we assign the dirrerence to specific objects in the data structure as credit. Credit can pay for the later operations whose amortized cost is less than their actual cost.&lt;br&gt;实际成本优于均摊成本，把差额分配给数据结构中的特定对象，表示为credit, credit可以帮助支付后续操作的费用，这些操作的摊还成本小于实际成本&lt;br&gt;For all sequences of $n$ operations, we must assure:&lt;br&gt;$$&lt;br&gt;\sum_{i&amp;#x3D;1}^n \hat{c_i} \geq \sum_{i&amp;#x3D;1}^n c_i&lt;br&gt;$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当某次操作的 &lt;strong&gt;摊还代价 &amp;gt; 实际代价&lt;/strong&gt;（(\hat{c}_i &amp;gt; c_i)），&lt;br&gt;多出来的部分 (\hat{c}_i - c_i) 被存为 &lt;strong&gt;credit（信用）&lt;/strong&gt;，附着在数据结构的某些对象上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当后续某次操作 &lt;strong&gt;实际代价 &amp;gt; 摊还代价&lt;/strong&gt;（(c_j &amp;gt; \hat{c}_j)），&lt;br&gt;就用之前存下的 credit 来“支付”超出的部分。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但有一个&lt;strong&gt;硬性约束&lt;/strong&gt;：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;任何时候都不能透支 credit！&lt;/strong&gt;&lt;br&gt;也就是说，在任何前缀操作 (1..k) 中，累计的 credit 必须 ≥ 0。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这等价于要求：&lt;br&gt;$$&lt;br&gt;\forall k,\quad \sum_{i&amp;#x3D;1}^k \hat{c}&lt;em&gt;i \geq \sum&lt;/em&gt;{i&amp;#x3D;1}^k c_i&lt;br&gt;$$&lt;br&gt;特别地，对整个序列（(k &amp;#x3D; n)）就有：&lt;br&gt;$$&lt;br&gt;\sum_{i&amp;#x3D;1}^n \hat{c}&lt;em&gt;i \geq \sum&lt;/em&gt;{i&amp;#x3D;1}^n c_i&lt;br&gt;$$&lt;br&gt;&lt;img data-src=&#34;/1202-1.png&#34;&gt;&lt;br&gt;不同操作的摊还代价可能会不同，&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Potential method&lt;br&gt;&lt;img data-src=&#34;/12-5-1.png&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;+++info&lt;br&gt;;;;id3 例子&lt;br&gt;2-5 Consider the following buffer management problem. Initially the buffer size (the number of blocks) is one. Each block can accommodate exactly one item. As soon as a new item arrives, check if there is an available block. If yes, put the item into the block, induced a cost of one. Otherwise, the buffer size is doubled, and then the item is able to put into. Moreover, the old items have to be moved into the new buffer so it costs &lt;em&gt;k&lt;/em&gt;+1 to make this insertion, where &lt;em&gt;k&lt;/em&gt; is the number of old items. Clearly, if there are &lt;em&gt;N&lt;/em&gt; items, the worst-case cost for one insertion can be Ω(&lt;em&gt;N&lt;/em&gt;). To show that the average cost is &lt;em&gt;O&lt;/em&gt;(1), let us turn to the amortized analysis. To simplify the problem, assume that the buffer is full after all the &lt;em&gt;N&lt;/em&gt; items are placed. Which of the following potential functions works?&lt;/p&gt;
&lt;p&gt;A. The number of items currently in the buffer&lt;/p&gt;
&lt;p&gt;B. The opposite number of items currently in the buffer&lt;/p&gt;
&lt;p&gt;C. The number of available blocks currently in the buffer&lt;/p&gt;
&lt;p&gt;D. The opposite number of available blocks in the buffer&lt;br&gt;;;;&lt;/p&gt;
&lt;p&gt;;;;&lt;br&gt;D.&amp;#x3D;&amp;#x3D;势能函数需要保证摊还成本都为常数，一个一个试只能选D&amp;#x3D;&amp;#x3D;&lt;br&gt;&lt;img data-src=&#34;/hw.png&#34;&gt;&lt;br&gt;;;;&lt;br&gt;+++&lt;/p&gt;
</content>
        <category term="Amortized Analysis" />
        <updated>2025-09-14T16:00:00.000Z</updated>
    </entry>
</feed>
