{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog • All posts by \"中间代码\" tag",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/06/15/computer-science/compile-principles/ch7/",
            "url": "http://example.com/2025/06/15/computer-science/compile-principles/ch7/",
            "title": "Ch7",
            "date_published": "2025-06-14T16:00:00.000Z",
            "content_html": "<h1 id=\"IR\"><a href=\"#IR\" class=\"headerlink\" title=\"IR\"></a>IR</h1><p>Intermediate Representation<br>解决高级语言和目标机器汇编语言之间的转化<br>为什么需要IR:</p>\n<ul>\n<li>更模块化、可迁移</li>\n<li>分层分析和优化<br>IR可以有好多层：IR1-&gt;IR2-&gt;…-&gt;IRn<br>+++info 编译流程划分<br>前端：源代码-&gt;词法分析-&gt;语法分析-&gt;语义分析（IR之前的都是）<br>中端：基于IR的分析与变换（可能生成新IR，可以做一些机器无关优化比如循环展开等）<br>后端：指令选择-&gt;寄存器分配-&gt;指令调度-&gt;机器码（IR之后的）<br>+++</li>\n</ul>\n<h2 id=\"Three-Address-Code\"><a href=\"#Three-Address-Code\" class=\"headerlink\" title=\"Three-Address Code\"></a>Three-Address Code</h2><p>最多有三个操作数<br>x &#x3D; y op z<br>“地址”可以具有如下形式</p>\n<ul>\n<li>源程序中的名字(name)</li>\n<li>常量 (constant)</li>\n<li>临时变量(temporary)<br><img data-src=\"/f1.jpg\"><br>最常见的实现方法是将三地址代码作为四元组实现<br>+++info example<br>t1&#x3D;x&gt;0                  (gt, x, 0, t1)<br>if_false t1 goto L1     (if_f, t1, L1, _)<br>fact&#x3D;1                  (asn, 1, fact, _)<br>label L2                (lab, L2, _, _)<br>+++</li>\n</ul>\n<h2 id=\"IR-Tree\"><a href=\"#IR-Tree\" class=\"headerlink\" title=\"IR Tree\"></a>IR Tree</h2><p>两大类节点：</p>\n<ol>\n<li>表达式Exp</li>\n<li>语句Stmt<br>文法：<br><img data-src=\"/f2.jpg\"><br>表达式：<table>\n<thead>\n<tr>\n<th>Node</th>\n<th>Description</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CONST(i)</td>\n<td>整数常量i</td>\n<td>CONST(42) → the value 42</td>\n</tr>\n<tr>\n<td>NAME(n)</td>\n<td>符号常量n，通常是一个label，值是label的地址</td>\n<td>NAME(L1) → address of label L1</td>\n</tr>\n<tr>\n<td>TEMP(t)</td>\n<td>临时变量t (like register)</td>\n<td>TEMP(t123) → contents of temporary t123</td>\n</tr>\n<tr>\n<td>BINOP(o,e1,e2)</td>\n<td>对e1和e2执行二元操作o</td>\n<td>BINOP(PLUS,TEMP(t1),CONST(1)) → t1+1</td>\n</tr>\n<tr>\n<td>MEM(e)</td>\n<td>Memory access</td>\n<td>MEM(CONST(100)) → contents at address 100</td>\n</tr>\n<tr>\n<td>CALL(f,l)</td>\n<td>Function call, l是参数列表</td>\n<td>CALL(NAME(print),[TEMP(t1)]) → call print(t1)</td>\n</tr>\n<tr>\n<td>ESEQ(s,e)</td>\n<td>先执行语句s，再求值表达式e并返回e的结果</td>\n<td>ESEQ(MOVE(TEMP(t),CONST(1)),TEMP(t)) → (t&#x3D;1; t)</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<p>语句：</p>\n<table>\n<thead>\n<tr>\n<th>Node</th>\n<th>Description</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>MOVE(TEMP t, e)</td>\n<td>将表达式e的值赋给临时变量t</td>\n<td>MOVE(TEMP(t1), CONST(42)) → t1 &#x3D; 42</td>\n</tr>\n<tr>\n<td>MOVE(MEM(e1), e2)</td>\n<td>将表达式e2的值存储到由e1指定的内存地址中</td>\n<td>MOVE(MEM(TEMP(t1)), CONST(42)) → *t1 &#x3D; 42</td>\n</tr>\n<tr>\n<td>EXP(e)</td>\n<td>计算表达式e的值但不返回结果，通常用于有副作用的操作（如函数调用）</td>\n<td>EXP(CALL(NAME(print), …)) → 调用print()函数以产生效果</td>\n</tr>\n<tr>\n<td>JUMP(e, labs)</td>\n<td>无条件跳转到由e指定的地址</td>\n<td>JUMP(NAME(L1), [L1]) → goto L1</td>\n</tr>\n<tr>\n<td>CJUMP(o,e1,e2,t,f)</td>\n<td>条件跳转，根据操作o对e1和e2的结果决定跳转到t或f</td>\n<td>CJUMP(LT, TEMP(t1), CONST(0), L1, L2) → 如果t1 &lt; 0则跳转到L1，否则跳转到L2</td>\n</tr>\n<tr>\n<td>SEQ(s1, s2)</td>\n<td>语句序列，先执行s1再执行s2</td>\n<td>SEQ(MOVE(…), JUMP(…)) → 先赋值再跳转</td>\n</tr>\n<tr>\n<td>LABEL(n)</td>\n<td>定义一个标签</td>\n<td>LABEL(L1) → L1:</td>\n</tr>\n</tbody></table>\n<p>例子：<br><img data-src=\"/f3.jpg\"><br>ADD那个地方写成BINOP的写法也可以</p>\n<h2 id=\"翻译AST成IR-Tree\"><a href=\"#翻译AST成IR-Tree\" class=\"headerlink\" title=\"翻译AST成IR Tree\"></a>翻译AST成IR Tree</h2><p>把AST表达式分为三类：</p>\n<ul>\n<li>Ex: 有结果的AST表达式比如a+b</li>\n<li>Nx：无结果的语句的比如print</li>\n<li>Cx：条件语句，值为bool的AST表达式</li>\n</ul>\n<h3 id=\"translate-Exp\"><a href=\"#translate-Exp\" class=\"headerlink\" title=\"translate Exp\"></a>translate Exp</h3><ol>\n<li>翻译简单变量：<br>在函数中访问一个局部变量实际上是访问它在当前栈帧中的位置，所以访问一个距离fp的offset为k的局部变量v，其IR Tree表示为:<br>$$<br>MEM(BINOP(PLUS, TEMP fp, CONST k))<br>$$<br><img data-src=\"/f4.jpg\"><br>如果通过static link访问一个变量，就要嵌套好几层MEM和BINOP<br>比如这个访问嵌套两层外面的x<br>最内层使用 CONST(8)：是因为需要从 inner 函数的帧指针 FP 开始，偏移 8 字节来访问静态链，该静态链指向 middle 函数的帧。<br>中间层和最外层使用 CONST(0)：是因为它们分别通过静态链直接访问 outer 函数的帧和变量 x，不需要额外的偏移<br><img data-src=\"/f5.jpg\"><br>:::danger<br>这个地方为什么内层是8中层是0存疑<br>:::</li>\n</ol>\n<p>左值和右值：&#x3D;左右的<br>MEM(addr)可以是左值也可以是右值</p>\n<ul>\n<li>Scalar L-value(Tiger): 一个地址</li>\n<li>Structured L-value(Pascal&#x2F;C): 一块内存</li>\n</ul>\n<ol start=\"2\">\n<li>翻译算术运算</li>\n</ol>\n<ul>\n<li>二元: BINOP(op, e1, e2)</li>\n<li>一元: <ul>\n<li>-x &#x3D;&#x3D;&gt; BINOP(MINUS, CONST(0), e_x)</li>\n<li>~x &#x3D;&#x3D;&gt; BINOP(XOR, e_x, CONST(-1))</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li>数组访问<br>$$<br>MEM(BINOP(PLUS, MEM(e_a), BINOP(MUL, e_i, CONST(W))))<br>$$</li>\n</ol>\n<ul>\n<li><code>e_a</code> 是表示变量 <code>a</code> 的表达式，通常是&#x3D;&#x3D; <code>MEM(+(TEMP(fp), CONST(k_a)))</code>&#x3D;&#x3D;</li>\n<li><code>MEM(e_a)</code>：&#x3D;&#x3D;获取存储在变量 <code>a</code> 中的值，即数组基地址&#x3D;&#x3D;</li>\n<li><code>e_i</code> 是计算索引 <code>i</code> 的表达式</li>\n<li><code>BINOP(MUL, e_i, CONST(W))</code>：计算偏移<br><img data-src=\"/f6.jpg\"></li>\n</ul>\n<p>记录字段r.f访问:<br>$$<br>MEM(BINOP(PLUS, MEM(e_r), BINOP(MUL, n, CONST(W))))<br>$$</p>\n<ol start=\"4\">\n<li>翻译控制流<br>对于if e1 op e2 then stmt1 else stmt2翻译成</li>\n</ol>\n<figure class=\"highlight c\"><figcaption><span>IR</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 6个SEQ</span></span><br><span class=\"line\">SEQ(</span><br><span class=\"line\">    CJUMP(op, e1, e2, t, f),</span><br><span class=\"line\">    SEQ(</span><br><span class=\"line\">        LABEL(t),</span><br><span class=\"line\">        SEQ(</span><br><span class=\"line\">            stm1,</span><br><span class=\"line\">            SEQ(</span><br><span class=\"line\">                JUMP(NAME(end)),</span><br><span class=\"line\">                SEQ(</span><br><span class=\"line\">                    LABEL(f),</span><br><span class=\"line\">                    SEQ(stm2, LABEL(end))</span><br><span class=\"line\">                )</span><br><span class=\"line\">            )</span><br><span class=\"line\">        )</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>Tiger的逻辑运算符&amp;(and)和|(or)需要实现短路求值：只计算必要的操作数<br>每个Cx是一个Label</p>\n<ul>\n<li>逻辑与 (a &amp; b)的短路规则：<ul>\n<li>计算a<br>  -若a为假，直接得到假结果（不计算b）<br>  -若a为真，继续计算b，最终结果即为b的值</li>\n</ul>\n</li>\n<li>逻辑或 (a | b)的短路规则：<br>  -计算a<br>  -若a为真，直接得到真结果（不计算b）<ul>\n<li>若a为假，继续计算b，最终结果即为b的值</li>\n</ul>\n</li>\n</ul>\n<ol start=\"5\">\n<li>循环语句</li>\n</ol>\n<figure class=\"highlight c\"><figcaption><span>tiger</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> a &gt; <span class=\"number\">0</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">a := a - <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>翻译成</p>\n<figure class=\"highlight c\"><figcaption><span>IR</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SEQ(LABEL test, </span><br><span class=\"line\">    SEQ(CJUMP(GT, TEMP a, CONST <span class=\"number\">0</span>, body, done), </span><br><span class=\"line\">        SEQ(LABEL body, </span><br><span class=\"line\">            SEQ(MOVE(TEMP a, BINOP(MINUS, TEMP a, CONST <span class=\"number\">1</span>)), </span><br><span class=\"line\">                SEQ(JUMP(NAME(test), [test]), </span><br><span class=\"line\">                    LABEL done)))))</span><br></pre></td></tr></table></figure>\n<p>break翻译为直接跳转到done<br>for循环我懒得写了，也是一个道理<br>和汇编差不多意思</p>\n<ol start=\"6\">\n<li>翻译函数<br>$$<br>CALL(NAME(l_f), [sl, a_1, …, a_n])<br>$$<br>sl是static link。</li>\n</ol>\n<h3 id=\"translate-Declaration\"><a href=\"#translate-Declaration\" class=\"headerlink\" title=\"translate Declaration\"></a>translate Declaration</h3><ul>\n<li>Variable declaration</li>\n<li>Type declaration</li>\n<li>Function declaration</li>\n</ul>\n<ol>\n<li>翻译变量声明</li>\n</ol>\n<figure class=\"highlight c\"><figcaption><span>tiger</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let</span><br><span class=\"line\">    var x := <span class=\"number\">10</span></span><br><span class=\"line\">    var y := x + <span class=\"number\">5</span></span><br><span class=\"line\">in </span><br><span class=\"line\">    x + y</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><figcaption><span>IR</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ESEQ( </span><br><span class=\"line\">    SEQ( </span><br><span class=\"line\">        MOVE(MEM(+(FP, CONST(x_offset))), CONST(<span class=\"number\">10</span>)), </span><br><span class=\"line\">        MOVE(MEM(+(FP, CONST(y_offset))), </span><br><span class=\"line\">        BINOP(PLUS, </span><br><span class=\"line\">        MEM(+(FP, CONST(x_offset))), </span><br><span class=\"line\">        CONST(<span class=\"number\">5</span>))) </span><br><span class=\"line\">    ), </span><br><span class=\"line\">    BINOP(PLUS, </span><br><span class=\"line\">    MEM(+(FP, CONST(x_offset))), </span><br><span class=\"line\">    MEM(+(FP, CONST(y_offset)))) </span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>let body in e end翻译成ESEQ(body, e)<br>变量定义翻译成 MEM(+(FP, CONST(offset)))<br>初始化翻译成 MOVE(MEM(+(FP, CONST(offset))), CONST(value))</p>\n<ol start=\"2\">\n<li><p>类型声明<br>No need to generate any IR tree code</p>\n</li>\n<li><p>函数声明<br> – Prologue（序言）<br> – Body（函数体）<br> – Epilogue（尾声）</p>\n</li>\n</ol>\n<ul>\n<li>Prologue<ul>\n<li>pseudo-instructions to announce the beginning of a function</li>\n<li>定义函数标签用于跳转&#x2F;调用</li>\n<li>修改栈指针（SP），为新栈帧分配空间，一般是$SP :&#x3D; SP - frame_size$</li>\n<li>保存被调用者需要保存的寄存器（callee-save），如 $s0-$s7；保存返回地址（RA）</li>\n<li>保存函数参数到栈中（尤其是传值调用时）；保存静态链（static link）</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "中间代码"
            ]
        }
    ]
}