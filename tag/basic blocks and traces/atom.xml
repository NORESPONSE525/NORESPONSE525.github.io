<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>NoResponse&#39;s Blog • Posts by &#34;basic blocks and traces&#34; tag</title>
    <link href="http://example.com" />
    <updated>2025-06-16T16:00:00.000Z</updated>
    <category term="软件工程" />
    <category term="人工智能" />
    <category term="计算机网络" />
    <category term="计算机组成" />
    <category term="存储系统" />
    <category term="数据的表示与运算" />
    <category term="错题" />
    <category term="编译原理" />
    <category term="Liveness Analysis" />
    <category term="Register Allocation" />
    <category term="词法分析" />
    <category term="语法分析" />
    <category term="活动记录" />
    <category term="抽象语法" />
    <category term="语义分析" />
    <category term="中间代码" />
    <category term="Basic Blocks and Traces" />
    <category term="指令选择" />
    <entry>
        <id>http://example.com/2025/06/17/computer-science/compile-principles/ch8/</id>
        <title>Basic Blocks &amp; Traces</title>
        <link rel="alternate" href="http://example.com/2025/06/17/computer-science/compile-principles/ch8/"/>
        <content type="html">&lt;h1 id=&#34;Basic-Blocks-and-Traces&#34;&gt;&lt;a href=&#34;#Basic-Blocks-and-Traces&#34; class=&#34;headerlink&#34; title=&#34;Basic Blocks and Traces&#34;&gt;&lt;/a&gt;Basic Blocks and Traces&lt;/h1&gt;&lt;h2 id=&#34;Canonical-Form&#34;&gt;&lt;a href=&#34;#Canonical-Form&#34; class=&#34;headerlink&#34; title=&#34;Canonical Form&#34;&gt;&lt;/a&gt;Canonical Form&lt;/h2&gt;&lt;p&gt;IR存在一些与机器语言不能完全对应的情况，和与编译优化分析相冲突的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CJUMP能够转移到t或者f，但是真正的机器语言在条件为假的时候直接下降至下一条指令（条件为真才跳转）&lt;/li&gt;
&lt;li&gt;在表达式中使用ESEQ不太方便，会使子树不同的计算顺序产生不同的计算结果&lt;/li&gt;
&lt;li&gt;CALL调用CALL作为参数的时候会有寄存器冲突、语句副作用（修改全局变量、改变堆内存, etc.）等问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Linearize: Transform trees into a list of canonical&lt;br&gt;trees without SEQ or ESEQ nodes&lt;/li&gt;
&lt;li&gt;Basic blocks: Group statements into sequences with&lt;br&gt;no internal jumps&amp;#x2F;labels&lt;/li&gt;
&lt;li&gt;Trace schedule: Order basic blocks so every CJUMP is followed by its false label&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;线性化&#34;&gt;&lt;a href=&#34;#线性化&#34; class=&#34;headerlink&#34; title=&#34;线性化&#34;&gt;&lt;/a&gt;线性化&lt;/h3&gt;&lt;p&gt;&amp;#x3D;&amp;#x3D;规范树（Canonical Tree）定义：&amp;#x3D;&amp;#x3D;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无SEQ或ESEQ&lt;/li&gt;
&lt;li&gt;每一个CALL的父亲不是EXP(…)就是MOVE(TEMP t, …)&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;消除ESEQ&#34;&gt;&lt;a href=&#34;#消除ESEQ&#34; class=&#34;headerlink&#34; title=&#34;消除ESEQ&#34;&gt;&lt;/a&gt;消除ESEQ&lt;/h4&gt;&lt;h5 id=&#34;规则&#34;&gt;&lt;a href=&#34;#规则&#34; class=&#34;headerlink&#34; title=&#34;规则&#34;&gt;&lt;/a&gt;规则&lt;/h5&gt;&lt;p&gt;合并副作用，提升ESEQ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ESEQ(s1, ESEQ(s2,e)) &amp;#x3D;&amp;gt; ESEQ(SEQ(s1,s2),e)&lt;/li&gt;
&lt;li&gt;BINOP(op, ESEQ(s, e1), e2) ⇒ ESEQ(s, BINOP(op, e1, e2))&lt;/li&gt;
&lt;li&gt;MEM(ESEQ(s, e1)) ⇒ ESEQ(s, MEM(e1))&lt;/li&gt;
&lt;li&gt;JUMP(ESEQ(s, e1)) ⇒ SEQ(s, JUMP(e1))&lt;/li&gt;
&lt;li&gt;CJUMP(op, ESEQ(s, e1), e2, l1, l2) ⇒ SEQ(s, CJUMP(op, e1, e2, l1, l2))&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;Commutativity（重点）&#34;&gt;&lt;a href=&#34;#Commutativity（重点）&#34; class=&#34;headerlink&#34; title=&#34;Commutativity（重点）&#34;&gt;&lt;/a&gt;Commutativity（重点）&lt;/h5&gt;&lt;p&gt;当&lt;code&gt;ESEQ&lt;/code&gt;出现在&lt;code&gt;BINOP&lt;/code&gt;的右操作数，即$BINOP(op, e1, ESEQ(s, e2))$时，我们不能再像之前那样简单地把&lt;code&gt;s&lt;/code&gt;提升到整个&lt;code&gt;BINOP&lt;/code&gt;之前，因为&lt;code&gt;e1&lt;/code&gt;的求值在&lt;code&gt;e2&lt;/code&gt;之前，否则可能影响&lt;code&gt;e1&lt;/code&gt;的计算结果&lt;/p&gt;
&lt;p&gt;Commutativity：交换性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Commuting: s不影响e1的结果&lt;ul&gt;
&lt;li&gt;rule: $BINOP(op, e1, ESEQ(s, e2)) &amp;#x3D; ESEQ(s, BINOP(op, e1, e2))$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Non-commuting: s会影响e1的结果，把e1的结果显算出来放到临时变量t里，再提升s&lt;ul&gt;
&lt;li&gt;rule: $BINOP(op, ESEQ(s, e1), e2) &amp;#x3D; ESEQ(MOVE(TEMP t, e1), ESEQ(s, BINOP(op, TEMP t, e2)))$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;将CALL移到顶层&#34;&gt;&lt;a href=&#34;#将CALL移到顶层&#34; class=&#34;headerlink&#34; title=&#34;将CALL移到顶层&#34;&gt;&lt;/a&gt;将CALL移到顶层&lt;/h4&gt;&lt;p&gt;方法：立即将每一个返回值赋给一个新的临时寄存器&lt;br&gt;$$&lt;br&gt;CALL(fun, args) ⇒ ESEQ(MOVE(TEMP t, CALL(fun, args)), TEMP t)&lt;br&gt;$$&lt;/p&gt;
&lt;h4 id=&#34;消除SEQ&#34;&gt;&lt;a href=&#34;#消除SEQ&#34; class=&#34;headerlink&#34; title=&#34;消除SEQ&#34;&gt;&lt;/a&gt;消除SEQ&lt;/h4&gt;&lt;p&gt;$$&lt;br&gt;SEQ(SEQ(a, b), c) &amp;#x3D; SEQ(a, SEQ(b, c))&lt;br&gt;$$&lt;br&gt;把SEQ变成一个线性语句表：$SEQ(s_1, SEQ(s_2, …, SEQ(s_{n-1}, s_n) …))$&lt;br&gt;就可以认为是由语句组成的简单列表$s_1, s_2, …, s_n$&lt;/p&gt;
&lt;h3 id=&#34;处理CJUMP&#34;&gt;&lt;a href=&#34;#处理CJUMP&#34; class=&#34;headerlink&#34; title=&#34;处理CJUMP&#34;&gt;&lt;/a&gt;处理CJUMP&lt;/h3&gt;&lt;p&gt;重排CJUMP，使得每个$CJUMP(op, e_1, e_2, l_t, l_f)后面都紧跟着$LABEL(l_f)$&lt;br&gt;分两步：1. 取一列canonical tree由它们形成basic block 2. 对basic block进行排序形成trace&lt;/p&gt;
&lt;h4 id=&#34;Basic-Block&#34;&gt;&lt;a href=&#34;#Basic-Block&#34; class=&#34;headerlink&#34; title=&#34;Basic Block&#34;&gt;&lt;/a&gt;Basic Block&lt;/h4&gt;&lt;p&gt;一个基本块是一段连续的指令序列，即:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个语句是一个&lt;code&gt;LABEL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;最后一个语句是&lt;code&gt;JUMP&lt;/code&gt;或&lt;code&gt;CJUMP&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;没有其他的&lt;code&gt;LABEL&lt;/code&gt;, &lt;code&gt;JUMP&lt;/code&gt;或&lt;code&gt;CJUMP&lt;/code&gt;&lt;br&gt;划分方法：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;每一个&lt;code&gt;LABEL&lt;/code&gt;都对应一个基本块的开始&lt;/li&gt;
&lt;li&gt;每一个&lt;code&gt;JUMP&lt;/code&gt;或&lt;code&gt;CJUMP&lt;/code&gt;都对应一个基本块的结束&lt;/li&gt;
&lt;li&gt;如果遇到&lt;code&gt;LABEL1&lt;/code&gt; -&amp;gt; &lt;code&gt;LABEL2&lt;/code&gt;,就在&lt;code&gt;LABEL2&lt;/code&gt;前面加一个&lt;code&gt;JUMP&lt;/code&gt;到&lt;code&gt;LABEL2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果遇到开头没有&lt;code&gt;LABEL&lt;/code&gt;的，则加一个&lt;code&gt;LABEL&lt;/code&gt;（比如程序的开头）&lt;/li&gt;
&lt;li&gt;出口处理：添加一个LABEL &lt;code&gt;done&lt;/code&gt;表示出口处理的开始，并把$JUMP done$放最后一个block末尾&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;Trace&#34;&gt;&lt;a href=&#34;#Trace&#34; class=&#34;headerlink&#34; title=&#34;Trace&#34;&gt;&lt;/a&gt;Trace&lt;/h4&gt;&lt;p&gt;现在我们可以按任意顺序来安排这些基本块，并且程序执行的结果仍是相同的——因为无论怎么排序，每个基本块的末尾都能转移到一个正确的位置。我们可以利用这一点来选择适当的基本块排列顺序，以满足每个&lt;code&gt;CJUMP&lt;/code&gt;之后都跟随它的false标号这一条件。&lt;br&gt;与此同时，我们也可以安排基本块使得无条件转移&lt;code&gt;JUMP&lt;/code&gt;之后直接跟随的是它们的目标标号。这样便可以删除这些无条件转移，从而使编译生成的程序的执行速度更快。&lt;/p&gt;
&lt;p&gt;把basic block排成trace的方法也很简单：&amp;#x3D;&amp;#x3D;从每个基本块开始，追踪JUMP链，标记遇到的每一个未标记的基本快并添加到当前trace中，最终到达一个其后继都标记过的块，就是结束块。之后再选则一个未标记的基本块开始，重复上述过程。&amp;#x3D;&amp;#x3D;&lt;/p&gt;
&lt;p&gt;因为轨迹调度不可能覆盖所有情况，所以：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果CJUMP 后跟 true label: 条件取反，交换 true&amp;#x2F;false，改成：&lt;br&gt;$$&lt;br&gt;CJUMP(!cond, lf, lt)&lt;br&gt;$$&lt;/li&gt;
&lt;li&gt;CJUMP 后跟的不是 true 也不是 false: 创建中间 label，插入 JUMP&lt;br&gt;$$&lt;br&gt;CJUMP(cond, lt, lf) &amp;#x3D;&amp;gt; CJUMP(cond, lt, l’f) LABEL l’f   JUMP NAME(lf)&lt;br&gt;$$&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;最优轨迹-Optimal-Trace&#34;&gt;&lt;a href=&#34;#最优轨迹-Optimal-Trace&#34; class=&#34;headerlink&#34; title=&#34;最优轨迹(Optimal Trace)&#34;&gt;&lt;/a&gt;最优轨迹(Optimal Trace)&lt;/h4&gt;&lt;p&gt;对于basic block可能有不同的trace划分方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hot Path Prioritization（优先热路径）: 优先将**运行频率高的基本块（hot blocks）**合并在同一条轨迹（trace）里，减少跳转，提高局部性。&lt;br&gt;+++info example&lt;br&gt;假设 if-else 中 if 分支占 90% 执行概率，else 只有 10%：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;tiger&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; x &amp;gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt; then&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    a := a + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;   -- 热路径&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    a := a - &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;生成时应把 x &amp;gt; 0 为真的路径（包括 CJUMP 的 false 分支）安排成 fall-through，避免跳转开销出现在热路径上。&lt;br&gt;+++&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Locality Enhancement（增强局部性）: 把逻辑上相关联的代码块放得更近一些，让它们在内存中“邻近”。&lt;ul&gt;
&lt;li&gt;原因：&lt;ul&gt;
&lt;li&gt;更好地利用 CPU cache、预取机制。&lt;/li&gt;
&lt;li&gt;避免指令 cache miss 导致性能下降。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如：将循环体和循环条件代码块排在一起（而不是让条件跳到远处），从而保持指令流顺序性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Jump Minimization（最小化跳转）: 尽量减少无条件跳转（JUMP）和不必要的条件跳转（CJUMP），尤其在常走路径上，	减少分支预测失败。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;/f1.jpg&#34;&gt;&lt;br&gt;哪个划分比较好？&lt;br&gt;根据3，c比a好；&lt;/p&gt;
</content>
        <category term="Basic Blocks and Traces" />
        <updated>2025-06-16T16:00:00.000Z</updated>
    </entry>
</feed>
