{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog • All posts by \"杂项\" tag",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/12/11/note/20251211/",
            "url": "http://example.com/2025/12/11/note/20251211/",
            "title": "杂项",
            "date_published": "2025-12-10T16:00:00.000Z",
            "content_html": "<h1 id=\"默认构造、拷贝构造、移动构造以及赋值运算符重载\"><a href=\"#默认构造、拷贝构造、移动构造以及赋值运算符重载\" class=\"headerlink\" title=\"默认构造、拷贝构造、移动构造以及赋值运算符重载\"></a>默认构造、拷贝构造、移动构造以及赋值运算符重载</h1><figure class=\"highlight c++\"><figcaption><span>构造函数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span>* data;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>(): <span class=\"built_in\">data</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">MyClass</span>() &#123; <span class=\"keyword\">delete</span> data; &#125;</span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>(<span class=\"type\">const</span> MyClass&amp; other): <span class=\"built_in\">data</span>(<span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (other.data != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>(*other.data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>(MyClass&amp;&amp; other) <span class=\"keyword\">noexcept</span>: <span class=\"built_in\">data</span>(<span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        data = other.data;</span><br><span class=\"line\">        other.data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 拷贝赋值运算符</span></span><br><span class=\"line\">    MyClass&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> MyClass&amp; other) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == &amp;other) &#123;      <span class=\"comment\">// 自赋值检查</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> data;              <span class=\"comment\">// 释放当前资源</span></span><br><span class=\"line\">        data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (other.data != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>(*other.data); <span class=\"comment\">// 深拷贝</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 移动赋值运算符</span></span><br><span class=\"line\">    MyClass&amp; <span class=\"keyword\">operator</span>=(MyClass&amp;&amp; other) <span class=\"keyword\">noexcept</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == &amp;other) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> data;               <span class=\"comment\">// 释放当前资源</span></span><br><span class=\"line\">        data = other.data;         <span class=\"comment\">// 接管</span></span><br><span class=\"line\">        other.data = <span class=\"literal\">nullptr</span>;      <span class=\"comment\">// 置空</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>下面用动态数组示例补全拷贝&#x2F;移动语义（遵循 Rule of Five）：</p>\n<figure class=\"highlight c++\"><figcaption><span>数组</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyArray</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span>* data;</span><br><span class=\"line\">    <span class=\"type\">int</span> size;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MyArray</span>(): <span class=\"built_in\">data</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">size</span>(<span class=\"number\">0</span>) &#123;&#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">MyArray</span>()&#123; <span class=\"keyword\">delete</span>[] data; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">MyArray</span>(<span class=\"type\">int</span> sz): <span class=\"built_in\">data</span>(sz ? <span class=\"keyword\">new</span> <span class=\"type\">int</span>[sz] : <span class=\"literal\">nullptr</span>), <span class=\"built_in\">size</span>(sz) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 拷贝构造：深拷贝</span></span><br><span class=\"line\">    <span class=\"built_in\">MyArray</span>(<span class=\"type\">const</span> MyArray&amp; other): <span class=\"built_in\">data</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">size</span>(other.size) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (other.data &amp;&amp; other.size &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[other.size];</span><br><span class=\"line\">            <span class=\"built_in\">copy</span>(other.data, other.data + other.size, data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 移动构造：接管资源</span></span><br><span class=\"line\">    <span class=\"built_in\">MyArray</span>(MyArray&amp;&amp; other) <span class=\"keyword\">noexcept</span>: <span class=\"built_in\">data</span>(other.data), <span class=\"built_in\">size</span>(other.size) &#123;</span><br><span class=\"line\">        other.data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        other.size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 拷贝赋值：先复制再交换（异常安全）</span></span><br><span class=\"line\">    MyArray&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> MyArray&amp; other) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == &amp;other) <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span>* newData = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (other.size &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            newData = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[other.size];</span><br><span class=\"line\">            <span class=\"built_in\">copy</span>(other.data, other.data + other.size, newData);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] data;</span><br><span class=\"line\">        data = newData;</span><br><span class=\"line\">        size = other.size;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 移动赋值：释放当前资源并接管</span></span><br><span class=\"line\">    MyArray&amp; <span class=\"keyword\">operator</span>=(MyArray&amp;&amp; other) <span class=\"keyword\">noexcept</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == &amp;other) <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] data;</span><br><span class=\"line\">        data = other.data;</span><br><span class=\"line\">        size = other.size;</span><br><span class=\"line\">        other.data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        other.size = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getSize</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> size; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span>* <span class=\"title\">getData</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> data; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>要点：</p>\n<ul>\n<li>对于拥有动态资源的类型，建议同时实现析构、拷贝构造、移动构造、拷贝赋值、移动赋值（Rule of Five）。</li>\n<li>拷贝要做深拷贝，移动要尽可能接管资源并置空原对象以避免双重释放。</li>\n<li>拷贝赋值实现中可以先分配新资源，再释放旧资源以提高异常安全性。</li>\n</ul>\n<h1 id=\"智能指针怎么用\"><a href=\"#智能指针怎么用\" class=\"headerlink\" title=\"智能指针怎么用\"></a>智能指针怎么用</h1><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xOTIxNTc5ODE0Mjg1OTc1Njcw\">https://zhuanlan.zhihu.com/p/1921579814285975670</span></p>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用std::make_shared</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> ptr1 = std::<span class=\"built_in\">make_shared</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用std::shared_ptr(new T(args...))</span></span><br><span class=\"line\"><span class=\"function\">std::shared_ptr&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">ptr2</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"type\">int</span>(<span class=\"number\">10</span>))</span></span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::shared_ptr&lt;<span class=\"type\">int</span>&gt; shared_ptr1 = std::<span class=\"built_in\">make_shared</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">10</span>); </span><br><span class=\"line\">std::weak_ptr&lt;<span class=\"type\">int</span>&gt; weak_ptr1 = shared_ptr1; </span><br><span class=\"line\"><span class=\"keyword\">auto</span> shared_ptr2 = weak_ptr<span class=\"number\">1.l</span>ock(); </span><br><span class=\"line\"><span class=\"keyword\">if</span> (shared_ptr2) &#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Object is still alive: &quot;</span> &lt;&lt; *shared_ptr2 &lt;&lt; std::endl; </span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Object has been destroyed&quot;</span> &lt;&lt; std::endl; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>多个 shared_ptr 对象可以共享同一个动态分配的对象，并通过一个&#x3D;&#x3D;共享的控制块&#x3D;&#x3D;（control block）来维护引用计数，当最后一个 shared_ptr 被销毁或重置时，自动释放所管理的对象。</p>\n<h3 id=\"1-控制块（Control-Block）\"><a href=\"#1-控制块（Control-Block）\" class=\"headerlink\" title=\"1. 控制块（Control Block）\"></a>1. 控制块（Control Block）</h3><p>每个被 <code>shared_ptr</code> 管理的对象都会关联一个 <strong>控制块（control block）</strong>，这个控制块通常包含以下信息：</p>\n<ul>\n<li><strong>强引用计数（strong reference count）</strong>：即有多少个 <code>shared_ptr</code> 正在共享该对象。</li>\n<li><strong>弱引用计数（weak reference count）</strong>：即有多少个 <code>weak_ptr</code> 指向该控制块（用于支持 <code>weak_ptr</code>）。</li>\n<li><strong>被管理对象的指针</strong>（有时直接内嵌对象，如通过 <code>make_shared</code>）。</li>\n<li><strong>删除器（deleter）</strong>：可自定义的函数对象，用于释放资源（默认是 <code>delete</code>）。</li>\n<li><strong>分配器（allocator）</strong>：如果使用了自定义内存分配策略。</li>\n</ul>\n<blockquote>\n<p>注意：控制块本身是堆上分配的（除非使用 <code>make_shared</code>，此时对象和控制块可能分配在同一块内存中以提高效率）。</p>\n</blockquote>\n<h3 id=\"2-引用计数的增减\"><a href=\"#2-引用计数的增减\" class=\"headerlink\" title=\"2. 引用计数的增减\"></a>2. 引用计数的增减</h3><ul>\n<li><strong>构造&#x2F;拷贝&#x2F;赋值</strong>：<ul>\n<li>当一个新的 <code>shared_ptr</code> 通过拷贝构造、移动构造或赋值操作指向同一对象时，<strong>强引用计数加 1</strong>。</li>\n</ul>\n</li>\n<li><strong>析构&#x2F;重置（reset）</strong>：<ul>\n<li>当一个 <code>shared_ptr</code> 被销毁或调用 <code>reset()</code> 时，<strong>强引用计数减 1</strong>。</li>\n<li>如果强引用计数变为 0，则：<ul>\n<li>调用删除器（deleter）释放被管理的对象；</li>\n<li><strong>但控制块不会立即释放</strong>，因为可能还有 <code>weak_ptr</code> 存在（需等待弱引用计数也为 0 才释放控制块）。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-线程安全性\"><a href=\"#3-线程安全性\" class=\"headerlink\" title=\"3. 线程安全性\"></a>3. 线程安全性</h3><ul>\n<li><strong>引用计数的操作是原子的</strong>（通常使用 <code>std::atomic</code> 实现），因此多个线程同时拷贝或销毁 <code>shared_ptr</code> 是线程安全的。</li>\n<li>但注意：<strong>对被管理对象本身的访问不是线程安全的</strong>，需要用户自己加锁。</li>\n</ul>\n<h1 id=\"shared-ptr什么时候-1什么时候-1\"><a href=\"#shared-ptr什么时候-1什么时候-1\" class=\"headerlink\" title=\"shared_ptr什么时候+1什么时候-1\"></a>shared_ptr什么时候+1什么时候-1</h1><h2 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"+1\"></a>+1</h2><ol>\n<li>拷贝构造</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::shared_ptr&lt;<span class=\"type\">int</span>&gt; p1 = std::<span class=\"built_in\">make_shared</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">42</span>);</span><br><span class=\"line\"><span class=\"function\">std::shared_ptr&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">p2</span><span class=\"params\">(p1)</span></span>;  <span class=\"comment\">// +1 → 强引用计数变为 2</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>拷贝赋值</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::shared_ptr&lt;<span class=\"type\">int</span>&gt; p3;</span><br><span class=\"line\">p3 = p1;  <span class=\"comment\">// p3 原来为空，现在共享 p1 的对象 → +1</span></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>函数传参</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">foo</span><span class=\"params\">(std::shared_ptr&lt;<span class=\"type\">int</span>&gt; p)</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\"><span class=\"built_in\">foo</span>(p1);  <span class=\"comment\">// 进入函数时拷贝 → +1；函数返回时析构 → -1</span></span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>作为返回值返回</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::shared_ptr&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">getPtr</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p1;  <span class=\"comment\">// 返回时可能触发拷贝或移动（见下文）</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> p4 = <span class=\"built_in\">getPtr</span>();  <span class=\"comment\">// 若发生拷贝 → +1；若被优化为移动 → 不变</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>现代编译器通常会进行 返回值优化（RVO） 或使用 移动语义，避免不必要的 +1&#x2F;-1</p>\n<ol start=\"5\">\n<li>放入容器（如 vector、list）</li>\n</ol>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::vector&lt;std::shared_ptr&lt;<span class=\"type\">int</span>&gt;&gt; vec;</span><br><span class=\"line\">vec.<span class=\"built_in\">push_back</span>(p1);  <span class=\"comment\">// 拷贝进容器 → +1</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-1\"><a href=\"#1-1\" class=\"headerlink\" title=\"-1\"></a>-1</h2><ol>\n<li>析构</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    std::shared_ptr&lt;<span class=\"type\">int</span>&gt; p = p1;  <span class=\"comment\">// +1</span></span><br><span class=\"line\">&#125; <span class=\"comment\">// p 析构 → -1</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>调用reset</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p<span class=\"number\">1.</span><span class=\"built_in\">reset</span>();        <span class=\"comment\">// 放弃当前对象 → -1</span></span><br><span class=\"line\">p<span class=\"number\">1.</span><span class=\"built_in\">reset</span>(<span class=\"literal\">nullptr</span>); <span class=\"comment\">// 同上</span></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>被赋予新值</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::shared_ptr&lt;<span class=\"type\">int</span>&gt; p2 = std::<span class=\"built_in\">make_shared</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">100</span>);</span><br><span class=\"line\">p1 = p2;  </span><br><span class=\"line\"><span class=\"comment\">// 先对 p1 原来的对象 -1，</span></span><br><span class=\"line\"><span class=\"comment\">// 再对 p2 的对象 +1（因为 p1 现在共享 p2 的对象）</span></span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>被赋予nullptr或空</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p1 = <span class=\"literal\">nullptr</span>;  <span class=\"comment\">// 相当于 reset() → -1</span></span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>从容器中移除或clear</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec.<span class=\"built_in\">clear</span>();  <span class=\"comment\">// 容器中每个 shared_ptr 析构 → 各自管理的对象引用计数 -1</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"vector底层\"><a href=\"#vector底层\" class=\"headerlink\" title=\"vector底层\"></a>vector底层</h1><p>连续内存存储 + 动态扩容</p>\n<h2 id=\"一、基本结构\"><a href=\"#一、基本结构\" class=\"headerlink\" title=\"一、基本结构\"></a>一、基本结构</h2><p><code>std::vector&lt;T&gt;</code> 内部通常维护三个关键指针（或等效的成员）：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> Allocator = std::allocator&lt;T&gt;&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> vector &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    T* begin_;     <span class=\"comment\">// 指向首元素</span></span><br><span class=\"line\">    T* end_;       <span class=\"comment\">// 指向最后一个元素的下一个位置（即 size 的边界）</span></span><br><span class=\"line\">    T* capacity_;  <span class=\"comment\">// 指向已分配内存的末尾（即 capacity 的边界）</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong><code>size()</code></strong> &#x3D; <code>end_ - begin_</code></li>\n<li><strong><code>capacity()</code></strong> &#x3D; <code>capacity_ - begin_</code></li>\n<li>所有元素在 <code>[begin_, end_)</code> 范围内，内存连续。</li>\n</ul>\n<blockquote>\n<p>实际标准库实现（如 libstdc++、libc++）可能用一个指针 + 两个整数（size&#x2F;capacity），但逻辑等价。</p>\n</blockquote>\n<h2 id=\"二、内存分配与释放\"><a href=\"#二、内存分配与释放\" class=\"headerlink\" title=\"二、内存分配与释放\"></a>二、内存分配与释放</h2><ul>\n<li>使用 <strong>分配器（Allocator）</strong> 管理内存，默认是 <code>std::allocator&lt;T&gt;</code>。</li>\n<li>初始时 <code>capacity() == 0</code>，不分配内存（除非显式 <code>reserve</code> 或插入元素）。</li>\n<li>当需要更多空间时，<strong>重新分配一块更大的连续内存</strong>，将旧元素<strong>移动或拷贝</strong>过去，再释放旧内存。</li>\n</ul>\n<h2 id=\"三、动态扩容机制（关键！）\"><a href=\"#三、动态扩容机制（关键！）\" class=\"headerlink\" title=\"三、动态扩容机制（关键！）\"></a>三、动态扩容机制（关键！）</h2><h3 id=\"1-何时扩容？\"><a href=\"#1-何时扩容？\" class=\"headerlink\" title=\"1. 何时扩容？\"></a>1. <strong>何时扩容？</strong></h3><p>当 <code>size() == capacity()</code> 且尝试插入新元素（如 <code>push_back</code>、<code>insert</code>）时，触发扩容。</p>\n<h3 id=\"2-扩容策略\"><a href=\"#2-扩容策略\" class=\"headerlink\" title=\"2. 扩容策略\"></a>2. <strong>扩容策略</strong></h3><ul>\n<li><strong>不是每次只加 1 个元素</strong>（那样效率极低）。</li>\n<li>通常采用 <strong>倍增策略（geometric growth）</strong>：<ul>\n<li>GCC (libstdc++)：<strong>容量 × 2</strong></li>\n<li>MSVC：<strong>容量 × 1.5</strong></li>\n<li>目的：保证 <strong>摊还时间复杂度 O(1)</strong> 的 <code>push_back</code></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>例如：初始容量 1 → 2 → 4 → 8 → 16 …</p>\n</blockquote>\n<h3 id=\"3-扩容过程\"><a href=\"#3-扩容过程\" class=\"headerlink\" title=\"3. 扩容过程\"></a>3. <strong>扩容过程</strong></h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_back</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">size</span>() == <span class=\"built_in\">capacity</span>()) &#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> new_cap = (<span class=\"built_in\">capacity</span>() == <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : <span class=\"built_in\">capacity</span>() * <span class=\"number\">2</span>;</span><br><span class=\"line\">        T* new_mem = allocator.<span class=\"built_in\">allocate</span>(new_cap);           <span class=\"comment\">// 分配新内存</span></span><br><span class=\"line\">        <span class=\"built_in\">uninitialized_move</span>(begin_, end_, new_mem);          <span class=\"comment\">// 移动旧元素</span></span><br><span class=\"line\">        allocator.<span class=\"built_in\">deallocate</span>(begin_, <span class=\"built_in\">capacity</span>());           <span class=\"comment\">// 释放旧内存</span></span><br><span class=\"line\">        begin_ = new_mem;</span><br><span class=\"line\">        end_ = new_mem + <span class=\"built_in\">size</span>();</span><br><span class=\"line\">        capacity_ = new_mem + new_cap;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">construct</span>(end_, value);  <span class=\"comment\">// 在 end_ 处构造新元素</span></span><br><span class=\"line\">    ++end_;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：C++11 起优先使用 <strong>移动语义</strong>（move）而非拷贝，提升性能。</p>\n</blockquote>\n<h2 id=\"四、关键操作的时间复杂度\"><a href=\"#四、关键操作的时间复杂度\" class=\"headerlink\" title=\"四、关键操作的时间复杂度\"></a>四、关键操作的时间复杂度</h2><table>\n<thead>\n<tr>\n<th>操作</th>\n<th>时间复杂度</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>operator[]</code>, <code>at()</code></td>\n<td>O(1)</td>\n<td>随机访问</td>\n</tr>\n<tr>\n<td><code>push_back()</code></td>\n<td><strong>O(1) 摊还</strong></td>\n<td>偶尔 O(n) 扩容</td>\n</tr>\n<tr>\n<td><code>pop_back()</code></td>\n<td>O(1)</td>\n<td>仅析构最后一个元素，不释放内存</td>\n</tr>\n<tr>\n<td><code>insert(pos, val)</code></td>\n<td>O(n)</td>\n<td>需移动 pos 后所有元素</td>\n</tr>\n<tr>\n<td><code>erase(pos)</code></td>\n<td>O(n)</td>\n<td>同上</td>\n</tr>\n<tr>\n<td><code>clear()</code></td>\n<td>O(n)</td>\n<td>析构所有元素，但 <strong>不释放内存</strong>（capacity 不变）</td>\n</tr>\n<tr>\n<td><code>shrink_to_fit()</code></td>\n<td>O(n)</td>\n<td>请求释放多余内存（非强制，依赖实现）</td>\n</tr>\n</tbody></table>\n<h2 id=\"五、内存管理特性\"><a href=\"#五、内存管理特性\" class=\"headerlink\" title=\"五、内存管理特性\"></a>五、内存管理特性</h2><ul>\n<li><strong>内存连续</strong>：支持与 C 数组互操作（如 <code>&amp;vec[0]</code> 或 <code>vec.data()</code>）。</li>\n<li><strong>不自动缩容</strong>：<code>pop_back</code> 或 <code>erase</code> 后 <code>capacity()</code> 不变，避免频繁 realloc。</li>\n<li><strong>异常安全</strong>：现代实现通常提供 <strong>强异常安全保证</strong>（如 copy-and-swap 技术）。</li>\n</ul>\n",
            "tags": [
                "杂项"
            ]
        },
        {
            "id": "http://example.com/2025/11/20/note/20251130/",
            "url": "http://example.com/2025/11/20/note/20251130/",
            "title": "杂项",
            "date_published": "2025-11-19T16:00:00.000Z",
            "content_html": "<h1 id=\"杂项\"><a href=\"#杂项\" class=\"headerlink\" title=\"杂项\"></a>杂项</h1><ol>\n<li>explicit<br>构造函数默认是隐式转换的，如果想要禁止隐式转换，可以使用explicit关键字修饰构造函数。<br>比如</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>explicit</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">FileSize</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 构造函数：接受字节数</span></span><br><span class=\"line\">    <span class=\"built_in\">FileSize</span>(<span class=\"type\">long</span> <span class=\"type\">long</span> bytes) : <span class=\"built_in\">bytes_</span>(bytes) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">long</span> <span class=\"type\">long</span> <span class=\"title\">getBytes</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> bytes_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"type\">long</span> bytes_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">deleteFileLargerThan</span><span class=\"params\">(<span class=\"type\">const</span> FileSize&amp; maxSize)</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Deleting files larger than &quot;</span> &lt;&lt; maxSize.<span class=\"built_in\">getBytes</span>() &lt;&lt; <span class=\"string\">&quot; bytes.\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 实际逻辑省略...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">deleteFileLargerThan</span>(<span class=\"string\">&quot;100MB&quot;</span>);  <span class=\"comment\">// 打错了！本想传字符串配置，但函数不接受 string</span></span><br><span class=\"line\">    <span class=\"comment\">// &quot;100MB&quot;  →  const char*  →  bool(true)  →  long long(1)   →  FileSize(1)</span></span><br><span class=\"line\">    <span class=\"comment\">// 变成：Deleting files larger than 1 bytes. 严重错误</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>回调函数<br>回调函数是一种函数指针，它允许在运行时指定一个函数，并在某个事件发生时调用该函数。<br>人话：一个被作为参数传递给另一个函数，并在“合适的时候”被调用的函数。</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>callback</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">std::function&lt;R(Args...)&gt; cb;</span><br><span class=\"line\"><span class=\"comment\">// R: 返回类型</span></span><br><span class=\"line\"><span class=\"comment\">// Args...: 参数列表</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>std::function 能装什么？</p>\n</blockquote>\n<ul>\n<li>普通函数</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>callback</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">greet</span><span class=\"params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"string\">&quot;Hello!\\n&quot;</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">std::function&lt;<span class=\"type\">void</span>()&gt; cb = greet;</span><br><span class=\"line\"><span class=\"built_in\">cb</span>(); <span class=\"comment\">// 输出 Hello!</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>Lambda表达式</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>callback</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> x = <span class=\"number\">42</span>;</span><br><span class=\"line\">std::function&lt;<span class=\"type\">void</span>()&gt; cb = [x]() &#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Captured x = &quot;</span> &lt;&lt; x &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">cb</span>(); <span class=\"comment\">// 输出 Captured x = 42</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>函数对象</li>\n<li>成员函数</li>\n</ul>\n<ol start=\"3\">\n<li><p><code>mutable std::mutex mtx_;</code><br><code>mutable</code> 关键字表示变量可以在常量函数中修改。<br>如果没有 mutable，mtx_ 是普通成员变量，在 const 函数中，所有成员都被视为 const，调用 mtx_.lock() 会报错</p>\n</li>\n<li><p>std::unique_lock<span class=\"exturl\" data-url=\"c3RkOjptdXRleA==\">std::mutex</span> lock(mtx_)<br>进入时自动调用 mtx_.lock()（当前线程获得锁），当 lock 变量离开作用域（比如函数返回、出 {}），会自动调用 mtx_.unlock()</p>\n</li>\n<li><p>lambda<br>有点抽象，有空继续研究<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jLmJpYW5jaGVuZy5uZXQvdmlldy9ibDF5dnd5Lmh0bWw=\">https://c.biancheng.net/view/bl1yvwy.html</span></p>\n</li>\n</ol>\n<ul>\n<li>作为函数对象（Functor）替代手写类</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>lambda</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">IsEven</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> x % <span class=\"number\">2</span> == <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">std::vector&lt;<span class=\"type\">int</span>&gt; v = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> it = std::<span class=\"built_in\">find_if</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), IsEven&#123;&#125;);</span><br><span class=\"line\"><span class=\"comment\">// lambda写法</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> it = std::<span class=\"built_in\">find_if</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), [](<span class=\"type\">int</span> x) &#123; <span class=\"keyword\">return</span> x % <span class=\"number\">2</span> == <span class=\"number\">0</span>; &#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>STL 算法的自定义谓词（最常用！）</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>lambda</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::vector&lt;Person&gt; people = &#123;...&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 按年龄降序</span></span><br><span class=\"line\">std::<span class=\"built_in\">sort</span>(people.<span class=\"built_in\">begin</span>(), people.<span class=\"built_in\">end</span>(),</span><br><span class=\"line\">          [](<span class=\"type\">const</span> Person&amp; a, <span class=\"type\">const</span> Person&amp; b) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> a.age &gt; b.age;</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除所有空字符串</span></span><br><span class=\"line\">vec.<span class=\"built_in\">erase</span>(</span><br><span class=\"line\">    std::<span class=\"built_in\">remove_if</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">end</span>(),</span><br><span class=\"line\">                   [](<span class=\"type\">const</span> std::string&amp; s) &#123; <span class=\"keyword\">return</span> s.<span class=\"built_in\">empty</span>(); &#125;),</span><br><span class=\"line\">    vec.<span class=\"built_in\">end</span>()</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 找第一个大于 10 的数</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> it = std::<span class=\"built_in\">find_if</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), [](<span class=\"type\">int</span> x) &#123; <span class=\"keyword\">return</span> x &gt; <span class=\"number\">10</span>; &#125;);</span><br></pre></td></tr></table></figure>\n\n\n<ol start=\"6\">\n<li>condition_variable<br>不希望 FSM 的 worker 线程这样:</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>轮询</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (queue 空)</span><br><span class=\"line\">        一直查（忙等）</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>condition_variable 的作用：</p>\n<ul>\n<li>队列空 → 工作线程睡觉</li>\n<li>有事件 → 唤醒工作线程<br>写法：</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>condition_variable</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cv.<span class=\"built_in\">wait</span>(lock, []&#123; <span class=\"keyword\">return</span> !queue.<span class=\"built_in\">empty</span>(); &#125;);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li><p>atomic库<br><code>atomic&lt;bool&gt;</code> 原子变量，线程安全的 bool</p>\n</li>\n<li><p>匿名函数</p>\n</li>\n<li><p>workerThread + 队列 + 状态机</p>\n</li>\n</ol>\n",
            "tags": [
                "杂项"
            ]
        }
    ]
}