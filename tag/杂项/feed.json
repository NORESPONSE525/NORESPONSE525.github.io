{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog • All posts by \"杂项\" tag",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/11/20/note/20251130/",
            "url": "http://example.com/2025/11/20/note/20251130/",
            "title": "杂项",
            "date_published": "2025-11-19T16:00:00.000Z",
            "content_html": "<h1 id=\"杂项\"><a class=\"markdownIt-Anchor\" href=\"#杂项\">#</a> 杂项</h1>\n<ol>\n<li>explicit<br>\n 构造函数默认是隐式转换的，如果想要禁止隐式转换，可以使用 explicit 关键字修饰构造函数。<br>\n比如</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>explicit</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">FileSize</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 构造函数：接受字节数</span></span><br><span class=\"line\">    <span class=\"built_in\">FileSize</span>(<span class=\"type\">long</span> <span class=\"type\">long</span> bytes) : <span class=\"built_in\">bytes_</span>(bytes) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">long</span> <span class=\"type\">long</span> <span class=\"title\">getBytes</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> bytes_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"type\">long</span> bytes_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">deleteFileLargerThan</span><span class=\"params\">(<span class=\"type\">const</span> FileSize&amp; maxSize)</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Deleting files larger than &quot;</span> &lt;&lt; maxSize.<span class=\"built_in\">getBytes</span>() &lt;&lt; <span class=\"string\">&quot; bytes.\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 实际逻辑省略...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">deleteFileLargerThan</span>(<span class=\"string\">&quot;100MB&quot;</span>);  <span class=\"comment\">// 打错了！本想传字符串配置，但函数不接受 string</span></span><br><span class=\"line\">    <span class=\"comment\">// &quot;100MB&quot;  →  const char*  →  bool(true)  →  long long(1)   →  FileSize(1)</span></span><br><span class=\"line\">    <span class=\"comment\">// 变成：Deleting files larger than 1 bytes. 严重错误</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>回调函数<br>\n回调函数是一种函数指针，它允许在运行时指定一个函数，并在某个事件发生时调用该函数。<br>\n人话：一个被作为参数传递给另一个函数，并在 “合适的时候” 被调用的函数。</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>callback</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">std::function&lt;R(Args...)&gt; cb;</span><br><span class=\"line\"><span class=\"comment\">// R: 返回类型</span></span><br><span class=\"line\"><span class=\"comment\">// Args...: 参数列表</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>std::function 能装什么？</p>\n</blockquote>\n<ul>\n<li>普通函数</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>callback</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">greet</span><span class=\"params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"string\">&quot;Hello!\\n&quot;</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">std::function&lt;<span class=\"type\">void</span>()&gt; cb = greet;</span><br><span class=\"line\"><span class=\"built_in\">cb</span>(); <span class=\"comment\">// 输出 Hello!</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>Lambda 表达式</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>callback</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> x = <span class=\"number\">42</span>;</span><br><span class=\"line\">std::function&lt;<span class=\"type\">void</span>()&gt; cb = [x]() &#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Captured x = &quot;</span> &lt;&lt; x &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">cb</span>(); <span class=\"comment\">// 输出 Captured x = 42</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>函数对象</li>\n<li>成员函数</li>\n</ul>\n<ol start=\"3\">\n<li>\n<p><code>mutable std::mutex mtx_;</code> <br>\n <code>mutable</code>  关键字表示变量可以在常量函数中修改。<br>\n如果没有 mutable，mtx_ 是普通成员变量，在 const 函数中，所有成员都被视为 const，调用 mtx_.lock () 会报错</p>\n</li>\n<li>\n<p>std::unique_lock<span class=\"exturl\" data-url=\"c3RkOjptdXRleA==\">std::mutex</span> lock(mtx_)<br>\n 进入时自动调用 mtx_.lock ()（当前线程获得锁），当 lock 变量离开作用域（比如函数返回、出 {}），会自动调用 mtx_.unlock ()</p>\n</li>\n<li>\n<p>lambda<br>\n 有点抽象，有空继续研究<br>\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jLmJpYW5jaGVuZy5uZXQvdmlldy9ibDF5dnd5Lmh0bWw=\"> https://c.biancheng.net/view/bl1yvwy.html</span></p>\n</li>\n</ol>\n<ul>\n<li>作为函数对象（Functor）替代手写类</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>lambda</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">IsEven</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> x % <span class=\"number\">2</span> == <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">std::vector&lt;<span class=\"type\">int</span>&gt; v = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> it = std::<span class=\"built_in\">find_if</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), IsEven&#123;&#125;);</span><br><span class=\"line\"><span class=\"comment\">// lambda写法</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> it = std::<span class=\"built_in\">find_if</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), [](<span class=\"type\">int</span> x) &#123; <span class=\"keyword\">return</span> x % <span class=\"number\">2</span> == <span class=\"number\">0</span>; &#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>STL 算法的自定义谓词（最常用！）</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>lambda</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::vector&lt;Person&gt; people = &#123;...&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 按年龄降序</span></span><br><span class=\"line\">std::<span class=\"built_in\">sort</span>(people.<span class=\"built_in\">begin</span>(), people.<span class=\"built_in\">end</span>(),</span><br><span class=\"line\">          [](<span class=\"type\">const</span> Person&amp; a, <span class=\"type\">const</span> Person&amp; b) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> a.age &gt; b.age;</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除所有空字符串</span></span><br><span class=\"line\">vec.<span class=\"built_in\">erase</span>(</span><br><span class=\"line\">    std::<span class=\"built_in\">remove_if</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">end</span>(),</span><br><span class=\"line\">                   [](<span class=\"type\">const</span> std::string&amp; s) &#123; <span class=\"keyword\">return</span> s.<span class=\"built_in\">empty</span>(); &#125;),</span><br><span class=\"line\">    vec.<span class=\"built_in\">end</span>()</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 找第一个大于 10 的数</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> it = std::<span class=\"built_in\">find_if</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), [](<span class=\"type\">int</span> x) &#123; <span class=\"keyword\">return</span> x &gt; <span class=\"number\">10</span>; &#125;);</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>condition_variable<br>\n 不希望 FSM 的 worker 线程这样:</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>轮询</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (queue 空)</span><br><span class=\"line\">        一直查（忙等）</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>condition_variable 的作用：</p>\n<ul>\n<li>队列空 → 工作线程睡觉</li>\n<li>有事件 → 唤醒工作线程<br>\n写法：</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>condition_variable</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cv.<span class=\"built_in\">wait</span>(lock, []&#123; <span class=\"keyword\">return</span> !queue.<span class=\"built_in\">empty</span>(); &#125;);</span><br></pre></td></tr></table></figure>\n<ol start=\"7\">\n<li>\n<p>atomic 库<br>\n <code>atomic&lt;bool&gt;</code>  原子变量，线程安全的 bool</p>\n</li>\n<li>\n<p>匿名函数</p>\n</li>\n<li>\n<p>workerThread + 队列 + 状态机</p>\n</li>\n</ol>\n",
            "tags": [
                "杂项"
            ]
        }
    ]
}