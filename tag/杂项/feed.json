{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog • All posts by \"杂项\" tag",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/12/11/note/20251211/",
            "url": "http://example.com/2025/12/11/note/20251211/",
            "title": "杂项",
            "date_published": "2025-12-10T16:00:00.000Z",
            "content_html": "<h1 id=\"默认构造-拷贝构造-移动构造以及赋值运算符重载\"><a class=\"markdownIt-Anchor\" href=\"#默认构造-拷贝构造-移动构造以及赋值运算符重载\">#</a> 默认构造、拷贝构造、移动构造以及赋值运算符重载</h1>\n<figure class=\"highlight c++\"><figcaption><span>构造函数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span>* data;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>(): <span class=\"built_in\">data</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">MyClass</span>() &#123; <span class=\"keyword\">delete</span> data; &#125;</span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>(<span class=\"type\">const</span> MyClass&amp; other): <span class=\"built_in\">data</span>(<span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (other.data != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>(*other.data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>(MyClass&amp;&amp; other) <span class=\"keyword\">noexcept</span>: <span class=\"built_in\">data</span>(<span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        data = other.data;</span><br><span class=\"line\">        other.data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 拷贝赋值运算符</span></span><br><span class=\"line\">    MyClass&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> MyClass&amp; other) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == &amp;other) &#123;      <span class=\"comment\">// 自赋值检查</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> data;              <span class=\"comment\">// 释放当前资源</span></span><br><span class=\"line\">        data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (other.data != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>(*other.data); <span class=\"comment\">// 深拷贝</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 移动赋值运算符</span></span><br><span class=\"line\">    MyClass&amp; <span class=\"keyword\">operator</span>=(MyClass&amp;&amp; other) <span class=\"keyword\">noexcept</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == &amp;other) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> data;               <span class=\"comment\">// 释放当前资源</span></span><br><span class=\"line\">        data = other.data;         <span class=\"comment\">// 接管</span></span><br><span class=\"line\">        other.data = <span class=\"literal\">nullptr</span>;      <span class=\"comment\">// 置空</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>下面用动态数组示例补全拷贝 / 移动语义（遵循 Rule of Five）：</p>\n<figure class=\"highlight c++\"><figcaption><span>数组</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyArray</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span>* data;</span><br><span class=\"line\">    <span class=\"type\">int</span> size;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MyArray</span>(): <span class=\"built_in\">data</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">size</span>(<span class=\"number\">0</span>) &#123;&#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">MyArray</span>()&#123; <span class=\"keyword\">delete</span>[] data; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">MyArray</span>(<span class=\"type\">int</span> sz): <span class=\"built_in\">data</span>(sz ? <span class=\"keyword\">new</span> <span class=\"type\">int</span>[sz] : <span class=\"literal\">nullptr</span>), <span class=\"built_in\">size</span>(sz) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 拷贝构造：深拷贝</span></span><br><span class=\"line\">    <span class=\"built_in\">MyArray</span>(<span class=\"type\">const</span> MyArray&amp; other): <span class=\"built_in\">data</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">size</span>(other.size) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (other.data &amp;&amp; other.size &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[other.size];</span><br><span class=\"line\">            <span class=\"built_in\">copy</span>(other.data, other.data + other.size, data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 移动构造：接管资源</span></span><br><span class=\"line\">    <span class=\"built_in\">MyArray</span>(MyArray&amp;&amp; other) <span class=\"keyword\">noexcept</span>: <span class=\"built_in\">data</span>(other.data), <span class=\"built_in\">size</span>(other.size) &#123;</span><br><span class=\"line\">        other.data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        other.size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 拷贝赋值：先复制再交换（异常安全）</span></span><br><span class=\"line\">    MyArray&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> MyArray&amp; other) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == &amp;other) <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span>* newData = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (other.size &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            newData = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[other.size];</span><br><span class=\"line\">            <span class=\"built_in\">copy</span>(other.data, other.data + other.size, newData);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] data;</span><br><span class=\"line\">        data = newData;</span><br><span class=\"line\">        size = other.size;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 移动赋值：释放当前资源并接管</span></span><br><span class=\"line\">    MyArray&amp; <span class=\"keyword\">operator</span>=(MyArray&amp;&amp; other) <span class=\"keyword\">noexcept</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == &amp;other) <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] data;</span><br><span class=\"line\">        data = other.data;</span><br><span class=\"line\">        size = other.size;</span><br><span class=\"line\">        other.data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        other.size = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getSize</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> size; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span>* <span class=\"title\">getData</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> data; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>要点：</p>\n<ul>\n<li>对于拥有动态资源的类型，建议同时实现析构、拷贝构造、移动构造、拷贝赋值、移动赋值（Rule of Five）。</li>\n<li>拷贝要做深拷贝，移动要尽可能接管资源并置空原对象以避免双重释放。</li>\n<li>拷贝赋值实现中可以先分配新资源，再释放旧资源以提高异常安全性。</li>\n</ul>\n<h1 id=\"智能指针怎么用\"><a class=\"markdownIt-Anchor\" href=\"#智能指针怎么用\">#</a> 智能指针怎么用</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xOTIxNTc5ODE0Mjg1OTc1Njcw\">https://zhuanlan.zhihu.com/p/1921579814285975670</span></p>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用std::make_shared</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> ptr1 = std::<span class=\"built_in\">make_shared</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用std::shared_ptr(new T(args...))</span></span><br><span class=\"line\"><span class=\"function\">std::shared_ptr&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">ptr2</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"type\">int</span>(<span class=\"number\">10</span>))</span></span>;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::shared_ptr&lt;<span class=\"type\">int</span>&gt; shared_ptr1 = std::<span class=\"built_in\">make_shared</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">10</span>); </span><br><span class=\"line\">std::weak_ptr&lt;<span class=\"type\">int</span>&gt; weak_ptr1 = shared_ptr1; </span><br><span class=\"line\"><span class=\"keyword\">auto</span> shared_ptr2 = weak_ptr<span class=\"number\">1.l</span>ock(); </span><br><span class=\"line\"><span class=\"keyword\">if</span> (shared_ptr2) &#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Object is still alive: &quot;</span> &lt;&lt; *shared_ptr2 &lt;&lt; std::endl; </span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Object has been destroyed&quot;</span> &lt;&lt; std::endl; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"智能指针的实现原理\"><a class=\"markdownIt-Anchor\" href=\"#智能指针的实现原理\">#</a> 智能指针的实现原理</h3>\n<p>模板类</p>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> Deleter = std::default_delete&lt;T&gt;&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> unique_ptr &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    T* ptr_;</span><br><span class=\"line\">    Deleter deleter_;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">unique_ptr</span><span class=\"params\">(T* p = <span class=\"literal\">nullptr</span>)</span> : ptr_(p) &#123;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 禁止拷贝</span></span><br><span class=\"line\">    <span class=\"built_in\">unique_ptr</span>(<span class=\"type\">const</span> unique_ptr&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">    unique_ptr&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> unique_ptr&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 允许移动</span></span><br><span class=\"line\">    <span class=\"built_in\">unique_ptr</span>(unique_ptr&amp;&amp; other) <span class=\"keyword\">noexcept</span> </span><br><span class=\"line\">        : <span class=\"built_in\">ptr_</span>(other.ptr_), <span class=\"built_in\">deleter_</span>(std::<span class=\"built_in\">move</span>(other.deleter_)) &#123;</span><br><span class=\"line\">        other.ptr_ = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    unique_ptr&amp; <span class=\"keyword\">operator</span>=(unique_ptr&amp;&amp; other) <span class=\"keyword\">noexcept</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != &amp;other) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">reset</span>(other.<span class=\"built_in\">release</span>());</span><br><span class=\"line\">            deleter_ = std::<span class=\"built_in\">move</span>(other.deleter_);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 析构函数</span></span><br><span class=\"line\">    ~<span class=\"built_in\">unique_ptr</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ptr_) <span class=\"built_in\">deleter_</span>(ptr_);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 访问操作</span></span><br><span class=\"line\">    T&amp; <span class=\"keyword\">operator</span>*() <span class=\"type\">const</span> &#123; <span class=\"keyword\">return</span> *ptr_; &#125;</span><br><span class=\"line\">    T* <span class=\"keyword\">operator</span>-&gt;() <span class=\"type\">const</span> &#123; <span class=\"keyword\">return</span> ptr_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 释放所有权</span></span><br><span class=\"line\">    <span class=\"function\">T* <span class=\"title\">release</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        T* tmp = ptr_;</span><br><span class=\"line\">        ptr_ = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 重置指针</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">reset</span><span class=\"params\">(T* p = <span class=\"literal\">nullptr</span>)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ptr_ != p) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">deleter_</span>(ptr_);</span><br><span class=\"line\">            ptr_ = p;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"keyword\">operator</span> <span class=\"title\">bool</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> ptr_ != <span class=\"literal\">nullptr</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>shared_ptr 有一个 control block，shared_ptr 的实现原理如下：</p>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">shared_ptr</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    T* ptr_;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">ControlBlock</span> &#123;</span><br><span class=\"line\">        std::atomic&lt;<span class=\"type\">long</span>&gt; shared_count;</span><br><span class=\"line\">        std::atomic&lt;<span class=\"type\">long</span>&gt; weak_count;</span><br><span class=\"line\">        std::function&lt;<span class=\"type\">void</span>()&gt; deleter;</span><br><span class=\"line\">        <span class=\"built_in\">ControlBlock</span>() : <span class=\"built_in\">shared_count</span>(<span class=\"number\">1</span>), <span class=\"built_in\">weak_count</span>(<span class=\"number\">0</span>) &#123;&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ControlBlock* ctrl_;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">shared_ptr</span><span class=\"params\">(T* p = <span class=\"literal\">nullptr</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">        : ptr_(p), ctrl_(p ? new ControlBlock&#123;</span>&#125; : <span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 拷贝构造</span></span><br><span class=\"line\">    <span class=\"built_in\">shared_ptr</span>(<span class=\"type\">const</span> shared_ptr&amp; other)</span><br><span class=\"line\">        : <span class=\"built_in\">ptr_</span>(other.ptr_), <span class=\"built_in\">ctrl_</span>(other.ctrl_) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ctrl_) ++ctrl_-&gt;shared_count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 赋值</span></span><br><span class=\"line\">    shared_ptr&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> shared_ptr&amp; other) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != &amp;other) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;~<span class=\"built_in\">shared_ptr</span>(); <span class=\"comment\">// 先析构当前对象</span></span><br><span class=\"line\">            <span class=\"keyword\">new</span> (<span class=\"keyword\">this</span>) <span class=\"built_in\">shared_ptr</span>(other); <span class=\"comment\">// placement new 拷贝构造</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 析构</span></span><br><span class=\"line\">    ~<span class=\"built_in\">shared_ptr</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ctrl_ &amp;&amp; --ctrl_-&gt;shared_count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ctrl_-&gt;<span class=\"built_in\">deleter</span>(); <span class=\"comment\">// 或 delete ptr_</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ctrl_-&gt;weak_count == <span class=\"number\">0</span>) <span class=\"keyword\">delete</span> ctrl_;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    T&amp; <span class=\"keyword\">operator</span>*() <span class=\"type\">const</span> &#123; <span class=\"keyword\">return</span> *ptr_; &#125;</span><br><span class=\"line\">    T* <span class=\"keyword\">operator</span>-&gt;() <span class=\"type\">const</span> &#123; <span class=\"keyword\">return</span> ptr_; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">long</span> <span class=\"title\">use_count</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> ctrl_ ? ctrl_-&gt;shared_count.<span class=\"built_in\">load</span>() : <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>weak_ptr 的实现原理如下：</p>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">weak_ptr</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    T* ptr_;                <span class=\"comment\">// 指向实际对象（可能已析构！仅用于快速访问）</span></span><br><span class=\"line\">    ControlBlock* ctrl_;    <span class=\"comment\">// 指向共享的控制块</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 默认构造</span></span><br><span class=\"line\">    <span class=\"built_in\">weak_ptr</span>() : <span class=\"built_in\">ptr_</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">ctrl_</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从 shared_ptr 构造</span></span><br><span class=\"line\">    <span class=\"built_in\">weak_ptr</span>(<span class=\"type\">const</span> shared_ptr&lt;T&gt;&amp; sp)</span><br><span class=\"line\">        : <span class=\"built_in\">ptr_</span>(sp.ptr_), <span class=\"built_in\">ctrl_</span>(sp.ctrl_) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ctrl_) ++ctrl_-&gt;weak_count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 拷贝构造</span></span><br><span class=\"line\">    <span class=\"built_in\">weak_prot</span>(<span class=\"type\">const</span> weak_ptr&amp; wp)</span><br><span class=\"line\">        : <span class=\"built_in\">ptr_</span>(wp.ptr_), <span class=\"built_in\">ctrl_</span>(wp.ctrl_) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ctrl_) ++ctrl_-&gt;weak_count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 赋值运算符</span></span><br><span class=\"line\">    weak_ptr&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> weak_ptr&amp; wp) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != &amp;wp) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;~<span class=\"built_in\">weak_ptr</span>();               <span class=\"comment\">// 先析构当前状态</span></span><br><span class=\"line\">            <span class=\"keyword\">new</span> (<span class=\"keyword\">this</span>) <span class=\"built_in\">weak_ptr</span>(wp);         <span class=\"comment\">// placement new 拷贝</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 析构函数</span></span><br><span class=\"line\">    ~<span class=\"built_in\">weak_ptr</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ctrl_ &amp;&amp; --ctrl_-&gt;weak_count == <span class=\"number\">0</span> &amp;&amp; ctrl_-&gt;shared_count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> ctrl_;  <span class=\"comment\">// 控制块不再被任何 shared_ptr 或 weak_ptr 引用</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 转换为 shared_ptr（如果对象还活着）</span></span><br><span class=\"line\">    <span class=\"function\">shared_ptr&lt;T&gt; <span class=\"title\">lock</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">expired</span>()) <span class=\"keyword\">return</span> shared_ptr&lt;T&gt;&#123;&#125;;</span><br><span class=\"line\">        <span class=\"comment\">// 原子地尝试增加 shared_count（需线程安全）</span></span><br><span class=\"line\">        <span class=\"type\">long</span> old_count = ctrl_-&gt;shared_count.<span class=\"built_in\">load</span>();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (old_count != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ctrl_-&gt;shared_count.<span class=\"built_in\">compare_exchange_weak</span>(old_count, old_count + <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"built_in\">shared_ptr</span>&lt;T&gt;(ptr_, ctrl_); <span class=\"comment\">// 复用控制块</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> shared_ptr&lt;T&gt;&#123;&#125;; <span class=\"comment\">// 对象已被销毁</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 检查对象是否已销毁</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">expired</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ctrl_ == <span class=\"literal\">nullptr</span> || ctrl_-&gt;shared_count == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取弱引用计数（调试用）</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">long</span> <span class=\"title\">use_count</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ctrl_ ? ctrl_-&gt;shared_count.<span class=\"built_in\">load</span>() : <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>多个 shared_ptr 对象可以共享同一个动态分配的对象，并通过一个<mark>共享的控制块</mark>（control block）来维护引用计数，当最后一个 shared_ptr 被销毁或重置时，自动释放所管理的对象。</p>\n<h3 id=\"1-控制块control-block\"><a class=\"markdownIt-Anchor\" href=\"#1-控制块control-block\">#</a> 1. 控制块（Control Block）</h3>\n<p>每个被  <code>shared_ptr</code>  管理的对象都会关联一个 <strong>控制块（control block）</strong>，这个控制块通常包含以下信息：</p>\n<ul>\n<li><strong>强引用计数（strong reference count）</strong>：即有多少个  <code>shared_ptr</code>  正在共享该对象。</li>\n<li><strong>弱引用计数（weak reference count）</strong>：即有多少个  <code>weak_ptr</code>  指向该控制块（用于支持  <code>weak_ptr</code> ）。</li>\n<li><strong>被管理对象的指针</strong>（有时直接内嵌对象，如通过  <code>make_shared</code> ）。</li>\n<li><strong>删除器（deleter）</strong>：可自定义的函数对象，用于释放资源（默认是  <code>delete</code> ）。</li>\n<li><strong>分配器（allocator）</strong>：如果使用了自定义内存分配策略。</li>\n</ul>\n<blockquote>\n<p>注意：控制块本身是堆上分配的（除非使用  <code>make_shared</code> ，此时对象和控制块可能分配在同一块内存中以提高效率）。</p>\n</blockquote>\n<h3 id=\"2-引用计数的增减\"><a class=\"markdownIt-Anchor\" href=\"#2-引用计数的增减\">#</a> 2. 引用计数的增减</h3>\n<ul>\n<li><strong>构造 / 拷贝 / 赋值</strong>：\n<ul>\n<li>当一个新的  <code>shared_ptr</code>  通过拷贝构造、移动构造或赋值操作指向同一对象时，<strong>强引用计数加 1</strong>。</li>\n</ul>\n</li>\n<li><strong>析构 / 重置（reset）</strong>：\n<ul>\n<li>当一个  <code>shared_ptr</code>  被销毁或调用  <code>reset()</code>  时，<strong>强引用计数减 1</strong>。</li>\n<li>如果强引用计数变为 0，则：\n<ul>\n<li>调用删除器（deleter）释放被管理的对象；</li>\n<li><strong>但控制块不会立即释放</strong>，因为可能还有  <code>weak_ptr</code>  存在（需等待弱引用计数也为 0 才释放控制块）。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-线程安全性\"><a class=\"markdownIt-Anchor\" href=\"#3-线程安全性\">#</a> 3. 线程安全性</h3>\n<ul>\n<li><strong>引用计数的操作是原子的</strong>（通常使用  <code>std::atomic</code>  实现），因此多个线程同时拷贝或销毁  <code>shared_ptr</code>  是线程安全的。</li>\n<li>但注意：<strong>对被管理对象本身的访问不是线程安全的</strong>，需要用户自己加锁。</li>\n</ul>\n<h1 id=\"shared_ptr什么时候1什么时候-1\"><a class=\"markdownIt-Anchor\" href=\"#shared_ptr什么时候1什么时候-1\">#</a> shared_ptr 什么时候 + 1 什么时候 - 1</h1>\n<h2 id=\"1\"><a class=\"markdownIt-Anchor\" href=\"#1\">#</a> +1</h2>\n<ol>\n<li>拷贝构造</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::shared_ptr&lt;<span class=\"type\">int</span>&gt; p1 = std::<span class=\"built_in\">make_shared</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">42</span>);</span><br><span class=\"line\"><span class=\"function\">std::shared_ptr&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">p2</span><span class=\"params\">(p1)</span></span>;  <span class=\"comment\">// +1 → 强引用计数变为 2</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>拷贝赋值</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::shared_ptr&lt;<span class=\"type\">int</span>&gt; p3;</span><br><span class=\"line\">p3 = p1;  <span class=\"comment\">// p3 原来为空，现在共享 p1 的对象 → +1</span></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>函数传参</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">foo</span><span class=\"params\">(std::shared_ptr&lt;<span class=\"type\">int</span>&gt; p)</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\"><span class=\"built_in\">foo</span>(p1);  <span class=\"comment\">// 进入函数时拷贝 → +1；函数返回时析构 → -1</span></span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>作为返回值返回</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::shared_ptr&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">getPtr</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p1;  <span class=\"comment\">// 返回时可能触发拷贝或移动（见下文）</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> p4 = <span class=\"built_in\">getPtr</span>();  <span class=\"comment\">// 若发生拷贝 → +1；若被优化为移动 → 不变</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>现代编译器通常会进行 返回值优化（RVO） 或使用 移动语义，避免不必要的 +1/-1</p>\n</blockquote>\n<ol start=\"5\">\n<li>放入容器（如 vector、list）</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::vector&lt;std::shared_ptr&lt;<span class=\"type\">int</span>&gt;&gt; vec;</span><br><span class=\"line\">vec.<span class=\"built_in\">push_back</span>(p1);  <span class=\"comment\">// 拷贝进容器 → +1</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"-1\"><a class=\"markdownIt-Anchor\" href=\"#-1\">#</a> -1</h2>\n<ol>\n<li>析构</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    std::shared_ptr&lt;<span class=\"type\">int</span>&gt; p = p1;  <span class=\"comment\">// +1</span></span><br><span class=\"line\">&#125; <span class=\"comment\">// p 析构 → -1</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>调用 reset</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p<span class=\"number\">1.</span><span class=\"built_in\">reset</span>();        <span class=\"comment\">// 放弃当前对象 → -1</span></span><br><span class=\"line\">p<span class=\"number\">1.</span><span class=\"built_in\">reset</span>(<span class=\"literal\">nullptr</span>); <span class=\"comment\">// 同上</span></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>被赋予新值</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::shared_ptr&lt;<span class=\"type\">int</span>&gt; p2 = std::<span class=\"built_in\">make_shared</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">100</span>);</span><br><span class=\"line\">p1 = p2;  </span><br><span class=\"line\"><span class=\"comment\">// 先对 p1 原来的对象 -1，</span></span><br><span class=\"line\"><span class=\"comment\">// 再对 p2 的对象 +1（因为 p1 现在共享 p2 的对象）</span></span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>被赋予 nullptr 或空</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p1 = <span class=\"literal\">nullptr</span>;  <span class=\"comment\">// 相当于 reset() → -1</span></span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>从容器中移除或 clear</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec.<span class=\"built_in\">clear</span>();  <span class=\"comment\">// 容器中每个 shared_ptr 析构 → 各自管理的对象引用计数 -1</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"vector底层\"><a class=\"markdownIt-Anchor\" href=\"#vector底层\">#</a> vector 底层</h1>\n<p>连续内存存储 + 动态扩容</p>\n<h2 id=\"一-基本结构\"><a class=\"markdownIt-Anchor\" href=\"#一-基本结构\">#</a> 一、基本结构</h2>\n<p><code>std::vector&lt;T&gt;</code>  内部通常维护三个关键指针（或等效的成员）：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> Allocator = std::allocator&lt;T&gt;&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> vector &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    T* begin_;     <span class=\"comment\">// 指向首元素</span></span><br><span class=\"line\">    T* end_;       <span class=\"comment\">// 指向最后一个元素的下一个位置（即 size 的边界）</span></span><br><span class=\"line\">    T* capacity_;  <span class=\"comment\">// 指向已分配内存的末尾（即 capacity 的边界）</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong> <code>size()</code> </strong> =  <code>end_ - begin_</code></li>\n<li><strong> <code>capacity()</code> </strong> =  <code>capacity_ - begin_</code></li>\n<li>所有元素在  <code>[begin_, end_)</code>  范围内，内存连续。</li>\n</ul>\n<blockquote>\n<p>实际标准库实现（如 libstdc++、libc++）可能用一个指针 + 两个整数（size/capacity），但逻辑等价。</p>\n</blockquote>\n<h2 id=\"二-内存分配与释放\"><a class=\"markdownIt-Anchor\" href=\"#二-内存分配与释放\">#</a> 二、内存分配与释放</h2>\n<ul>\n<li>使用 <strong>分配器（Allocator）</strong> 管理内存，默认是  <code>std::allocator&lt;T&gt;</code> 。</li>\n<li>初始时  <code>capacity() == 0</code> ，不分配内存（除非显式  <code>reserve</code>  或插入元素）。</li>\n<li>当需要更多空间时，<strong>重新分配一块更大的连续内存</strong>，将旧元素<strong>移动或拷贝</strong>过去，再释放旧内存。</li>\n</ul>\n<h2 id=\"三-动态扩容机制关键\"><a class=\"markdownIt-Anchor\" href=\"#三-动态扩容机制关键\">#</a> 三、动态扩容机制（关键！）</h2>\n<h3 id=\"1-何时扩容\"><a class=\"markdownIt-Anchor\" href=\"#1-何时扩容\">#</a> 1. <strong>何时扩容？</strong></h3>\n<p>当  <code>size() == capacity()</code>  且尝试插入新元素（如  <code>push_back</code> 、 <code>insert</code> ）时，触发扩容。</p>\n<h3 id=\"2-扩容策略\"><a class=\"markdownIt-Anchor\" href=\"#2-扩容策略\">#</a> 2. <strong>扩容策略</strong></h3>\n<ul>\n<li>通常采用 <strong>倍增策略（geometric growth）</strong>：\n<ul>\n<li>GCC (libstdc++)：<strong>容量 × 2</strong></li>\n<li>MSVC：<strong>容量 × 1.5</strong></li>\n<li>目的：保证 <strong>摊还时间复杂度 O (1)</strong> 的  <code>push_back</code></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>例如：初始容量 1 → 2 → 4 → 8 → 16 …</p>\n</blockquote>\n<h3 id=\"3-扩容过程\"><a class=\"markdownIt-Anchor\" href=\"#3-扩容过程\">#</a> 3. <strong>扩容过程</strong></h3>\n<p>std::vector<mark> 申请一块新的、更大的连续内存</mark></p>\n<ul>\n<li>将旧内存中的所有元素 逐个移动（move）或复制（copy） 到新内存（优先使用 move 构造，若类型支持）。</li>\n<li>销毁旧内存中的对象。</li>\n<li>释放旧内存。</li>\n<li>更新内部指针（指向新内存）和 capacity ()。<br>\n这个过程的时间复杂度是 O (n)，其中 n 是当前元素数量。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_back</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">size</span>() == <span class=\"built_in\">capacity</span>()) &#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> new_cap = (<span class=\"built_in\">capacity</span>() == <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : <span class=\"built_in\">capacity</span>() * <span class=\"number\">2</span>;</span><br><span class=\"line\">        T* new_mem = allocator.<span class=\"built_in\">allocate</span>(new_cap);           <span class=\"comment\">// 分配新内存</span></span><br><span class=\"line\">        <span class=\"built_in\">uninitialized_move</span>(begin_, end_, new_mem);          <span class=\"comment\">// 移动旧元素</span></span><br><span class=\"line\">        allocator.<span class=\"built_in\">deallocate</span>(begin_, <span class=\"built_in\">capacity</span>());           <span class=\"comment\">// 释放旧内存</span></span><br><span class=\"line\">        begin_ = new_mem;</span><br><span class=\"line\">        end_ = new_mem + <span class=\"built_in\">size</span>();</span><br><span class=\"line\">        capacity_ = new_mem + new_cap;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">construct</span>(end_, value);  <span class=\"comment\">// 在 end_ 处构造新元素</span></span><br><span class=\"line\">    ++end_;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：C++11 起优先使用 <strong>移动语义</strong>（move）而非拷贝，提升性能。</p>\n</blockquote>\n<h2 id=\"四-关键操作的时间复杂度\"><a class=\"markdownIt-Anchor\" href=\"#四-关键操作的时间复杂度\">#</a> 四、关键操作的时间复杂度</h2>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>时间复杂度</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>operator[]</code> ,  <code>at()</code></td>\n<td>O(1)</td>\n<td>随机访问</td>\n</tr>\n<tr>\n<td><code>push_back()</code></td>\n<td><strong>O (1) 摊还</strong></td>\n<td>偶尔 O (n) 扩容</td>\n</tr>\n<tr>\n<td><code>pop_back()</code></td>\n<td>O(1)</td>\n<td>仅析构最后一个元素，不释放内存</td>\n</tr>\n<tr>\n<td><code>insert(pos, val)</code></td>\n<td>O(n)</td>\n<td>需移动 pos 后所有元素</td>\n</tr>\n<tr>\n<td><code>erase(pos)</code></td>\n<td>O(n)</td>\n<td>同上</td>\n</tr>\n<tr>\n<td><code>clear()</code></td>\n<td>O(n)</td>\n<td>析构所有元素，但 <strong>不释放内存</strong>（capacity 不变）</td>\n</tr>\n<tr>\n<td><code>shrink_to_fit()</code></td>\n<td>O(n)</td>\n<td>请求释放多余内存（非强制，依赖实现）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"五-内存管理特性\"><a class=\"markdownIt-Anchor\" href=\"#五-内存管理特性\">#</a> 五、内存管理特性</h2>\n<ul>\n<li><strong>内存连续</strong>：支持与 C 数组互操作（如  <code>&amp;vec[0]</code>  或  <code>vec.data()</code> ）。</li>\n<li><strong>不自动缩容</strong>： <code>pop_back</code>  或  <code>erase</code>  后  <code>capacity()</code>  不变，避免频繁 realloc。</li>\n<li><strong>异常安全</strong>：现代实现通常提供 <strong>强异常安全保证</strong>（如 copy-and-swap 技术）。</li>\n</ul>\n<h1 id=\"内存对齐\"><a class=\"markdownIt-Anchor\" href=\"#内存对齐\">#</a> 内存对齐</h1>\n<p>结构体内存对齐，理论上，32 位系统下，int 占 4byte，char 占一个 byte，那么将它们放到一个结构体中应该占 4+1=5byte；但是实际上，通过运行程序得到的结果是 8 byte，这就是内存对齐所导致的</p>\n<figure class=\"highlight c++\"><figcaption><span>内存对齐</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//32位系统</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x;</span><br><span class=\"line\">    <span class=\"type\">char</span> y;</span><br><span class=\"line\">&#125;s;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,<span class=\"built_in\">sizeof</span>(s));  <span class=\"comment\">// 输出8</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的。它一般会以双字节，四字节，8 字节，16 字节甚至 32 字节为单位来存取内存，我们将上述这些存取单位称为内存存取粒度</p>\n<p>每个特定平台上的编译器都有自己的默认 “对齐系数”（也叫对齐模数）。gcc 中默认 #pragma pack (4)，可以通过预编译命令 #pragma pack (n)，n = 1,2,4,8,16 来改变这一系数。</p>\n<p>内存对齐需要遵循的规则：</p>\n<p>(1) 结构体第一个成员的偏移量（offset）为 0，以后每个成员相对于结构体首地址的 offset 都是<mark>该成员大小与有效对齐值中较小那个的整数倍</mark>，如有需要编译器会在成员之间加上填充字节。<br>\n(3) 结构体的总大小为 有效对齐值 的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。</p>\n<figure class=\"highlight c++\"><figcaption><span>内存对齐</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//32位系统</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">struct</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;    </span><br><span class=\"line\">    <span class=\"type\">char</span> c1;  </span><br><span class=\"line\">    <span class=\"type\">char</span> c2;  </span><br><span class=\"line\">&#125;x1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> c1;  </span><br><span class=\"line\">    <span class=\"type\">int</span> i;    </span><br><span class=\"line\">    <span class=\"type\">char</span> c2;  </span><br><span class=\"line\">&#125;x2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> c1;  </span><br><span class=\"line\">    <span class=\"type\">char</span> c2; </span><br><span class=\"line\">    <span class=\"type\">int</span> i;    </span><br><span class=\"line\">&#125;x3;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,<span class=\"built_in\">sizeof</span>(x1));  <span class=\"comment\">// 输出8, 4 2 2</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,<span class=\"built_in\">sizeof</span>(x2));  <span class=\"comment\">// 输出12, 4 4 4</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,<span class=\"built_in\">sizeof</span>(x3));  <span class=\"comment\">// 输出8, 2 2 4</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>C 的 _Alignof 和 C++ 的 alignof 可以获得类型的对齐。</p>\n",
            "tags": [
                "杂项"
            ]
        },
        {
            "id": "http://example.com/2025/11/20/note/20251130/",
            "url": "http://example.com/2025/11/20/note/20251130/",
            "title": "杂项",
            "date_published": "2025-11-19T16:00:00.000Z",
            "content_html": "<h1 id=\"杂项\"><a class=\"markdownIt-Anchor\" href=\"#杂项\">#</a> 杂项</h1>\n<ol>\n<li>explicit<br>\n 构造函数默认是隐式转换的，如果想要禁止隐式转换，可以使用 explicit 关键字修饰构造函数。<br>\n比如</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>explicit</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">FileSize</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 构造函数：接受字节数</span></span><br><span class=\"line\">    <span class=\"built_in\">FileSize</span>(<span class=\"type\">long</span> <span class=\"type\">long</span> bytes) : <span class=\"built_in\">bytes_</span>(bytes) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">long</span> <span class=\"type\">long</span> <span class=\"title\">getBytes</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> bytes_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"type\">long</span> bytes_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">deleteFileLargerThan</span><span class=\"params\">(<span class=\"type\">const</span> FileSize&amp; maxSize)</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Deleting files larger than &quot;</span> &lt;&lt; maxSize.<span class=\"built_in\">getBytes</span>() &lt;&lt; <span class=\"string\">&quot; bytes.\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 实际逻辑省略...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">deleteFileLargerThan</span>(<span class=\"string\">&quot;100MB&quot;</span>);  <span class=\"comment\">// 打错了！本想传字符串配置，但函数不接受 string</span></span><br><span class=\"line\">    <span class=\"comment\">// &quot;100MB&quot;  →  const char*  →  bool(true)  →  long long(1)   →  FileSize(1)</span></span><br><span class=\"line\">    <span class=\"comment\">// 变成：Deleting files larger than 1 bytes. 严重错误</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>回调函数<br>\n回调函数是一种函数指针，它允许在运行时指定一个函数，并在某个事件发生时调用该函数。<br>\n人话：一个被作为参数传递给另一个函数，并在 “合适的时候” 被调用的函数。</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>callback</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">std::function&lt;R(Args...)&gt; cb;</span><br><span class=\"line\"><span class=\"comment\">// R: 返回类型</span></span><br><span class=\"line\"><span class=\"comment\">// Args...: 参数列表</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>std::function 能装什么？</p>\n</blockquote>\n<ul>\n<li>普通函数</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>callback</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">greet</span><span class=\"params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"string\">&quot;Hello!\\n&quot;</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">std::function&lt;<span class=\"type\">void</span>()&gt; cb = greet;</span><br><span class=\"line\"><span class=\"built_in\">cb</span>(); <span class=\"comment\">// 输出 Hello!</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>Lambda 表达式</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>callback</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> x = <span class=\"number\">42</span>;</span><br><span class=\"line\">std::function&lt;<span class=\"type\">void</span>()&gt; cb = [x]() &#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Captured x = &quot;</span> &lt;&lt; x &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">cb</span>(); <span class=\"comment\">// 输出 Captured x = 42</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>函数对象</li>\n<li>成员函数</li>\n</ul>\n<ol start=\"3\">\n<li>\n<p><code>mutable std::mutex mtx_;</code> <br>\n <code>mutable</code>  关键字表示变量可以在常量函数中修改。<br>\n如果没有 mutable，mtx_ 是普通成员变量，在 const 函数中，所有成员都被视为 const，调用 mtx_.lock () 会报错</p>\n</li>\n<li>\n<p>std::unique_lock<span class=\"exturl\" data-url=\"c3RkOjptdXRleA==\">std::mutex</span> lock(mtx_)<br>\n 进入时自动调用 mtx_.lock ()（当前线程获得锁），当 lock 变量离开作用域（比如函数返回、出 {}），会自动调用 mtx_.unlock ()</p>\n</li>\n<li>\n<p>lambda<br>\n 有点抽象，有空继续研究<br>\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jLmJpYW5jaGVuZy5uZXQvdmlldy9ibDF5dnd5Lmh0bWw=\"> https://c.biancheng.net/view/bl1yvwy.html</span></p>\n</li>\n</ol>\n<ul>\n<li>作为函数对象（Functor）替代手写类</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>lambda</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">IsEven</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> x % <span class=\"number\">2</span> == <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">std::vector&lt;<span class=\"type\">int</span>&gt; v = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> it = std::<span class=\"built_in\">find_if</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), IsEven&#123;&#125;);</span><br><span class=\"line\"><span class=\"comment\">// lambda写法</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> it = std::<span class=\"built_in\">find_if</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), [](<span class=\"type\">int</span> x) &#123; <span class=\"keyword\">return</span> x % <span class=\"number\">2</span> == <span class=\"number\">0</span>; &#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>STL 算法的自定义谓词（最常用！）</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>lambda</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::vector&lt;Person&gt; people = &#123;...&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 按年龄降序</span></span><br><span class=\"line\">std::<span class=\"built_in\">sort</span>(people.<span class=\"built_in\">begin</span>(), people.<span class=\"built_in\">end</span>(),</span><br><span class=\"line\">          [](<span class=\"type\">const</span> Person&amp; a, <span class=\"type\">const</span> Person&amp; b) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> a.age &gt; b.age;</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除所有空字符串</span></span><br><span class=\"line\">vec.<span class=\"built_in\">erase</span>(</span><br><span class=\"line\">    std::<span class=\"built_in\">remove_if</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">end</span>(),</span><br><span class=\"line\">                   [](<span class=\"type\">const</span> std::string&amp; s) &#123; <span class=\"keyword\">return</span> s.<span class=\"built_in\">empty</span>(); &#125;),</span><br><span class=\"line\">    vec.<span class=\"built_in\">end</span>()</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 找第一个大于 10 的数</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> it = std::<span class=\"built_in\">find_if</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), [](<span class=\"type\">int</span> x) &#123; <span class=\"keyword\">return</span> x &gt; <span class=\"number\">10</span>; &#125;);</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>condition_variable<br>\n 不希望 FSM 的 worker 线程这样:</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>轮询</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (queue 空)</span><br><span class=\"line\">        一直查（忙等）</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>condition_variable 的作用：</p>\n<ul>\n<li>队列空 → 工作线程睡觉</li>\n<li>有事件 → 唤醒工作线程<br>\n写法：</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>condition_variable</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cv.<span class=\"built_in\">wait</span>(lock, []&#123; <span class=\"keyword\">return</span> !queue.<span class=\"built_in\">empty</span>(); &#125;);</span><br></pre></td></tr></table></figure>\n<ol start=\"7\">\n<li>\n<p>atomic 库<br>\n <code>atomic&lt;bool&gt;</code>  原子变量，线程安全的 bool</p>\n</li>\n<li>\n<p>匿名函数</p>\n</li>\n<li>\n<p>workerThread + 队列 + 状态机</p>\n</li>\n</ol>\n",
            "tags": [
                "杂项"
            ]
        }
    ]
}