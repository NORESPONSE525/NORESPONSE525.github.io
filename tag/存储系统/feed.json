{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog • All posts by \"存储系统\" tag",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/07/01/computer-science/computer-organization/ch3/",
            "url": "http://example.com/2025/07/01/computer-science/computer-organization/ch3/",
            "title": "Ch3",
            "date_published": "2025-06-30T16:00:00.000Z",
            "content_html": "<h1 id=\"ch3-存储系统\"><a class=\"markdownIt-Anchor\" href=\"#ch3-存储系统\">#</a> Ch3 存储系统</h1>\n<h2 id=\"存储器概述\"><a class=\"markdownIt-Anchor\" href=\"#存储器概述\">#</a> 存储器概述</h2>\n<h3 id=\"存储器的分类\"><a class=\"markdownIt-Anchor\" href=\"#存储器的分类\">#</a> 存储器的分类</h3>\n<ol>\n<li>按层次分</li>\n</ol>\n<ul>\n<li>主存（小、快、成本高）</li>\n<li>辅存（大、慢、成本低）</li>\n<li>Cache</li>\n</ul>\n<ol start=\"2\">\n<li>按存储介质分</li>\n</ol>\n<ul>\n<li>磁表面存储器（磁盘、磁带）</li>\n<li>磁芯存储器</li>\n<li>半导体存储器（MOS 型、双极型）</li>\n<li>光存储器（光盘）</li>\n</ul>\n<ol start=\"3\">\n<li>按存储方式分</li>\n</ol>\n<ul>\n<li>RAM （随机存储器）: 随机读取存储单元，存取时间与存储单元的物理位置无关。读写方便，主要用作主存和 cache，分静态 RAM 和动态 RAM。</li>\n<li>ROM （只读存储器）：只能读不能写，非易失性，随机读取。广义的 ROM 也可以通过电擦除进行写入 (EEPROM)</li>\n<li>SAM （顺序存储器）：按顺序存储，存取时间与存储单元的物理位置有关</li>\n<li>DAM （直接存储器）：先选取信息所在区域，然后顺序存取。结合了 RAM 和 SAM 的特性（磁盘）</li>\n<li>Associated memory: 不根据地址而是根据存储内容来进行存取的存储器，可以实现快速地查找快表。既可以按照<mark>地址</mark>寻址也可以按照<mark>内容</mark>寻址（通常是某些字段）</li>\n<li>串行访问存储器：SAM 和 DAM 都是，所以读写时间和物理位置有关</li>\n</ul>\n<ol start=\"4\">\n<li>按信息的可保存性分类</li>\n</ol>\n<ul>\n<li>易失性存储器：断电后丢失数据，如 RAM</li>\n<li>非易失性存储器：断电后数据还在，如 ROM，磁盘光盘</li>\n<li>破坏性读出：读出数据后数据被破坏</li>\n<li>非破坏性读出：读出数据后数据不改变</li>\n</ul>\n<h3 id=\"存储器的性能指标\"><a class=\"markdownIt-Anchor\" href=\"#存储器的性能指标\">#</a> 存储器的性能指标</h3>\n<p>三个主要性能指标：存储容量、单位成本、存储速度</p>\n<ol>\n<li>容量 = 存储字数 * 字长</li>\n<li>单位成本 = 总成本 / 总容量</li>\n<li>存储速度：<br>\n存取时间<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>T</mi><mi>a</mi></msub></mrow><annotation encoding=\"application/x-tex\">T_a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>: 启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入事件<br>\n存取周期<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>T</mi><mi>m</mi></msub></mrow><annotation encoding=\"application/x-tex\">T_m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>: 进行连续读 / 写操作所允许的最短时间间隔<br>\n主存带宽<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>B</mi><mi>m</mi></msub></mrow><annotation encoding=\"application/x-tex\">B_m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>: b/s, B/s, word/s</li>\n</ol>\n<blockquote>\n<p>存取时间仅为完成一次操作的时间，而存取周期不仅包含操作时间，还包括操作后线路的恢复时间</p>\n</blockquote>\n<h3 id=\"多级层次的存储系统\"><a class=\"markdownIt-Anchor\" href=\"#多级层次的存储系统\">#</a> 多级层次的存储系统</h3>\n<p><img data-src=\"f1.jpg\" alt><br>\n从上到下价格越来越低，速度越来越慢，容量越来越大，CPU 访问频度越来越低<br>\n<img data-src=\"f2.jpg\" alt><br>\n存储时间与存储周期的关系</p>\n<ul>\n<li>透明（transparent）指的是某种机制或技术的存在对使用者来说是不可见或无感知的<br>\n主存 - Cache 之间的数据调用由硬件自动完成，对所有程序员均是透明的<br>\n主存 - 辅存的数据调用由硬件和操作系统共同完成，对应用程序员是透明的</li>\n</ul>\n<h2 id=\"主存储器\"><a class=\"markdownIt-Anchor\" href=\"#主存储器\">#</a> 主存储器</h2>\n<p>存储元件：MOS 管</p>\n<h3 id=\"sram-dram\"><a class=\"markdownIt-Anchor\" href=\"#sram-dram\">#</a> SRAM &amp; DRAM</h3>\n<p>RAM: SRAM 静态随机存储器和 DRAM 动态随机存储器<br>\n<mark>主存主要是 DRAM，Cache 主要是 SRAM</mark>，都易失</p>\n<p>DRAM 芯片：使用栅极电容存储信息，只要一个晶体管，读写<mark>更慢</mark>，是<mark>破坏性读出</mark>，需要重写，<mark>成本低，集成度高，功耗低</mark></p>\n<p>SRAM 芯片：使用双稳态触发器存储信息（六晶体管 MOS，RS, JK, D）。读写<mark>更快</mark>，是非破坏性读出，<mark>成本高，集成度低，功耗大</mark><br>\n<img data-src=\"f4.jpg\" alt><br>\n栅极电容需要一直刷新给电容充电，触发器不需要刷新，只要不断电状态不会改变</p>\n<h4 id=\"dram的刷新\"><a class=\"markdownIt-Anchor\" href=\"#dram的刷新\">#</a> DRAM 的刷新</h4>\n<ol>\n<li>多久需要刷新一次？ 刷新周期：一般为 2ms</li>\n<li>每次刷新多少存储单元？以行为单位，每次刷新一行存储单元<br>\n —— 为什么要用行列地址？减少选通线的数量</li>\n<li>在什么时刻刷新？<br>\n有硬件支持，读出一行的信息后重新写入，占用 1 个读 / 写周期<br>\n假设 DRAM 内部结构排列成 128×128 的形式，读 / 写周期 0.5us<br>\n2ms 共 2ms/0.5us = 4000 个周期<br>\n三种刷新方式：<br>\n<img data-src=\"f5.jpg\" alt><br>\n刷新以行为单位，再生（重写）只需要恢复被读出来的存储单元<br>\n刷新由存储器独立完成，不需要 CPU 控制</li>\n</ol>\n<h5 id=\"dram的地址引脚复用技术\"><a class=\"markdownIt-Anchor\" href=\"#dram的地址引脚复用技术\">#</a> DRAM 的地址引脚复用技术</h5>\n<p><img data-src=\"f6.jpg\" alt><br>\n行列地址分成两次送，节省了一半的地址线<br>\n行列数优化原则：尽量使行、列数相同，且行数较少（因为按行刷新）<br>\n目前常用 SDRAM（同步 DRAM），数据交换同步于 CPU 的时钟信号，使得 CPU 不需要等待</p>\n<h3 id=\"rom\"><a class=\"markdownIt-Anchor\" href=\"#rom\">#</a> ROM</h3>\n<p>结构简单、非易失性<br>\n类型：</p>\n<ol>\n<li>MROM 掩模式 ROM<br>\n 在芯片生产过程中写入，无法改变，可靠性高，急程度高，价格便宜，灵活性差</li>\n<li>PROM 一次可编程 ROM<br>\n 可以用专门的设备写入一次，一旦写入无法改变</li>\n<li>EPROM 可擦除可编程 ROM<br>\n 可以写入并多次改写，但是编程次数有限且时间长</li>\n<li>Flash<br>\n 兼有 RAM 和 ROM 的优点，可以不加电长期保存信息，又能在线快速擦除和重写，价格便宜，急程度高，电可擦除重写且速度快<br>\n SSD 固态硬盘基于 Flash，由控制单元和 Flash 组成，长期保存、快速擦除和重写，对比传统硬盘读写速度快。低功耗。但是价格高</li>\n</ol>\n<h3 id=\"主存储器的基本组成\"><a class=\"markdownIt-Anchor\" href=\"#主存储器的基本组成\">#</a> 主存储器的基本组成</h3>\n<p>核心部件：一个个存储 0 或 1 的存储单元构成的存储矩阵<br>\n访问主存时，CPU 把地址送到 MAR，MAR 通过地址总线把地址送到主存中的地址寄存器，地址译码器进行译码，选中相应的内存单元，然后通过控制电路决定读 / 写操作：</p>\n<ul>\n<li>读操作：将选中的内存单元的内容通过数据总线送到 MDR 中</li>\n<li>写操作：将 MDR 中的内容通过数据总线送到选中的内存单元中<br>\n MDR 的位数和数据总线位数相同，通常等于存储字长；MAR 的位数和地址总线位数相同</li>\n</ul>\n<h3 id=\"多模块存储器\"><a class=\"markdownIt-Anchor\" href=\"#多模块存储器\">#</a> 多模块存储器</h3>\n<p>DRAM 芯片的恢复时间比较长，有可能是存取时间的几倍（SRAM 的恢复时间较短）。CPU 的读写速度比主存快很多，主存恢复时间太长<br>\n —— 利用多个完全相同的存储模块并行工作来提高吞吐率：单体多字存储器，多体低位交叉存储器</p>\n<ul>\n<li>双端口 RAM（408 不考，了解即可）<br>\n<img data-src=\"f7.jpg\" alt></li>\n</ul>\n<ol>\n<li>\n<p>单体多字存储器<br>\n一般一个存储单元只存储一个 word，但是单体多字存储器一个存储单元存储多个 word，然后读的时候一次性读取这多个字。好处是快，缺点是只有指令和数据连续存放时才能提高存取速度，否则造成不必要的读取。</p>\n</li>\n<li>\n<p><mark>多体并行存储器（重点）</mark><br>\n分为高位交叉编址和低位交叉编址两种<br>\n<img data-src=\"f8.jpg\" alt><br>\n高位交叉编址每一块存储体的高位是一样的，实际上还是顺序存储。因此访问连续内存实际上访问的还是同一块存储体，并不能通过并行加快访问速度<br>\n低位交叉编址的每一块存储体低位相同，因此可以在恢复时间并行存取下一块内存的数据<br>\n存取周期为 <code>T</code> , 存取时间为 <code>r</code> , T = r + 恢复时间<br>\n对于 n 个存储器并行访问的存储器：<br>\n采用高位交叉编址的时间为 <code>n*T</code> <br>\n 低位交叉编址为 <code>T + (n-1)*r</code></p>\n</li>\n</ol>\n<p><img data-src=\"f9.png\" alt></p>\n<ul>\n<li>轮流启动：每个 bank 的存储位数等于数据总线的位数，此时采用轮流启动\n<ul>\n<li>对于低位交叉编址，要保证 <code>m&gt;=T/r</code> ，以保证流水线不间断</li>\n<li>理想情况下，m 个 bank 的交叉存储器每隔 <code>T/m</code>  个周期可以读 / 写一个数据，若相邻 m 次访问的当存地址出现在同一个模块内，则会发生访存冲突，此时需要延迟发生冲突的访问请求。</li>\n</ul>\n</li>\n<li>同时启动：如果 m 个 bank 的总位数加起来刚好等于数据总线的位数，则 m 个同时存 / 取</li>\n</ul>\n<h2 id=\"主存储器与cpu的连接\"><a class=\"markdownIt-Anchor\" href=\"#主存储器与cpu的连接\">#</a> 主存储器与 CPU 的连接</h2>\n<h3 id=\"连接原理\"><a class=\"markdownIt-Anchor\" href=\"#连接原理\">#</a> 连接原理</h3>\n<p>通过总线连接（控制、地址、数据）<br>\n传输速率 = 总线宽度 / 传输时间<br>\n地址总线的位数决定了可寻址的最大内存空间<br>\n控制总线指出总线周期的类型和本次输入输出完成的时刻<br>\n将多个芯片集成在内存条上，由多个内存条和主板上的 ROM 芯片组成计算机所需的主存空间，通过总线与 CPU 连接</p>\n<h3 id=\"主存容量的扩展\"><a class=\"markdownIt-Anchor\" href=\"#主存容量的扩展\">#</a> 主存容量的扩展</h3>\n<p>数据总线宽度 &gt; 存储字长 —— 位扩展<br>\n地址总线宽度 &gt; 存储字数量所需的宽度<br>\n<img data-src=\"f10.jpg\" alt></p>\n<ol>\n<li>\n<p>位扩展法：增加存储字长<br>\n由于数据总线宽度大于存储字长，存在浪费情况，必须进行位扩展使数据位数与数据总线位数相等<br>\n如图：<br>\n<img data-src=\"f11.jpg\" alt></p>\n</li>\n<li>\n<p>字扩展法<br>\n地址总线存在浪费情况，对存储字的数量进行扩展<br>\n用多出来的地址线提供 CS 片选信号，决定输出的是哪个芯片的数据</p>\n</li>\n</ol>\n<ul>\n<li>线选法：n 条多余的地址线，对应 n 个选片信号，地址空间不连续造成地址空间浪费（只能有一个 1 有效），电路简单<br>\n<img data-src=\"f13.jpg\" alt></li>\n<li>译码器选法：n 条多余的线对应<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> 个选片信号，地址空间可以连续<br>\n<img data-src=\"f12.jpg\" alt></li>\n</ul>\n<ol start=\"3\">\n<li>字、位同时扩展<br>\n既增加存储字的数量，又增加存储字长<br>\n<img data-src=\"f14.jpg\" alt></li>\n</ol>\n<h3 id=\"存储芯片的地址分配和片选\"><a class=\"markdownIt-Anchor\" href=\"#存储芯片的地址分配和片选\">#</a> 存储芯片的地址分配和片选</h3>\n<p>见上方线选法译码器选法</p>\n<h3 id=\"存储器与cpu的连接\"><a class=\"markdownIt-Anchor\" href=\"#存储器与cpu的连接\">#</a> 存储器与 CPU 的连接</h3>\n<p>…<br>\n 片选信号还与 CPU 的方寸控制信号<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mrow><mi>M</mi><mi>R</mi><mi>E</mi><mi>Q</mi></mrow><mo stretchy=\"true\">‾</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\overline{MREQ}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0777700000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord overline\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8833300000000001em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathnormal\">Q</span></span></span><span style=\"top:-3.80333em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span></span></span></span> 有关（低电平有效），若 CPU 访问 IO 则此信号为高电平<br>\n MAR 位数要看主存地址空间大小，而不能看实际上用了多少位</p>\n<h2 id=\"外部存储器\"><a class=\"markdownIt-Anchor\" href=\"#外部存储器\">#</a> 外部存储器</h2>\n<p>磁盘存储器是以磁盘为存储介质的存储器，优点：容量大，价格低；记录介质可重复使用；可以长期保存；非破坏性读出。缺点：存取速度慢；机械结构复杂；对工作环境要求高</p>\n<h3 id=\"磁盘存储器\"><a class=\"markdownIt-Anchor\" href=\"#磁盘存储器\">#</a> 磁盘存储器</h3>\n<ol>\n<li>磁盘存储器</li>\n</ol>\n<ul>\n<li>\n<p>组成：磁盘驱动器，磁盘控制器，盘片<br>\n<img data-src=\"f15.jpg\" alt></p>\n</li>\n<li>\n<p>存储区域：<mark>扇区（也称块）是磁盘读写的最小单位</mark>，按块存取</p>\n<ul>\n<li>磁头数 (Heads)：一个记录面对应一个磁头</li>\n<li>柱面数 (Cylinders)：表示每面盘片上的磁道数，不同记录面的相同位置的磁道构成一个柱面</li>\n<li>扇区数 (Sectors)：每条磁道上有多少扇区</li>\n</ul>\n</li>\n<li>\n<p>Disk Cache</p>\n<ul>\n<li>在内存上的一片区域，用来缓冲被送到磁盘上的数据。优点：写磁盘时按簇进行，可以避免频繁地用小块数据写；中间结果数据写回之前可以被快速再次使用</li>\n</ul>\n</li>\n<li>\n<p>磁记录原理</p>\n<ul>\n<li>原理：当磁头和磁性记录介质有相对运动时，通过电磁转换完成读 / 写操作。</li>\n<li>编码方法：按某种方案（规律），把一连串的二进制信息变换成存储介质磁层中一个磁化翻转状态的序列，并使读 / 写控制电路容易、可靠地实现转换。</li>\n<li>磁记录方式：通常采用调频制（FM）和改进型调频制（MFM）的记录方式。</li>\n</ul>\n</li>\n<li>\n<p>性能指标</p>\n<ul>\n<li>\n<p>磁盘的容量：一个磁盘所能存储的字节总数称为磁盘容量。磁盘容量有非格式化容量和格式化容量之分。<br>\n非格式化容量是指磁记录表面可以利用的磁化单元总数，非格式化容量 = 记录面数 * 柱面数 * 每条磁道的磁化单元数<br>\n格式化容量是指按照某种特定的记录格式所能存储信息的总量，格式化容量 = 记录面数 * 柱面数 * 每道扇区数 * 每个扇区的容量<br>\n<mark>格式化容量 &lt; 非格式化容量</mark></p>\n</li>\n<li>\n<p>记录密度：记录密度是指盘片单位面积上记录的二进制的信息量，通常以 <code>道密度</code> 、 <code>位密度</code> 和 <code>面密度</code> 表示。道密度是<mark>沿磁盘半径方向单位长度上的磁道数</mark>；位密度是<mark>磁道单位长度上能记录的二进制代码位数</mark>；面密度是位密度和道密度的乘积。<br>\n<mark>磁盘所有磁道记录的信息量一定是相等的，并不是圆越大信息越多，故每个磁道的位密度都不同，越靠近圆心位密度越大</mark></p>\n</li>\n<li>\n<p>平均存取时间：<br>\n<mark>平均存取时间 = 寻道时间（磁头移动到目的磁道）+ 旋转延迟时间（磁头定位到所在扇区）+ 传输时间（传输数据所花费的时间）</mark><br>\n<mark>寻道时间通常取从最外道到最内道时间的一半，旋转延迟时间通常取旋转半周的时间</mark></p>\n</li>\n<li>\n<p>数据传输率：磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输率<br>\n假设磁盘转速为 r（转 / 秒），每条磁道容量为 N 个字节，则数据传输率为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>D</mi><mi>r</mi></msub><mo>=</mo><mi>r</mi><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">D_r=rN</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></p>\n</li>\n</ul>\n</li>\n<li>\n<p>磁盘地址<br>\n<img data-src=\"f16.jpg\" alt></p>\n</li>\n<li>\n<p>磁盘的工作原理<br>\n硬盘的主要操作是寻址、读盘、写盘。每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字。<br>\n硬盘属于机械式部件，其读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据。</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>RAID<br>\n 将多个独立的物理磁盘组成一个独立的逻辑磁盘，数据分割交叉存储，并行访问。</li>\n</ol>\n<ul>\n<li>RAID0：无冗余和无校验的磁盘阵列。</li>\n<li>RAID1：镜像磁盘阵列。每份数据存两遍，成本太高</li>\n<li>RAID2：采用纠错的海明码的磁盘阵列。<br>\n逻辑上连续的几个 bit 物理上分散存储在各个盘中 4bit 信息位 + 3bit 海明校验位 —— 可纠正 1bit 错误<br>\n每个码字有  <code>m</code>  个信息位和  <code>r</code>  个冗余位，$ (m+r+1)≤2^r$<br>\n 参考 xyx 学长的计网笔记：<br>\n<img data-src=\"f17.jpg\" alt></li>\n<li>RAID3：位交叉奇偶校验的磁盘阵列。前三个盘的奇偶校验位写在第四个盘上</li>\n<li>RAID4：块交叉奇偶校验的磁盘阵列。</li>\n<li>RAID5：无独立校验的奇偶校验磁盘阵列。在所有磁盘之间分条，并且每个数据块的奇偶校验块 § 写入到同一条带上<br>\n RAID1-RAID5 数据不会损坏</li>\n</ul>\n<h3 id=\"固态硬盘ssd\"><a class=\"markdownIt-Anchor\" href=\"#固态硬盘ssd\">#</a> 固态硬盘 (SSD)</h3>\n<ol>\n<li>特性<br>\n属于 Flash memory, EEPROM<br>\n 组成：闪存翻译层，存储介质<br>\n<img data-src=\"f18.jpg\" alt><br>\n<mark>数据以页为单位读写，以块为单位擦除</mark>只有整个块被擦除之后才能写这一页，若视图修改包含已有数据的页<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">P_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，则这个快中所有含有有用数据的页必须被复制到新的空白的块中，才能对<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">P_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 进行写操作<br>\n SSD 的优点：<mark>随机写很慢，随机读比机械磁盘块</mark>，没噪声，能耗低，抗震性好，安全性高</li>\n<li>Wear Leveling 磨损均衡<br>\n重复擦写块就会磨损坏，一般是几百次到几千次<br>\n (1) 动态磨损均衡：<mark>写入时</mark>优先选择擦除次数少的新闪存块，只在写入时触发，仅考虑可用空间（对于冷数据不包括在空间池中，减少了可以用的 block 数量）<br>\n(2) 静态磨损均衡：就算没有写入，SSD 也会监测并自动进行数据分配，让老的闪存快以读为主，让新的块腾出空间，以写为主：将数据从写入 / 擦除次数较低的 block 移动到其他 block 中，这样可以将低擦写次数的 block 释放出来，添加到可用可用空间池中，以便后续使用。仅覆盖单个闪存芯片单元</li>\n</ol>\n<h2 id=\"cache\"><a class=\"markdownIt-Anchor\" href=\"#cache\">#</a> Cache</h2>\n<p>解决 CPU 和主存速度不一致问题，由 SRAM 组成，通常集成在 CPU 中</p>\n<h3 id=\"程序访问的局部性原理\"><a class=\"markdownIt-Anchor\" href=\"#程序访问的局部性原理\">#</a> 程序访问的局部性原理</h3>\n<ul>\n<li>时间局部性：比如循环、数组（每次循环访问一次数组能体现时间局部性）</li>\n<li>空间局部性：最近的未来用到的信息很可能和正在使用的信息在存储空间上是临近的（顺序访问数组能体现空间局部性）<br>\nCache 利用局部性原理，将最近或频繁访问的数据复制到更快但容量较小的存储中，以便提高访问速度和系统性能。</li>\n</ul>\n<div class=\"note primary\">\n<p><strong>hit/miss 计算</strong><br>\n设<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>t</mi><mi>c</mi></msub></mrow><annotation encoding=\"application/x-tex\">t_c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76508em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 为访问一次 Cache 所需时间，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>t</mi><mi>m</mi></msub></mrow><annotation encoding=\"application/x-tex\">t_m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76508em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 为访问一次内存所需时间，则 Cache 和主存同时被访问总时间为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mo>=</mo><mi>H</mi><msub><mi>t</mi><mi>c</mi></msub><mo>+</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mo>−</mo><mi>H</mi><mo stretchy=\"false\">)</mo><msub><mi>t</mi><mi>m</mi></msub></mrow><annotation encoding=\"application/x-tex\">t = Ht_c + (1 - H)t_m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mclose\">)</span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span><br>\n 若先访问 Cache 再访问主存则时间为：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mo>=</mo><msub><mi>t</mi><mi>c</mi></msub><mo>+</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mo>−</mo><mi>H</mi><mo stretchy=\"false\">)</mo><msub><mi>t</mi><mi>m</mi></msub></mrow><annotation encoding=\"application/x-tex\">t = t_c + (1 - H)t_m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76508em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mclose\">)</span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></p>\n</div>\n<h3 id=\"cache工作原理\"><a class=\"markdownIt-Anchor\" href=\"#cache工作原理\">#</a> Cache 工作原理</h3>\n<p>主存和 Cache 之间以 == 块 (Block)== 为单位进行数据交换</p>\n<h3 id=\"映射方式\"><a class=\"markdownIt-Anchor\" href=\"#映射方式\">#</a> 映射方式</h3>\n<ol>\n<li>直接映射 Directed mapped<br>\n<img data-src=\"f20.jpg\" alt><br>\n<img data-src=\"f27.jpg\" alt><br>\ncache 行号 = 主存块号 mod cache 行数<br>\n物理地址结构：<br>\n| tag | index（行号） | byte offset |<br>\n<img data-src=\"f19.jpg\" alt></li>\n</ol>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mtext>的位数</mtext><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mi>c</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>e</mi><mtext>的</mtext><mi>b</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi><mtext>数</mtext><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">index的位数 = log_2(cache的block数) \n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">x</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">位</span><span class=\"mord cjk_fallback\">数</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">e</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord cjk_fallback\">数</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>b</mi><mi>y</mi><mi>t</mi><mi>e</mi><mtext> </mtext><mi>o</mi><mi>f</mi><mi>f</mi><mi>s</mi><mi>e</mi><mi>t</mi><mtext>的位数</mtext><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mi>c</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>e</mi><mtext>的</mtext><mi>b</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi><mtext>的字节数</mtext><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">byte\\ offset的位数 = log_2(cache的block的字节数) \n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">t</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">位</span><span class=\"mord cjk_fallback\">数</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">e</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">字</span><span class=\"mord cjk_fallback\">节</span><span class=\"mord cjk_fallback\">数</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>t</mi><mi>a</mi><mi>g</mi><mtext>的位数</mtext><mo>=</mo><mn>32</mn><mo>−</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mtext>的位数</mtext><mo>−</mo><mi>b</mi><mi>y</mi><mi>t</mi><mi>e</mi><mtext> </mtext><mi>o</mi><mi>f</mi><mi>f</mi><mi>s</mi><mi>e</mi><mi>t</mi><mtext>的位数</mtext></mrow><annotation encoding=\"application/x-tex\">tag的位数 = 32 - index的位数 - byte\\ offset的位数 \n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">位</span><span class=\"mord cjk_fallback\">数</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">3</span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">x</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">位</span><span class=\"mord cjk_fallback\">数</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">t</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">位</span><span class=\"mord cjk_fallback\">数</span></span></span></span></span></p>\n<p>在 32 位系统中，一个 word 是 4B；64 位系统中，一个 word 是 8B<br>\nCache 的一行构成：<br>\n| valid bit | dirty bit | tag | data |</p>\n<details class=\"primary\"><summary>example</summary><div>\n<p><img data-src=\"f21.jpg\" alt><br>\n<img data-src=\"f22.jpg\" alt><br>\n<img data-src=\"f23.jpg\" alt><br>\n<img data-src=\"f24.jpg\" alt><br>\n<img data-src=\"f25.jpg\" alt><br>\n<img data-src=\"f26.jpg\" alt></p>\n</div></details>\n<ol start=\"2\">\n<li>\n<p>全相连 Full Associative<br>\nblock can go anywhere in cache<br>\n 主存地址：<br>\n| tag | byte offset |<br>\n 好处是能降低冲突率，每次需要和所有 block 比较是否 hit 开销大，不适合大容量 Cache</p>\n</li>\n<li>\n<p>组相连 Set Associative<br>\n<img data-src=\"f28.jpg\" alt><br>\n 物理地址构成：<br>\n| tag | set index | 块内偏移 |<br>\nset index 的位数表示有多少组，</p>\n</li>\n</ol>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>s</mi><mi>e</mi><mi>t</mi><mi>N</mi><mi>u</mi><mi>m</mi><mo>=</mo><mfrac><mrow><mi>C</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>e</mi><mtext>大小</mtext></mrow><mrow><mi>b</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>∗</mo><mtext>路数</mtext></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">setNum =  \\frac{Cache大小}{blockSize * 路数} \n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.05744em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.37144em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord cjk_fallback\">路</span><span class=\"mord cjk_fallback\">数</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">e</span><span class=\"mord cjk_fallback\">大</span><span class=\"mord cjk_fallback\">小</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<details class=\"primary\"><summary></summary><div>\n<p>一个四路相联 cache，CPU 字长为 4 字节，内存和 cache 都是以字节编址，cache 和内存交换单位为块，每个块大小为 512 字节，cache 能够容纳 1024 个块。如果物理内存为 32 位地址:<br>\nset 数 = 1024/4 = 256<br>\nindex 位数 = log2 (256) = 8<br>\nblockOffset 位数 = log2 (512) = 9<br>\ntag 位数 = 32 - 8 - 9 = 17</p>\n<ul>\n<li>物理地址构成：| tag 17 位 | set index 8 位 | block offset 9 位 |</li>\n<li>计算内存地址 FAB12389（16 进制）在 cache 中可能的位置块号:<br>\n1111 1010 1011 0001 0010 0011 1000 1001<br>\nset index 是 10010001 也就是 145，所以可能的 block 号是 145*4 = 580, 581, 582, 583</li>\n</ul>\n</div></details>\n<p><img data-src=\"f29.jpg\" alt><br>\n<mark>n 路组相连需要 n 个比较器，位数 = tag 位数</mark></p>\n<h3 id=\"替换算法\"><a class=\"markdownIt-Anchor\" href=\"#替换算法\">#</a> 替换算法</h3>\n<ol>\n<li>\n<p>Random Replacement<br>\n 随机找一块替换，实现简单，命中率低</p>\n</li>\n<li>\n<p>FIFO<br>\n 选择最早进入的 Cache 行的进行替换</p>\n</li>\n<li>\n<p>LRU<br>\n 选择近期用得最少的 Cache 行进行替换，对每个 Cache 行维护一个计数器表示访问的次数，每次替换掉数值最小的。<br>\n2-way Cache 要用 1 bit 来记录，4-way Cache 要用 2 bit 来记录</p>\n</li>\n</ol>\n<details class=\"primary\"><summary></summary><div>\n<p>4-way Cache，有五个块映射到 Cache 同一组，访问顺序是 {1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5}<br>\n<img data-src=\"f30.jpg\" alt></p>\n</div></details>\n<h3 id=\"cache一致性问题\"><a class=\"markdownIt-Anchor\" href=\"#cache一致性问题\">#</a> Cache 一致性问题</h3>\n<p>当 write hit 时：</p>\n<ol>\n<li>Write through 全写法<br>\n Cache hit 的时候，CPU 不仅写入 Cache，而且写入主存<br>\n为了减少写入主存的时间小号，增加一个 write buffer，CPU 同时写入 Cache 和 write buffer，write buffer 采用 FIFO，当 write buffer 满时，将 write buffer 中的数据写入主存</li>\n<li>Write back 写回法<br>\n write hit 时，只把数据写入 Cache，只有此块被 replace 的时候才写入主存。减少了方寸次数，所以给 cache 行设置一个 dirty bit，CPU 写数据时将 dirty bit 置为 1 表示此块被修改过，repalce 时需要写入主存</li>\n</ol>\n<p>write miss 时：</p>\n<ol>\n<li>Write Allocate 写分配法<br>\n如果发生 write miss，会从内存中加载对应的数据块到 cache 中，然后进行写操作。和 write-back 搭配使用，把后续对该块的修改都缓存在 cache 中</li>\n<li>Not-Write-Allocate 非写分配法<br>\n只更新主存不把主存写入 Cache，适用于 write-through，因为即使写入 cache，也会马上写回内存，没必要占用 cache 空间。</li>\n</ol>\n<p><mark>write through 通常和 not-write-allocate 一起用，write back 通常和 write allocate 一起用</mark></p>\n<h4 id=\"使用分离的指令cache和数据cache\"><a class=\"markdownIt-Anchor\" href=\"#使用分离的指令cache和数据cache\">#</a> 使用分离的指令 Cache 和数据 Cache</h4>\n<details class=\"primary\"><summary></summary><div>\n<p><img data-src=\"f31.jpg\" alt><br>\n<img data-src=\"f32.jpg\" alt></p>\n</div></details>\n<h2 id=\"虚拟存储器\"><a class=\"markdownIt-Anchor\" href=\"#虚拟存储器\">#</a> 虚拟存储器</h2>\n<h3 id=\"基本概念\"><a class=\"markdownIt-Anchor\" href=\"#基本概念\">#</a> 基本概念</h3>\n<p>主存和辅存共同构成了虚拟存储器，对于应用程序员而言，虚拟存储器是透明的。（对 OS 开系统程序员不透明，他们必须管理 TLB）<br>\n虚拟存储器具有主存的速度和辅存的容量</p>\n<ul>\n<li>允许多个程序之间高效、安全地共享内存</li>\n<li>允许单个程序使用超过内存容量的内存</li>\n</ul>\n<details class=\"primary\"><summary></summary><div>\n<p>实地址 = 主存页号 + 页内字地址<br>\n虚地址 = 虚存页号 + 页内字地址<br>\n辅存地址 = 磁盘号 + 盘面号 + 磁道号 + 扇区号</p>\n</div></details>\n<p>虚拟存储器缺页访问辅存的代价很大，当程序访问某个 virtual page 时，如果该页当前不在主存中，就会发生 page fault，操作系统需要从辅存加载该页到主存，访问很慢所以访问代价大。因此采用 <code>full associative</code>  允许 virtual page 可以加载到主存的任何一个空闲物理页框中，提高命中率。<br>\n写操作中处理一致性问题时采用  <code>write back</code> 。主存中的页面状态维护一个 dirty 标志位。当操作系统需要将该页替换出主存时，会检查该页的脏页标志：如果 dirty，说明主存页面数据修改过，必须写回辅存；如果 dirty 为 0，说明主存数据和辅存一致，直接丢弃主存页面，无需写回</p>\n<h3 id=\"页式虚拟存储器\"><a class=\"markdownIt-Anchor\" href=\"#页式虚拟存储器\">#</a> 页式虚拟存储器</h3>\n",
            "tags": [
                "存储系统"
            ]
        }
    ]
}