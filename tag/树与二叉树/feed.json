{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog • All posts by \"树与二叉树\" tag",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/10/10/computer-science/DS/ch5/",
            "url": "http://example.com/2025/10/10/computer-science/DS/ch5/",
            "title": "ch5",
            "date_published": "2025-10-09T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch5\"><a href=\"#Ch5\" class=\"headerlink\" title=\"Ch5\"></a>Ch5</h1><h2 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h2><p>树的性质：</p>\n<ul>\n<li>$n$个节点的树有$n-1$条边</li>\n<li>结点数$n$等于所以结点的度数和+1</li>\n<li>度为$m$的树中第$i$层上之多有$m^{i-1}$个结点</li>\n<li>高度为$h$的$m$叉树中至多有$(m^h-1)&#x2F;(m-1)$个结点</li>\n<li>度为$m$，具有$n$个结点的树的最小高度$h$<br>$$<br>h_{\\min} &#x3D;<br>\\left\\lceil \\log_m \\left( (m - 1)n + 1 \\right) \\right\\rceil<br>$$</li>\n<li>度为$m$，具有$n$个结点的树的最大高度h为$n-m-1$</li>\n<li>高度为$h$，度为$m$的树至少有$h+m-1$个结点</li>\n</ul>\n<h2 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h2><p>二叉树：每个结点最多有两个子树，称为左子树和右子树<br>二叉树和度为2的有序树的区别：</p>\n<ol>\n<li>度为2的有序树至少有3个结点，二叉树可以为空</li>\n<li>二叉树不管有没有兄弟结点都需要区分是左子树还是右子树</li>\n</ol>\n<ul>\n<li>满二叉树：每层都满</li>\n<li>完全二叉树：除了最后一层外，其他层都是满二叉树，最后一层左边要是满的</li>\n<li>二叉排序树：每个结点都满足左子树小于该结点，右子树大于该结点</li>\n<li>平衡二叉树：任意结点的左右子树的高度差不超过1</li>\n<li>正则二叉树：树中每个分支结点都有两个子结点，树中只有度为0或2的结点</li>\n</ul>\n<p>性质：</p>\n<ol>\n<li>非空二叉树上的叶结点数等于度为2的结点数加1，$n_0 &#x3D; n_2 + 1$</li>\n<li>非空二叉树第k层最多有$2^{k-1}$个结点</li>\n<li>高度为h的二叉树最多有$2^h-1$个结点</li>\n<li>对完全二叉树按从上到下、从左到右的顺序依次编号，则<br>最后一个分支节点的编号为$\\left\\lfloor \\frac{n}{2} \\right\\rfloor$，如果$i$小于等于这个数就是分支节点，否则就是叶子结点<br>如果$n$为奇数，则每个分支节点都有左右孩子，如果是偶数就编号最大的分支只有左孩子<br>结点$i$的左孩子编号为$2i$，右孩子编号$2i+1$<br>结点i所在的depth为$\\left\\lceil \\log_2 i \\right\\rceil + 1$</li>\n<li>具有n个结点的完全二叉树的高度为$\\left\\lfloor \\log_2 n \\right\\rfloor + 1$或者$\\left\\lceil \\log_2 {n+1} \\right\\rceil$</li>\n</ol>\n<h3 id=\"二叉树的存储结构\"><a href=\"#二叉树的存储结构\" class=\"headerlink\" title=\"二叉树的存储结构\"></a>二叉树的存储结构</h3><ul>\n<li>完全二叉树可以存储在数组里，数组中第i个结点对应数组中的第i个元素，0为空，就可以利用下标找到parent&#x2F;left child&#x2F;right child</li>\n<li>普通的二叉树采用链式存储结构</li>\n</ul>\n<figure class=\"highlight c\"><figcaption><span>二叉树</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTNode</span>&#123;</span></span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTNode</span> *<span class=\"title\">lchild</span>, *<span class=\"title\">rchild</span>;</span></span><br><span class=\"line\">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二叉树的遍历和线索二叉树\"><a href=\"#二叉树的遍历和线索二叉树\" class=\"headerlink\" title=\"二叉树的遍历和线索二叉树\"></a>二叉树的遍历和线索二叉树</h3><ol>\n<li>PreOrder先（前）序遍历: 根左右</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>先序遍历</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">PreOrder</span><span class=\"params\">(BiTree T)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(T != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">Visit</span>(T);</span><br><span class=\"line\">        <span class=\"built_in\">PreOrder</span>(T-&gt;lchild);</span><br><span class=\"line\">        <span class=\"built_in\">PreOrder</span>(T-&gt;rchild);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>InOrder中序遍历: 左根右</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>中序遍历</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">InOrder</span><span class=\"params\">(BiTree T)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(T != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">InOrder</span>(T-&gt;lchild);</span><br><span class=\"line\">        <span class=\"built_in\">Visit</span>(T);</span><br><span class=\"line\">        <span class=\"built_in\">InOrder</span>(T-&gt;rchild);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>PostOrder后序遍历: 左右根</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>后序遍历</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">PostOrder</span><span class=\"params\">(BiTree T)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(T != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">PostOrder</span>(T-&gt;lchild);</span><br><span class=\"line\">        <span class=\"built_in\">PostOrder</span>(T-&gt;rchild);</span><br><span class=\"line\">        <span class=\"built_in\">Visit</span>(T);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>:::info<br>以上三种遍历方式都是递归方式，栈的深度就是树的高度，时间复杂度都是$O(n)$<br>最坏的情况下，二叉树是有n个结点且深度为n的单支树，此时空间复杂度为$O(n)$<br>:::<br>4. LevelOrder层序遍历: 从上到下从左到右<br>需要借助一个队列，其实就是bfs</p>\n<figure class=\"highlight c++\"><figcaption><span>层序遍历</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">LevelOrder</span><span class=\"params\">(BiTree T)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">initQueue</span>(Q);   <span class=\"comment\">//根节点入队</span></span><br><span class=\"line\">    BiTree p;</span><br><span class=\"line\">    <span class=\"built_in\">enQueue</span>(Q, T);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!<span class=\"built_in\">isEmpty</span>(Q))&#123; <span class=\"comment\">//若队列非空</span></span><br><span class=\"line\">        <span class=\"built_in\">DeQueue</span>(Q, p);  <span class=\"comment\">//出队</span></span><br><span class=\"line\">        <span class=\"built_in\">visit</span>(p);   <span class=\"comment\">//访问当前节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p-&gt;lchild != <span class=\"literal\">NULL</span>)   <span class=\"comment\">//左孩子入队</span></span><br><span class=\"line\">            <span class=\"built_in\">EnQueue</span>(Q, p-&gt;lchild);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p-&gt;rchild != <span class=\"literal\">NULL</span>)   <span class=\"comment\">//右孩子入队</span></span><br><span class=\"line\">            <span class=\"built_in\">EnQueue</span>(Q, p-&gt;rchild);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>由遍历序列构造二叉树<br>若已知InOrder，再给出PreOrder&#x2F;PostOrder&#x2F;LevelOrder都可以唯一的确定一棵二叉树</li>\n</ol>\n<ul>\n<li>前序 + 中序<br>用先序遍历得到根节点，在中序遍历中找，根节点把中序遍历分为左右两段分别是左子树和右子树，递归构造左右子树</li>\n<li>后序 + 中序<br>和前序同理</li>\n<li>层序 + 中序<br>层序的第一个是根节点，然后在层序找到左右子树的根节点（如果有左子树，根后面第一个就是左子树的根节点，如果有右子树，下一个就是右子树的根节点）<br>+++primary 例<br><img data-src=\"/f1.jpg\"><br><img data-src=\"/f2.jpg\"><br>+++</li>\n</ul>\n<h3 id=\"线索二叉树\"><a href=\"#线索二叉树\" class=\"headerlink\" title=\"线索二叉树\"></a>线索二叉树</h3><p>利用叶子结点和不满的结点的空指针存放指向其前驱或者后继的指针，若没有左子树，则lchild指向前驱结点，若没有右子树，则rchild指向后继结点。新增ltag和rtag，如果为0表示指向左&#x2F;右孩子，为1表示为线索指向前驱&#x2F;后继结点</p>\n<figure class=\"highlight c++\"><figcaption><span>线索二叉树</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">ThreadNode</span>&#123;</span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">ThreadNode</span> *lchild, *rchild;</span><br><span class=\"line\">    <span class=\"type\">int</span> ltag, rtag;</span><br><span class=\"line\">&#125;ThreadNode, *ThreadTree;</span><br></pre></td></tr></table></figure>\n\n<p>方法就是找出遍历的序列，然后对每个不满的节点建立线索</p>\n<h4 id=\"中序线索二叉树：\"><a href=\"#中序线索二叉树：\" class=\"headerlink\" title=\"中序线索二叉树：\"></a>中序线索二叉树：</h4><figure class=\"highlight c++\"><figcaption><span>中序线索二叉树</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">InThread</span><span class=\"params\">(ThreadTree &amp;p, ThreadTree &amp;pre)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">InThread</span>(p-&gt;lchild, pre);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p-&gt;lchild == <span class=\"literal\">NULL</span>)&#123; </span><br><span class=\"line\">            p-&gt;lchild = pre;</span><br><span class=\"line\">            p-&gt;ltag = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pre != <span class=\"literal\">NULL</span> &amp;&amp; pre-&gt;rchild == <span class=\"literal\">NULL</span>)&#123; </span><br><span class=\"line\">            pre-&gt;rchild = p;</span><br><span class=\"line\">            pre-&gt;rtag = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre = p;</span><br><span class=\"line\">        <span class=\"built_in\">InThread</span>(p-&gt;rchild, pre);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CreateInThread</span><span class=\"params\">(ThreadTree &amp;T)</span></span>&#123;</span><br><span class=\"line\">    ThreadTree pre = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(T != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">InThread</span>(T, pre);</span><br><span class=\"line\">    pre-&gt;rchild = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    pre-&gt;rtag = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了方便会增加一个head结点的lchild指向根节点，rchild指向中序遍历的最后一个结点，令中序遍历第一个节点的lchild和最后一个节点的rchild指向head</p>\n<figure class=\"highlight c++\"><figcaption><span>求中序线索二叉树中序序列下的第一个节点</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ThreadNode *<span class=\"title\">Firstnode</span><span class=\"params\">(ThreadNode *p)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p-&gt;ltag == <span class=\"number\">0</span>) p = p-&gt;lchild;  <span class=\"comment\">//找到最左下的节点但不一定是叶子</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>求节点p的后继结点</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ThreadNode *<span class=\"title\">Nextnode</span><span class=\"params\">(ThreadNode *p)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p-&gt;rtag == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">Firstnode</span>(p-&gt;rchild);   <span class=\"comment\">//如果有右孩子，则返回右孩子的最左下的节点</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> p-&gt;rchild;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>求中序线索二叉树的最后一个结点</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ThreadNode *<span class=\"title\">Lastnode</span><span class=\"params\">(ThreadNode *p)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p-&gt;rtag == <span class=\"number\">0</span>) p = p-&gt;rchild;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>求节点p的前驱结点</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ThreadNode *<span class=\"title\">Prevnode</span><span class=\"params\">(ThreadNode *p)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p-&gt;ltag == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">Lastnode</span>(p-&gt;lchild);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> p-&gt;lchild;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>不含头结点的中序线索二叉树的中序遍历</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">InOrder</span><span class=\"params\">(ThreadNode *T)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(ThreadNode *p = <span class=\"built_in\">Firstnode</span>(T); p != <span class=\"literal\">NULL</span>; p = <span class=\"built_in\">Nextnode</span>(p))</span><br><span class=\"line\">        <span class=\"built_in\">Visit</span>(p);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"先序线索二叉树\"><a href=\"#先序线索二叉树\" class=\"headerlink\" title=\"先序线索二叉树\"></a>先序线索二叉树</h4><h4 id=\"后序线索二叉树\"><a href=\"#后序线索二叉树\" class=\"headerlink\" title=\"后序线索二叉树\"></a>后序线索二叉树</h4><h2 id=\"树，森林\"><a href=\"#树，森林\" class=\"headerlink\" title=\"树，森林\"></a>树，森林</h2><h3 id=\"树的存储结构\"><a href=\"#树的存储结构\" class=\"headerlink\" title=\"树的存储结构\"></a>树的存储结构</h3><ol>\n<li>双亲表示法<br>用一个结构体数组来存，一个node包括数据域和parent域，parent域的值是父节点的数组下标。根节点的parent域为-1</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>双亲表示法</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAX_TREE_SIZE 100</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"type\">int</span> parent;</span><br><span class=\"line\">&#125;PTNode;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    PTNode nodes[MAX_TREE_SIZE];</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">&#125;PTree;</span><br></pre></td></tr></table></figure>\n<p>优点：可以很快找到parent，但求孩子需要遍历整个树<br>2. 孩子表示法<br>将每个结点的孩子视为一个线性表，以单链表作为存储结构<br>3. 孩子兄弟表示法<br>二叉树表示法，每个结点包括数据域，左孩子指针，右兄弟指针</p>\n<figure class=\"highlight c++\"><figcaption><span>孩子兄弟表示法</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">CSNode</span>&#123;</span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">CSNode</span> *firstchild, *nextsibling;</span><br><span class=\"line\">&#125;CSNode, *CSTree;</span><br></pre></td></tr></table></figure>\n<p>+++primary 图示<br><img data-src=\"/f3.jpg\"><br><img data-src=\"/f4.jpg\"><br>+++</p>\n<h3 id=\"树、森林和二叉树的转换\"><a href=\"#树、森林和二叉树的转换\" class=\"headerlink\" title=\"树、森林和二叉树的转换\"></a>树、森林和二叉树的转换</h3><ol>\n<li>树转二叉树<br>用孩子兄弟表示法（左孩子右兄弟）</li>\n<li>森林转二叉树<br>先讲森林中的每棵树转为二叉树，每棵树视为兄弟，将第二棵树对应的二叉树作为第一颗二叉树根的右子树……<br>+++primary 例<br><img data-src=\"/f5.jpg\"><br>+++</li>\n<li>二叉树转森林<br>把右子树分开，知道最后只剩一棵没有右子树的二叉树为止。和森林转二叉树相反</li>\n</ol>\n<h3 id=\"树和森林的遍历\"><a href=\"#树和森林的遍历\" class=\"headerlink\" title=\"树和森林的遍历\"></a>树和森林的遍历</h3><ol>\n<li>树的遍历</li>\n</ol>\n<ul>\n<li>先根后子树，遍历序列和这棵树对应的二叉树的先序序列相同</li>\n<li>先子树后根，遍历序列和这棵树对应的二叉树的中序序列相同</li>\n</ul>\n<ol start=\"2\">\n<li>森林的遍历</li>\n</ol>\n<ul>\n<li>先序遍历：从第一棵树开始，先根，再子树</li>\n<li>中序遍历：从第一棵树开始，先子树，再根</li>\n</ul>\n<h2 id=\"树与二叉树的应用\"><a href=\"#树与二叉树的应用\" class=\"headerlink\" title=\"树与二叉树的应用\"></a>树与二叉树的应用</h2><h3 id=\"哈夫曼树\"><a href=\"#哈夫曼树\" class=\"headerlink\" title=\"哈夫曼树\"></a>哈夫曼树</h3><h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>带权路径长度：根结点到该结点的路径长度<em>该结点的权值<br>树的带权路径长度<br>$$<br>WPL &#x3D; \\sum_{i&#x3D;1}^{n}w_i</em>l_i<br>$$<br>WPL最小的二叉树称为哈夫曼树，也称最优二叉树</p>\n<h4 id=\"构造\"><a href=\"#构造\" class=\"headerlink\" title=\"构造\"></a>构造</h4><ul>\n<li>构造方法：不断合并两个权值加起来最小的结点<br><img data-src=\"/f6.jpg\"></li>\n</ul>\n<h4 id=\"哈夫曼编码\"><a href=\"#哈夫曼编码\" class=\"headerlink\" title=\"哈夫曼编码\"></a>哈夫曼编码</h4><p>可变长度编码，让频率高的字符编码长度短，频率低的字符编码长度长<br>用哈夫曼树构建哈夫曼编码，是前缀编码，因此每个编码都可以唯一区分一个字符（没有字符的编码是其他编码的前缀）<br>构造的方法是权值为频率，左分支为0，右分支为1（左边1右边0也可以，主要是看长度）<br><img data-src=\"/f7.jpg\"><br>编码方式不唯一，因为长度相同的字符编码方式是可以互换的</p>\n<h3 id=\"并查集-Disjoint-Set\"><a href=\"#并查集-Disjoint-Set\" class=\"headerlink\" title=\"并查集 Disjoint Set\"></a>并查集 Disjoint Set</h3><p>主要用来求等价关系<br>基本操作：</p>\n<ul>\n<li>初始化：所有元素都是单元素集合</li>\n<li>Union(S, Root1, Root2):合并两个集合，把Root2的根节点连到Root1的根节点上</li>\n<li>Find(S, x): 查找x的根节点</li>\n</ul>\n<p>基本实现：</p>\n<figure class=\"highlight c++\"><figcaption><span>disjoint set</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SIZE 100</span></span><br><span class=\"line\"><span class=\"type\">int</span> UFSets[SIZE];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Initial</span><span class=\"params\">(<span class=\"type\">int</span> S[])</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; SIZE; i++)&#123;</span><br><span class=\"line\">        S[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"type\">int</span> S[], <span class=\"type\">int</span> x)</span></span>&#123;   <span class=\"comment\">//时间复杂度为O(d)，d为树的深度</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(S[x] &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        x = S[x];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Union</span><span class=\"params\">(<span class=\"type\">int</span> S[], <span class=\"type\">int</span> Root1, <span class=\"type\">int</span> Root2)</span></span>&#123;  <span class=\"comment\">//时间复杂度为O(1)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Root1 == Root2) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    S[Root2] = Root1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"并查集的优化\"><a href=\"#并查集的优化\" class=\"headerlink\" title=\"并查集的优化\"></a>并查集的优化</h4><ol>\n<li>按高度求并 Union-by-Height</li>\n</ol>\n<ul>\n<li>用根节点的绝对值表示树的结点总数（根节点的值是负数）</li>\n<li>把小树合并到大树，能够保证所有树的深度最多是$O(logn)$</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>Union-by-Height</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Union</span><span class=\"params\">(<span class=\"type\">int</span> S[], <span class=\"type\">int</span> Root1, <span class=\"type\">int</span> Root2)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Root1 == Root2) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(S[Root2] &gt; S[Root1])&#123;    <span class=\"comment\">//Root2的深度小于Root1</span></span><br><span class=\"line\">        S[Root1] += S[Root2];</span><br><span class=\"line\">        S[Root2] = Root1;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        S[Root2] += S[Root1];</span><br><span class=\"line\">        S[Root1] = Root2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>路径压缩<br>为了减少深度，在Find操作时将从根到元素x路径上的所有元素都变成根的孩子</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>路径压缩</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"type\">int</span> S[], <span class=\"type\">int</span> x)</span></span>&#123;   <span class=\"comment\">//先搜一次找到根，再搜一次把路径上所有节点的父节点都改成根</span></span><br><span class=\"line\">    <span class=\"type\">int</span> root = x;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(S[root] &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        root = S[root];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x != root)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> temp = S[x];</span><br><span class=\"line\">        S[x] = root;</span><br><span class=\"line\">        x = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n",
            "tags": [
                "树与二叉树"
            ]
        }
    ]
}