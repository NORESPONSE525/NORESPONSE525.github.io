{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog • All posts by \"i/o\" tag",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/08/15/computer-science/computer-organization/ch7/",
            "url": "http://example.com/2025/08/15/computer-science/computer-organization/ch7/",
            "title": "Ch7",
            "date_published": "2025-08-14T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch7-输入-输出系统\"><a href=\"#Ch7-输入-输出系统\" class=\"headerlink\" title=\"Ch7 输入&#x2F;输出系统\"></a>Ch7 输入&#x2F;输出系统</h1><h2 id=\"I-O接口\"><a href=\"#I-O接口\" class=\"headerlink\" title=\"I&#x2F;O接口\"></a>I&#x2F;O接口</h2><p>inerrface，主机与外设之间的交接界面</p>\n<h3 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h3><ol>\n<li>进行地址译码和设备选择</li>\n<li>实现主机和外设的通信联络控制<br>解决时序、工作速度不同的问题</li>\n<li>实现数据缓冲</li>\n<li>信号格式的转换<br>电平转换、并&#x2F;串或串&#x2F;并转换、模&#x2F;数或数&#x2F;模转换</li>\n<li>传送控制命令和状态信息<br>CPU通过接口中的命令寄存器发出启动命令给外设，外设就绪是传回Ready状态信息通过接口中的状态寄存器反馈给CPU</li>\n</ol>\n<h3 id=\"基本结构\"><a href=\"#基本结构\" class=\"headerlink\" title=\"基本结构\"></a>基本结构</h3><p><img data-src=\"/f1.jpg\"><br>主机侧通过I&#x2F;O总线与内存、CPU相连。数据缓冲器用来暂存与CPU或内存之间传送的数据信息。状态寄存器用来记录接口和设备的状态信息，控制寄存器用来保存CPU对外设的控制信息<br>状态寄存器和控制寄存器在传送方向是相反的，访问时间上是错开的，所以可以合二为一<br>数据线传送读&#x2F;写数据、状态信息、控制信息、中断类型号<br>地址线传送访问I&#x2F;O接口中的寄存器的地址<br>控制线传送读写控制信号、中断请求、响应信号、仲裁信号、握手信号<br>I&#x2F;O控制逻辑需要对控制寄存器的命令字进行译码，还有收集外设状态到状态寄存器<br><img data-src=\"/f2.jpg\"></p>\n<blockquote>\n<p>对上面两个寄存器的访问操作通过I&#x2F;O指令来完成，只能在操作系统内核的底层I&#x2F;O软件中使用，是一种特权指令<br><img data-src=\"/f3.jpg\"></p>\n</blockquote>\n<h3 id=\"接口类型\"><a href=\"#接口类型\" class=\"headerlink\" title=\"接口类型\"></a>接口类型</h3><ol>\n<li>按（外设和接口一侧的）数据传送方式：并行接口、串行接口</li>\n<li>按主机访问I&#x2F;O设备的控制方式：程序查询接口、中断接口、DMA接口</li>\n<li>按功能选择的灵活性：可编程接口、不可编程接口</li>\n</ol>\n<h3 id=\"I-O端口及其编址\"><a href=\"#I-O端口及其编址\" class=\"headerlink\" title=\"I&#x2F;O端口及其编址\"></a>I&#x2F;O端口及其编址</h3><p>I&#x2F;O端口是指I&#x2F;O接口电路中<strong>可被CPU直接访问的寄存器</strong>，主要有&#x3D;&#x3D;数据端口、状态端口和控制端口&#x3D;&#x3D;。<br>CPU能对数据端口中的数据进行读&#x2F;写操作，但对状态端口中外设的状态只能读，对控制端口只能写<br>每个端口对应一个端口地址，编址方式有与存储器独立编址和统一编址两种</p>\n<ol>\n<li>独立编址<br>也称I&#x2F;O映射方式，I&#x2F;O端口的地址空间与主存地址空间是两个独立的地址空间<br>需要设置专门的I&#x2F;O指令来表明访问的是I&#x2F;O地址空间，I&#x2F;O指令的地址码给出I&#x2F;O端口号<blockquote>\n<p>x86 架构中的 IN 和 OUT 指令<br>IN AL, 0x64    从 I&#x2F;O 端口 0x64 读取一个字节的数据，存入寄存器 AL<br>优点：I&#x2F;O端口数比主存单元数少得多，秩序少量地址线，使得I&#x2F;O端口译码简单，寻址速度更快。使用专门的I&#x2F;O指令，是程序更加清晰<br>缺点：I&#x2F;O指令少，只提供简单的传输操作，灵活性差。CPU需要提供存储器读&#x2F;写、I&#x2F;O设备读写两组控制信号，增大了控制的复杂性</p>\n</blockquote>\n</li>\n<li>统一编址<br>也称存储器映射方式(Memory-Mapped I&#x2F;O)，无需设置专门的I&#x2F;O指令，用统一的访存指令就可以访问I&#x2F;O端口<blockquote>\n<p>riscv就是用Memory-Mapped I&#x2F;O<br>优点：不需要专门的I&#x2F;O指令，CPU访问I&#x2F;O更灵活方便，端口有较大的编址空间。I&#x2F;O访问的保护机制可由虚拟存储管理系统来实现，无需专门设置（内核态才能访问）<br>缺点：端口地址占用了部分主存地址空间。译码电路复杂</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"I-O方式\"><a href=\"#I-O方式\" class=\"headerlink\" title=\"I&#x2F;O方式\"></a>I&#x2F;O方式</h2><p>程序查询、程序中断、DMA<br><img data-src=\"/f5.jpg\"></p>\n<h3 id=\"程序查询方式-Polling\"><a href=\"#程序查询方式-Polling\" class=\"headerlink\" title=\"程序查询方式(Polling)\"></a>程序查询方式(Polling)</h3><p>轮询法，程序执行到某个 I&#x2F;O 操作指令时，由操作系统或设备驱动程序发起<br><img data-src=\"/f4.jpg\"><br>程序查询方式分为两类：</p>\n<ol>\n<li>独占查询<br>一旦设备启动，CPU就一直持续查询接口状态，CPU话费100%时间用于I&#x2F;O操作，外设和CPU完全串行（忙等待）</li>\n<li>定时查询<br>CPU周期性地查询接口状态，每次总是等到条件满足才进行一个数据的传送，传送完成后返回到用户程序。<br>比如设备每 10ms 产生一个数据，可以设置 5ms 查询一次，这样既能及时读取数据，又不至于过度查询。&#x3D;&#x3D;定时查询的时间间隔与设备的数据传输速率有关。&#x3D;&#x3D;</li>\n</ol>\n<h3 id=\"程序中断方式\"><a href=\"#程序中断方式\" class=\"headerlink\" title=\"程序中断方式\"></a>程序中断方式</h3><p><img data-src=\"/f6.jpg\"><br>工作流程：</p>\n<ol>\n<li>中断请求<br>中断源向CPU发送中断请求信号。中断系统对每个中断源设置中断请求标记触发器<br>可屏蔽中断：通过<code>INTR</code>线发出的，优先级低，关中断下不被响应<br>不可屏蔽中断：通过<code>NMI</code>线发出的，优先级最高</li>\n<li>中断响应<br>响应中断的条件。<br>中断判优：多个中断源同时提出请求时通过中断判优逻辑响应一个中断源。<br>一般来说：不可屏蔽中断&gt;可屏蔽中断；在I&#x2F;O传送类终端中，高速设备&gt;低速设备，输入设备&gt;输出设备，实时设备&gt;普通设备<br>CPU响应中断的条件：</li>\n</ol>\n<ul>\n<li>中断源有中断请求</li>\n<li>允许中断及开中断</li>\n<li>一条指令执行完毕（除非是指令执行异常）</li>\n</ul>\n<ol start=\"3\">\n<li>中断处理</li>\n</ol>\n<ul>\n<li>中断隐指令：<ul>\n<li>关中断（防止在中断处理程序执行期间被其他（同级或低优先级）中断再次打断）</li>\n<li>保护现场（把PC, PSW等压入内核栈）</li>\n<li>引出中断服务程序：硬件向量法和软件查询法</li>\n</ul>\n</li>\n</ul>\n<p>中断向量：硬件提供向量号，中断控制器将该中断对应的向量号放到数据总线上，CPU读取该向量号，CPU使用该向量号作为索引，查找中断向量表（IVT）获取ISR的入口地址</p>\n<p>处理流程：</p>\n<ul>\n<li>关中断</li>\n<li>保存断点</li>\n<li>中断服务程序寻址</li>\n<li>保存现场和屏蔽字</li>\n<li>开中断（允许更高级中断请求得到响应）</li>\n<li>执行ISR</li>\n<li>关中断</li>\n<li>恢复现场和屏蔽字</li>\n<li>开中断，中断返回<br>1-3由硬件自动完成，4-9由ISR完成<blockquote>\n<p>为什么要先关再开？<br>确保这个保护现场的操作不会被其他中断打断</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"多重中断和中断屏蔽技术\"><a href=\"#多重中断和中断屏蔽技术\" class=\"headerlink\" title=\"多重中断和中断屏蔽技术\"></a>多重中断和中断屏蔽技术</h4><p>通过中断屏蔽字寄存器来实现，每个中断源都有一个屏蔽触发器，&#x3D;&#x3D;1表示屏蔽该中断源的请求&#x3D;&#x3D;，0表示可以正常申请<br>&#x3D;&#x3D;屏蔽字中‘1’越多，优先级越高。每个屏蔽字中至少有一个<code>1</code>(至少要能屏蔽自身的中断)&#x3D;&#x3D;<br>方法：要能屏蔽自身所以主对角线全为1，同时优先级比自身低的中断要屏蔽屏蔽字全填1，其他的填0</p>\n<h3 id=\"DMA方式\"><a href=\"#DMA方式\" class=\"headerlink\" title=\"DMA方式\"></a>DMA方式</h3><p>DMA方式是一种完全由硬件进行组信息传送的控制方式<br><img data-src=\"/f7.jpg\"><br><img data-src=\"/f8.jpg\"><br><img data-src=\"/f9.jpg\"></p>\n<p>当I&#x2F;O设备和CPU同时访问主存时，可能发生冲突，DMA与CPU通常采用以下3种方式使用驻村：<br><img data-src=\"/f10.jpg\"><br>周期挪用：<br>一次传一组数据</p>\n<ul>\n<li>CPU不访存时：如果CPU当前并不需要访问主存，那么DMA控制器可以直接使用总线进行数据传输，此时不会对CPU的工作造成任何影响。</li>\n<li>CPU正在访存时：如果CPU正在进行主存访问，DMA控制器会等待CPU的当前访问周期结束，然后立即“借用”接下来的一个或几个总线周期来进行自己的数据传输。这种情况下，CPU的访问会被短暂延迟，但通常这种延迟非常短，以至于CPU几乎感觉不到，因此可以认为CPU的正常工作没有受到显著影响。</li>\n<li>CPU与DMA同时请求访存时：在这种情况下，I&#x2F;O设备的访存请求通常具有更高的优先级，这意味着即使CPU也在请求访问主存，DMA控制器也会被优先考虑，从而保证I&#x2F;O设备的数据传输不受阻。</li>\n</ul>\n<ol>\n<li>停止CPU访存<br>优点：控制简单，适用于数据传输速率很高的I&#x2F;O设备实现成组数据的传送<br>缺点：DMA访问主存时，CPU基本上不工作</li>\n<li>周期挪用<br>优点：既实现了I&#x2F;O传送，又较好地发挥了主存与CPU的效率<br>缺点：每挪用一个主存周期，DMA接口都要申请、建立和归还总线周期</li>\n<li>交替访存<br>优点：不需要总线控制权的申请、建立和归还过程，传送效率高<br>缺点：相应的硬件逻辑变得更复杂</li>\n</ol>\n<h4 id=\"DMA的传送过程\"><a href=\"#DMA的传送过程\" class=\"headerlink\" title=\"DMA的传送过程\"></a>DMA的传送过程</h4><p><img data-src=\"/f9.jpg\"></p>\n<ul>\n<li>预处理：由CPU初始化DMA控制其中的寄存器、设置传送方式、测试并启动设备</li>\n<li>数据传送：DMA以数据块为基本传送单位。数据传送完全由DMA控制</li>\n<li>后处理：DMA控制器向CPU发送中断请求，CPU处理中断做DMA结束处理（包括校验）</li>\n</ul>\n<p>DMA方式和中断方式的区别：</p>\n<ul>\n<li>中断需要save context，DMA不需要，除了预处理和后处理其他时候不占用CPU（我觉得DMA方式的预处理和后处理的中断也是需要save context的，只是因为DMA方式中断次数极少，整个数据块只中断一次，所以不需要保存那么多次，所以比较快）</li>\n<li>对中断请求的相应只能发生在每条指令执行结束时，但对DMA请求的相应可以发生在任意一个机器周期结束时(IF, ID, EX…  DMA请求的是总线控制权，不是CPU的执行权。它不关心 CPU正在执行哪条指令，只关心总线是否空闲。只要当前总线周期结束，DMA就可以插空使用)</li>\n<li>中断传送过程需要CPU的干预，DMA传送不需要，数据传输速率高</li>\n</ul>\n<p>优先级：</p>\n<ul>\n<li>DMA请求的优先级高于中断请求</li>\n<li>中断方式具有处理异常事件的能力，DMA方式局限于大批数据的传送</li>\n<li>中断方式靠程序传送，DMA方式靠硬件传送</li>\n</ul>\n",
            "tags": [
                "I/O"
            ]
        }
    ]
}