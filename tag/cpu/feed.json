{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog • All posts by \"cpu\" tag",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/08/10/computer-science/computer-organization/ch5/",
            "url": "http://example.com/2025/08/10/computer-science/computer-organization/ch5/",
            "title": "Ch5",
            "date_published": "2025-08-09T16:00:00.000Z",
            "content_html": "<h1 id=\"ch5-中央处理器\"><a class=\"markdownIt-Anchor\" href=\"#ch5-中央处理器\">#</a> Ch5 中央处理器</h1>\n<h2 id=\"cpu的功能和基本结构\"><a class=\"markdownIt-Anchor\" href=\"#cpu的功能和基本结构\">#</a> CPU 的功能和基本结构</h2>\n<h3 id=\"功能\"><a class=\"markdownIt-Anchor\" href=\"#功能\">#</a> 功能</h3>\n<p>CPU 由运算器和控制器组成，具体功能包括：</p>\n<ul>\n<li>指令控制</li>\n<li>操作控制</li>\n<li>时间控制</li>\n<li>数据加工</li>\n<li>中断处理</li>\n</ul>\n<h3 id=\"基本结构\"><a class=\"markdownIt-Anchor\" href=\"#基本结构\">#</a> 基本结构</h3>\n<ol>\n<li>运算器：ALU, 暂存器，ACC, GPRs, PSW, 移位寄存器， 计数器…</li>\n<li>控制器：PC, IR, ID, 时序电路，未操作信号发生器…</li>\n</ol>\n<h3 id=\"cpu的寄存器\"><a class=\"markdownIt-Anchor\" href=\"#cpu的寄存器\">#</a> CPU 的寄存器</h3>\n<p>按汇编程序是否可访问分为用户可见寄存器 (GPRs, PSW, PC) 和用户不可见寄存器 (存储器地址寄存器，存储器数据寄存器，IR, 暂存寄存器，累加寄存器，移位寄存器)<br>\n 各寄存器的作用：</p>\n<ul>\n<li>在运算器中：\n<ul>\n<li>GPRs</li>\n<li>ACC: 通用寄存器，用于暂时存放 ALU 运算的结果</li>\n<li>SR（移位寄存器）：存放操作数且可以移位</li>\n<li>暂存寄存器：暂存从数据总线或通用寄存器送来的操作数，对应用程序员透明</li>\n<li>PSW：保留各种状态信息</li>\n</ul>\n</li>\n<li>在控制器中：\n<ul>\n<li>PC: 存放当前指令的地址</li>\n<li>IR: 存放当前指令</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"指令执行过程\"><a class=\"markdownIt-Anchor\" href=\"#指令执行过程\">#</a> 指令执行过程</h2>\n<h3 id=\"指令周期\"><a class=\"markdownIt-Anchor\" href=\"#指令周期\">#</a> 指令周期</h3>\n<p>= 取值周期 + 执行周期<br>\n间址周期在取址和执行之间<br>\n如果 CPU 在每条指令结束前都要发中断查询信号 （轮询法），后面要加上中断周期</p>\n<h3 id=\"指令周期的数据流\"><a class=\"markdownIt-Anchor\" href=\"#指令周期的数据流\">#</a> 指令周期的数据流</h3>\n<ol>\n<li>取址周期</li>\n</ol>\n<ul>\n<li>PC-&gt;MAR-&gt; 地址总线 -&gt; 存储器</li>\n<li>CU 发出读命令 -&gt; 控制总线 -&gt; 主存</li>\n<li>主存 -&gt; 数据总线 -&gt;IR</li>\n<li>CU 发出控制信号 -&gt;PC=PC+1</li>\n</ul>\n<ol start=\"2\">\n<li>间址周期<br>\n取指结束后，控制单元 CU 会检查 IR 中是否有间接地址（操作数有效地址的地址）。若有，CPU 执行如下操作：</li>\n</ol>\n<ul>\n<li>IR (或 MDR) 的间址 -&gt;MAR-&gt; 地址总线 -&gt; 主存</li>\n<li>CU 发出读命令 -&gt; 控制总线 -&gt; 主存</li>\n<li>主存 -&gt; 数据总线 -&gt;MDR（取出有效地址存入 MDR）</li>\n</ul>\n<ol start=\"3\">\n<li>\n<p>执行周期</p>\n</li>\n<li>\n<p>中断周期<br>\n假设程序断点存入堆栈中，push 操作先修改 SP 再存入（x86 采用满递减栈）</p>\n</li>\n</ol>\n<ul>\n<li>CU 控制将 SP 减 1，SP-&gt;MAR-&gt; 地址总线 -&gt;zhucun1</li>\n<li>CU 发出写命令 -&gt; 控制总线 -&gt; 主存</li>\n<li>PC-&gt;MDR-&gt; 数据总线 -&gt; 主存（把中断时的 PC 存入栈中）</li>\n<li>CU 将中断服务程序入口地址存入 PC</li>\n</ul>\n<h3 id=\"指令执行方案\"><a class=\"markdownIt-Anchor\" href=\"#指令执行方案\">#</a> 指令执行方案</h3>\n<ol>\n<li>单周期处理器<br>\n CPI = 1，指令执行周期取决于执行时间最长的指令的执行时间</li>\n<li>多周期处理器<br>\n CPI &gt; 1,</li>\n<li>流水线处理器<br>\n理想状态下 CPI = 1，流水线并行</li>\n</ol>\n<h2 id=\"数据通路\"><a class=\"markdownIt-Anchor\" href=\"#数据通路\">#</a> 数据通路</h2>\n<h3 id=\"功能-2\"><a class=\"markdownIt-Anchor\" href=\"#功能-2\">#</a> 功能</h3>\n<p>。</p>\n<h3 id=\"组成\"><a class=\"markdownIt-Anchor\" href=\"#组成\">#</a> 组成</h3>\n<ol>\n<li>组合逻辑<br>\n译码器，MUX，三态门…</li>\n<li>时序逻辑<br>\n包含存储信号的记忆单元</li>\n</ol>\n<h3 id=\"基本结构-2\"><a class=\"markdownIt-Anchor\" href=\"#基本结构-2\">#</a> 基本结构</h3>\n<p>2 种：</p>\n<ul>\n<li>CPU 内部总线（单总线、多总线）</li>\n<li>专用数据通路</li>\n</ul>\n<ol>\n<li>CPU 内部单总线方式<br>\n ALU 和寄存器连接到一条总线上，性能低<br>\n单总线的 ALU 要配合暂存器使用，比如从内存取出来的数据要放在暂存器中，再从暂存器中取数据给 ALU<br>\n<img data-src=\"f1.jpg\" alt><br>\n 了解每条指令的 datapath</li>\n<li>CPU 内部多总线方式<br>\n允许同时在多个总线上传送不同的数据，提高效率</li>\n<li>专用数据通路方式<br>\n看图说话，没什么好说的</li>\n</ol>\n<h3 id=\"数据通路的操作举例\"><a class=\"markdownIt-Anchor\" href=\"#数据通路的操作举例\">#</a> 数据通路的操作举例</h3>\n<p>会画图就会</p>\n<h2 id=\"控制器的功能和工作原理\"><a class=\"markdownIt-Anchor\" href=\"#控制器的功能和工作原理\">#</a> 控制器的功能和工作原理</h2>\n<h3 id=\"结构和功能\"><a class=\"markdownIt-Anchor\" href=\"#结构和功能\">#</a> 结构和功能</h3>\n<ol>\n<li>取指令，指出下一条指令的位置</li>\n<li>译码或测试，产生控制信号</li>\n<li>控制 CPU，主存，I/O 的数据流动方向<br>\n分为硬布线控制器和微程序控制器</li>\n</ol>\n<h3 id=\"硬布线控制器\"><a class=\"markdownIt-Anchor\" href=\"#硬布线控制器\">#</a> 硬布线控制器</h3>\n<p>组合逻辑控制器<br>\n CU 的输入信号来自 (1) 指令译码器 (2) 时钟脉冲 (3) 执行单元的反馈信息<br>\n比如这种：<br>\n<img data-src=\"f2.jpg\" alt></p>\n<h3 id=\"微程序控制器\"><a class=\"markdownIt-Anchor\" href=\"#微程序控制器\">#</a> 微程序控制器</h3>\n<p>采用存储逻辑实现，将未操作信号代码化，使没调机器指令转化成一段微程序并存入专门的控制存储器中<br>\n晚点回来学</p>\n<h2 id=\"异常和中断机制\"><a class=\"markdownIt-Anchor\" href=\"#异常和中断机制\">#</a> 异常和中断机制</h2>\n<h3 id=\"概念\"><a class=\"markdownIt-Anchor\" href=\"#概念\">#</a> 概念</h3>\n<p>内部产生的意外事件叫异常，是同步的；外部产生的事件叫中断，是异步的</p>\n<h3 id=\"分类\"><a class=\"markdownIt-Anchor\" href=\"#分类\">#</a> 分类</h3>\n<ul>\n<li>\n<p>异常：CPU 内部执行指令引起的异常事件，比如整除 0，溢出，单步跟踪，非法指令，栈溢出，地址越界，缺页等</p>\n<ul>\n<li>\n<ol>\n<li>Fault 故障<br>\n引起故障的指令启动后、执行结束前检测到的异常事件（所以处理完之后要重新执行该指令或者无法恢复的终止进程）</li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>Trap 自陷<br>\n人为设定的特殊中断机制，最常见的是 sys call，还有断点、单步，还有一些条件自陷指令（MIPS 的 teq, teqi, tne, tnei）等<br>\n<mark>以上两种都属于软件中断</mark></li>\n</ol>\n</li>\n<li>\n<ol start=\"3\">\n<li>Abort 终止<br>\n执行过程中发生了硬件故障，比如控制器出错、存储器校验错、总线错误等<br>\n<mark> Abort 和外中断属于硬件中断</mark></li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>中断：CPU 外部比如 I/O 引起的中断，分为可屏蔽中断和不可屏蔽中断</p>\n<ul>\n<li>可屏蔽中断：可屏蔽中断请求线 INTR 向 CPU 发出中断请求，CPU 可以设置相应的 bit 屏蔽</li>\n<li>不可屏蔽中断：通过专门的不可屏蔽中断请求线 NMI 向 CPU 发出的中断请求，通常是非常紧急的硬件故障<br>\n<mark>所有的异常和终端都是由硬件检测发现的</mark><br>\n根据识别中断服务程序地址的方式，可以分为向量中断和非向量中断；<br>\n根据中断处理过程是否允许被打断分为单重中断和多重中断</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"异常和中断的响应过程\"><a class=\"markdownIt-Anchor\" href=\"#异常和中断的响应过程\">#</a> 异常和中断的响应过程</h3>\n<ol>\n<li>关中断<br>\n保存断点和程序状态期间，把 IF 置 0 不允许响应中断</li>\n<li>保存断点和程序状态<br>\n将返回地址和被中断时的 PSW 送到栈或特定寄存器中（通常是栈，才能支持嵌套中断），处理完之后恢复</li>\n<li>识别异常和中断并转到相应的处理程序<br>\n异常大多采用软件识别，中断可以采用软件识别或硬件识别<br>\n软件识别：CPU 设置异常状态寄存器，操作系统使用查询程序按优先级顺序查询异常状态寄存器以检测类型并处理<br>\n硬件识别：向量中断。每个异常或中断被指定一个中断类型号，发生之后查询中断向量表，找到处理程序的入口地址（中断向量），并跳转到处理程序</li>\n</ol>\n<h2 id=\"指令流水线\"><a class=\"markdownIt-Anchor\" href=\"#指令流水线\">#</a> 指令流水线</h2>\n<ul>\n<li>Performance via parallelism</li>\n<li>Performance via pipelining</li>\n<li>Performance via prediction<br>\n 时间并行：流水线<br>\n空间并行：超标量</li>\n</ul>\n<h3 id=\"基本实现\"><a class=\"markdownIt-Anchor\" href=\"#基本实现\">#</a> 基本实现</h3>\n<p>单周期 CPU 以执行最慢的指令周期作为时钟周期。不能缩短单挑指令的执行时间，但可以提高整个程序的执行速度<br>\n每个流水段后面都要加一个流水段寄存器锁存数据，保证本段的执行结果能在下个周期给下一流水段使用。</p>\n<h3 id=\"hazard\"><a class=\"markdownIt-Anchor\" href=\"#hazard\">#</a> Hazard</h3>\n<ul>\n<li>结构冒险、数据冒险、控制冒险</li>\n</ul>\n<ol>\n<li>structural hazard<br>\n 在流水线执行期间，两条及以上指令同一时间对同一个硬件资源发起使用的请求（Memory conflicts, Register File conflicts, Other units conflicts）<br>\n解决方法：(1) stall (2) 增加更多的硬件支持单元（比如 Double Bump，前半周期写后半周期读）</li>\n<li>data hazard<br>\nRAW, WAR, WAW<br>\n 统考不考乱序执行所以只需要考虑 RAW 写后读<br>\n解决方法：(1) stall (2) NOP (3) forwarding</li>\n</ol>\n<ul>\n<li>stall<br>\n 硬件解决方法，流水线阻塞，使数据相关的后续指令延迟执行，也称为插入气泡（bubble）</li>\n<li>NOP<br>\n 软件解决方法，编译时插入空操作（NOP）比如 <code>addi x0,x0,0</code> ，使数据相关的后续指令延迟执行</li>\n<li>forwarding<br>\n 旁路转发，将数据通路生成的中间数据直接往前传递到 ALU 的输入端，参与下一条指令的运算<br>\n必须同时满足两个条件：</li>\n<li>指令确实会写入寄存器（通过检查 RegWrite 信号）。</li>\n<li>目标寄存器编号不是 x0（零寄存器不会变）<br>\n才需要 forwarding</li>\n</ul>\n<blockquote>\n<p>ALU-&gt;ALU<br>\n 数据可以从  <code>EX/MEM</code>  或  <code>MEM/WB</code>  阶段转发到当前在 EX 阶段的 ALU 输入<br>\n MEM-&gt;ALU<br>\nload 指令的数据只有在 <code>MEM/WB</code>  阶段才能被转发到当前在 EX 阶段的 ALU 输入，所以如果 load 下一条指令要用到 load 指令的数据，则需要先 stall 一周期再 forwarding</p>\n</blockquote>\n<ol start=\"3\">\n<li>control hazard<br>\n 解决方法：</li>\n</ol>\n<ul>\n<li>插入 3 条 <code>NOP</code>  直到分支指令的 <code>WB</code>  阶段才进行下一条指令的 <code>IF</code></li>\n<li>分支预测<br>\n<img data-src=\"f5.jpg\" alt></li>\n</ul>\n<h3 id=\"流水线的性能指标\"><a class=\"markdownIt-Anchor\" href=\"#流水线的性能指标\">#</a> 流水线的性能指标</h3>\n<ol>\n<li>吞吐率<br>\n单位时间内流水线所完成的任务数量</li>\n</ol>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>T</mi><mi>P</mi><mo>=</mo><mfrac><mi>n</mi><msub><mi>T</mi><mi>k</mi></msub></mfrac></mrow><annotation encoding=\"application/x-tex\">TP = \\frac{n}{T_k}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.9435600000000002em;vertical-align:-0.8360000000000001em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.10756em;\"><span style=\"top:-2.3139999999999996em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8360000000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p k+n-1>k 是流水线的段数，n 是任务数，Tk 是处理 n 个任务所用的总时间。理想状态下一条 k 段流水线能在 <code>k+n-1</code>  个时钟周期完成 <code>n</code>  个任务，吞吐率为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mi>n</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">Δ</mi><mi>t</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{n}{(k + n - 1) \\Delta t}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.215392em;vertical-align:-0.52em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.695392em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span><span class=\"mord mtight\">Δ</span><span class=\"mord mathnormal mtight\">t</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.52em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span><br>\n 2. 流水线的加速比<br>\n完成同一批任务，不适用流水线和使用流水线所用的时间之比<br>\n理想状态下流水线加速比为\\frac{k n}</p>\n<h3 id=\"高级流水线技术\"><a class=\"markdownIt-Anchor\" href=\"#高级流水线技术\">#</a> 高级流水线技术</h3>\n<ol>\n<li>超标量流水线<br>\n动态多发射技术，支持乱序执行</li>\n</ol>\n<ul>\n<li>Scoreboard<br>\n<img data-src=\"f3.jpg\" alt></li>\n<li>Tomasulo<br>\n<img data-src=\"f4.jpg\" alt></li>\n</ul>\n<ol start=\"2\">\n<li>超长指令字技术<br>\n静态多发射技术，将多条能并行操作的指令组合成一个超长指令字，需要多个处理不见</li>\n<li>超流水线技术<br>\n流水线功能段划分的越多，时钟周期越短，指令吞吐率越高。<br>\n超流水线技术通过提高流水线主频来提高性能，但是流水段越多中间寄存器的开销就越大</li>\n</ol>\n<blockquote>\n<p>超流水线或者理想状态下流水线技术 CPI=1；多发射流水线的 CPI 可以小于 1</p>\n</blockquote>\n<h2 id=\"多处理器\"><a class=\"markdownIt-Anchor\" href=\"#多处理器\">#</a> 多处理器</h2>\n<h3 id=\"sisd-simd-mimd\"><a class=\"markdownIt-Anchor\" href=\"#sisd-simd-mimd\">#</a> SISD SIMD MIMD</h3>\n<ol>\n<li>SISD: single instruction single data<br>\n 传统串行处理器</li>\n<li>SIMD: single instruction multiple data<br>\n 数据级并行技术 (DLP)，一条指令可以同时对多个数据元素执行相同的操作，用到向量寄存器<br>\n在处理 for 循环数组时最有效（比如两个数组相加）；在使用 case/seitch 时效率最低</li>\n<li>MISD: multiple instruction single data<br>\n 实际上不存在</li>\n<li>MIMD: multiple instruction multiple data<br>\nTLP<br>\n 分为多计算机系统和多处理器系统。<br>\n多计算机系统由多个独立的计算机节点组成，每个节点通常包含自己的存储器、CPU，具有独立的主存地址空间，通过消息传递进行数据传送，也称 <code>消息传递MIMD</code> <br>\n 多处理器系统是共享存储多处理器 <code>SMP</code>  系统的简称，共享单一地址空间，也称共享存储 MIMD<br>\n 向量处理器是 SIMD 的变体，实现了直接操作一维数组指令集</li>\n</ol>\n<h3 id=\"硬件多线程\"><a class=\"markdownIt-Anchor\" href=\"#硬件多线程\">#</a> 硬件多线程</h3>\n<ol>\n<li>细粒度多线程 Fine-grained multithreading<br>\n 多个线程交叉执行指令，线程之间的指令不相关，可以乱序并行执行，需要频繁进行上下文切换，不需要重载流水线。牺牲单个线程执行的性能，来换取整个进程吞吐量的提升</li>\n<li>粗粒度多线程 Coarse-grained multithreading<br>\n 连续几个时钟周期都执行同一线程的指令序列，尽在当前线程出现较大开销的阻塞才切换（比如 L2 miss, L2 miss）相比细粒度多线程，上下文切换的频率较低，切换时需要重载流水线</li>\n<li>同时多线程 SMT<br>\nILP+TLP，指令级并行的同时实现线程级并行，在同一个时钟周期发射多个不同线程中的多条指令执行<br>\n Intal 的 Hyper-threading 就是 SMT<br>\n<img data-src=\"f6.jpg\" alt></li>\n</ol>\n<h3 id=\"多核处理器\"><a class=\"markdownIt-Anchor\" href=\"#多核处理器\">#</a> 多核处理器</h3>\n<p>一个 CPU 有多个 core，也称片上多处理器<br>\n每个核既可以有自己的 Cache，又可以共享同一个 Cache，所有核共享主存储器<br>\n多核处理器必须采用多线程（或多进程）才能发挥性能</p>\n<h3 id=\"共享内存多处理器-smp\"><a class=\"markdownIt-Anchor\" href=\"#共享内存多处理器-smp\">#</a> 共享内存多处理器 SMP</h3>\n<p>处理器通过存储器中的共享变量互相通信，所有存储器都能通过存取指令访问存储器的任何位置，有两种：<br>\n<img data-src=\"f7.jpg\" alt></p>\n<ul>\n<li>UMA 统一存储访问多处理器<br>\n UMA 中所有处理器对所有内存模块的访问延迟是相同的，由于访问延迟一致，数据放在哪个内存模块上对性能影响不大。随着系统规模扩大，所有处理器都通过同一个前端总线访问内存，导致互连网络成为瓶颈，延迟增加，带宽受限<br>\n<img data-src=\"f8.jpg\" alt></li>\n<li>NUMA 非统一存储访问多处理器<br>\n内存有本地内存和远程内存，访问本地内存快。CPU 可以通过 QPI 总线访问远程内存<br>\n<img data-src=\"f9.jpg\" alt></li>\n<li>需要解决 Cache coherence 问题：Snooping (MSI, MESI, MOESI…), Directory<br>\n 基本思想都是对共享变量加锁，保证互斥访问\n<ul>\n<li>Snooping:<br>\n<img data-src=\"f10.jpg\" alt><br>\n<img data-src=\"f11.jpg\" alt></li>\n<li>Directory:<br>\n<img data-src=\"f12.jpg\" alt></li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "CPU"
            ]
        }
    ]
}