<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>NoResponse&#39;s Blog • Posts by &#34;liveness analysis&#34; tag</title>
        <link>http://example.com</link>
        <description>成分复杂的CSer from ZJU</description>
        <language>en</language>
        <pubDate>Wed, 18 Jun 2025 00:00:00 +0800</pubDate>
        <lastBuildDate>Wed, 18 Jun 2025 00:00:00 +0800</lastBuildDate>
        <category>软件工程</category>
        <category>人工智能</category>
        <category>计算机网络</category>
        <category>计算机组成</category>
        <category>数据的表示与运算</category>
        <category>存储系统</category>
        <category>总线</category>
        <category>CPU</category>
        <category>指令系统</category>
        <category>错题</category>
        <category>Liveness Analysis</category>
        <category>编译原理</category>
        <category>I/O</category>
        <category>词法分析</category>
        <category>Register Allocation</category>
        <category>抽象语法</category>
        <category>语法分析</category>
        <category>语义分析</category>
        <category>活动记录</category>
        <category>Basic Blocks and Traces</category>
        <category>中间代码</category>
        <category>指令选择</category>
        <item>
            <guid isPermalink="true">http://example.com/2025/06/18/computer-science/compile-principles/ch10/</guid>
            <title>Liveness Analysis</title>
            <link>http://example.com/2025/06/18/computer-science/compile-principles/ch10/</link>
            <category>Liveness Analysis</category>
            <pubDate>Wed, 18 Jun 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Liveness-Analysis-活跃变量分析&#34;&gt;&lt;a href=&#34;#Liveness-Analysis-活跃变量分析&#34; class=&#34;headerlink&#34; title=&#34;Liveness Analysis 活跃变量分析&#34;&gt;&lt;/a&gt;Liveness Analysis 活跃变量分析&lt;/h1&gt;&lt;p&gt;判断在程序执行的某个点上，一个变量的值是否可能在未来被使用，是寄存器分配、死代码消除的基础&lt;/p&gt;
&lt;h2 id=&#34;Compiler-Optimizations&#34;&gt;&lt;a href=&#34;#Compiler-Optimizations&#34; class=&#34;headerlink&#34; title=&#34;Compiler Optimizations&#34;&gt;&lt;/a&gt;Compiler Optimizations&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Local: 基于basic blocks&lt;/li&gt;
&lt;li&gt;Intraprocedural (or “global’): 基本块的控制流转移&lt;/li&gt;
&lt;li&gt;Interprocedural (or “whole-program”): Operate on &amp;gt; 1 procedure, up to whole program; Sometimes, at link time (LTO, link time optimization)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Analyze program to gather “facts”&lt;/li&gt;
&lt;li&gt;Apply transformation (e.g., optimizations)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Dataflow-Analysis&#34;&gt;&lt;a href=&#34;#Dataflow-Analysis&#34; class=&#34;headerlink&#34; title=&#34;Dataflow Analysis&#34;&gt;&lt;/a&gt;Dataflow Analysis&lt;/h2&gt;&lt;p&gt;Control Flow Graph: A directed graph 数据流图&lt;br&gt;– Nodes represent statements&lt;br&gt;– Edges represent control flow&lt;/p&gt;
&lt;p&gt;CFG的简化：基本块&lt;br&gt;&lt;img data-src=&#34;/f1.jpg&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;变量的活跃性：&#34;&gt;&lt;a href=&#34;#变量的活跃性：&#34; class=&#34;headerlink&#34; title=&#34;变量的活跃性：&#34;&gt;&lt;/a&gt;变量的活跃性：&lt;/h3&gt;&lt;p&gt;变量x在语句s处（执行s之前）处于活动状态，当且仅当满足以下三个条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;存在一个使用x的语句s’；&lt;/li&gt;
&lt;li&gt;存在从s到s’的路径；&lt;/li&gt;
&lt;li&gt;这条路径上没有对x进行任何赋值操作&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过分析liveness，我们可以实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Register Allocation&lt;/li&gt;
&lt;li&gt;Code Optimizations：Remove unused assignments&lt;/li&gt;
&lt;li&gt;IR Construction： Optimize the construction of SSA&lt;/li&gt;
&lt;li&gt;Security&amp;#x2F;Reliability: Detect the use of uninitialized variables&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;Dataflow-Equations-for-Liveness-构建数据流方程&#34;&gt;&lt;a href=&#34;#Dataflow-Equations-for-Liveness-构建数据流方程&#34; class=&#34;headerlink&#34; title=&#34;Dataflow Equations for Liveness 构建数据流方程&#34;&gt;&lt;/a&gt;Dataflow Equations for Liveness 构建数据流方程&lt;/h2&gt;&lt;p&gt;A CFG node has&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;out-edges: lead to successor nodes&lt;/li&gt;
&lt;li&gt;in-edges: come from predecessor nodes&lt;/li&gt;
&lt;li&gt;pred[n]: the predecessors of node n       前驱&lt;/li&gt;
&lt;li&gt;succ[n]: the successors of node n     后继&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;几个定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;use[n]: 在节点n被读取或使用(x &amp;#x3D; a + b的a和b, if(a &amp;lt; b)的a和b, return c的c)&lt;/li&gt;
&lt;li&gt;def[n]: 在节点n被定义(x &amp;#x3D; a + b的x)&lt;/li&gt;
&lt;li&gt;in[n]: 在节点n之前，所有活跃变量的集合&lt;/li&gt;
&lt;li&gt;out[n]: 在节点n之后，所有活跃变量的集合&lt;br&gt;三条活跃性规则：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;if $a \in in[n]$ then for $\all m \in pred[n]$ we have $a \in out[m]$&lt;/li&gt;
&lt;li&gt;if $a \in use[n]$ then $a \in in[n]$&lt;/li&gt;
&lt;li&gt;if $a \in out[n]$ and $a \notin def[n]$ then $a \in in[n]$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;得到以下两个数据流方程：&lt;br&gt;$$&lt;br&gt;out[n] &amp;#x3D; \cup_{s \in succ[n]} in[s]&lt;br&gt;$$&lt;br&gt; 一个节点在n的出口处活跃当且仅当在它后继的入口处是活跃的（活跃性的反向传播）&lt;br&gt;$$&lt;br&gt;in[n] &amp;#x3D; use[n] \cup (out[n] - def[n])&lt;br&gt;$$&lt;/p&gt;
&lt;h2 id=&#34;求解数据流方程&#34;&gt;&lt;a href=&#34;#求解数据流方程&#34; class=&#34;headerlink&#34; title=&#34;求解数据流方程&#34;&gt;&lt;/a&gt;求解数据流方程&lt;/h2&gt;&lt;p&gt;有了上面的两个数据流方程，就可以求解数据流方程了&lt;br&gt;算法：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;figcaption&gt;&lt;span&gt;pseudo&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;for each n&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    in[n] ←&amp;#123;&amp;#125;; out[n] ←&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;repeat&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    for each n&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        in′[n] ← in[n]; out′[n] ← out[n]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        in[n] ← use[n] ∪ (out[n] − def[n])&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        out[n] ← ⋃( ∈()**[+] in[s]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;until in′[n] = in[n] and out′[n] = out[n] for all n&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;将所有节点的 &lt;code&gt;in&lt;/code&gt; 和 &lt;code&gt;out&lt;/code&gt; 集合初始化为空集。&lt;/li&gt;
&lt;li&gt;写出&lt;code&gt;use[n]&lt;/code&gt;和&lt;code&gt;def[n]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用数据流方程更新&lt;code&gt;in&lt;/code&gt;和&lt;code&gt;out&lt;/code&gt;集合&lt;/li&gt;
&lt;li&gt;直到&lt;code&gt;in&lt;/code&gt;和&lt;code&gt;out&lt;/code&gt;集合不再改变为止&lt;br&gt;例：&lt;br&gt;&lt;img data-src=&#34;/f2.jpg&#34;&gt;&lt;br&gt;对于这个CFG&lt;br&gt;每一次迭代如图：&lt;br&gt;&lt;img data-src=&#34;/f3.jpg&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;Improvements&#34;&gt;&lt;a href=&#34;#Improvements&#34; class=&#34;headerlink&#34; title=&#34;Improvements&#34;&gt;&lt;/a&gt;Improvements&lt;/h2&gt;&lt;h3 id=&#34;Use-Basic-Block&#34;&gt;&lt;a href=&#34;#Use-Basic-Block&#34; class=&#34;headerlink&#34; title=&#34;Use Basic Block&#34;&gt;&lt;/a&gt;Use Basic Block&lt;/h3&gt;&lt;p&gt;后面有点懒得看，先放着&lt;/p&gt;
&lt;h2 id=&#34;集合的表示方法&#34;&gt;&lt;a href=&#34;#集合的表示方法&#34; class=&#34;headerlink&#34; title=&#34;集合的表示方法&#34;&gt;&lt;/a&gt;集合的表示方法&lt;/h2&gt;&lt;p&gt;对于in, out, use, def集合的表示和操作对性能有很大影响&lt;/p&gt;
&lt;h3 id=&#34;Bit-Arrays&#34;&gt;&lt;a href=&#34;#Bit-Arrays&#34; class=&#34;headerlink&#34; title=&#34;Bit Arrays&#34;&gt;&lt;/a&gt;Bit Arrays&lt;/h3&gt;&lt;p&gt;有点像bit map，适用于稠密集合（1比较多的，如果0太多就浪费了）&lt;/p&gt;
&lt;h3 id=&#34;Sorted-Lists&#34;&gt;&lt;a href=&#34;#Sorted-Lists&#34; class=&#34;headerlink&#34; title=&#34;Sorted Lists&#34;&gt;&lt;/a&gt;Sorted Lists&lt;/h3&gt;&lt;p&gt;适合稀疏集合（用一个链表存集合中的变量, Sorted by variable name&amp;#x2F;ID）&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
