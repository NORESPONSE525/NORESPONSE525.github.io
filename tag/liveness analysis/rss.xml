<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>NoResponse&#39;s Blog • Posts by &#34;liveness analysis&#34; tag</title>
        <link>http://example.com</link>
        <description>成分复杂的CSer from ZJU</description>
        <language>en</language>
        <pubDate>Wed, 18 Jun 2025 00:00:00 +0800</pubDate>
        <lastBuildDate>Wed, 18 Jun 2025 00:00:00 +0800</lastBuildDate>
        <category>人工智能</category>
        <category>编译原理</category>
        <category>Liveness Analysis</category>
        <category>词法分析</category>
        <category>抽象语法</category>
        <category>活动记录</category>
        <category>语义分析</category>
        <category>中间代码</category>
        <category>指令选择</category>
        <category>语法分析</category>
        <category>计算机网络</category>
        <category>计算机组成</category>
        <category>Basic Blocks and Traces</category>
        <category>数据的表示与运算</category>
        <item>
            <guid isPermalink="true">http://example.com/2025/06/18/computer-science/compile-principles/ch10/</guid>
            <title>Ch10</title>
            <link>http://example.com/2025/06/18/computer-science/compile-principles/ch10/</link>
            <category>Liveness Analysis</category>
            <pubDate>Wed, 18 Jun 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;liveness-analysis-活跃变量分析&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#liveness-analysis-活跃变量分析&#34;&gt;#&lt;/a&gt; Liveness Analysis 活跃变量分析&lt;/h1&gt;
&lt;p&gt;判断在程序执行的某个点上，一个变量的值是否可能在未来被使用，是寄存器分配、死代码消除的基础&lt;/p&gt;
&lt;h2 id=&#34;compiler-optimizations&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#compiler-optimizations&#34;&gt;#&lt;/a&gt; Compiler Optimizations&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Local: 基于 basic blocks&lt;/li&gt;
&lt;li&gt;Intraprocedural (or “global’): 基本块的控制流转移&lt;/li&gt;
&lt;li&gt;Interprocedural (or “whole-program”): Operate on &amp;gt; 1 procedure, up to whole program; Sometimes, at link time (LTO, link time optimization)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Analyze program to gather “facts”&lt;/li&gt;
&lt;li&gt;Apply transformation (e.g., optimizations)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dataflow-analysis&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#dataflow-analysis&#34;&gt;#&lt;/a&gt; Dataflow Analysis&lt;/h2&gt;
&lt;p&gt;Control Flow Graph: A directed graph 数据流图&lt;br&gt;
– Nodes represent statements&lt;br&gt;
– Edges represent control flow&lt;/p&gt;
&lt;p&gt;CFG 的简化：基本块&lt;br&gt;
&lt;img data-src=&#34;f1.jpg&#34; alt&gt;&lt;/p&gt;
&lt;h3 id=&#34;变量的活跃性&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#变量的活跃性&#34;&gt;#&lt;/a&gt; 变量的活跃性：&lt;/h3&gt;
&lt;p&gt;变量 x 在语句 s 处（执行 s 之前）处于活动状态，当且仅当满足以下三个条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;存在一个使用 x 的语句 s’；&lt;/li&gt;
&lt;li&gt;存在从 s 到 s’的路径；&lt;/li&gt;
&lt;li&gt;这条路径上没有对 x 进行任何赋值操作&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过分析 liveness，我们可以实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Register Allocation&lt;/li&gt;
&lt;li&gt;Code Optimizations：Remove unused assignments&lt;/li&gt;
&lt;li&gt;IR Construction： Optimize the construction of SSA&lt;/li&gt;
&lt;li&gt;Security/Reliability: Detect the use of uninitialized variables&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;dataflow-equations-for-liveness-构建数据流方程&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#dataflow-equations-for-liveness-构建数据流方程&#34;&gt;#&lt;/a&gt; Dataflow Equations for Liveness 构建数据流方程&lt;/h2&gt;
&lt;p&gt;A CFG node has&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;out-edges: lead to successor nodes&lt;/li&gt;
&lt;li&gt;in-edges: come from predecessor nodes&lt;/li&gt;
&lt;li&gt;pred [n]: the predecessors of node n       前驱&lt;/li&gt;
&lt;li&gt;succ [n]: the successors of node n     后继&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
    </channel>
</rss>
