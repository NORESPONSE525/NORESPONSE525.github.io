{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog • All posts by \"liveness analysis\" tag",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/06/18/computer-science/compile-principles/ch10/",
            "url": "http://example.com/2025/06/18/computer-science/compile-principles/ch10/",
            "title": "Ch10",
            "date_published": "2025-06-17T16:00:00.000Z",
            "content_html": "<h1 id=\"Liveness-Analysis-活跃变量分析\"><a href=\"#Liveness-Analysis-活跃变量分析\" class=\"headerlink\" title=\"Liveness Analysis 活跃变量分析\"></a>Liveness Analysis 活跃变量分析</h1><p>判断在程序执行的某个点上，一个变量的值是否可能在未来被使用，是寄存器分配、死代码消除的基础</p>\n<h2 id=\"Compiler-Optimizations\"><a href=\"#Compiler-Optimizations\" class=\"headerlink\" title=\"Compiler Optimizations\"></a>Compiler Optimizations</h2><ul>\n<li>Local: 基于basic blocks</li>\n<li>Intraprocedural (or “global’): 基本块的控制流转移</li>\n<li>Interprocedural (or “whole-program”): Operate on &gt; 1 procedure, up to whole program; Sometimes, at link time (LTO, link time optimization)</li>\n</ul>\n<p>两步：</p>\n<ul>\n<li>Analyze program to gather “facts”</li>\n<li>Apply transformation (e.g., optimizations)</li>\n</ul>\n<h2 id=\"Dataflow-Analysis\"><a href=\"#Dataflow-Analysis\" class=\"headerlink\" title=\"Dataflow Analysis\"></a>Dataflow Analysis</h2><p>Control Flow Graph: A directed graph 数据流图<br>– Nodes represent statements<br>– Edges represent control flow</p>\n<p>CFG的简化：基本块<br><img data-src=\"/f1.jpg\"></p>\n<h3 id=\"变量的活跃性：\"><a href=\"#变量的活跃性：\" class=\"headerlink\" title=\"变量的活跃性：\"></a>变量的活跃性：</h3><p>变量x在语句s处（执行s之前）处于活动状态，当且仅当满足以下三个条件：</p>\n<ol>\n<li>存在一个使用x的语句s’；</li>\n<li>存在从s到s’的路径；</li>\n<li>这条路径上没有对x进行任何赋值操作</li>\n</ol>\n<p>通过分析liveness，我们可以实现：</p>\n<ol>\n<li>Register Allocation</li>\n<li>Code Optimizations：Remove unused assignments</li>\n<li>IR Construction： Optimize the construction of SSA</li>\n<li>Security&#x2F;Reliability: Detect the use of uninitialized variables</li>\n</ol>\n<h2 id=\"Dataflow-Equations-for-Liveness-构建数据流方程\"><a href=\"#Dataflow-Equations-for-Liveness-构建数据流方程\" class=\"headerlink\" title=\"Dataflow Equations for Liveness 构建数据流方程\"></a>Dataflow Equations for Liveness 构建数据流方程</h2><p>A CFG node has</p>\n<ul>\n<li>out-edges: lead to successor nodes</li>\n<li>in-edges: come from predecessor nodes</li>\n<li>pred[n]: the predecessors of node n       前驱</li>\n<li>succ[n]: the successors of node n     后继</li>\n</ul>\n<p>几个定义：</p>\n<ul>\n<li>use[n]: 在节点n被读取或使用(x &#x3D; a + b的a和b, if(a &lt; b)的a和b, return c的c)</li>\n<li>def[n]: 在节点n被定义(x &#x3D; a + b的x)</li>\n<li>in[n]: 在节点n之前，所有活跃变量的集合</li>\n<li>out[n]: 在节点n之后，所有活跃变量的集合<br>三条活跃性规则：</li>\n</ul>\n<ol>\n<li>if $a \\in in[n]$ then for $\\all m \\in pred[n]$ we have $a \\in out[m]$</li>\n<li>if $a \\in use[n]$ then $a \\in in[n]$</li>\n<li>if $a \\in out[n]$ and $a \\notin def[n]$ then $a \\in in[n]$</li>\n</ol>\n<p>得到以下两个数据流方程：</p>\n<ul>\n<li>$$out[n] &#x3D; \\cup_{s \\in succ[n]} in[s]$$<br> 一个节点在n的出口处活跃当且仅当在它后继的入口处是活跃的（活跃性的反向传播）</li>\n<li>$$in[n] &#x3D; use[n] \\cup (out[n] - def[n])$$</li>\n</ul>\n<h2 id=\"求解数据流方程\"><a href=\"#求解数据流方程\" class=\"headerlink\" title=\"求解数据流方程\"></a>求解数据流方程</h2><p>有了上面的两个数据流方程，就可以求解数据流方程了<br>算法：</p>\n<figure class=\"highlight plaintext\"><figcaption><span>pseudo</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for each n</span><br><span class=\"line\">    in[n] ←&#123;&#125;; out[n] ←&#123;&#125;</span><br><span class=\"line\">repeat</span><br><span class=\"line\">    for each n</span><br><span class=\"line\">        in′[n] ← in[n]; out′[n] ← out[n]</span><br><span class=\"line\">        in[n] ← use[n] ∪ (out[n] − def[n])</span><br><span class=\"line\">        out[n] ← ⋃( ∈()**[+] in[s]</span><br><span class=\"line\">until in′[n] = in[n] and out′[n] = out[n] for all n</span><br></pre></td></tr></table></figure>\n<ol>\n<li>将所有节点的 <code>in</code> 和 <code>out</code> 集合初始化为空集。</li>\n<li>写出<code>use[n]</code>和<code>def[n]</code></li>\n<li>用数据流方程更新<code>in</code>和<code>out</code>集合</li>\n<li>直到<code>in</code>和<code>out</code>集合不再改变为止<br>例：<br><img data-src=\"/f2.jpg\"><br>对于这个CFG<br>每一次迭代如图：<br><img data-src=\"/f3.jpg\"></li>\n</ol>\n<h2 id=\"Improvements\"><a href=\"#Improvements\" class=\"headerlink\" title=\"Improvements\"></a>Improvements</h2><h3 id=\"Use-Basic-Block\"><a href=\"#Use-Basic-Block\" class=\"headerlink\" title=\"Use Basic Block\"></a>Use Basic Block</h3><p>后面有点懒得看，先放着</p>\n<h2 id=\"集合的表示方法\"><a href=\"#集合的表示方法\" class=\"headerlink\" title=\"集合的表示方法\"></a>集合的表示方法</h2><p>对于in, out, use, def集合的表示和操作对性能有很大影响</p>\n<h3 id=\"Bit-Arrays\"><a href=\"#Bit-Arrays\" class=\"headerlink\" title=\"Bit Arrays\"></a>Bit Arrays</h3><p>有点像bit map，适用于稠密集合（1比较多的，如果0太多就浪费了）</p>\n<h3 id=\"Sorted-Lists\"><a href=\"#Sorted-Lists\" class=\"headerlink\" title=\"Sorted Lists\"></a>Sorted Lists</h3><p>适合稀疏集合（用一个链表存集合中的变量, Sorted by variable name&#x2F;ID）</p>\n",
            "tags": [
                "Liveness Analysis"
            ]
        }
    ]
}