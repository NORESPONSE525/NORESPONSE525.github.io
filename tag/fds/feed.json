{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog • All posts by \"fds\" tag",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/10/31/computer-science/DS/fds/",
            "url": "http://example.com/2023/10/31/computer-science/DS/fds/",
            "title": "fds课程笔记",
            "date_published": "2023-10-30T16:00:00.000Z",
            "content_html": "<h1 id=\"FDS复习\"><a href=\"#FDS复习\" class=\"headerlink\" title=\"FDS复习\"></a>FDS复习</h1><h2 id=\"期中模拟卷\"><a href=\"#期中模拟卷\" class=\"headerlink\" title=\"期中模拟卷\"></a>期中模拟卷</h2><h5 id=\"1-sqrt-N-logN-is-O-N\"><a href=\"#1-sqrt-N-logN-is-O-N\" class=\"headerlink\" title=\"1.$\\sqrt N logN$ is $O(N)$.\"></a>1.$\\sqrt N logN$ is $O(N)$.</h5><p>T</p>\n<h5 id=\"2-In-Union-Find-algorithm-if-Unions-are-done-by-size-the-depth-of-any-node-must-be-no-more-than-N-2-but-not-O-logN\"><a href=\"#2-In-Union-Find-algorithm-if-Unions-are-done-by-size-the-depth-of-any-node-must-be-no-more-than-N-2-but-not-O-logN\" class=\"headerlink\" title=\"2.In Union&#x2F;Find algorithm, if Unions are done by size, the depth of any node must be no more than N&#x2F;2 , but not $O(logN)$.\"></a>2.In <em>Union&#x2F;Find</em> algorithm, if <em>Unions</em> are done by size, the depth of any node must be no more than N&#x2F;2 , but not $O(logN)$.</h5><p>F</p>\n<p>每做一次归并，都会使得小的集合深度加1，但是总的深度还是看大的集合。只有深度相同的归并才能使得总的深度加1，2,2归并，深度变为3；3,3归并深度变为4。因此深度最大为**$log_2 N+1$**.</p>\n<h5 id=\"3-For-a-sequentially-stored-linear-list-of-length-N-the-time-complexities-for-query-and-insertion-are\"><a href=\"#3-For-a-sequentially-stored-linear-list-of-length-N-the-time-complexities-for-query-and-insertion-are\" class=\"headerlink\" title=\"3.For a sequentially stored linear list of length N, the time complexities for query and insertion are:\"></a>3.For a <code>sequentially stored</code> linear list of length <em>N</em>, the time complexities for query and insertion are:</h5><p>C.$O(1)$,$O(N)$.</p>\n<p>注意是顺序存储，因此查询只需要$O(1)$, 插入需要调整后面的元素的位置，因此是$O(N)$.</p>\n<h5 id=\"4-The-following-figure-shows-the-AOE-network-of-a-project-with-8-activities-The-earliest-and-the-latest-start-times-of-the-activity-d-are-respectively\"><a href=\"#4-The-following-figure-shows-the-AOE-network-of-a-project-with-8-activities-The-earliest-and-the-latest-start-times-of-the-activity-d-are-respectively\" class=\"headerlink\" title=\"4.The following figure shows the AOE network of a project with 8 activities. The earliest and the latest start times of the activity d are __, respectively.\"></a>4.The following figure shows the AOE network of a project with 8 activities. The earliest and the latest start times of the activity <code>d</code> are __, respectively.</h5><p><img data-src=\"https://images.ptausercontent.com/28de33de-076f-4f94-b856-445865994fb0.jpg\" alt=\"GRE19-5.jpg\"></p>\n<p>还没学，下次再来补</p>\n<h5 id=\"5-If-besides-finding-the-shortest-path-from-S-to-every-other-vertices-we-also-need-to-count-the-number-of-different-shortest-paths-we-can-modify-the-Dijkstra-algorithm-in-the-following-way-add-an-array-count-so-that-count-V-records-the-number-of-different-shortest-paths-from-S-to-V-Then-count-V-shall-be-initialized-as\"><a href=\"#5-If-besides-finding-the-shortest-path-from-S-to-every-other-vertices-we-also-need-to-count-the-number-of-different-shortest-paths-we-can-modify-the-Dijkstra-algorithm-in-the-following-way-add-an-array-count-so-that-count-V-records-the-number-of-different-shortest-paths-from-S-to-V-Then-count-V-shall-be-initialized-as\" class=\"headerlink\" title=\"5.If besides finding the shortest path from S to every other vertices, we also need to count the number of different shortest paths, we can modify the Dijkstra algorithm in the following way: add an array count[] so that count[V] records the number of different shortest paths from S to V. Then count[V] shall be initialized as:\"></a>5.If besides finding the shortest path from <code>S</code> to every other vertices, we also need to count the number of different shortest paths, we can modify the Dijkstra algorithm in the following way: add an array <code>count[]</code> so that <code>count[V]</code> records the number of different shortest paths from <code>S</code> to <code>V</code>. Then <code>count[V]</code> shall be initialized as:</h5><p>A. count[S]&#x3D;1; and count[V]&#x3D;0 for other V</p>\n<p>还没学应该不考，下次再来补</p>\n<h5 id=\"6-程序填空题-Reverse-Linked-List\"><a href=\"#6-程序填空题-Reverse-Linked-List\" class=\"headerlink\" title=\"6.程序填空题  Reverse Linked List\"></a>6.程序填空题  Reverse Linked List</h5><p>The function is to return the reverse linked list of <code>L</code>, with a dummy head.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List <span class=\"title function_\">Reverse</span><span class=\"params\">( List L )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Position Old_head, New_head, Temp;</span><br><span class=\"line\">    New_head = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    Old_head = L-&gt;Next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( Old_head )  &#123;</span><br><span class=\"line\">        Temp = Old_head-&gt;Next;</span><br><span class=\"line\">        Old_head-&gt;Next = New_head;</span><br><span class=\"line\">        New_head = Old_head;  </span><br><span class=\"line\">        Old_head = Temp; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    L-&gt;Next = New_head;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>先把下一个节点用temp存起来，然后把当前节点指向上一个节点，然后移动上一个节点的指针到当前节点，把当前节点指针移动到下一节点。</p>\n<h5 id=\"7-程序填空题-MinHeap-Deletion\"><a href=\"#7-程序填空题-MinHeap-Deletion\" class=\"headerlink\" title=\"7.程序填空题  MinHeap Deletion\"></a>7.程序填空题  MinHeap Deletion</h5><p>Please fill in the blanks in the program which deletes a given element at position <code>p</code> from a min-heap <code>H</code>.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Deletion ( PriorityQueue H,  <span class=\"type\">int</span> p )  <span class=\"comment\">/* delete the element H-&gt;Elements[p] */</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   ElementType temp;</span><br><span class=\"line\">   <span class=\"type\">int</span> child;</span><br><span class=\"line\"></span><br><span class=\"line\">   temp = H-&gt; Elements[ H-&gt;Size-- ];</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( temp &lt; H-&gt;Elements[p] ) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> ( (p != <span class=\"number\">1</span>) &amp;&amp; (temp &lt; H-&gt;Elements[p/<span class=\"number\">2</span>]) ) &#123; </span><br><span class=\"line\">         H-&gt;Elements[p] = H-&gt;Elements[p/<span class=\"number\">2</span>]；</span><br><span class=\"line\">         p /= <span class=\"number\">2</span>;</span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">while</span>( (child = <span class=\"number\">2</span>*p) &lt;= H-&gt;Size) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> ( child != H-&gt;Size &amp;&amp; H-&gt;Elements[child] &lt; H-&gt;Elements[child + <span class=\"number\">1</span>] )</span><br><span class=\"line\">            child ++;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> ( temp &gt; H-&gt;Elements[child] ) &#123;</span><br><span class=\"line\">            H-&gt;Elements[p] = H-&gt;Elements[child];</span><br><span class=\"line\">            p = child;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   H-&gt;Elements[p] = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"HW1\"><a href=\"#HW1\" class=\"headerlink\" title=\"HW1\"></a>HW1</h2><h5 id=\"1-2-The-Fibonacci-number-sequence-F-N-is-defined-as-F-0-0-F-1-1-F-N-F-N-1-F-N-2-N-2-3-…-The-time-complexity-of-the-function-which-calculates-F-N-recursively-is-Theta-N\"><a href=\"#1-2-The-Fibonacci-number-sequence-F-N-is-defined-as-F-0-0-F-1-1-F-N-F-N-1-F-N-2-N-2-3-…-The-time-complexity-of-the-function-which-calculates-F-N-recursively-is-Theta-N\" class=\"headerlink\" title=\"1-2 The Fibonacci number sequence {$F_N$} is defined as: $F_0&#x3D;0,F_1&#x3D;1,$ $F_N&#x3D;F_{N-1}+F_{N-2}$, N&#x3D;2, 3, …. The time complexity of the function which calculates $F_N$ recursively is $\\Theta(N!)$.\"></a>1-2 The Fibonacci number sequence {$F_N$} is defined as: $F_0&#x3D;0,F_1&#x3D;1,$ $F_N&#x3D;F_{N-1}+F_{N-2}$, <em>N</em>&#x3D;2, 3, …. The time complexity of the function which calculates $F_N$ recursively is $\\Theta(N!)$.</h5><p>F</p>\n<p>递归求斐波那契数的时间复杂度是$O(2^N)$.</p>\n<p>二叉树的高度是 n-1，一个高度为k的二叉树最多可以由 $2^k-1$个叶子节点，也就是递归过程函数调用的次数，所以时间复杂度为 $O(2^N)$，而空间复杂度就是树的高度 $S(N)$.</p>\n<h5 id=\"2-1-Given-the-following-four-algorithms-with-their-runtimes-for-problem-size-100-and-their-time-complexities\"><a href=\"#2-1-Given-the-following-four-algorithms-with-their-runtimes-for-problem-size-100-and-their-time-complexities\" class=\"headerlink\" title=\"2-1 Given the following four algorithms with their runtimes for problem size 100 and their time complexities:\"></a>2-1 Given the following four algorithms with their runtimes for problem size 100 and their time complexities:</h5><table>\n<thead>\n<tr>\n<th>Algorithm</th>\n<th>Runtime</th>\n<th>Time Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>A</td>\n<td>100</td>\n<td>$O(N)$</td>\n</tr>\n<tr>\n<td>B</td>\n<td>50</td>\n<td>$O(N^2)$</td>\n</tr>\n<tr>\n<td>C</td>\n<td>2</td>\n<td>$O(N^3)$</td>\n</tr>\n<tr>\n<td>D</td>\n<td>10</td>\n<td>$O(N^4)$</td>\n</tr>\n</tbody></table>\n<p><strong>Which algorithm is the fastest for problem size 200?</strong></p>\n<p>D</p>\n<p>200 &#x3D; 100*2</p>\n<p>A 100*2 &#x3D; 200</p>\n<p>B 50 * $2^2$&#x3D;200</p>\n<p>C 25*$2^3$&#x3D;200</p>\n<p>&#x3D;&#x3D;D 10*$2^4$&#x3D;160 最快&#x3D;&#x3D;</p>\n<h5 id=\"2-3-The-recurrent-equations-for-the-time-complexities-of-programs-P1-and-P2-are\"><a href=\"#2-3-The-recurrent-equations-for-the-time-complexities-of-programs-P1-and-P2-are\" class=\"headerlink\" title=\"2-3 The recurrent equations for the time complexities of programs P1 and P2 are:\"></a>2-3 The recurrent equations for the time complexities of programs P1 and P2 are:</h5><ul>\n<li>P1: <em>T</em>(1)&#x3D;1,<em>T</em>(<em>N</em>)&#x3D;<em>T</em>(<em>N</em>&#x2F;3)+1</li>\n<li>P2: <em>T</em>(1)&#x3D;1,<em>T</em>(<em>N</em>)&#x3D;3<em>T</em>(<em>N</em>&#x2F;3)+1</li>\n</ul>\n<p>Then the correct conclusion about their time complexities is:</p>\n<p>A.they are both <em>O</em>(log<em>N</em>)</p>\n<p>B.O*(log*N) for P1, <em>O</em>(<em>N</em>) for P2</p>\n<p>C.they are both <em>O</em>(<em>N</em>)</p>\n<p>D.<em>O</em>(log<em>N</em>) for P1, <em>O</em>(<em>N</em>log<em>N</em>) for P2</p>\n<p><strong>B</strong></p>\n<p>$T(N)&#x3D;T(N&#x2F;3)+1&#x3D;T(N&#x2F;3&#x2F;3)+1+1&#x3D;…&#x3D;O(logN)$</p>\n<p>$T(N)&#x3D;3T(N&#x2F;3)+1&#x3D;3(3T(N&#x2F;3&#x2F;3)+1)+1&#x3D;…&#x3D;3^{log_3N}&#x3D;O(N)$</p>\n<h5 id=\"R1-2-logN-2-is-O-N\"><a href=\"#R1-2-logN-2-is-O-N\" class=\"headerlink\" title=\"R1-2 $(logN)^2$is $O(N)$.\"></a>R1-2 $(logN)^2$is $O(N)$.</h5><p>T</p>\n<p>记住即可</p>\n<h5 id=\"R1-3-The-time-comlexity-of-Selection-Sort-will-be-the-same-no-matter-we-store-the-elements-in-an-array-or-a-linked-list\"><a href=\"#R1-3-The-time-comlexity-of-Selection-Sort-will-be-the-same-no-matter-we-store-the-elements-in-an-array-or-a-linked-list\" class=\"headerlink\" title=\"R1-3 The time comlexity of Selection Sort will be the same no matter we store the elements in an array or a linked list.\"></a>R1-3 The time comlexity of Selection Sort will be the same no matter we store the elements in an array or a linked list.</h5><p>T</p>\n<h2 id=\"HW2\"><a href=\"#HW2\" class=\"headerlink\" title=\"HW2\"></a>HW2</h2><h5 id=\"1-1-For-a-sequentially-stored-linear-list-of-length-N-the-time-complexities-for-deleting-the-first-element-and-inserting-the-last-element-are-O-1-and-O-N-respectively\"><a href=\"#1-1-For-a-sequentially-stored-linear-list-of-length-N-the-time-complexities-for-deleting-the-first-element-and-inserting-the-last-element-are-O-1-and-O-N-respectively\" class=\"headerlink\" title=\"1-1 For a sequentially stored linear list of length N, the time complexities for deleting the first element and inserting the last element are O(1) and O(N), respectively.\"></a>1-1 For a <code>sequentially stored</code> linear list of length <em>N</em>, the time complexities for deleting the first element and inserting the last element are <em>O</em>(1) and <em>O</em>(<em>N</em>), respectively.</h5><p>F</p>\n<p>注意是顺序存储的。删除第一个节点需要把后面的都往前移动一个位置，所以是$O(N)$，插入最后一个节点是$O(1)$。</p>\n<p>对于顺序存储的长度为N的线性表，访问节点的时间复杂度是$O(1)$（线性存储，直接按标号访问就可以了），插入的时间复杂度是$O(N)$（要调整后面的元素的位置）。</p>\n<h5 id=\"2-3-To-merge-two-singly-linked-ascending-lists-both-with-N-nodes-into-one-singly-linked-ascending-list-the-minimum-possible-number-of-comparisons-is\"><a href=\"#2-3-To-merge-two-singly-linked-ascending-lists-both-with-N-nodes-into-one-singly-linked-ascending-list-the-minimum-possible-number-of-comparisons-is\" class=\"headerlink\" title=\"2-3 To merge two singly linked ascending lists, both with N nodes, into one singly linked ascending list, the minimum possible number of comparisons is:\"></a>2-3 To merge two singly linked ascending lists, both with <em>N</em> nodes, into one singly linked ascending list, the minimum possible number of comparisons is:</h5><p>B.$N$</p>\n<p>最少比较的次数就是第一个链表的每个节点都和第二个链表的头节点比较一次，所以是N</p>\n<h4 id=\"函数题\"><a href=\"#函数题\" class=\"headerlink\" title=\"函数题\"></a>函数题</h4><h5 id=\"6-1-Add-Two-Polynomials\"><a href=\"#6-1-Add-Two-Polynomials\" class=\"headerlink\" title=\"6-1 Add Two Polynomials\"></a>6-1 Add Two Polynomials</h5><p>Write a function to add two polynomials. Do not destroy the input. Use a linked list implementation with a dummy head node.<br>Note: The zero polynomial is represented by an empty list with only the dummy head node.</p>\n<h3 id=\"Format-of-functions\"><a href=\"#Format-of-functions\" class=\"headerlink\" title=\"Format of functions:\"></a>Format of functions:</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Polynomial <span class=\"title function_\">Add</span><span class=\"params\">( Polynomial a, Polynomial b )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>where <code>Polynomial</code> is defined as the following:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> *<span class=\"title\">PtrToNode</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> Coefficient;</span><br><span class=\"line\">    <span class=\"type\">int</span> Exponent;</span><br><span class=\"line\">    PtrToNode Next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToNode Polynomial;</span><br><span class=\"line\"><span class=\"comment\">/* Nodes are sorted in decreasing order of exponents.*/</span>  </span><br></pre></td></tr></table></figure>\n\n<p>The function <code>Add</code> is supposed to return a polynomial which is the sum of <code>a</code> and <code>b</code>.</p>\n<h3 id=\"Sample-program-of-judge\"><a href=\"#Sample-program-of-judge\" class=\"headerlink\" title=\"Sample program of judge:\"></a>Sample program of judge:</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> *<span class=\"title\">PtrToNode</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>  &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> Coefficient;</span><br><span class=\"line\">    <span class=\"type\">int</span> Exponent;</span><br><span class=\"line\">    PtrToNode Next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToNode Polynomial;</span><br><span class=\"line\"></span><br><span class=\"line\">Polynomial <span class=\"title function_\">Read</span><span class=\"params\">()</span>; <span class=\"comment\">/* details omitted */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Print</span><span class=\"params\">( Polynomial p )</span>; <span class=\"comment\">/* details omitted */</span></span><br><span class=\"line\">Polynomial <span class=\"title function_\">Add</span><span class=\"params\">( Polynomial a, Polynomial b )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Polynomial a, b, s;</span><br><span class=\"line\">    a = Read();</span><br><span class=\"line\">    b = Read();</span><br><span class=\"line\">    s = Add(a, b);</span><br><span class=\"line\">    Print(s);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Your function will be put here */</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Sample-Input\"><a href=\"#Sample-Input\" class=\"headerlink\" title=\"Sample Input:\"></a>Sample Input:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4</span><br><span class=\"line\">3 4 -5 2 6 1 -2 0</span><br><span class=\"line\">3</span><br><span class=\"line\">5 20 -7 4 3 1</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Sample-Output\"><a href=\"#Sample-Output\" class=\"headerlink\" title=\"Sample Output:\"></a>Sample Output:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5 20 -4 4 -5 2 9 1 -2 0</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Polynomial <span class=\"title function_\">Add</span><span class=\"params\">( Polynomial a, Polynomial b )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//如果有一个为空则直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(b==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    <span class=\"comment\">//head用于保存头结点，pre用于遍历，tmp用于产生新节点</span></span><br><span class=\"line\">    Polynomial head,pre,tmp;</span><br><span class=\"line\">    pre=(<span class=\"keyword\">struct</span> Node*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> Node));<span class=\"comment\">//申请内存</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    head=pre;<span class=\"comment\">//head保存头结点</span></span><br><span class=\"line\">    a=a-&gt;Next;<span class=\"comment\">//因为有头结点，所以需要next一下寻找第一个元素</span></span><br><span class=\"line\">    b=b-&gt;Next;<span class=\"comment\">//因为有头结点，所以需要next一下寻找第一个元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(a!=<span class=\"literal\">NULL</span>&amp;&amp;b!=<span class=\"literal\">NULL</span>)&#123;<span class=\"comment\">//两多项式都没遍历完</span></span><br><span class=\"line\">    </span><br><span class=\"line\">        tmp=(Polynomial)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Polynomial));  </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a-&gt;Exponent == b-&gt;Exponent)&#123;</span><br><span class=\"line\">            tmp-&gt;Exponent=a-&gt;Exponent;</span><br><span class=\"line\">            tmp-&gt;Coefficient=a-&gt;Coefficient+b-&gt;Coefficient;</span><br><span class=\"line\">            a=a-&gt;Next;</span><br><span class=\"line\">            b=b-&gt;Next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp-&gt;Coefficient==<span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;<span class=\"comment\">//系数可能为0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a-&gt;Exponent&gt;b-&gt;Exponent)&#123;</span><br><span class=\"line\">            tmp-&gt;Exponent=a-&gt;Exponent;</span><br><span class=\"line\">            tmp-&gt;Coefficient=a-&gt;Coefficient;</span><br><span class=\"line\">            a=a-&gt;Next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            tmp-&gt;Exponent=b-&gt;Exponent;</span><br><span class=\"line\">            tmp-&gt;Coefficient=b-&gt;Coefficient;</span><br><span class=\"line\">            b=b-&gt;Next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        tmp-&gt;Next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        pre-&gt;Next=tmp;<span class=\"comment\">//pre遍历</span></span><br><span class=\"line\">        pre=tmp;<span class=\"comment\">//遍历</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//其中一个多项式遍历完了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a!=<span class=\"literal\">NULL</span>&amp;&amp;b==<span class=\"literal\">NULL</span>) pre-&gt;Next=a;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a==<span class=\"literal\">NULL</span>&amp;&amp;b!=<span class=\"literal\">NULL</span>) pre-&gt;Next=b;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"6-2-Reverse-Linked-List\"><a href=\"#6-2-Reverse-Linked-List\" class=\"headerlink\" title=\"6-2 Reverse Linked List\"></a>6-2 Reverse Linked List</h5><p>Write a nonrecursive procedure to reverse a singly linked list in <em>O</em>(<em>N</em>) time using constant extra space.</p>\n<h3 id=\"Format-of-functions-1\"><a href=\"#Format-of-functions-1\" class=\"headerlink\" title=\"Format of functions:\"></a>Format of functions:</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List <span class=\"title function_\">Reverse</span><span class=\"params\">( List L )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>where <code>List</code> is defined as the following:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> *PtrToNode;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToNode List;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToNode Position;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">    ElementType Element;</span><br><span class=\"line\">    Position Next;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>The function <code>Reverse</code> is supposed to return the reverse linked list of <code>L</code>, with a dummy header.</p>\n<h3 id=\"Sample-program-of-judge-1\"><a href=\"#Sample-program-of-judge-1\" class=\"headerlink\" title=\"Sample program of judge:\"></a>Sample program of judge:</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> ElementType;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> *<span class=\"title\">PtrToNode</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToNode List;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToNode Position;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">    ElementType Element;</span><br><span class=\"line\">    Position Next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">List <span class=\"title function_\">Read</span><span class=\"params\">()</span>; <span class=\"comment\">/* details omitted */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Print</span><span class=\"params\">( List L )</span>; <span class=\"comment\">/* details omitted */</span></span><br><span class=\"line\">List <span class=\"title function_\">Reverse</span><span class=\"params\">( List L )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    List L1, L2;</span><br><span class=\"line\">    L1 = Read();</span><br><span class=\"line\">    L2 = Reverse(L1);</span><br><span class=\"line\">    Print(L1);</span><br><span class=\"line\">    Print(L2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Your function will be put here */</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Sample-Input-1\"><a href=\"#Sample-Input-1\" class=\"headerlink\" title=\"Sample Input:\"></a>Sample Input:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">1 3 4 5 2</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Sample-Output-1\"><a href=\"#Sample-Output-1\" class=\"headerlink\" title=\"Sample Output:\"></a>Sample Output:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2 5 4 3 1</span><br><span class=\"line\">2 5 4 3 1</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List <span class=\"title function_\">Reverse</span><span class=\"params\">( List L )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    PtrToNode p = <span class=\"literal\">NULL</span>, q = <span class=\"literal\">NULL</span>, r = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    p = L-&gt;Next;</span><br><span class=\"line\">    r = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L-&gt;Next == <span class=\"literal\">NULL</span> || p-&gt;Next == <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> L;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p)&#123;</span><br><span class=\"line\">        q = p-&gt;Next;</span><br><span class=\"line\">        p-&gt;Next = r;</span><br><span class=\"line\">        r = p;</span><br><span class=\"line\">        p = q;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    L-&gt;Next = r;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>见期中模拟卷</p>\n<h3 id=\"线性表\"><a href=\"#线性表\" class=\"headerlink\" title=\"线性表\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODAyNTMxNS9hcnRpY2xlL2RldGFpbHMvMTE5Nzc4MDY4\">线性表</span></h3><h4 id=\"线性表的定义与操作–顺序表\"><a href=\"#线性表的定义与操作–顺序表\" class=\"headerlink\" title=\"线性表的定义与操作–顺序表\"></a>线性表的定义与操作–顺序表</h4><p>顺序表是用一段<strong>物理地址连续的存储单元</strong>依次存储数据元素的线性结构，一般情况下采用数组存储。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> Position;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">List</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> &#123;</span> </span><br><span class=\"line\">    ElementType Data[MAXSIZE];</span><br><span class=\"line\">    Position Last;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 初始化 */</span></span><br><span class=\"line\">List <span class=\"title function_\">MakeEmpty</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    List L; </span><br><span class=\"line\">    L = (List)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> LNode)); </span><br><span class=\"line\">    L-&gt;Last = <span class=\"number\">-1</span>; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> L;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 查找 */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ERROR -1</span></span><br><span class=\"line\">Position <span class=\"title function_\">Find</span><span class=\"params\">( List L, ElementType X )</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    Position i = <span class=\"number\">0</span>; </span><br><span class=\"line\">    <span class=\"keyword\">while</span>( i &lt;= L-&gt;Last &amp;&amp; L-&gt;Data[i]!= X ) </span><br><span class=\"line\">        i++; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( i &gt; L-&gt;Last ) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ERROR; <span class=\"comment\">/* 如果没找到，返回错误信息 */</span> </span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> i; <span class=\"comment\">/* 找到后返回的是存储位置 */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 插入 */</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Insert</span><span class=\"params\">( List L, ElementType X, Position P )</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    <span class=\"comment\">/* 在L的指定位置P前插入一个新元素X */</span> </span><br><span class=\"line\">    Position i; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( L-&gt;Last == MAXSIZE<span class=\"number\">-1</span>) &#123; <span class=\"comment\">/* 表空间已满，不能插入 */</span> </span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;表满&quot;</span>); </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( P&lt;<span class=\"number\">0</span> || P&gt;L-&gt;Last+<span class=\"number\">1</span> ) &#123; <span class=\"comment\">/* 检查插入位置的合法性 */</span> </span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;位置不合法&quot;</span>); </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">for</span>( i=L-&gt;Last; i&gt;=P; i-- ) </span><br><span class=\"line\">        L-&gt;Data[i+<span class=\"number\">1</span>] = L-&gt;Data[i]; <span class=\"comment\">/* 将位置P及以后的元素顺序向后移动 */</span> </span><br><span class=\"line\">    L-&gt;Data[P] = X; <span class=\"comment\">/* 新元素插入 */</span> </span><br><span class=\"line\">    L-&gt;Last++; <span class=\"comment\">/* Last仍指向最后元素 */</span> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 删除 */</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Delete</span><span class=\"params\">( List L, Position P )</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    <span class=\"comment\">/* 从L中删除指定位置P的元素 */</span> </span><br><span class=\"line\">    Position i; </span><br><span class=\"line\">    <span class=\"keyword\">if</span>( P&lt;<span class=\"number\">0</span> || P&gt;L-&gt;Last ) &#123; <span class=\"comment\">/* 检查空表及删除位置的合法性 */</span> </span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;位置%d不存在元素&quot;</span>, P ); </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">for</span>( i=P+<span class=\"number\">1</span>; i&lt;=L-&gt;Last; i++ ) </span><br><span class=\"line\">        L-&gt;Data[i<span class=\"number\">-1</span>] = L-&gt;Data[i]; <span class=\"comment\">/* 将位置P+1及以后的元素顺序向前移动 */</span> </span><br><span class=\"line\">    L-&gt;Last--; <span class=\"comment\">/* Last仍指向最后元素 */</span> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"线性表的定义与操作–链表\"><a href=\"#线性表的定义与操作–链表\" class=\"headerlink\" title=\"线性表的定义与操作–链表\"></a>线性表的定义与操作–<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Vkd2FyZF9Bc2lhL2FydGljbGUvZGV0YWlscy8xMjA4NzYzMTQ=\">链表</span></h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">PtrToLNode</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> &#123;</span> </span><br><span class=\"line\">    ElementType Data; </span><br><span class=\"line\">    PtrToLNode Next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToLNode Position;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToLNode List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 查找 */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ERROR NULL</span></span><br><span class=\"line\">Position <span class=\"title function_\">Find</span><span class=\"params\">( List L, ElementType X )</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    Position p = L; <span class=\"comment\">/* p指向L的第1个结点 */</span> </span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( p &amp;&amp; p-&gt;Data!=X ) </span><br><span class=\"line\">        p = p-&gt;Next; </span><br><span class=\"line\">    <span class=\"comment\">/* 下列语句可以用 return p; 替换 */</span> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( p ) <span class=\"keyword\">return</span> p; </span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 带头结点的插入 */</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Insert</span><span class=\"params\">( List L, ElementType X, Position P )</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    <span class=\"comment\">/* 这里默认L有头结点 */</span> </span><br><span class=\"line\">    Position tmp, pre; </span><br><span class=\"line\">    <span class=\"comment\">/* 查找P的前一个结点 */</span> </span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( pre=L; pre&amp;&amp;pre-&gt;Next!=P; pre=pre-&gt;Next ) ; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( pre==<span class=\"literal\">NULL</span> ) &#123; </span><br><span class=\"line\">        <span class=\"comment\">/* P所指的结点不在L中 */</span> </span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;插入位置参数错误\\n&quot;</span>); </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">/* 找到了P的前一个结点pre */</span> </span><br><span class=\"line\">        <span class=\"comment\">/* 在P前插入新结点 */</span> </span><br><span class=\"line\">        tmp = (Position)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> LNode)); </span><br><span class=\"line\">        <span class=\"comment\">/* 申请、填装结点 */</span> </span><br><span class=\"line\">        tmp-&gt;Data = X; </span><br><span class=\"line\">        tmp-&gt;Next = P; </span><br><span class=\"line\">        pre-&gt;Next = tmp; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 带头结点的删除 */</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Delete</span><span class=\"params\">( List L, Position P )</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    <span class=\"comment\">/* 这里默认L有头结点 */</span> </span><br><span class=\"line\">    Position pre; </span><br><span class=\"line\">    <span class=\"comment\">/* 查找P的前一个结点 */</span> </span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( pre=L; pre&amp;&amp;pre-&gt;Next!=P; pre=pre-&gt;Next ) ; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( pre==<span class=\"literal\">NULL</span> || P==<span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* P所指的结点不在L中 */</span> </span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;删除位置参数错误\\n&quot;</span>); </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">/* 找到了P的前一个结点pre */</span> </span><br><span class=\"line\">        <span class=\"comment\">/* 将P位置的结点删除 */</span> </span><br><span class=\"line\">        pre-&gt;Next = P-&gt;Next; </span><br><span class=\"line\">        <span class=\"built_in\">free</span>(P); </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p> <strong>If N numbers are stored in a singly linked list in increasing order, then the average time complexity for binary search is O(logN).</strong></p>\n<p>F</p>\n<p>链表不能用二分查找，只能从头开始遍历</p>\n<h2 id=\"HW3\"><a href=\"#HW3\" class=\"headerlink\" title=\"HW3\"></a>HW3</h2><h5 id=\"2-1-Push-5-characters-ooops-onto-a-stack-In-how-many-different-ways-that-we-can-pop-these-characters-and-still-obtain-ooops\"><a href=\"#2-1-Push-5-characters-ooops-onto-a-stack-In-how-many-different-ways-that-we-can-pop-these-characters-and-still-obtain-ooops\" class=\"headerlink\" title=\"2-1 Push 5 characters ooops onto a stack. In how many different ways that we can pop these characters and still obtain ooops?\"></a>2-1 Push 5 characters <code>ooops</code> onto a stack. In how many different ways that we can pop these characters and still obtain <code>ooops</code>?</h5><p>C.5</p>\n<p>stack-FILO</p>\n<p>queue-FIFO</p>\n<h5 id=\"2-3-Suppose-that-an-array-of-size-6-is-used-to-store-a-circular-queue-and-the-values-of-front-and-rear-are-0-and-4-respectively-Now-after-2-dequeues-and-2-enqueues-what-will-the-values-of-front-and-rear-be\"><a href=\"#2-3-Suppose-that-an-array-of-size-6-is-used-to-store-a-circular-queue-and-the-values-of-front-and-rear-are-0-and-4-respectively-Now-after-2-dequeues-and-2-enqueues-what-will-the-values-of-front-and-rear-be\" class=\"headerlink\" title=\"2-3 Suppose that an array of size 6 is used to store a circular queue, and the values of front and rear are 0 and 4, respectively. Now after 2 dequeues and 2 enqueues, what will the values of front and rear be?\"></a>2-3 Suppose that an array of size 6 is used to store a circular queue, and the values of <code>front</code> and <code>rear</code> are 0 and 4, respectively. Now after 2 dequeues and 2 enqueues, what will the values of <code>front</code> and <code>rear</code> be?</h5><pre class=\"mermaid\">graph LR;\n0-->1;\n1-->2;\n2-->3;\n3-->4;\n4-->5;\n5-->0;</pre>\n\n<p>In circular queue:</p>\n<p>Rear &#x3D; 0, front &#x3D; 1</p>\n<p>Empty: Rear &#x3D; front-1</p>\n<p>When enqueue, rear ++</p>\n<p>When dequeue, front++</p>\n<p>front &#x3D; 0 + 2 &#x3D; 2</p>\n<p>rear &#x3D; (4 + 2)%6 &#x3D; 0</p>\n<h4 id=\"编程题\"><a href=\"#编程题\" class=\"headerlink\" title=\"编程题\"></a>编程题</h4><h5 id=\"7-1-Pop-Sequence\"><a href=\"#7-1-Pop-Sequence\" class=\"headerlink\" title=\"7-1 Pop Sequence\"></a>7-1 Pop Sequence</h5><p>Given a stack which can keep <em>M</em> numbers at most. Push <em>N</em> numbers in the order of 1, 2, 3, …, <em>N</em> and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if <em>M</em> is 5 and <em>N</em> is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.</p>\n<h3 id=\"Input-Specification\"><a href=\"#Input-Specification\" class=\"headerlink\" title=\"Input Specification:\"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): <em>M</em> (the maximum capacity of the stack), <em>N</em> (the length of push sequence), and <em>K</em> (the number of pop sequences to be checked). Then <em>K</em> lines follow, each contains a pop sequence of <em>N</em> numbers. All the numbers in a line are separated by a space.</p>\n<h3 id=\"Output-Specification\"><a href=\"#Output-Specification\" class=\"headerlink\" title=\"Output Specification:\"></a>Output Specification:</h3><p>For each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not.</p>\n<h3 id=\"Sample-Input-2\"><a href=\"#Sample-Input-2\" class=\"headerlink\" title=\"Sample Input:\"></a>Sample Input:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5 7 5</span><br><span class=\"line\">1 2 3 4 5 6 7</span><br><span class=\"line\">3 2 1 7 5 6 4</span><br><span class=\"line\">7 6 5 4 3 2 1</span><br><span class=\"line\">5 6 4 3 7 2 1</span><br><span class=\"line\">1 7 6 5 4 3 2</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Sample-Output-2\"><a href=\"#Sample-Output-2\" class=\"headerlink\" title=\"Sample Output:\"></a>Sample Output:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">YES</span><br><span class=\"line\">NO</span><br><span class=\"line\">NO</span><br><span class=\"line\">YES</span><br><span class=\"line\">NO</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> m, n, k;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d %d&quot;</span>,&amp;m, &amp;n, &amp;k);</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"built_in\">stack</span>[n], pop[n], result[k];</span><br><span class=\"line\">    <span class=\"type\">int</span> i, j;</span><br><span class=\"line\">    <span class=\"type\">int</span> ptr_s = <span class=\"number\">0</span>, ptr_p = <span class=\"number\">0</span>, element = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i&lt;k; i++)&#123;</span><br><span class=\"line\">        ptr_s =<span class=\"number\">0</span>, ptr_p = <span class=\"number\">0</span>, element = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; j&lt;n; j++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;pop[j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(ptr_p&lt;n)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(element == pop[ptr_p]&amp;&amp;ptr_s&lt;m)&#123;</span><br><span class=\"line\">                element++;</span><br><span class=\"line\">                ptr_p++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">stack</span>[ptr_s<span class=\"number\">-1</span>] == pop[ptr_p] &amp;&amp; ptr_s&gt;=<span class=\"number\">0</span> &amp;&amp; ptr_s&lt;=m)&#123;</span><br><span class=\"line\">                ptr_p++;</span><br><span class=\"line\">                ptr_s--;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(element&lt;=n &amp;&amp; ptr_s&lt;=m)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">stack</span>[ptr_s] = element;</span><br><span class=\"line\">                ptr_s++;</span><br><span class=\"line\">                element++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ptr_p&lt;n)&#123;</span><br><span class=\"line\">            result[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            result[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i&lt;k; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(result[i] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;NO\\n&quot;</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;YES\\n&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>新开一个栈用来存1234567，然后依次比较用来pop栈顶元素和popseq的栈的元素，相等就pop。</p>\n<h2 id=\"HW4\"><a href=\"#HW4\" class=\"headerlink\" title=\"HW4\"></a>HW4</h2><h5 id=\"1-1-It-is-always-possible-to-represent-a-tree-by-a-one-dimensional-integer-array\"><a href=\"#1-1-It-is-always-possible-to-represent-a-tree-by-a-one-dimensional-integer-array\" class=\"headerlink\" title=\"1-1 It is always possible to represent a tree by a one-dimensional integer array.\"></a>1-1 It is always possible to represent a tree by a one-dimensional integer array.</h5><p>T</p>\n<p>二叉树可以经过前序遍历、中序遍历、后序遍历得到一维数组。其他degree的树也同理。</p>\n<h5 id=\"1-2-There-exists-a-binary-tree-with-2016-nodes-in-total-and-with-16-nodes-having-only-one-child\"><a href=\"#1-2-There-exists-a-binary-tree-with-2016-nodes-in-total-and-with-16-nodes-having-only-one-child\" class=\"headerlink\" title=\"1-2 There exists a binary tree with 2016 nodes in total, and with 16 nodes having only one child.\"></a>1-2 There exists a binary tree with 2016 nodes in total, and with 16 nodes having only one child.</h5><p>F</p>\n<p>假设没有孩子的结点（叶结点）个数为n₀，只有一个孩子的结点（度为1的结点）个数为n₁，有两个孩子的结点（度为2的结点）个数为n₂。<br>则n₀+n₁+n₂&#x3D;2016<br>&#x3D;&#x3D;∵n₀&#x3D;n₂+1（二叉树的性质：叶结点个数等于度为2的结点个数加1）&#x3D;&#x3D;<br>∴n₀+n₁+n₂&#x3D;2016<br>⇨n₂+1+16+n₂&#x3D;2016<br>⇨2n₂&#x3D;1999<br>n₂除不尽，所以答案错误。</p>\n<p>【 Theorem 】 A tree with n vertices has n-1 edges.</p>\n<p>【 Theorem 】 edge &#x3D; 1&#x2F;2(sum of degree)</p>\n<p>【 Theorem 】A full m-ary tree with i internal vertices contains n&#x3D;mi+1 vertices.</p>\n<p>&#x3D;&#x3D;<strong>For a full binary tree,</strong> <strong>l&#x3D; i +1</strong>, <strong>e</strong> <strong>&#x3D;</strong> <strong>v</strong> <strong>- 1.</strong>&#x3D;&#x3D;</p>\n<p>对于二叉树来说，叶子结点的个数等于中间节点个数+1，边数等于节点数-1</p>\n<h5 id=\"2-1-Given-a-tree-of-degree-3-Suppose-that-there-are-3-nodes-of-degree-2-and-2-nodes-of-degree-3-Then-the-number-of-leaf-nodes-must-be\"><a href=\"#2-1-Given-a-tree-of-degree-3-Suppose-that-there-are-3-nodes-of-degree-2-and-2-nodes-of-degree-3-Then-the-number-of-leaf-nodes-must-be\" class=\"headerlink\" title=\"2-1 Given a tree of degree 3. Suppose that there are 3 nodes of degree 2 and 2 nodes of degree 3. Then the number of leaf nodes must be ____.\"></a>2-1 Given a tree of degree 3. Suppose that there are 3 nodes of degree 2 and 2 nodes of degree 3. Then the number of leaf nodes must be ____.</h5><p>$n&#x3D;n_0+n_1+n_2+n_3$</p>\n<p>$e&#x3D;n-1&#x3D;n_1+2n_2+3n_3$</p>\n<p>$–&gt;n_0&#x3D;n_2+2n_3+1$</p>\n<p>直接画一棵树</p>\n<pre class=\"mermaid\">graph TD;\n0-->1;\n0-->2;\n1-->3;\n1-->4;\n2-->5;\n2-->6;\n3-->7;\n3-->8;\n3-->9;\n5-->10;\n5-->11;\n5-->12;</pre>\n\n\n\n<h5 id=\"2-2-If-a-general-tree-T-is-converted-into-a-binary-tree-BT-then-which-of-the-following-BT-traversals-gives-the-same-sequence-as-that-of-the-post-order-traversal-of-T\"><a href=\"#2-2-If-a-general-tree-T-is-converted-into-a-binary-tree-BT-then-which-of-the-following-BT-traversals-gives-the-same-sequence-as-that-of-the-post-order-traversal-of-T\" class=\"headerlink\" title=\"2-2 If a general tree T is converted into a binary tree BT, then which of the following BT traversals gives the same sequence as that of the post-order traversal of T?\"></a>2-2 If a general tree <em>T</em> is converted into a binary tree <em>BT</em>, then which of the following <em>BT</em> traversals gives the same sequence as that of the post-order traversal of <em>T</em>?</h5><p>B. In-order traversal</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV2ZXJfZHJlYW1zL2FydGljbGUvZGV0YWlscy84MTAzMjg2MT9vcHNfcmVxdWVzdF9taXNjPSZyZXF1ZXN0X2lkPSZiaXpfaWQ9MTAyJnV0bV90ZXJtPSVFNiU5OSVBRSVFOSU4MCU5QSVFNiVBMCU5MSVFOCVCRCVBQyVFNSU4QyU5NiVFNiU4OCU5MCVFNCVCQSU4QyVFNSU4RiU4OSVFNiVBMCU5MSZ1dG1fbWVkaXVtPWRpc3RyaWJ1dGUucGNfc2VhcmNoX3Jlc3VsdC5ub25lLXRhc2stYmxvZy0yfmFsbH5zb2JhaWR1d2VifmRlZmF1bHQtMy04MTAzMjg2MS5ub25lY2FzZSZzcG09MTAxOC4yMjI2LjMwMDEuNDE4Nw==\">普通树转二叉树</span></p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">将树的根节点直接作为二叉树的根节点</span><br><span class=\"line\">将树的根节点的第一个子节点作为根节点的左儿子，若该子节点存在兄弟节点，则将该子节点的第一个兄弟节点（方向从左往右）作为该子节点的右儿子</span><br><span class=\"line\">将树中的剩余节点按照上一步的方式，依序添加到二叉树中，直到树中所有的节点都在二叉树中</span><br></pre></td></tr></table></figure>\n\n<p><img data-src=\"https://img-blog.csdn.net/20180713160942112?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV2ZXJfZHJlYW1z/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"img\"></p>\n<p>T：<br>前序preorder：ABEICFDGJH<br>中序无（多节点没法定义中序）<br>后序：IEBFCJGHDA</p>\n<p>BT：<br>前序preorder: ABEICFDGJH<br>中序inorder：IEBFCJGHDA<br>后序postorder:IEBFJHGDCBA<br>层级levelorder：ABECIFDGJH</p>\n<p><strong>结论：</strong></p>\n<p><strong>T的preorder &#x3D; BT的preorder<br>T的postorder &#x3D; BT的inorder</strong></p>\n<p>preorder-根左右  inorder-左根右  postorder-左右根</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">还可以这样理解普通树转换成二叉树（实际上是一样的）：</span><br><span class=\"line\"></span><br><span class=\"line\">在所有兄弟结点之间加一连线</span><br><span class=\"line\">对每个结点，除了保留与其第一个儿子的连线外，去掉该结点与其它孩子的连线</span><br></pre></td></tr></table></figure>\n\n<p><img data-src=\"https://img-blog.csdn.net/20180724230432154?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV2ZXJfZHJlYW1z/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"img\"></p>\n<h5 id=\"2-3-Given-the-shape-of-a-binary-tree-shown-by-the-figure-below-If-its-inorder-traversal-sequence-is-E-A-D-B-F-H-C-G-then-the-node-on-the-same-level-of-C-must-be\"><a href=\"#2-3-Given-the-shape-of-a-binary-tree-shown-by-the-figure-below-If-its-inorder-traversal-sequence-is-E-A-D-B-F-H-C-G-then-the-node-on-the-same-level-of-C-must-be\" class=\"headerlink\" title=\"2-3 Given the shape of a binary tree shown by the figure below. If its inorder traversal sequence is { E, A, D, B, F, H, C, G }, then the node on the same level of C must be:\"></a>2-3 Given the shape of a binary tree shown by the figure below. If its inorder traversal sequence is { E, A, D, B, F, H, C, G }, then the node on the same level of C must be:</h5><p><img data-src=\"https://images.ptausercontent.com/19185355-2b08-4b74-9bb7-8262720437bd.jpg\" alt=\"未标题-2.jpg\"></p>\n<p>B.E</p>\n<pre class=\"mermaid\">graph TD\nF-->E\nF-->C\nE-->_\nE-->D\nD-->A\nD-->B\nC-->H\nC-->G</pre>\n\n<p>中序遍历：左根右</p>\n<h5 id=\"2-4-Among-the-following-threaded-binary-trees-the-threads-are-represented-by-dotted-curves-which-one-is-the-postorder-threaded-tree\"><a href=\"#2-4-Among-the-following-threaded-binary-trees-the-threads-are-represented-by-dotted-curves-which-one-is-the-postorder-threaded-tree\" class=\"headerlink\" title=\"2-4 Among the following threaded binary trees (the threads are represented by dotted curves), which one is the postorder threaded tree?\"></a>2-4 Among the following threaded binary trees (the threads are represented by dotted curves), which one is the postorder threaded tree?</h5><p>A. <img data-src=\"https://images.ptausercontent.com/64\" alt=\"64\"></p>\n<p>B. <img data-src=\"https://images.ptausercontent.com/65\" alt=\"65\"></p>\n<p>C. <img data-src=\"https://images.ptausercontent.com/66\" alt=\"66\"></p>\n<p>D. <img data-src=\"https://images.ptausercontent.com/67\" alt=\"67\"></p>\n<p><strong>B</strong></p>\n<p>thread tree 线索二叉树</p>\n<p>下面这个树，<strong>后序排序</strong>是：dbca<br>前驱就是前面的，比如b的前驱是d, d的前驱是Null<br>后驱就是后面的，比如d的后驱是b，a的后驱是Null<br>d有两个指针没有用，左边指向前驱Null，右边指向b（然后就选出来B了）<br>b的右节点有用的（已经指向d了），左节点指向其前驱，也就是d<br>c前驱是b，后驱是a，所以左指向b，右指向a<br>a没有指针可用了（已经左为b右为c）了<br>所以选B。</p>\n<h5 id=\"Expression-Trees-syntax-trees\"><a href=\"#Expression-Trees-syntax-trees\" class=\"headerlink\" title=\"Expression Trees (syntax trees)\"></a>Expression Trees (syntax trees)</h5><p>prefix&#x2F;infix&#x2F;postfix分别对应前序遍历、中序遍历、后序遍历</p>\n<h5 id=\"6-1-Isomorphic\"><a href=\"#6-1-Isomorphic\" class=\"headerlink\" title=\"6-1 Isomorphic\"></a><strong>6-1 Isomorphic</strong></h5><p>Two trees, <code>T1</code> and <code>T2</code>, are <strong>isomorphic</strong> if <code>T1</code> can be transformed into <code>T2</code> by swapping left and right children of (some of the) nodes in <code>T1</code>. For instance, the two trees in Figure 1 are isomorphic because they are the same if the children of A, B, and G, but not the other nodes, are swapped. Give a polynomial time algorithm to decide if two trees are isomorphic.</p>\n<p><img data-src=\"https://images.ptausercontent.com/37\" alt=\"37\"></p>\n<h3 id=\"Format-of-functions-2\"><a href=\"#Format-of-functions-2\" class=\"headerlink\" title=\"Format of functions:\"></a>Format of functions:</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Isomorphic</span><span class=\"params\">( Tree T1, Tree T2 )</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>where <code>Tree</code> is defined as the following:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">TreeNode</span> *Tree;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TreeNode</span> &#123;</span><br><span class=\"line\">    ElementType Element;</span><br><span class=\"line\">    Tree  Left;</span><br><span class=\"line\">    Tree  Right;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>The function is supposed to return 1 if <code>T1</code> and <code>T2</code> are indeed isomorphic, or 0 if not.</p>\n<h3 id=\"Sample-program-of-judge-2\"><a href=\"#Sample-program-of-judge-2\" class=\"headerlink\" title=\"Sample program of judge:\"></a>Sample program of judge:</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">char</span> ElementType;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">TreeNode</span> *Tree;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TreeNode</span> &#123;</span><br><span class=\"line\">    ElementType Element;</span><br><span class=\"line\">    Tree  Left;</span><br><span class=\"line\">    Tree  Right;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Tree <span class=\"title\">BuildTree</span><span class=\"params\">()</span></span>; <span class=\"comment\">/* details omitted */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Isomorphic</span><span class=\"params\">( Tree T1, Tree T2 )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Tree T1, T2;</span><br><span class=\"line\">    T1 = <span class=\"built_in\">BuildTree</span>();</span><br><span class=\"line\">    T2 = <span class=\"built_in\">BuildTree</span>();</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(“%d\\n”, <span class=\"built_in\">Isomorphic</span>(T1, T2));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Your function will be put here */</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Sample-Output-1-for-the-trees-shown-in-Figure-1\"><a href=\"#Sample-Output-1-for-the-trees-shown-in-Figure-1\" class=\"headerlink\" title=\"Sample Output 1 (for the trees shown in Figure 1):\"></a>Sample Output 1 (for the trees shown in Figure 1):</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Sample-Output-2-for-the-trees-shown-in-Figure-2\"><a href=\"#Sample-Output-2-for-the-trees-shown-in-Figure-2\" class=\"headerlink\" title=\"Sample Output 2 (for the trees shown in Figure 2):\"></a>Sample Output 2 (for the trees shown in Figure 2):</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n\n<p><img data-src=\"https://images.ptausercontent.com/38\" alt=\"img\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Isomorphic</span><span class=\"params\">(Tree T1,Tree T2)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> \t<span class=\"keyword\">if</span>((T1 == <span class=\"literal\">NULL</span>) &amp;&amp; (T2 == <span class=\"literal\">NULL</span>))  <span class=\"comment\">//树都为空树，视为同构 </span></span><br><span class=\"line\"> \t    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"> \t<span class=\"keyword\">if</span>(((T1 == <span class=\"literal\">NULL</span>)&amp;&amp;(T2 != <span class=\"literal\">NULL</span>)) || ((T1 != <span class=\"literal\">NULL</span>)&amp;&amp;(T2 == <span class=\"literal\">NULL</span>)))  <span class=\"comment\">//两树其中之一为空树,不同构 </span></span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(T1-&gt;Element != T2-&gt;Element)  <span class=\"comment\">//若两树都非空的话，比较根结点 </span></span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>((T1-&gt;Left == <span class=\"literal\">NULL</span>) &amp;&amp; (T2-&gt;Left == <span class=\"literal\">NULL</span>))  <span class=\"comment\">//左子树都为空，比较右子树 </span></span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> Isomorphic(T1-&gt;Right,T2-&gt;Right);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((T1-&gt;Left != <span class=\"literal\">NULL</span>)&amp;&amp;(T2-&gt;Left != <span class=\"literal\">NULL</span>) &amp;&amp; (T1-&gt;Left-&gt;Element == T2-&gt;Left-&gt;Element))</span><br><span class=\"line\">    <span class=\"comment\">/*左子树非空，并且左子树根结点相同，递归比较左右子树*/</span> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> (Isomorphic(T1-&gt;Left,T2-&gt;Left) &amp;&amp; Isomorphic(T1-&gt;Right,T2-&gt;Right));</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (Isomorphic(T1-&gt;Left,T2-&gt;Right) &amp;&amp; Isomorphic(T1-&gt;Right,T2-&gt;Left));</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"HW5\"><a href=\"#HW5\" class=\"headerlink\" title=\"HW5\"></a>HW5</h2><h5 id=\"1-2-In-a-binary-search-tree-which-contains-several-integer-keys-including-4-5-and-6-if-4-and-6-are-on-the-same-level-then-5-must-be-their-parent\"><a href=\"#1-2-In-a-binary-search-tree-which-contains-several-integer-keys-including-4-5-and-6-if-4-and-6-are-on-the-same-level-then-5-must-be-their-parent\" class=\"headerlink\" title=\"1-2 In a binary search tree which contains several integer keys including 4, 5, and 6, if 4 and 6 are on the same level, then 5 must be their parent.\"></a>1-2 In a binary search tree which contains several integer keys including 4, 5, and 6, if 4 and 6 are on the same level, then 5 must be their parent.</h5><p>F</p>\n<p>不一定是父节点，可能是祖先节点。</p>\n<h5 id=\"2-2-Given-the-structure-of-a-binary-search-tree-as-shown-in-the-figure-which-one-of-the-following-insertion-sequences-is-impossible\"><a href=\"#2-2-Given-the-structure-of-a-binary-search-tree-as-shown-in-the-figure-which-one-of-the-following-insertion-sequences-is-impossible\" class=\"headerlink\" title=\"2-2 Given the structure of a binary search tree (as shown in the figure), which one of the following insertion sequences is impossible?\"></a>2-2 Given the structure of a binary search tree (as shown in the figure), which one of the following insertion sequences is impossible?</h5><p><img data-src=\"https://images.ptausercontent.com/84984823-130d-462a-ad9e-ee6457b1ce56.jpg\" alt=\"206.jpg\"></p>\n<p>A.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">83 67 91 98 20 75</span><br></pre></td></tr></table></figure>\n\n<p>B.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">83 67 75 91 20 98</span><br></pre></td></tr></table></figure>\n\n<p>C.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">83 91 75 67 20 98</span><br></pre></td></tr></table></figure>\n\n<p>D.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">83 91 98 67 75 20</span><br></pre></td></tr></table></figure>\n\n<p><strong>C</strong></p>\n<h5 id=\"Binary-Search-Tree\"><a href=\"#Binary-Search-Tree\" class=\"headerlink\" title=\"Binary Search Tree\"></a>Binary Search Tree</h5><p>二叉搜索树（BST，Binary Search Tree），也称二叉排序树或二叉查找树。<br>二叉搜索树：一棵二叉树，可以为空；如果不为空，满足以下性质：</p>\n<ol>\n<li>非空左子树的所有键值小于其根结点的键值。</li>\n<li>非空右子树的所有键值大于其根结点的键值。</li>\n<li>左、右子树都是二叉搜索树。</li>\n</ol>\n<p><strong>定义：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> ElementType;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TNode</span> *<span class=\"title\">Position</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> Position BinTree; <span class=\"comment\">/* 二叉树类型 */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TNode</span>&#123;</span> <span class=\"comment\">/* 树结点定义 */</span></span><br><span class=\"line\">    ElementType Data; <span class=\"comment\">/* 结点数据 */</span></span><br><span class=\"line\">    BinTree Left;     <span class=\"comment\">/* 指向左子树 */</span></span><br><span class=\"line\">    BinTree Right;    <span class=\"comment\">/* 指向右子树 */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>查找</strong></p>\n<p>（1）查找从根结点开始，如果树为空，返回NULL<br>（2）若搜索树非空，则根结点关键字和X进行比较，并进行不同处理：<br>  ① 若X小于根结点键值，只需在左子树中继续搜索；<br>  ② 如果X大于根结点的键值，在右子树中进行继续搜索；<br>  ③若两者比较结果是相等，搜索完成，返回指向此结点的指针。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Position <span class=\"title function_\">Find</span><span class=\"params\">( ElementType X, BinTree BST )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>( !BST ) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>; <span class=\"comment\">/*查找失败*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>( X &gt; BST-&gt;Data )</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Find( X, BST-&gt;Right ); <span class=\"comment\">/*在右子树中继续查找*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>( X &lt; BST-&gt;Data )</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Find( X, BST-&gt;Left ); <span class=\"comment\">/*在左子树中继续查找*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"comment\">/* X == BST-&gt;Data */</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> BST; <span class=\"comment\">/*查找成功，返回结点的找到结点的地址*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>查找最小（递归法）</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Position <span class=\"title function_\">FindMin</span><span class=\"params\">( BinTree BST )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t <span class=\"keyword\">if</span>( !BST ) </span><br><span class=\"line\">\t \t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>; <span class=\"comment\">/*空的二叉搜索树，返回NULL*/</span></span><br><span class=\"line\">\t <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>( !BST-&gt;Left )</span><br><span class=\"line\">\t \t<span class=\"keyword\">return</span> BST; <span class=\"comment\">/*找到最左叶结点并返回*/</span></span><br><span class=\"line\">\t <span class=\"keyword\">else</span></span><br><span class=\"line\">\t \t<span class=\"keyword\">return</span> FindMin( BST-&gt;Left ); <span class=\"comment\">/*沿左分支继续查找*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>查找最大（迭代法）</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Position <span class=\"title function_\">FindMax</span><span class=\"params\">( BinTree BST )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t <span class=\"keyword\">if</span>(BST )</span><br><span class=\"line\">\t \t<span class=\"keyword\">while</span>( BST-&gt;Right )  <span class=\"comment\">/*沿右分支继续查找，直到最右叶结点*/</span></span><br><span class=\"line\">\t \t\tBST = BST-&gt;Right;</span><br><span class=\"line\">\t <span class=\"keyword\">return</span> BST;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p><strong>插入</strong></p>\n<p>从根节点开始比较，大的插右边，小的插左边</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BinTree <span class=\"title function_\">Insert</span><span class=\"params\">( BinTree BST, ElementType X )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( !BST )&#123; <span class=\"comment\">/* 若原树为空，生成并返回一个结点的二叉搜索树 */</span></span><br><span class=\"line\">        BST = (BinTree)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> TNode));</span><br><span class=\"line\">        BST-&gt;Data = X;</span><br><span class=\"line\">        BST-&gt;Left = BST-&gt;Right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123; <span class=\"comment\">/* 开始找要插入元素的位置 */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>( X &lt; BST-&gt;Data )</span><br><span class=\"line\">            BST-&gt;Left = Insert( BST-&gt;Left, X );   <span class=\"comment\">/*递归插入左子树*/</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>  <span class=\"keyword\">if</span>( X &gt; BST-&gt;Data )</span><br><span class=\"line\">            BST-&gt;Right = Insert( BST-&gt;Right, X ); <span class=\"comment\">/*递归插入右子树*/</span></span><br><span class=\"line\">        <span class=\"comment\">/* else X已经存在，什么都不做 */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BST;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>删除</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BinTree <span class=\"title function_\">Delete</span><span class=\"params\">( BinTree BST, ElementType X )</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    Position Tmp; </span><br><span class=\"line\">    <span class=\"keyword\">if</span>( !BST ) </span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;要删除的元素未找到&quot;</span>); </span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( X &lt; BST-&gt;Data ) </span><br><span class=\"line\">            BST-&gt;Left = Delete( BST-&gt;Left, X );   <span class=\"comment\">/* 从左子树递归删除 */</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>( X &gt; BST-&gt;Data ) </span><br><span class=\"line\">            BST-&gt;Right = Delete( BST-&gt;Right, X ); <span class=\"comment\">/* 从右子树递归删除 */</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> </span><br><span class=\"line\">        &#123; <span class=\"comment\">/* BST就是要删除的结点 */</span></span><br><span class=\"line\">            <span class=\"comment\">/* 如果被删除结点有左右两个子结点 */</span> </span><br><span class=\"line\">            <span class=\"keyword\">if</span>( BST-&gt;Left &amp;&amp; BST-&gt;Right ) </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">/* 从右子树中找最小的元素填充删除结点 */</span></span><br><span class=\"line\">                Tmp = FindMin( BST-&gt;Right );</span><br><span class=\"line\">                BST-&gt;Data = Tmp-&gt;Data;</span><br><span class=\"line\">                <span class=\"comment\">/* 从右子树中删除最小元素 */</span></span><br><span class=\"line\">                BST-&gt;Right = Delete( BST-&gt;Right, BST-&gt;Data );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> </span><br><span class=\"line\">            &#123; <span class=\"comment\">/* 被删除结点有一个或无子结点 */</span></span><br><span class=\"line\">                Tmp = BST; </span><br><span class=\"line\">                <span class=\"keyword\">if</span>( !BST-&gt;Left )       <span class=\"comment\">/* 只有右孩子或无子结点 */</span></span><br><span class=\"line\">                    BST = BST-&gt;Right; </span><br><span class=\"line\">                <span class=\"keyword\">else</span>                   <span class=\"comment\">/* 只有左孩子 */</span></span><br><span class=\"line\">                    BST = BST-&gt;Left;</span><br><span class=\"line\">                <span class=\"built_in\">free</span>( Tmp );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BST;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"Given-a-binary-search-tree-with-its-preorder-traversal-sequence-8-2-15-10-12-21-If-8-is-deleted-from-the-tree-which-one-of-the-following-statements-is-FALSE\"><a href=\"#Given-a-binary-search-tree-with-its-preorder-traversal-sequence-8-2-15-10-12-21-If-8-is-deleted-from-the-tree-which-one-of-the-following-statements-is-FALSE\" class=\"headerlink\" title=\"Given a binary search tree with its preorder traversal sequence { 8, 2, 15, 10, 12, 21 }. If 8 is deleted from the tree, which one of the following statements is FALSE?\"></a>Given a binary search tree with its preorder traversal sequence { 8, 2, 15, 10, 12, 21 }. If 8 is deleted from the tree, which one of the following statements is FALSE?</h5><p>A. One possible preprder traversal sequence of the resulting tree may be { 2, 15, 10, 12, 21 }</p>\n<p>B. One possible preprder traversal sequence of the resulting tree may be { 10, 2, 15, 12, 21 }</p>\n<p>C. One possible preprder traversal sequence of the resulting tree may be { 15, 10, 2, 12, 21 }</p>\n<p>D. It is possible that the new root may have 2 children</p>\n<p>C</p>\n<p>8是根节点，删除之后根可能是左子树最大的元素或者右子树最小的元素</p>\n<pre class=\"mermaid\">graph TD\n8-->2\n8-->15\n15-->10\n10-->_\n10-->12\n15-->21</pre>\n\n<p>delete 8:</p>\n<pre class=\"mermaid\">graph TD\n2-->15\n15-->10\n10-->-\n10-->12\n15-->21</pre>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">10--&gt;2</span><br><span class=\"line\">10--&gt;15</span><br><span class=\"line\">15--&gt;12</span><br><span class=\"line\">15--&gt;21</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h5 id=\"2-4-Insert-5-2-7-3-4-1-6-one-by-one-into-an-initially-empty-binary-search-tree-The-postorder-traversal-sequence-of-the-resulting-tree-is\"><a href=\"#2-4-Insert-5-2-7-3-4-1-6-one-by-one-into-an-initially-empty-binary-search-tree-The-postorder-traversal-sequence-of-the-resulting-tree-is\" class=\"headerlink\" title=\"2-4 Insert {5, 2, 7, 3, 4, 1, 6} one by one into an initially empty binary search tree. The postorder traversal sequence of the resulting tree is:\"></a>2-4 Insert {5, 2, 7, 3, 4, 1, 6} one by one into an initially empty binary search tree. The postorder traversal sequence of the resulting tree is:</h5><p>A. 1, 2, 3, 4, 6, 7, 5</p>\n<p>B. 1, 4, 2, 6, 3, 7, 5</p>\n<p>C. 1, 4, 3, 2, 6, 7, 5</p>\n<p>D. 5, 4, 3, 7, 6, 2, 1</p>\n<p>注意是&#x3D;&#x3D;one by one&#x3D;&#x3D;，所以选C</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">5--&gt;2</span><br><span class=\"line\">5--&gt;7</span><br><span class=\"line\">2--&gt;1</span><br><span class=\"line\">2--&gt;3</span><br><span class=\"line\">3--&gt;_</span><br><span class=\"line\">3--&gt;4</span><br><span class=\"line\">7--&gt;6</span><br><span class=\"line\">7--&gt;-</span><br></pre></td></tr></table></figure>\n\n<p>后序遍历：1 4 3 2 6 7 5</p>\n<h5 id=\"2-5-Among-the-following-binary-trees-which-one-can-possibly-be-the-decision-tree-the-external-nodes-are-excluded-for-binary-search\"><a href=\"#2-5-Among-the-following-binary-trees-which-one-can-possibly-be-the-decision-tree-the-external-nodes-are-excluded-for-binary-search\" class=\"headerlink\" title=\"2-5 Among the following binary trees, which one can possibly be the decision tree (the external nodes are excluded) for binary search?\"></a>2-5 Among the following binary trees, which one can possibly be the decision tree (the external nodes are excluded) for binary search?</h5><p>A.</p>\n<p><img data-src=\"https://images.ptausercontent.com/282\" alt=\"img\"></p>\n<p>B.</p>\n<p><img data-src=\"https://images.ptausercontent.com/283\" alt=\"img\"></p>\n<p>C.</p>\n<p><img data-src=\"https://images.ptausercontent.com/284\" alt=\"img\"></p>\n<p>D.</p>\n<p><img data-src=\"https://images.ptausercontent.com/285\" alt=\"img\"></p>\n<p><strong>A</strong></p>\n<p>决策树：左子树总是大于等于右子树或者右子树总是大于等于左子树才符合。</p>\n<p>用排除法可得A</p>\n<h5 id=\"2-6-For-a-binary-search-tree-in-which-order-of-traversal-that-we-can-obtain-a-non-decreasing-sequence\"><a href=\"#2-6-For-a-binary-search-tree-in-which-order-of-traversal-that-we-can-obtain-a-non-decreasing-sequence\" class=\"headerlink\" title=\"2-6 For a binary search tree, in which order of traversal that we can obtain a non-decreasing sequence?\"></a>2-6 For a binary search tree, in which order of traversal that we can obtain a non-decreasing sequence?</h5><p>A. preorder traversal</p>\n<p>B. postorder traversal</p>\n<p>C. inorder traversal</p>\n<p>D. level-order traversal</p>\n<p><strong>C</strong></p>\n<p>中序遍历得到的序列是非递减的，前序遍历和后序遍历得到的都是无序的。</p>\n<h2 id=\"HW6\"><a href=\"#HW6\" class=\"headerlink\" title=\"HW6\"></a>HW6</h2><h5 id=\"1-1-If-a-complete-binary-tree-with-137-nodes-is-stored-in-an-array-root-at-position-1-then-the-nodes-at-positions-128-and-137-are-at-the-same-level\"><a href=\"#1-1-If-a-complete-binary-tree-with-137-nodes-is-stored-in-an-array-root-at-position-1-then-the-nodes-at-positions-128-and-137-are-at-the-same-level\" class=\"headerlink\" title=\"1-1 If a complete binary tree with 137 nodes is stored in an array (root at position 1), then the nodes at positions 128 and 137 are at the same level.\"></a>1-1 If a complete binary tree with 137 nodes is stored in an array (root at position 1), then the nodes at positions 128 and 137 are at the same level.</h5><p>T</p>\n<p>完全二叉树：若二叉树的深度为h，则除第h层外，其他层的结点全部达到最大值，且第h层的所有结点都集中在左子树。</p>\n<p>满二叉树：满二叉树是一种特殊的的完全二叉树，所有层的结点都是最大值。</p>\n<p><a href=\"https://blog.csdn.net/xiaomucgwlmx/article/details/103522410\"><strong>堆（heap)</strong></a></p>\n<p>堆（英语：heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质：</p>\n<p>堆中某个节点的值总是不大于或不小于其父节点的值；</p>\n<p>堆总是一棵完全二叉树。</p>\n<p>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。</p>\n<p>堆是非线性数据结构，相当于一维数组，有两个直接后继。</p>\n<p><strong>注意： 在二叉树中，若当前节点的下标为 i， 则其父节点的下标为 i&#x2F;2，其左子节点的下标为 i*2，其右子节点的下标为i*2+1；</strong></p>\n<h5 id=\"1-2-The-inorder-traversal-sequence-of-any-min-heap-must-be-in-sorted-order\"><a href=\"#1-2-The-inorder-traversal-sequence-of-any-min-heap-must-be-in-sorted-order\" class=\"headerlink\" title=\"1-2 The inorder traversal sequence of any min-heap must be in sorted order.\"></a>1-2 The inorder traversal sequence of any min-heap must be in sorted order.</h5><p><strong>F</strong></p>\n<p>在最小堆中，虽然父节点的值小于或等于其子节点的值，但是并没有要求兄弟节点之间的大小关系。因此，在进行中序遍历时，并不能保证得到一个有序的序列。（完全二叉树vs二叉搜索树）</p>\n<h5 id=\"2-1-In-a-max-heap-with-n-1-elements-the-array-index-of-the-minimum-key-may-be\"><a href=\"#2-1-In-a-max-heap-with-n-1-elements-the-array-index-of-the-minimum-key-may-be\" class=\"headerlink\" title=\"2-1 In a max-heap with n (&gt;1) elements, the array index of the minimum key may be __.\"></a>2-1 In a max-heap with <em>n</em> (&gt;1) elements, the array index of the minimum key may be __.</h5><p>A. 1</p>\n<p>B. ⌊<em>n</em>&#x2F;2⌋−1</p>\n<p>C. ⌊<em>n</em>&#x2F;2⌋</p>\n<p>D. ⌊<em>n</em>&#x2F;2⌋+2</p>\n<p><strong>D</strong></p>\n<p>最大堆最小的元素在叶子结点上，⌊<em>n</em>&#x2F;2⌋有子节点是⌊<em>n</em>⌋，所以肯定不是最小的元素，只能选D</p>\n<h5 id=\"2-2-Using-the-linear-algorithm-to-build-a-min-heap-from-the-sequence-15-26-32-8-7-20-12-13-5-19-and-then-insert-6-Which-one-of-the-following-statements-is-FALSE\"><a href=\"#2-2-Using-the-linear-algorithm-to-build-a-min-heap-from-the-sequence-15-26-32-8-7-20-12-13-5-19-and-then-insert-6-Which-one-of-the-following-statements-is-FALSE\" class=\"headerlink\" title=\"2-2 Using the linear algorithm to build a min-heap from the sequence {15, 26, 32, 8, 7, 20, 12, 13, 5, 19}, and then insert 6. Which one of the following statements is FALSE?\"></a>2-2 Using the linear algorithm to build a min-heap from the sequence {15, 26, 32, 8, 7, 20, 12, 13, 5, 19}, and then insert 6. Which one of the following statements is FALSE?</h5><p>A. The root is 5</p>\n<p>B. The path from the root to 26 is {5, 6, 8, 26}</p>\n<p>C. 32 is the left child of 12</p>\n<p>D. 7 is the parent of 19 and 15</p>\n<p><strong>C</strong></p>\n<p>先按level order建堆，然后从第一个父节点开始上滤，直到得到MinHeap</p>\n<p>插入6：插入之后依旧是完全二叉树，然后上滤</p>\n<p><strong>堆的插入</strong></p>\n<p>插入到最后一层最左侧的位置，然后和父节点比较，如果最小堆插入的元素比父节点小就和父节点交换位置，一直换到比父节点大为止，复杂度O(logn)。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span>  <span class=\"title function_\">Insert</span><span class=\"params\">( ElementType  X,  PriorityQueue  H )</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">     <span class=\"type\">int</span>  i; </span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">if</span> ( IsFull( H ) ) </span><br><span class=\"line\">     &#123; </span><br><span class=\"line\">\t\tError( <span class=\"string\">&quot;Priority queue is full&quot;</span> ); </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>; </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">\t<span class=\"comment\">/*首先确定初始位置是堆的个数+1，这个位置到根的路径是i/2*/</span></span><br><span class=\"line\">     <span class=\"keyword\">for</span> ( i = ++H-&gt;Size; H-&gt;Elements[ i / <span class=\"number\">2</span> ] &gt; X; i /= <span class=\"number\">2</span> ) </span><br><span class=\"line\">\t\tH-&gt;Elements[ i ] = H-&gt;Elements[ i / <span class=\"number\">2</span> ]; </span><br><span class=\"line\">\t\t<span class=\"comment\">/*当第(i/2)个大于X的时候，就往后移动，i/2小于X的时候，就让孩子i变成X*/</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">     H-&gt;Elements[ i ] = X; <span class=\"comment\">//</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>堆的删除</strong></p>\n<p>堆中每次都只能删除堆顶元素。为了便于重建堆，实际的操作是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整(shift_down)。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ElementType  <span class=\"title function_\">DeleteMin</span><span class=\"params\">( PriorityQueue  H )</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    <span class=\"type\">int</span>  i, Child; </span><br><span class=\"line\">    ElementType  MinElement, LastElement; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( IsEmpty( H ) ) </span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">         Error( <span class=\"string\">&quot;Priority queue is empty&quot;</span> ); </span><br><span class=\"line\">         <span class=\"keyword\">return</span>  H-&gt;Elements[ <span class=\"number\">0</span> ];   </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    MinElement = H-&gt;Elements[ <span class=\"number\">1</span> ];  <span class=\"comment\">/* save the min element */</span></span><br><span class=\"line\">    LastElement = H-&gt;Elements[ H-&gt;Size-- ];  <span class=\"comment\">/* take last and reset size */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( i = <span class=\"number\">1</span>; i * <span class=\"number\">2</span> &lt;= H-&gt;Size; i = Child ) </span><br><span class=\"line\">    &#123;  <span class=\"comment\">/* Find smaller child */</span> </span><br><span class=\"line\">         Child = i * <span class=\"number\">2</span>; </span><br><span class=\"line\">         <span class=\"keyword\">if</span> (Child != H-&gt;Size &amp;&amp; H-&gt;Elements[Child+<span class=\"number\">1</span>] &lt; H-&gt;Elements[Child]) </span><br><span class=\"line\">\t       Child++;     <span class=\"comment\">/*如果child+1更小，让child指向child+1*/</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> ( LastElement &gt; H-&gt;Elements[ Child ] )   <span class=\"comment\">/* Percolate one level */</span> </span><br><span class=\"line\">\t     \tH-&gt;Elements[ i ] = H-&gt;Elements[ Child ]; <span class=\"comment\">/*把child放在i的位置，和最后一句对应*/</span></span><br><span class=\"line\">         <span class=\"keyword\">else</span></span><br><span class=\"line\">         \t<span class=\"keyword\">break</span>;   <span class=\"comment\">/* find the proper position */</span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    H-&gt;Elements[ i ] = LastElement; <span class=\"comment\">/*把本来的最后一个元素放在i的位置，和上面那句对应*/</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>  MinElement; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>建堆</strong></p>\n<p>1)首先把数组按照层序（level order）放在一个空堆中<br>(2)从最后一个父节点开始，让父节点，右孩子，左孩子中最小的放在父节点的位置。<br>(3)如果父节点被换下去了，那么必须执行shiftdown操作，即被换下去的结点与当前的子节点比较，并交换，直到符合比任何一个子节点大的条件。<br>对于2-2</p>\n<pre class=\"mermaid\">graph TD;\n15-->26;\n15-->32;\n26-->8;\n26-->7;\n32-->20;\n32-->12;\n8-->13;\n8-->5;\n7-->19;</pre>\n\n<p>一开始按层序遍历建堆，接下来从第一个父节点7开始执行shift_down，不变</p>\n<p>然后对8shift_down，交换8和5</p>\n<pre class=\"mermaid\">graph TD;\n15-->26;\n15-->32;\n26-->5;\n26-->7;\n32-->20;\n32-->12;\n5-->13;\n5-->8;\n7-->19;</pre>\n\n<p>以此类推</p>\n<p>总的过程：</p>\n<p>对7shiftdown:不变<br>对8shiftdown:15 26 32 5 7 20 12 13 8 19<br>对32shiftdown:15 26 12 5 7 20 32 13 8 19<br>对26shiftdown:15 5 12 8 7 20 32 13 26 19<br>对15shiftdown: 5 7 12 8 15 20 32 13 26 19<br>插入6: 6 12 8 7 20 32 13 20 19 15</p>\n<h5 id=\"2-3-If-a-d-heap-is-stored-as-an-array-for-an-entry-located-in-position-i-the-parent-the-first-child-and-the-last-child-are-at\"><a href=\"#2-3-If-a-d-heap-is-stored-as-an-array-for-an-entry-located-in-position-i-the-parent-the-first-child-and-the-last-child-are-at\" class=\"headerlink\" title=\"2-3 If a d-heap is stored as an array, for an entry located in position i, the parent, the first child and the last child are at:\"></a>2-3 If a <em>d</em>-heap is stored as an array, for an entry located in position <em>i</em>, the parent, the first child and the last child are at:</h5><p>A. ⌈(<em>i</em>+<em>d</em>−2)&#x2F;<em>d</em>⌉, (<em>i</em>−2)<em>d</em>+2, and (<em>i</em>−1)<em>d</em>+1</p>\n<p>B. ⌈(<em>i</em>+<em>d</em>−1)&#x2F;<em>d</em>⌉, (<em>i</em>−2)<em>d</em>+1, and (<em>i</em>−1)<em>d</em></p>\n<p>C. ⌊(<em>i</em>+<em>d</em>−2)&#x2F;<em>d</em>⌋, (<em>i</em>−1)<em>d</em>+2, and <em>id</em>+1</p>\n<p>D. ⌊(<em>i</em>+<em>d</em>−1)&#x2F;<em>d</em>⌋, (<em>i</em>−1)<em>d</em>+1, and <em>id</em></p>\n<p><strong>C</strong></p>\n<h5 id=\"2-6-If-a-binary-search-tree-of-N-nodes-is-complete-which-one-of-the-following-statements-is-FALSE\"><a href=\"#2-6-If-a-binary-search-tree-of-N-nodes-is-complete-which-one-of-the-following-statements-is-FALSE\" class=\"headerlink\" title=\"2-6 If a binary search tree of N nodes is complete, which one of the following statements is FALSE?\"></a>2-6 If a binary search tree of <em>N</em> nodes is complete, which one of the following statements is FALSE?</h5><p>A. the average search time for all nodes is <em>O</em>(log<em>N</em>)\t\t</p>\n<p>二叉搜索的时间复杂度是O(logN)，对</p>\n<p>B. the minimum key must be at a leaf node</p>\n<p>最左边的节点</p>\n<p>C. the maximum key must be at a leaf node</p>\n<p>最大值可能在上一层的最右边的结点（此节点只有leftchildren），错</p>\n<p>D. the median node must either be the root or in the left subtree</p>\n<h4 id=\"函数题-1\"><a href=\"#函数题-1\" class=\"headerlink\" title=\"函数题\"></a>函数题</h4><p><strong>6-1 Percolate Up and Down</strong></p>\n<p>Write the routines to do a “percolate up” and a “percolate down” in a binary min-heap.</p>\n<h3 id=\"Format-of-functions-3\"><a href=\"#Format-of-functions-3\" class=\"headerlink\" title=\"Format of functions:\"></a>Format of functions:</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">PercolateUp</span><span class=\"params\">( <span class=\"type\">int</span> p, PriorityQueue H )</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">PercolateDown</span><span class=\"params\">( <span class=\"type\">int</span> p, PriorityQueue H )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>where <code>int p</code> is the position of the element, and <code>PriorityQueue</code> is defined as the following:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HeapStruct</span> *<span class=\"title\">PriorityQueue</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HeapStruct</span> &#123;</span></span><br><span class=\"line\">    ElementType  *Elements;</span><br><span class=\"line\">    <span class=\"type\">int</span> Capacity;</span><br><span class=\"line\">    <span class=\"type\">int</span> Size;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Sample-program-of-judge-3\"><a href=\"#Sample-program-of-judge-3\" class=\"headerlink\" title=\"Sample program of judge:\"></a>Sample program of judge:</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> ElementType;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MinData -1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HeapStruct</span> *<span class=\"title\">PriorityQueue</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HeapStruct</span> &#123;</span></span><br><span class=\"line\">    ElementType  *Elements;</span><br><span class=\"line\">    <span class=\"type\">int</span> Capacity;</span><br><span class=\"line\">    <span class=\"type\">int</span> Size;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">PriorityQueue <span class=\"title function_\">Initialize</span><span class=\"params\">( <span class=\"type\">int</span> MaxElements )</span>; <span class=\"comment\">/* details omitted */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">PercolateUp</span><span class=\"params\">( <span class=\"type\">int</span> p, PriorityQueue H )</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">PercolateDown</span><span class=\"params\">( <span class=\"type\">int</span> p, PriorityQueue H )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Insert</span><span class=\"params\">( ElementType X, PriorityQueue H )</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> p = ++H-&gt;Size;</span><br><span class=\"line\">    H-&gt;Elements[p] = X;</span><br><span class=\"line\">    PercolateUp( p, H );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ElementType <span class=\"title function_\">DeleteMin</span><span class=\"params\">( PriorityQueue H )</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    ElementType MinElement; </span><br><span class=\"line\">    MinElement = H-&gt;Elements[<span class=\"number\">1</span>];</span><br><span class=\"line\">    H-&gt;Elements[<span class=\"number\">1</span>] = H-&gt;Elements[H-&gt;Size--];</span><br><span class=\"line\">    PercolateDown( <span class=\"number\">1</span>, H );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MinElement; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n, i, op, X;</span><br><span class=\"line\">    PriorityQueue H;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">    H = Initialize(n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( i=<span class=\"number\">0</span>; i&lt;n; i++ ) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;op);</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>( op ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;X);</span><br><span class=\"line\">            Insert(X, H);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, DeleteMin(H));</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\nInside H:&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( i=<span class=\"number\">1</span>; i&lt;=H-&gt;Size; i++ )</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; %d&quot;</span>, H-&gt;Elements[i]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Your function will be put here */</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Sample-Input-3\"><a href=\"#Sample-Input-3\" class=\"headerlink\" title=\"Sample Input:\"></a>Sample Input:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">9</span><br><span class=\"line\">1 10</span><br><span class=\"line\">1 5</span><br><span class=\"line\">1 2</span><br><span class=\"line\">0</span><br><span class=\"line\">1 9</span><br><span class=\"line\">1 1</span><br><span class=\"line\">1 4</span><br><span class=\"line\">0</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Sample-Output-3\"><a href=\"#Sample-Output-3\" class=\"headerlink\" title=\"Sample Output:\"></a>Sample Output:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2 1 4 </span><br><span class=\"line\">Inside H: 5 10 9</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">PercolateUp</span><span class=\"params\">( <span class=\"type\">int</span> p, PriorityQueue H )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p&gt;<span class=\"number\">1</span> &amp;&amp; H-&gt;Elements[p] &lt; H-&gt;Elements[p/<span class=\"number\">2</span>])&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> temp;</span><br><span class=\"line\">        temp = H-&gt;Elements[p];</span><br><span class=\"line\">        H-&gt;Elements[p] = H-&gt;Elements[p/<span class=\"number\">2</span>];</span><br><span class=\"line\">        H-&gt;Elements[p/<span class=\"number\">2</span>] = temp;</span><br><span class=\"line\">        p = p/<span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">PercolateDown</span><span class=\"params\">( <span class=\"type\">int</span> p, PriorityQueue H )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p*<span class=\"number\">2</span>&lt;=H-&gt;Size &amp;&amp; H-&gt;Elements[p*<span class=\"number\">2</span>] &lt; H-&gt;Elements[p])&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> temp;</span><br><span class=\"line\">        temp = H-&gt;Elements[p];</span><br><span class=\"line\">        H-&gt;Elements[p] = H-&gt;Elements[p*<span class=\"number\">2</span>];</span><br><span class=\"line\">        H-&gt;Elements[p*<span class=\"number\">2</span>] = temp;</span><br><span class=\"line\">        p = p*<span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>PercolateUp就是和父节点比较，如果比父节点小就交换，直到根节点或者比父节点大为止；</p>\n<p>PercolateDown就是和子节点比较，同理。</p>\n<h2 id=\"HW7\"><a href=\"#HW7\" class=\"headerlink\" title=\"HW7\"></a>HW7</h2><p>并查集（disjoint set)</p>\n<p><strong>查找</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SetType  <span class=\"title function_\">Find</span> <span class=\"params\">( ElementType X, </span></span><br><span class=\"line\"><span class=\"params\">                           DisjSet S )</span></span><br><span class=\"line\">&#123;   <span class=\"keyword\">for</span> ( ; S[X] &gt; <span class=\"number\">0</span>; X = S[X] )   ;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>  X ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>Please fill in the blanks in the program which performs <code>Find</code> as a Union&#x2F;Find operation with path compression.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SetType <span class=\"title function_\">Find</span> <span class=\"params\">( ElementType X, DisjSet S )</span></span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">   ElementType root, trail, lead;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">for</span> ( root = X; S[root] &gt; <span class=\"number\">0</span>; root=S[root] );  <span class=\"comment\">//查找</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> ( trail = X; trail != root; trail = lead ) &#123;</span><br><span class=\"line\">      lead = S[trail];   </span><br><span class=\"line\">       S[trail]=root;</span><br><span class=\"line\">   &#125; <span class=\"comment\">//路径压缩</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>合并</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Union</span><span class=\"params\">( ElementType i, ElementType j, DisjSet S )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> root1, root2;</span><br><span class=\"line\">    root1 = Find(i);</span><br><span class=\"line\">    root2 = Find(j);</span><br><span class=\"line\">    S[root2] = root1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Union by size:</strong></p>\n<p>Union by size 是一种基于并查集（Disjoint Set）的合并策略，用于在合并两个集合时选择根节点。该策略<strong>将小集合合并到大集合中</strong>，以减少合并后的树高度，提高查找效率。</p>\n<p>具体来说，在 Union by size 策略中，每个集合的大小都可以表示为其根节点的负值，即 S[root] 的值是集合的大小。因此，当要将两个集合合并时，首先找到它们各自的根节点 root1 和 root2，并比较两个根节点所代表的集合大小。如果 S[root1] 大于 S[root2]，则将 root2 的父节点设为 root1，同时将 root1 的大小更新为两个集合的大小之和；否则，将 root1 的父节点设为 root2，同时将 root2 的大小更新为两个集合的大小之和。</p>\n<p>这样做的原理是，将小集合合并到大集合中可以减少树的高度，从而提高了查找效率。因为树的高度越低，查找元素的时间复杂度就越小，路径压缩也更容易实现。</p>\n<p>1-1 In <em>Union&#x2F;Find</em> algorithm, if <em>Unions</em> are done by size, the depth of any node must be no more than <em>N</em>&#x2F;2, but not $$O(logN)$$.</p>\n<p>F</p>\n<pre class=\"mermaid\">graph TD\n0-->1\n0-->2\n2-->3\n2-->4\n4-->5\n4-->6</pre>\n\n<p>$$height(T)&lt;&#x3D;log_2N+1$$\t</p>\n<h5 id=\"2-3-Let-T-be-a-tree-created-by-union-by-size-with-N-nodes-then-the-height-of-T-can-be\"><a href=\"#2-3-Let-T-be-a-tree-created-by-union-by-size-with-N-nodes-then-the-height-of-T-can-be\" class=\"headerlink\" title=\"2-3 Let T be a tree created by union-by-size with N nodes, then the height of T can be .\"></a>2-3 Let <em>T</em> be a tree created by union-by-size with <em>N</em> nodes, then the height of <em>T</em> can be .</h5><p>A.at most $$log_2N+1$$</p>\n<p>B.at least $$log_2N+1$$</p>\n<p>C.as large as $$N$$</p>\n<p>D.anything that is greater than 1</p>\n<p><strong>A</strong></p>\n<h2 id=\"HW8\"><a href=\"#HW8\" class=\"headerlink\" title=\"HW8\"></a>HW8</h2><p><strong>一些定义：</strong></p>\n<p>Complete graph:  a graph that has the maximum number of edges.</p>\n<p>An undirected graph G is <strong>connected</strong> if every pair of distinct vi and vj are connected.</p>\n<p> (Connected) <strong>Component</strong> of an undirected G ::&#x3D; the maximal connected subgraph——联通分量</p>\n<p>最大联通分量</p>\n<p>A tree ::&#x3D; a graph that is connected and acyclic(无环的)</p>\n<p>A DAG ::&#x3D; a directed acyclic graph</p>\n<p>Strongly connected directed graph G ::&#x3D; for every pair of vi and vj in V( G ), there exist directed paths from vi to vj and from vj to vi.  If the graph is connected without direction to the edges, then it is said to be weakly connected.</p>\n<p>强联通：有向图的每一对顶点之间都有路径</p>\n<p>弱连通：有向图底下的无向图之间都是联通的</p>\n<p>边数最小的联通图是树，E&#x3D;V-1</p>\n<h5 id=\"2-3-Given-the-adjacency-list-of-a-directed-graph-as-shown-by-the-figure-There-is-are-strongly-connected-component-s\"><a href=\"#2-3-Given-the-adjacency-list-of-a-directed-graph-as-shown-by-the-figure-There-is-are-strongly-connected-component-s\" class=\"headerlink\" title=\"2-3 Given the adjacency list of a directed graph as shown by the figure. There is(are) __ strongly connected component(s).\"></a>2-3 Given the adjacency list of a directed graph as shown by the figure. There is(are) __ strongly connected component(s).</h5><p><img data-src=\"https://images.ptausercontent.com/119\" alt=\"img\"></p>\n\nA. 4 {{0, 1, 5}, {2}, {3}, {4}}\n\nB. 3 {{2}, {4}, {0, 1, 3, 5}}\n\nC. 1 {0, 1, 2, 3, 4, 5}\n\nD. 1 {0, 5, 1, 3}\n\n\n<p><strong>B</strong></p>\n<pre class=\"mermaid\">graph LR;\n0-->5;\n1-->0;\n1-->3;\n2-->1;\n2-->4;\n3-->0;\n3-->4;\n5-->1;</pre>\n\n<p>强联通分量</p>\n<p>在有向图G中，如果两个顶点vi,vj间（vi&gt;vj）有一条从vi到vj的有向路径，同时还有一条从vj到vi的有向路径，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)，也就是说是图G的一些特殊子集。</p>\n<h5 id=\"1-3-If-a-directed-graph-G-V-E-is-weakly-connected-then-there-must-be-at-least-V-edges-in-G\"><a href=\"#1-3-If-a-directed-graph-G-V-E-is-weakly-connected-then-there-must-be-at-least-V-edges-in-G\" class=\"headerlink\" title=\"1-3 If a directed graph G&#x3D;(V, E) is weakly connected, then there must be at least |V| edges in G.\"></a>1-3 If a directed graph G&#x3D;(V, E) is weakly connected, then there must be at least |V| edges in G.</h5><p>F</p>\n<p>至少|V|-1</p>\n<h5 id=\"2-1-If-graph-G-is-NOT-connected-and-has-35-edges-then-it-must-have-at-least-vertices\"><a href=\"#2-1-If-graph-G-is-NOT-connected-and-has-35-edges-then-it-must-have-at-least-vertices\" class=\"headerlink\" title=\"2-1 If graph G is NOT connected and has 35 edges, then it must have &#x3D;&#x3D;at least&#x3D;&#x3D; ____ vertices.\"></a>2-1 If graph G is NOT connected and has 35 edges, then it must have &#x3D;&#x3D;at least&#x3D;&#x3D; ____ vertices.</h5><p>A.7</p>\n<p>B.8</p>\n<p>C.9</p>\n<p>D.10</p>\n<p>D</p>\n<p>$$\\frac{9×8}{2}&#x3D;36&gt;35$$</p>\n<p>9+1&#x3D;10</p>\n<p>&#x3D;&#x3D;重点区分：&#x3D;&#x3D;</p>\n<h5 id=\"2-2-A-graph-with-90-vertices-and-20-edges-must-have-at-least-connected-component-s\"><a href=\"#2-2-A-graph-with-90-vertices-and-20-edges-must-have-at-least-connected-component-s\" class=\"headerlink\" title=\"2-2 A graph with 90 vertices and 20 edges must have &#x3D;&#x3D;at least&#x3D;&#x3D; __ connected component(s).\"></a>2-2 A graph with 90 vertices and 20 edges must have &#x3D;&#x3D;at least&#x3D;&#x3D; __ connected component(s).</h5><p>A.69</p>\n<p>&#x3D;&#x3D;B.70&#x3D;&#x3D;</p>\n<p>C.84</p>\n<p>D.85</p>\n<p>【解析】20×2&#x3D;40，90-40+20&#x3D;70</p>\n<h5 id=\"【区分】：A-graph-with-90-vertices-and-20-edges-must-have-at-most-connected-component-s\"><a href=\"#【区分】：A-graph-with-90-vertices-and-20-edges-must-have-at-most-connected-component-s\" class=\"headerlink\" title=\"【区分】：A graph with 90 vertices and 20 edges must have &#x3D;&#x3D;at most&#x3D;&#x3D; __ connected component(s).\"></a>【区分】：A graph with 90 vertices and 20 edges must have &#x3D;&#x3D;at most&#x3D;&#x3D; __ connected component(s).</h5><p>A.69</p>\n<p>B.70</p>\n<p>&#x3D;&#x3D;C.84&#x3D;&#x3D;</p>\n<p>D.85</p>\n<p>【解析】 (7×6)&#x2F;2&#x3D;21，90-7+1&#x3D;84</p>\n<h5 id=\"2-4-Given-an-undirected-graph-G-with-16-edges-where-3-vertices-are-of-degree-4-4-vertices-are-of-degree-3-and-all-the-other-vertices-are-of-degrees-less-than-3-Then-G-must-have-at-least-vertices\"><a href=\"#2-4-Given-an-undirected-graph-G-with-16-edges-where-3-vertices-are-of-degree-4-4-vertices-are-of-degree-3-and-all-the-other-vertices-are-of-degrees-less-than-3-Then-G-must-have-at-least-vertices\" class=\"headerlink\" title=\"2-4 Given an undirected graph G with 16 edges, where 3 vertices are of degree 4, 4 vertices are of degree 3, and all the other vertices are of degrees less than 3. Then G must have at least __ vertices.\"></a>2-4 Given an undirected graph G with 16 edges, where 3 vertices are of degree 4, 4 vertices are of degree 3, and all the other vertices are of degrees less than 3. Then G must have at least __ vertices.</h5><p>A.10</p>\n<p>B.11</p>\n<p>C.13</p>\n<p>D.15</p>\n<p>$$e&#x3D;n_1+2n_2+3×4+4×3&#x3D;16×2&#x3D;32$$</p>\n<p>因为要求至少有几个，所以假设剩下的都是度为2的节点，32-24&#x3D;8，8÷2&#x3D;4，4+3+4&#x3D;11</p>\n<p><strong>拓扑排序</strong></p>\n<p>拓扑排序存在的前提：</p>\n<p>当且仅当一个有向图为有向无环图（directed acyclic graph，或称DAG）时，才能得到对应于该图的拓扑排序。每一个有向无环图都至少存在一种拓扑排序。</p>\n<p>方法：不断寻找入度为0的节点pop出去，删除该节点和相关的边</p>\n<p><strong>6-1 Is Topological Order</strong></p>\n<p>Write a program to test if a give sequence <code>Seq</code> is a topological order of a given graph <code>Graph</code>.</p>\n<h3 id=\"Format-of-functions-4\"><a href=\"#Format-of-functions-4\" class=\"headerlink\" title=\"Format of functions:\"></a>Format of functions:</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">IsTopSeq</span><span class=\"params\">( LGraph Graph, Vertex Seq[] )</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>where <code>LGraph</code> is defined as the following:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">AdjVNode</span> *PtrToAdjVNode; </span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">AdjVNode</span>&#123;</span><br><span class=\"line\">    Vertex AdjV;</span><br><span class=\"line\">    PtrToAdjVNode Next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">Vnode</span>&#123;</span><br><span class=\"line\">    PtrToAdjVNode FirstEdge;</span><br><span class=\"line\">&#125; AdjList[MaxVertexNum];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">GNode</span> *PtrToGNode;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">GNode</span>&#123;  </span><br><span class=\"line\">    <span class=\"type\">int</span> Nv;</span><br><span class=\"line\">    <span class=\"type\">int</span> Ne;</span><br><span class=\"line\">    AdjList G;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToGNode LGraph;</span><br></pre></td></tr></table></figure>\n\n<p>The function <code>IsTopSeq</code> must return <code>true</code> if <code>Seq</code> does correspond to a topological order; otherwise return <code>false</code>.</p>\n<p><strong>Note:</strong> Although the vertices are numbered from 1 to MaxVertexNum, they are <strong>indexed from 0</strong> in the LGraph structure.</p>\n<h3 id=\"Sample-program-of-judge-4\"><a href=\"#Sample-program-of-judge-4\" class=\"headerlink\" title=\"Sample program of judge:\"></a>Sample program of judge:</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span> &#123;</span><span class=\"literal\">false</span>, <span class=\"literal\">true</span>&#125; <span class=\"type\">bool</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxVertexNum 10  <span class=\"comment\">/* maximum number of vertices */</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> Vertex;      <span class=\"comment\">/* vertices are numbered from 1 to MaxVertexNum */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AdjVNode</span> *<span class=\"title\">PtrToAdjVNode</span>;</span> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AdjVNode</span>&#123;</span></span><br><span class=\"line\">    Vertex AdjV;</span><br><span class=\"line\">    PtrToAdjVNode Next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Vnode</span>&#123;</span></span><br><span class=\"line\">    PtrToAdjVNode FirstEdge;</span><br><span class=\"line\">&#125; AdjList[MaxVertexNum];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GNode</span> *<span class=\"title\">PtrToGNode</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GNode</span>&#123;</span>  </span><br><span class=\"line\">    <span class=\"type\">int</span> Nv;</span><br><span class=\"line\">    <span class=\"type\">int</span> Ne;</span><br><span class=\"line\">    AdjList G;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToGNode LGraph;</span><br><span class=\"line\"></span><br><span class=\"line\">LGraph <span class=\"title function_\">ReadG</span><span class=\"params\">()</span>; <span class=\"comment\">/* details omitted */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">IsTopSeq</span><span class=\"params\">( LGraph Graph, Vertex Seq[] )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i, j, N;</span><br><span class=\"line\">    Vertex Seq[MaxVertexNum];</span><br><span class=\"line\">    LGraph G = ReadG();</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;N);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;N; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j=<span class=\"number\">0</span>; j&lt;G-&gt;Nv; j++)</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;Seq[j]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( IsTopSeq(G, Seq)==<span class=\"literal\">true</span> ) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;yes\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;no\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Your function will be put here */</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Sample-Input-for-the-graph-shown-in-the-figure\"><a href=\"#Sample-Input-for-the-graph-shown-in-the-figure\" class=\"headerlink\" title=\"Sample Input (for the graph shown in the figure):\"></a>Sample Input (for the graph shown in the figure):</h3><p><img data-src=\"https://images.ptausercontent.com/5373e878-196d-45dd-a82f-555b1fea6929.JPG\" alt=\"topord.JPG\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6 8</span><br><span class=\"line\">1 2</span><br><span class=\"line\">1 3</span><br><span class=\"line\">5 2</span><br><span class=\"line\">5 4</span><br><span class=\"line\">2 3</span><br><span class=\"line\">2 6</span><br><span class=\"line\">3 4</span><br><span class=\"line\">6 4</span><br><span class=\"line\">5</span><br><span class=\"line\">1 5 2 3 6 4</span><br><span class=\"line\">5 1 2 6 3 4</span><br><span class=\"line\">5 1 2 3 6 4</span><br><span class=\"line\">5 2 1 6 3 4</span><br><span class=\"line\">1 2 3 4 5 6</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Sample-Output-4\"><a href=\"#Sample-Output-4\" class=\"headerlink\" title=\"Sample Output:\"></a>Sample Output:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yes</span><br><span class=\"line\">yes</span><br><span class=\"line\">yes</span><br><span class=\"line\">no</span><br><span class=\"line\">no</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">IsTopSeq</span><span class=\"params\">( LGraph Graph, Vertex Seq[] )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Vertex InDegree[<span class=\"number\">9999</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i&lt;<span class=\"number\">9999</span>; i++)&#123;</span><br><span class=\"line\">        InDegree[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    PtrToAdjVNode p;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; Graph-&gt;Nv; i++)&#123;</span><br><span class=\"line\">        p = Graph-&gt;G[i].FirstEdge;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            InDegree[p-&gt;AdjV]++;</span><br><span class=\"line\">            p = p-&gt;Next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; Graph-&gt;Nv; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(InDegree[Seq[i]<span class=\"number\">-1</span>] != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        InDegree[Seq[i]<span class=\"number\">-1</span>] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        p = Graph-&gt;G[Seq[i]<span class=\"number\">-1</span>].FirstEdge;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            InDegree[p-&gt;AdjV]--;</span><br><span class=\"line\">            p = p-&gt;Next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>Hamiltonian Cycle: 无向图中包含所有顶点的<strong>回路</strong></p>\n<p>Hamiltonian Path: 无向图中包含所有顶点的<strong>路径</strong></p>\n<p>哈密顿图：具有哈密顿回路的无向图</p>\n<h2 id=\"HW9\"><a href=\"#HW9\" class=\"headerlink\" title=\"HW9\"></a>HW9</h2><p>无权图的单源最短路算法（BFS）</p>\n<p><strong>无权图的建立：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AdjVNode</span> *<span class=\"title\">PtrToAdjVNode</span>;</span> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AdjVNode</span>&#123;</span></span><br><span class=\"line\">    Vertex AdjV;</span><br><span class=\"line\">    PtrToAdjVNode Next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Vnode</span>&#123;</span></span><br><span class=\"line\">    PtrToAdjVNode FirstEdge;</span><br><span class=\"line\">&#125; AdjList[MaxVertexNum];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GNode</span> *<span class=\"title\">PtrToGNode</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GNode</span>&#123;</span>  </span><br><span class=\"line\">    <span class=\"type\">int</span> Nv;</span><br><span class=\"line\">    <span class=\"type\">int</span> Ne;</span><br><span class=\"line\">    AdjList G;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToGNode LGraph;</span><br></pre></td></tr></table></figure>\n\n<p>跟hw8的一样</p>\n<p><strong>求从顶点S到任意一个顶点的最短路径</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Unweighted</span><span class=\"params\">( Graph G, Queue Q, <span class=\"type\">int</span> dist[], <span class=\"type\">int</span> path[], Vertex S )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  Vertex V, U;</span><br><span class=\"line\">  NodePtr ptr;</span><br><span class=\"line\"></span><br><span class=\"line\">  dist[S] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  Enqueue(S, Q);</span><br><span class=\"line\">  <span class=\"keyword\">while</span> ( !IsEmpty(Q) ) &#123;</span><br><span class=\"line\">    V = Dequeue( Q ); <span class=\"comment\">//弹出队列的第一个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( ptr=G-&gt;List[V].FirstEdge; ptr; ptr=ptr-&gt;Next) &#123; <span class=\"comment\">//找到V的邻接点</span></span><br><span class=\"line\">      U = ptr-&gt;AdjV;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( dist[U] == INFINITY ) &#123;</span><br><span class=\"line\">         dist[U] = dist[V] + <span class=\"number\">1</span>; <span class=\"comment\">//路径长度等于前一个点的路经长度+1</span></span><br><span class=\"line\">         path[U] = V; <span class=\"comment\">//把前一个点记录在当前点的path上</span></span><br><span class=\"line\">         Enqueue(U, Q); <span class=\"comment\">//把当前点入队</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>有权图的单源最短路算法</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaWNvdXJzZTE2My5vcmcvbGVhcm4vWkpVLTkzMDAxP3RpZD0xNDcxMjE4NDkxIy9sZWFybi9jb250ZW50P3R5cGU9ZGV0YWlsJmlkPTEyNTYxODE3NTkmY2lkPTEyODg5OTQ3MTAmcmVwbGF5PXRydWU=\">Dijkstra算法</span></p>\n<p>多源最短路算法</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaWNvdXJzZTE2My5vcmcvbGVhcm4vWkpVLTkzMDAxP3RpZD0xNDcxMjE4NDkxIy9sZWFybi9jb250ZW50P3R5cGU9ZGV0YWlsJmlkPTEyNTYxODE3NTkmY2lkPTEyODg5OTQ3MTEmY29udGVudGlkPTE4NDAwMTU=\">Floyd算法</span></p>\n<h5 id=\"2-3-If-besides-finding-the-shortest-path-from-S-to-every-other-vertices-we-also-need-to-count-the-number-of-different-shortest-paths-we-can-modify-the-Dijkstra-algorithm-in-the-following-way-add-an-array-count-so-that-count-V-records-the-number-of-different-shortest-paths-from-S-to-V-Then-count-V-shall-be-initialized-as\"><a href=\"#2-3-If-besides-finding-the-shortest-path-from-S-to-every-other-vertices-we-also-need-to-count-the-number-of-different-shortest-paths-we-can-modify-the-Dijkstra-algorithm-in-the-following-way-add-an-array-count-so-that-count-V-records-the-number-of-different-shortest-paths-from-S-to-V-Then-count-V-shall-be-initialized-as\" class=\"headerlink\" title=\"2-3 If besides finding the shortest path from S to every other vertices, we also need to count the number of different shortest paths, we can modify the Dijkstra algorithm in the following way: add an array count[] so that count[V] records the number of different shortest paths from S to V. Then count[V] shall be initialized as:\"></a>2-3 If besides finding the shortest path from <code>S</code> to every other vertices, we also need to count the number of different shortest paths, we can modify the Dijkstra algorithm in the following way: add an array <code>count[]</code> so that <code>count[V]</code> records the number of different shortest paths from <code>S</code> to <code>V</code>. Then <code>count[V]</code> shall be initialized as:</h5><p>A.<code>count[S]=1; </code> and <code>count[V]=0</code> for other <code>V</code></p>\n<p>B.<code>count[S]=0; </code> and <code>count[V]=1</code> for other <code>V</code></p>\n<p>C.<code>count[V]=1</code> for all vertices</p>\n<p>D.<code>count[V]=0</code> for all vertices</p>\n<p><strong>A</strong></p>\n<h1 id=\"HW10\"><a href=\"#HW10\" class=\"headerlink\" title=\"HW10\"></a>HW10</h1><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMW1WNHkxZTdCNS8/c3BtX2lkX2Zyb209MzMzLjEwMDcudG9wX3JpZ2h0X2Jhcl93aW5kb3dfaGlzdG9yeS5jb250ZW50LmNsaWNrJnZkX3NvdXJjZT0xYTdkOGY1OTZmM2RmZTQwZmVlMzRjODU4ZWQ0N2U3Mw==\">AOE网</span></p>\n<p>最早开始时间和最晚结束时间</p>\n<p><img data-src=\"/image-20240116202502513.png\"></p>\n<p>V代表事件，a代表活动</p>\n<p>事件（V）：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>V1</th>\n<th>V2</th>\n<th>V3</th>\n<th>V4</th>\n<th>V5</th>\n<th>V6</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>最早开始时间</td>\n<td>0</td>\n<td>3</td>\n<td>2</td>\n<td>6</td>\n<td>6</td>\n<td>8</td>\n</tr>\n<tr>\n<td>最晚完成时间</td>\n<td>0</td>\n<td>4</td>\n<td>2</td>\n<td>6</td>\n<td>7</td>\n<td>8</td>\n</tr>\n</tbody></table>\n<p>最早开始时间从前往后取最大的</p>\n<p>最晚完成时间从后往前推(用最早开始时间 - a），取最小的</p>\n<p>&#x3D;&#x3D;最早开始时间 &#x3D; 最晚完成时间 —— 关键路径&#x3D;&#x3D;</p>\n<p>活动（A）：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>a1</th>\n<th>a2</th>\n<th>a3</th>\n<th>a4</th>\n<th>a5</th>\n<th>a6</th>\n<th>a7</th>\n<th>a8</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>最早开始时间</td>\n<td>0</td>\n<td>0</td>\n<td>3</td>\n<td>3</td>\n<td>2</td>\n<td>2</td>\n<td>6</td>\n<td>6</td>\n</tr>\n<tr>\n<td>最晚完成时间</td>\n<td>1</td>\n<td>0</td>\n<td>4</td>\n<td>4</td>\n<td>2</td>\n<td>5</td>\n<td>6</td>\n<td>7</td>\n</tr>\n</tbody></table>\n<p>最早开始时间取箭头的出发点的最早开始时间，最晚完成时间取箭头指向的点的最晚完成时间 - a</p>\n<p>&#x3D;&#x3D;最早开始时间 &#x3D; 最晚完成时间 —— 关键活动&#x3D;&#x3D;</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVB2NDExNTd4aC8/cD05JnNwbV9pZF9mcm9tPXBhZ2VEcml2ZXI=\">Ford-Fulkerson Algorithm 寻找网络最大流</span></p>\n<p>用Residual Graph添加反向路径，然后用原图减去Residual Graph</p>\n<p>worst-case time complexity: O(f*m)\t\tf是最大流的大小，m是边数</p>\n<p><strong>最小生成树</strong></p>\n<p>最小生成树：从连通无向图中找出一棵树（包含所有n个节点和n-1条边），同时边的权重之和要最小</p>\n<p>Prim算法：随便取一个根节点记作visited，不断寻找visited节点和unvisited节点之间权重最小的边</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUE1NDExTTd6Yy8/c3BtX2lkX2Zyb209cGFnZURyaXZlciZ2ZF9zb3VyY2U9MWE3ZDhmNTk2ZjNkZmU0MGZlZTM0Yzg1OGVkNDdlNzM=\">Prim算法 寻找最小生成树</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVN2NDExVjc4MS8/c3BtX2lkX2Zyb209MzMzLjc4OCZ2ZF9zb3VyY2U9MWE3ZDhmNTk2ZjNkZmU0MGZlZTM0Yzg1OGVkNDdlNzM=\">Kruskal算法：</span>（1）创建一个队列，将边按权重排序，最小的在最上面；（2）从顶端不断dequeue，如果符合就在图中圈出那条边</p>\n<p>——并查集</p>\n<p><strong>一句话：Prim算法对点做操作，Kruskal算法对边做操作</strong></p>\n<h1 id=\"HW11\"><a href=\"#HW11\" class=\"headerlink\" title=\"HW11\"></a>HW11</h1><h5 id=\"1-1-For-a-graph-if-each-vertex-has-an-even-degree-or-only-two-vertexes-have-odd-degree-we-can-find-a-cycle-that-visits-every-edge-exactly-once\"><a href=\"#1-1-For-a-graph-if-each-vertex-has-an-even-degree-or-only-two-vertexes-have-odd-degree-we-can-find-a-cycle-that-visits-every-edge-exactly-once\" class=\"headerlink\" title=\"1-1 For a graph, if each vertex has an even degree or only two vertexes have odd degree, we can find a cycle that visits every edge exactly once\"></a>1-1 For a graph, if each vertex has an even degree or only two vertexes have odd degree, we can find a cycle that visits every edge exactly once</h5><p>F</p>\n<p>欧拉回路：当且仅当图中每个顶点的度数都为偶数，并且图是连通的（一笔画）</p>\n<p>欧拉路径：当且仅当图中恰有两个顶点的度数为奇数，其余顶点的度数都为偶数，并且图是连通的</p>\n<p>哈密顿Cycle：经过所有节点的环</p>\n<p>哈密顿Path：经过所有节点的回路</p>\n<p>DFS:寻路–回溯</p>\n<h5 id=\"2-1-Apply-DFS-to-a-directed-acyclic-graph-and-output-the-vertex-before-the-end-of-each-recursion-The-output-sequence-will-be\"><a href=\"#2-1-Apply-DFS-to-a-directed-acyclic-graph-and-output-the-vertex-before-the-end-of-each-recursion-The-output-sequence-will-be\" class=\"headerlink\" title=\"2-1 Apply DFS to a directed acyclic graph, and output the vertex before the end of each recursion. The output sequence will be:\"></a>2-1 Apply DFS to a directed acyclic graph, and output the vertex before the end of each recursion. The output sequence will be:</h5><p>A.unsorted</p>\n<p>&#x3D;&#x3D;B.topologically sorted&#x3D;&#x3D;</p>\n<p>C.reversely topologically sorted</p>\n<p>D.None of the above</p>\n<p>Biconnected:（重连通）</p>\n<p><img data-src=\"/image-20240116215902974.png\"><br><img data-src=\"/image-20240116221328431.png\"></p>\n<p>插入排序：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InsertionSort</span><span class=\"params\">( ElementType A[], <span class=\"type\">int</span> N )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> j, P;</span><br><span class=\"line\">    ElementType Tmp;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(P=<span class=\"number\">1</span>; P&lt;N; P++)&#123;</span><br><span class=\"line\">        Tmp = A[P];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j=P; j&gt;<span class=\"number\">0</span> &amp;&amp; A[j<span class=\"number\">-1</span>]&gt;Tmp; j--)&#123;</span><br><span class=\"line\">            A[j]=A[j<span class=\"number\">-1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        A[j]=Tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>worst-case time complexity: $$O(N^2)$$</p>\n<p>best-case time complexity: $$O(N)$$</p>\n<p>$$T(N,I) &#x3D; O(I+N)$$ —— I:逆序对</p>\n<p>对于任意一个交换相邻元素的排序算法，平均时间复杂度都是$$\\Omega(N^2)$$.</p>\n<p><strong>ShellSort</strong></p>\n<p><strong>希尔排序</strong></p>\n<p>5-sort</p>\n<p>3-sort</p>\n<p>1-sort</p>\n<p>每一步都是插入排序</p>\n<p>（1）Define an increment sequence h1 &lt; h2 &lt; … &lt; ht  ( h1 &#x3D; 1 )</p>\n<p>（2）Define an $$h_k-sort$$ at each phase for k &#x3D; t, t - 1, …, 1</p>\n<p><strong>Shell’s increment sequence：$$h_t&#x3D;\\lfloor N \\rfloor$$, $$h_k &#x3D; \\lfloor h_k+1 &#x2F; 2\\rfloor $$</strong></p>\n<p>worst-case time complexity: $$\\theta(N^2)$$</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Shellsort</span><span class=\"params\">( ElementType A[ ], <span class=\"type\">int</span> N )</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">      <span class=\"type\">int</span>  i, j, Increment; </span><br><span class=\"line\">      ElementType  Tmp; </span><br><span class=\"line\">      <span class=\"keyword\">for</span> ( Increment = N / <span class=\"number\">2</span>; Increment &gt; <span class=\"number\">0</span>; Increment /= <span class=\"number\">2</span> )  </span><br><span class=\"line\">\t<span class=\"comment\">/*h sequence */</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( i = Increment; i &lt; N; i++ ) &#123; <span class=\"comment\">/* insertion sort */</span></span><br><span class=\"line\">\t      Tmp = A[ i ]; </span><br><span class=\"line\">\t      <span class=\"keyword\">for</span> ( j = i; j &gt;= Increment; j - = Increment ) </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>( Tmp &lt; A[ j - Increment ] ) </span><br><span class=\"line\">\t\t      A[ j ] = A[ j - Increment ]; </span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> </span><br><span class=\"line\">\t\t      <span class=\"keyword\">break</span>; </span><br><span class=\"line\">\t\tA[ j ] = Tmp; </span><br><span class=\"line\">\t&#125; <span class=\"comment\">/* end for-I and for-Increment loops */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>**Hibbard’s Increment Sequence: ** $$h_k &#x3D; 2^k-1$$</p>\n<p>worst-case time complexity: $$\\theta(N$$^2&#x2F;3^$$)$$</p>\n<p>in-place 不需要申请其余的空间</p>\n<p>stability （插入排序稳定，希尔排序不稳定）</p>\n<p><strong>HeapSort</strong></p>\n<p><strong>堆排序</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Heapsort</span><span class=\"params\">( ElementType A[ ], <span class=\"type\">int</span> N )</span> </span><br><span class=\"line\">&#123;  <span class=\"type\">int</span> i; </span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( i = N / <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i - - ) <span class=\"comment\">/* BuildHeap */</span> </span><br><span class=\"line\">        PercDown( A, i, N ); </span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( i = N - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i - - ) &#123; </span><br><span class=\"line\">        Swap( &amp;A[ <span class=\"number\">0</span> ], &amp;A[ i ] ); <span class=\"comment\">/* DeleteMax */</span> </span><br><span class=\"line\">        PercDown( A, <span class=\"number\">0</span>, i ); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度$$O(NlogN)$$</p>\n<p>归并排序</p>\n<p>$$O(NlogN)$$</p>\n<p>快排</p>\n",
            "tags": [
                "fds"
            ]
        }
    ]
}