{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog • All posts by \"register allocation\" tag",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/06/18/computer-science/compile-principles/ch11/",
            "url": "http://example.com/2025/06/18/computer-science/compile-principles/ch11/",
            "title": "Register Allocation",
            "date_published": "2025-06-17T16:00:00.000Z",
            "content_html": "<h1 id=\"Register-Allocation\"><a href=\"#Register-Allocation\" class=\"headerlink\" title=\"Register Allocation\"></a>Register Allocation</h1><p>目标：</p>\n<ul>\n<li>Map temporaries to registers</li>\n<li>Preserve program semantics</li>\n<li>Optimize performance</li>\n</ul>\n<h2 id=\"图着色算法\"><a href=\"#图着色算法\" class=\"headerlink\" title=\"图着色算法\"></a>图着色算法</h2><p>冲突图是一个无向图，冲突图中，每个节点是一个变量（寄存器分配的候选对象）。<br>如果两个变量在同一时刻是活跃的（live），它们就有冲突边（interference edge），表示它们不能被分配到同一个寄存器<br>冲突信息可以用矩阵或者图来表示</p>\n<h3 id=\"冲突图构建\"><a href=\"#冲突图构建\" class=\"headerlink\" title=\"冲突图构建\"></a>冲突图构建</h3><p>我们从一个中间代码的指令出发，根据live-out（就是out集合）添加冲突边：</p>\n<ol>\n<li>非 move 指令（不是a :&#x3D; b这种）<br>比如a :&#x3D; b1 + b2<br>对于每个bn和a之间都添加冲突边<br>比如下面这个例子：<br><img data-src=\"/f1.jpg\"><br>可以看到有ab ac同时live了，所以为a和b，a和c添加冲突边</li>\n<li>move指令<br>对于move指令，不添加冲突边：<br>比如对于第 2 条指令 d ← a，out[2] &#x3D; {a, e}，那么只对d和e添加冲突边，对d和a不添加<br>但如果move之后又对d重新赋值了，那么还是要添加上d和a之间的冲突边</li>\n</ol>\n<h3 id=\"冲突图着色\"><a href=\"#冲突图着色\" class=\"headerlink\" title=\"冲突图着色\"></a>冲突图着色</h3><p>Vertex Coloring: 给图中的顶点着色，使得图中没有边连接相同颜色的顶点<br>K-Coloring: 颜色数小于K</p>\n<h4 id=\"Kempe-简化\"><a href=\"#Kempe-简化\" class=\"headerlink\" title=\"Kempe 简化\"></a>Kempe 简化</h4><p>如果图中有一个节点 n 的度数 &lt; K（也就是它的冲突数少于寄存器数），那我们可以“临时删掉”这个节点，并递归给剩下的图上色。之后再把这个节点加回来，它一定可以找到一个合法颜色。</p>\n<p>如果图中所有节点的度数都 ≥ K，那就可能要进入溢出（spill）处理<br>算法步骤：</p>\n<ol>\n<li>build: 画冲突图</li>\n<li>simplify the nodes with insignificant degree: 选取degree &lt; k的节点，压栈</li>\n<li>select (or color) while rebuilding the graph: 出栈，分配颜色<br>A vertex such that its degree &lt; k is always k-colorable<br>Remove such vertices and push them to a stack until the graph becomes empty<br>移除顶点的同时移除相关边</li>\n</ol>\n<h4 id=\"Coalescing\"><a href=\"#Coalescing\" class=\"headerlink\" title=\"Coalescing\"></a>Coalescing</h4><p>遵循两种策略：</p>\n<ul>\n<li><strong>Briggs Criteria</strong>: 如果将节点 <code>a</code> 和 <code>b</code> 合并后得到的新节点 <code>ab</code>，其相邻节点中degree &gt;&#x3D; K 的节点（significant-degree neighbors）的数量 小于 K，则可以合并</li>\n<li><strong>George Criteria</strong>: 如果对节点 <code>a</code> 和 <code>b</code>，对于 <code>a</code> 的每一个邻居 <code>t</code>， 满足二者其中之一，就能合并：<ul>\n<li><code>t</code> 本来就和 <code>b</code> 有冲突</li>\n<li><code>t</code>的degree &lt; K</li>\n</ul>\n</li>\n</ul>\n<p>整体流程：<br><img data-src=\"/f2.jpg\"></p>\n<ul>\n<li>为什么要simplify non-move-related node: 保留move-related的后续可以合并</li>\n<li>freeze: 当我们遇到两个变量 a ← b 有 move 指令，但现在还不能安全合并，我们又不想立刻 spill，于是我们“冻结”这条 move 指令：不再试图合并 a 和 b，而是让其中一个变成非 move 相关（non-move-related），进入 Simplify 阶段继续处理</li>\n<li>spill规则：优先移除不被经常使用、degree大的节点<ul>\n<li>实际溢出的priority计算，对于节点a：<br>$$<br>priority(t) &#x3D; \\frac{(use + def outside loop) + loop_num * (use + def inside loop)}{D}<br>$$</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "Register Allocation"
            ]
        }
    ]
}