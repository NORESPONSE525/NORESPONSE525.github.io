<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>NoResponse&#39;s Blog • Posts by &#34;register allocation&#34; tag</title>
        <link>http://example.com</link>
        <description>成分复杂的CSer from ZJU</description>
        <language>en</language>
        <pubDate>Wed, 18 Jun 2025 00:00:00 +0800</pubDate>
        <lastBuildDate>Wed, 18 Jun 2025 00:00:00 +0800</lastBuildDate>
        <category>人工智能</category>
        <category>软件工程</category>
        <category>自监督学习</category>
        <category>操作系统</category>
        <category>线性表</category>
        <category>数据结构</category>
        <category>编译原理</category>
        <category>Register Allocation</category>
        <category>语法分析</category>
        <category>词法分析</category>
        <category>Liveness Analysis</category>
        <category>抽象语法</category>
        <category>语义分析</category>
        <category>活动记录</category>
        <category>中间代码</category>
        <category>指令选择</category>
        <category>Basic Blocks and Traces</category>
        <category>计算机组成</category>
        <category>计算机网络</category>
        <category>数据的表示与运算</category>
        <category>存储系统</category>
        <category>总线</category>
        <category>CPU</category>
        <category>I/O</category>
        <category>指令系统</category>
        <category>错题</category>
        <item>
            <guid isPermalink="true">http://example.com/2025/06/18/computer-science/compile-principles/ch11/</guid>
            <title>Register Allocation</title>
            <link>http://example.com/2025/06/18/computer-science/compile-principles/ch11/</link>
            <category>Register Allocation</category>
            <pubDate>Wed, 18 Jun 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Register-Allocation&#34;&gt;&lt;a href=&#34;#Register-Allocation&#34; class=&#34;headerlink&#34; title=&#34;Register Allocation&#34;&gt;&lt;/a&gt;Register Allocation&lt;/h1&gt;&lt;p&gt;目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Map temporaries to registers&lt;/li&gt;
&lt;li&gt;Preserve program semantics&lt;/li&gt;
&lt;li&gt;Optimize performance&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;图着色算法&#34;&gt;&lt;a href=&#34;#图着色算法&#34; class=&#34;headerlink&#34; title=&#34;图着色算法&#34;&gt;&lt;/a&gt;图着色算法&lt;/h2&gt;&lt;p&gt;冲突图是一个无向图，冲突图中，每个节点是一个变量（寄存器分配的候选对象）。&lt;br&gt;如果两个变量在同一时刻是活跃的（live），它们就有冲突边（interference edge），表示它们不能被分配到同一个寄存器&lt;br&gt;冲突信息可以用矩阵或者图来表示&lt;/p&gt;
&lt;h3 id=&#34;冲突图构建&#34;&gt;&lt;a href=&#34;#冲突图构建&#34; class=&#34;headerlink&#34; title=&#34;冲突图构建&#34;&gt;&lt;/a&gt;冲突图构建&lt;/h3&gt;&lt;p&gt;我们从一个中间代码的指令出发，根据live-out（就是out集合）添加冲突边：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;非 move 指令（不是a :&amp;#x3D; b这种）&lt;br&gt;比如a :&amp;#x3D; b1 + b2&lt;br&gt;对于每个bn和a之间都添加冲突边&lt;br&gt;比如下面这个例子：&lt;br&gt;&lt;img data-src=&#34;/f1.jpg&#34;&gt;&lt;br&gt;可以看到有ab ac同时live了，所以为a和b，a和c添加冲突边&lt;/li&gt;
&lt;li&gt;move指令&lt;br&gt;对于move指令，不添加冲突边：&lt;br&gt;比如对于第 2 条指令 d ← a，out[2] &amp;#x3D; {a, e}，那么只对d和e添加冲突边，对d和a不添加&lt;br&gt;但如果move之后又对d重新赋值了，那么还是要添加上d和a之间的冲突边&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;冲突图着色&#34;&gt;&lt;a href=&#34;#冲突图着色&#34; class=&#34;headerlink&#34; title=&#34;冲突图着色&#34;&gt;&lt;/a&gt;冲突图着色&lt;/h3&gt;&lt;p&gt;Vertex Coloring: 给图中的顶点着色，使得图中没有边连接相同颜色的顶点&lt;br&gt;K-Coloring: 颜色数小于K&lt;/p&gt;
&lt;h4 id=&#34;Kempe-简化&#34;&gt;&lt;a href=&#34;#Kempe-简化&#34; class=&#34;headerlink&#34; title=&#34;Kempe 简化&#34;&gt;&lt;/a&gt;Kempe 简化&lt;/h4&gt;&lt;p&gt;如果图中有一个节点 n 的度数 &amp;lt; K（也就是它的冲突数少于寄存器数），那我们可以“临时删掉”这个节点，并递归给剩下的图上色。之后再把这个节点加回来，它一定可以找到一个合法颜色。&lt;/p&gt;
&lt;p&gt;如果图中所有节点的度数都 ≥ K，那就可能要进入溢出（spill）处理&lt;br&gt;算法步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;build: 画冲突图&lt;/li&gt;
&lt;li&gt;simplify the nodes with insignificant degree: 选取degree &amp;lt; k的节点，压栈&lt;/li&gt;
&lt;li&gt;select (or color) while rebuilding the graph: 出栈，分配颜色&lt;br&gt;A vertex such that its degree &amp;lt; k is always k-colorable&lt;br&gt;Remove such vertices and push them to a stack until the graph becomes empty&lt;br&gt;移除顶点的同时移除相关边&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;Coalescing&#34;&gt;&lt;a href=&#34;#Coalescing&#34; class=&#34;headerlink&#34; title=&#34;Coalescing&#34;&gt;&lt;/a&gt;Coalescing&lt;/h4&gt;&lt;p&gt;遵循两种策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Briggs Criteria&lt;/strong&gt;: 如果将节点 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 合并后得到的新节点 &lt;code&gt;ab&lt;/code&gt;，其相邻节点中degree &amp;gt;&amp;#x3D; K 的节点（significant-degree neighbors）的数量 小于 K，则可以合并&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;George Criteria&lt;/strong&gt;: 如果对节点 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt;，对于 &lt;code&gt;a&lt;/code&gt; 的每一个邻居 &lt;code&gt;t&lt;/code&gt;， 满足二者其中之一，就能合并：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt; 本来就和 &lt;code&gt;b&lt;/code&gt; 有冲突&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt;的degree &amp;lt; K&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整体流程：&lt;br&gt;&lt;img data-src=&#34;/f2.jpg&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么要simplify non-move-related node: 保留move-related的后续可以合并&lt;/li&gt;
&lt;li&gt;freeze: 当我们遇到两个变量 a ← b 有 move 指令，但现在还不能安全合并，我们又不想立刻 spill，于是我们“冻结”这条 move 指令：不再试图合并 a 和 b，而是让其中一个变成非 move 相关（non-move-related），进入 Simplify 阶段继续处理&lt;/li&gt;
&lt;li&gt;spill规则：优先移除不被经常使用、degree大的节点&lt;ul&gt;
&lt;li&gt;实际溢出的priority计算，对于节点a：&lt;br&gt;$$&lt;br&gt;priority(t) &amp;#x3D; \frac{(use + def outside loop) + loop_num * (use + def inside loop)}{D}&lt;br&gt;$$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
    </channel>
</rss>
