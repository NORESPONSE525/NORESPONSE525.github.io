{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog • All posts by \"面向对象\" category",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/12/14/oop/java/",
            "url": "http://example.com/2025/12/14/oop/java/",
            "title": "JAVA基础",
            "date_published": "2025-12-13T16:00:00.000Z",
            "content_html": "<div class=\"note info\">\n<p>参考资料：菜鸟教程<br>\n不懂问 g 老师 /qw 老师</p>\n</div>\n<blockquote>\n<p>Q1: .java 是怎么变成可执行文件的？<br>\n.java → .class → JVM 运行</p>\n<ol>\n<li>编写.java</li>\n<li>javac 把.java 变成.class（平台无关的字节码文件，只能被 JVM 理解和执行）</li>\n<li>通过 JVM 运行：JVM 加载 HelloWorld.class 解释或 JIT（即时编译）成机器码</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>Q2: 关于 main 方法<br>\n每个类都可以有自己的 main 方法，你可以在命令行或 IDE 中选择运行任意一个<br>\n java A   # 输出: A’s main<br>\njava B   # 输出: B’s main<br>\n 但一个程序启动时只能指定一个主类:<br>\njava 全限定类名<br>\n JVM 只会去这个类里找 main 方法。其他类即使有 main，也不会自动执行。</p>\n</blockquote>\n<h1 id=\"java基础语法\"><a class=\"markdownIt-Anchor\" href=\"#java基础语法\">#</a> JAVA 基础语法</h1>\n<ol>\n<li>基本语法<br>\n类名首字母大写，方法名小写字母开头，源文件名必须和类名相同<br>\n所有的 Java 程序由 <code>public static void main(String[] args)</code>  方法开始执行</li>\n<li>标志符<br>\n数字字母下划线和<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>符，不能以数字开头（比</mtext><mi>c</mi><mi mathvariant=\"normal\">/</mi><mi>c</mi><mi>p</mi><mi>p</mi><mtext>多了个</mtext></mrow><annotation encoding=\"application/x-tex\">符，不能以数字开头（比c/cpp多了个</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord cjk_fallback\">符</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">不</span><span class=\"mord cjk_fallback\">能</span><span class=\"mord cjk_fallback\">以</span><span class=\"mord cjk_fallback\">数</span><span class=\"mord cjk_fallback\">字</span><span class=\"mord cjk_fallback\">开</span><span class=\"mord cjk_fallback\">头</span><span class=\"mord cjk_fallback\">（</span><span class=\"mord cjk_fallback\">比</span><span class=\"mord mathnormal\">c</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">p</span><span class=\"mord cjk_fallback\">多</span><span class=\"mord cjk_fallback\">了</span><span class=\"mord cjk_fallback\">个</span></span></span></span>符）</li>\n<li>修饰符<br>\n访问控制修饰符: default, public , protected, private<br>\n 非访问控制修饰符: final, abstract, static, synchronized</li>\n<li>变量<br>\n局部变量<br>\n类变量（静态变量）<br>\n成员变量（非静态变量）</li>\n<li>JAVA 枚举<br>\n enum<br>\n 和 c/cpp 的枚举一样</li>\n</ol>\n<figure class=\"highlight java\"><figcaption><span>枚举</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">FreshJuice</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">enum</span> <span class=\"title class_\">FreshJuiceSize</span>&#123; SMALL, MEDIUM , LARGE &#125;</span><br><span class=\"line\">   FreshJuiceSize size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FreshJuiceTest</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">      <span class=\"type\">FreshJuice</span> <span class=\"variable\">juice</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FreshJuice</span>();</span><br><span class=\"line\">      juice.size = FreshJuice.FreshJuiceSize.MEDIUM  ;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>java 关键字<br>\n看起来和 cpp 差不多，<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucnVub29iLmNvbS9qYXZhL2phdmEtYmFzaWMtc3ludGF4Lmh0bWw=\">https://www.runoob.com/java/java-basic-syntax.html</span></li>\n<li>注释<br>\n单行注释 //<br>\n 多行注释 /* <em>/<br>\n 文档注释 /</em>*  */，方便被工具提取生成文档<br>\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucnVub29iLmNvbS9qYXZhL2phdmEtZG9jdW1lbnRhdGlvbi5odG1s\"> https://www.runoob.com/java/java-documentation.html</span></li>\n</ol>\n<figure class=\"highlight java\"><figcaption><span>文档注释</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*** 这个类绘制一个条形图</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@author</span> runoob</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@version</span> 1.2</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"java-对象和类\"><a class=\"markdownIt-Anchor\" href=\"#java-对象和类\">#</a> JAVA 对象和类</h1>\n<p>其他的和 cpp 差不多</p>\n<ul>\n<li>abstract<br>\n 使用抽象类和接口来定义必须实现的方法，不提供具体实现。<br>\n示例：<br>\n抽象类： <code>public abstract class Shape &#123; abstract void draw(); &#125;</code> <br>\n 接口： <code>public interface Animal &#123; void eat(); &#125;</code></li>\n<li void drive();>interface<br>\n 定义类必须实现的方法，支持多重继承。<br>\n示例：public interface Drivable</li>\n<li>method overloading 方法重载<br>\n同一个类中，方法名相同<br>\n在 Java 中，如果你没有显式定义任何构造函数（constructor），编译器会自动为你提供一个 “隐式” 的无参构造函数（也叫默认构造函数），但如果有了带参构造就不会自动创建一个无参构造，此时用无参构造函数会报错</li>\n</ul>\n<div class=\"note danger\">\n<p>继承中的陷阱（重要！）<br>\n子类构造函数必须调用父类的某个构造函数（通过 super (…)）。<br>\n如果父类没有无参构造函数，而子类又没显式调用 super (…)，就会出错</p>\n<figure class=\"highlight java\"><figcaption><span>构造</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Parent</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Parent</span><span class=\"params\">(String name)</span> &#123; &#125; <span class=\"comment\">// 只有带参构造</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Parent</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Child</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 编译器自动加 super(); → 但 Parent 没有无参构造！</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解决方法：显示调用 <code>super(&quot;default&quot;)</code></p>\n<figure class=\"highlight java\"><figcaption><span>构造</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Parent</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Child</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(<span class=\"string\">&quot;default&quot;</span>); <span class=\"comment\">// 显式调用</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Q: 子类构造函数没有参数，但父类只有带参构造，那父类到底用什么值来构造？<br>\n子类在自己的无参构造函数内部，显式传了一个 “固定值” 给父类的带参构造函数。</p>\n</div>\n<figure class=\"highlight java\"><figcaption><span>方法重载</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MathUtils</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">double</span> a, <span class=\"type\">double</span> b)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>例子：</p>\n<figure class=\"highlight java\"><figcaption><span>对象和类</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Puppy</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 构造器</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Puppy</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;小狗的名字是 : &quot;</span> + name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 设置 age 的值</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setAge</span><span class=\"params\">(<span class=\"type\">int</span> age)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 获取 age 的值</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getAge</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 获取 name 的值</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 主方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建对象</span></span><br><span class=\"line\">        <span class=\"type\">Puppy</span> <span class=\"variable\">myPuppy</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Puppy</span>(<span class=\"string\">&quot;Tommy&quot;</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">// 通过方法来设定 age</span></span><br><span class=\"line\">        myPuppy.setAge(<span class=\"number\">2</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">// 调用另一个方法获取 age</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">age</span> <span class=\"operator\">=</span> myPuppy.getAge();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;小狗的年龄为 : &quot;</span> + age);</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">// 也可以直接访问成员变量（通过 getter 方法）</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;变量值 : &quot;</span> + myPuppy.getAge());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"源文件声明规则\"><a class=\"markdownIt-Anchor\" href=\"#源文件声明规则\">#</a> 源文件声明规则</h1>\n<p>在一个源文件中定义多个类，并且还有 import 语句和 package 语句时，要注意：</p>\n<ol>\n<li>一个源文件中只能有一个 public 类，一个源文件可以有多个非 public 类</li>\n<li>源文件名必须与源文件中 public 类名相同</li>\n<li>如果一个类定义在某个包中，那么 package 语句应该在源文件的首行<br>\n Java 编译器（javac）和 JVM 依赖 “一个 public 类 = 一个 .java 文件” 的约定来快速定位类。<br>\n如果允许多个 public 类在一个文件中，编译器就无法通过类名直接找到对应的源文件</li>\n<li>如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面<br>\n <code>package</code>  声明用于指定当前 Java 类所属的 “命名空间”（namespace），防止类名冲突，并建立代码的逻辑分组和访问控制边界。</li>\n</ol>\n<figure class=\"highlight java\"><figcaption><span>源文件声明规则</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// HelloWorld.java</span></span><br><span class=\"line\"><span class=\"comment\">// 当你编译带包的 Java 文件时，编译器会自动按包名创建目录结构：</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> com.example.hello;  <span class=\"comment\">// 包声明</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorld</span> &#123; &#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">执行javac -d out HelloWorld.java编译</span></span><br><span class=\"line\"><span class=\"comment\">编译之后的结构</span></span><br><span class=\"line\"><span class=\"comment\">out/</span></span><br><span class=\"line\"><span class=\"comment\">└── com/</span></span><br><span class=\"line\"><span class=\"comment\">    └── example/</span></span><br><span class=\"line\"><span class=\"comment\">        └── hello/</span></span><br><span class=\"line\"><span class=\"comment\">            └── HelloWorld.class</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明</li>\n</ol>\n<figure class=\"highlight java\"><figcaption><span>import</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.util.StringUtils;</span><br></pre></td></tr></table></figure>\n<p>让当前类在代码中可以直接使用其他包中的类，而不用写全限定名，没有 import 的话就得：</p>\n<figure class=\"highlight java\"><figcaption><span>import</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        java.util.ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">java</span>.util.ArrayList&lt;&gt;();</span><br><span class=\"line\">        com.example.util.StringUtils.isEmpty(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有了 import 之后：</p>\n<figure class=\"highlight java\"><figcaption><span>import</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.util.StringUtils;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(); <span class=\"comment\">// 不用写 java.util.</span></span><br><span class=\"line\">        StringUtils.isEmpty(<span class=\"string\">&quot;hello&quot;</span>);              <span class=\"comment\">// 不用写 com.example.util.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div class=\"note danger\">\n<ol>\n<li><code>import</code>  只是让编译器知道某个简短名字（如 <code>ArrayList</code> ）对应哪个全名（ <code>java.util.ArrayList</code> ）。类的实际加载是由 <code>JVM</code>  在运行时按需完成的，和 <code>import</code>  无关。</li>\n<li>同一包内的类可以直接使用，无需 <code>import</code></li>\n<li>可以 import 某个包下的所有类： <code>import com.example.util.*;</code> <br>\n 或者 import 某个类： <code>import com.example.util.StringUtils;</code></li>\n<li>在 Java 中，如果一个 <code>.java</code>  文件没有 <code>package</code>  语句，那么它就属于 “默认包”（unnamed package /default package）。所有在默认包中的类，彼此之间可以直接访问，无需 import</li>\n</ol>\n</div>\n<h1 id=\"java-基本数据类型\"><a class=\"markdownIt-Anchor\" href=\"#java-基本数据类型\">#</a> Java 基本数据类型</h1>\n<h2 id=\"不一样的bool-boolean\"><a class=\"markdownIt-Anchor\" href=\"#不一样的bool-boolean\">#</a> 不一样的：bool-&gt;boolean</h2>\n<p>java 的成员变量都有默认初始值</p>\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>byte</td>\n<td>0</td>\n</tr>\n<tr>\n<td>short</td>\n<td>0</td>\n</tr>\n<tr>\n<td>int</td>\n<td>0</td>\n</tr>\n<tr>\n<td>long</td>\n<td>0L</td>\n</tr>\n<tr>\n<td>float</td>\n<td>0.0f</td>\n</tr>\n<tr>\n<td>double</td>\n<td>0.0d</td>\n</tr>\n<tr>\n<td>char</td>\n<td>‘\\u0000’</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>false</td>\n</tr>\n<tr>\n<td>引用类型</td>\n<td>null</td>\n</tr>\n</tbody>\n</table>\n<p>Java 的局部变量（在方法、构造函数或代码块中定义的变量）如果没有显式初始化，编译器会报错 —— 不允许使用未初始化的局部变量。（c/cpp 没有初始化会是一个随机的垃圾值）</p>\n<div class=\"note danger\">\n<p>引用类型：相当于指针（不是引用！！！）</p>\n</div>\n<figure class=\"highlight java\"><figcaption><span>引用类型</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Person</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;Alice&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>引用类型变量 p 的值是 Person 对象的地址，而不是对象本身。<br>\n种类：</p>\n<ol>\n<li>类类型</li>\n</ol>\n<figure class=\"highlight java\"><figcaption><span>类类型</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Alice&quot;</span>;           <span class=\"comment\">// String 是类</span></span><br><span class=\"line\"><span class=\"type\">Scanner</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(...);   <span class=\"comment\">// 自定义或标准库类</span></span><br><span class=\"line\"><span class=\"type\">MyClass</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyClass</span>();     <span class=\"comment\">// 你自己写的类</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>接口类型</li>\n</ol>\n<figure class=\"highlight java\"><figcaption><span>接口类型</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(); <span class=\"comment\">// List 是接口，ArrayList 是实现类</span></span><br><span class=\"line\"><span class=\"type\">Runnable</span> <span class=\"variable\">task</span> <span class=\"operator\">=</span> () -&gt; System.out.println(<span class=\"string\">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>数组类型<br>\n数组本身总是引用类型</li>\n</ol>\n<figure class=\"highlight java\"><figcaption><span>数组类型</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>[] numbers = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">5</span>];      <span class=\"comment\">// 数组是引用类型，元素是基本类型</span></span><br><span class=\"line\">String[] names = &#123;<span class=\"string\">&quot;Alice&quot;</span>, <span class=\"string\">&quot;Bob&quot;</span>&#125;; <span class=\"comment\">// 数组和元素都是引用类型</span></span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>枚举类型</li>\n</ol>\n<figure class=\"highlight java\"><figcaption><span>枚举类型</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Color</span> &#123; RED, GREEN, BLUE &#125;</span><br><span class=\"line\"><span class=\"type\">Color</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> Color.RED; <span class=\"comment\">// Color 是引用类型</span></span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>引用类型<br>\n特性：</li>\n</ol>\n<ul>\n<li>默认为 null</li>\n<li>赋值是 “共享引用”</li>\n</ul>\n<figure class=\"highlight java\"><figcaption><span>“共享引用”</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Person</span> <span class=\"variable\">p1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;Alice&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Person</span> <span class=\"variable\">p2</span> <span class=\"operator\">=</span> p1;  <span class=\"comment\">// p2 和 p1 指向同一个对象！</span></span><br><span class=\"line\"></span><br><span class=\"line\">p2.setName(<span class=\"string\">&quot;Bob&quot;</span>);</span><br><span class=\"line\">System.out.println(p1.getName()); <span class=\"comment\">// 输出 &quot;Bob&quot;！</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用 == 比较的是引用地址，不是内容</li>\n</ul>\n<figure class=\"highlight java\"><figcaption><span>使用 </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(a == b);      <span class=\"comment\">// false（不同对象）</span></span><br><span class=\"line\">System.out.println(a.equals(b)); <span class=\"comment\">// true（内容相同）</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>方法参数传递是 “按值传递”，但对于引用类型，传递的是引用的副本（不是对象本身，也不是引用本身）</li>\n</ul>\n<figure class=\"highlight java\"><figcaption><span>传递</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">changeName</span><span class=\"params\">(Person p)</span> &#123;</span><br><span class=\"line\">    p.setName(<span class=\"string\">&quot;Charlie&quot;</span>); <span class=\"comment\">// 修改对象内容 → 外部可见</span></span><br><span class=\"line\">    p = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;David&quot;</span>); <span class=\"comment\">// 重新赋值引用 → 外部不可见</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Person</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;Alice&quot;</span>);</span><br><span class=\"line\">changeName(x);</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">栈（Stack）                     堆（Heap）</span></span><br><span class=\"line\"><span class=\"comment\">┌─────┐                       ┌──────────────────────┐</span></span><br><span class=\"line\"><span class=\"comment\">│  x  │──────────────────────▶│ Person&#123;name=&quot;Alice&quot;&#125; │</span></span><br><span class=\"line\"><span class=\"comment\">├─────┤                       └──────────────────────┘</span></span><br><span class=\"line\"><span class=\"comment\">│  p  │──────────────────────▶↑</span></span><br><span class=\"line\"><span class=\"comment\">└─────┘                        （p 和 x 指向同一个对象！）</span></span><br><span class=\"line\"><span class=\"comment\">---------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">栈（Stack）                     堆（Heap）</span></span><br><span class=\"line\"><span class=\"comment\">┌─────┐                       ┌──────────────────────┐</span></span><br><span class=\"line\"><span class=\"comment\">│  x  │──────────────────────▶│ Person&#123;name=&quot;Charlie&quot;&#125; │ ← 被修改了！</span></span><br><span class=\"line\"><span class=\"comment\">├─────┤                       └──────────────────────┘</span></span><br><span class=\"line\"><span class=\"comment\">│  p  │──────────────────────▶↑</span></span><br><span class=\"line\"><span class=\"comment\">└─────┘</span></span><br><span class=\"line\"><span class=\"comment\">---------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">栈（Stack）                     堆（Heap）</span></span><br><span class=\"line\"><span class=\"comment\">┌─────┐                       ┌──────────────────────┐</span></span><br><span class=\"line\"><span class=\"comment\">│  x  │──────────────────────▶│ Person&#123;name=&quot;Charlie&quot;&#125; │</span></span><br><span class=\"line\"><span class=\"comment\">├─────┤                       └──────────────────────┘</span></span><br><span class=\"line\"><span class=\"comment\">│  p  │──────────┐            </span></span><br><span class=\"line\"><span class=\"comment\">└─────┘          ▼          </span></span><br><span class=\"line\"><span class=\"comment\">             ┌──────────────────────┐</span></span><br><span class=\"line\"><span class=\"comment\">             │ Person&#123;name=&quot;David&quot;&#125; │</span></span><br><span class=\"line\"><span class=\"comment\">             └──────────────────────┘</span></span><br><span class=\"line\"><span class=\"comment\">只有 p 改变了指向,x 仍然指向原来的对象，而 p 是局部变量，方法结束后就销毁了</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">System.out.println(x.getName()); <span class=\"comment\">// 输出 &quot;Charlie&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"常量\"><a class=\"markdownIt-Anchor\" href=\"#常量\">#</a> 常量</h2>\n<p>在 Java 中使用 final 关键字来修饰常量</p>\n<figure class=\"highlight java\"><figcaption><span>常量</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">double</span> <span class=\"variable\">PI</span> <span class=\"operator\">=</span> <span class=\"number\">3.1415927</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"类型转换\"><a class=\"markdownIt-Anchor\" href=\"#类型转换\">#</a> 类型转换</h2>\n<h3 id=\"自动转\"><a class=\"markdownIt-Anchor\" href=\"#自动转\">#</a> 自动转</h3>\n<p>低的转高的</p>\n<blockquote>\n<p>低  ------------------------------------&gt;  高</p>\n<p>byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double</p>\n</blockquote>\n<h3 id=\"强制转\"><a class=\"markdownIt-Anchor\" href=\"#强制转\">#</a> 强制转</h3>\n<figure class=\"highlight java\"><figcaption><span>强制转换</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"type\">int</span>)<span class=\"number\">23.7</span> == <span class=\"number\">23</span>;        </span><br><span class=\"line\">(<span class=\"type\">int</span>)-<span class=\"number\">45.89f</span> == -<span class=\"number\">45</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"java-变量类型\"><a class=\"markdownIt-Anchor\" href=\"#java-变量类型\">#</a> Java 变量类型</h1>\n<ul>\n<li>局部变量：和 cpp 不一样的是不初始化会导致编译错误，在栈上，生命周期结束会被 JVM 自动回收。和 c/cpp 一样</li>\n<li>静态变量 / 类变量：类变量在类内用 static 修饰，所有这个类的对象共享这个变量</li>\n<li>实例变量：类不是 static 的成员变量（？）没有初始化会被赋予默认值（见上），需要考虑线程安全</li>\n<li>参数变量：形参，值传递和引用传递</li>\n</ul>\n<h1 id=\"java-修饰符\"><a class=\"markdownIt-Anchor\" href=\"#java-修饰符\">#</a> Java 修饰符</h1>\n<ol>\n<li>访问修饰符<br>\n default (即默认，什么也不写）: <mark>在同一包内可见，不同包内不可见</mark>，不使用任何修饰符。<br>\nprivate: 在同一类内可见。不能修饰类（不在其他类里面的类）<br>\npublic: 对所有类可见。<br>\nprotected: 对同一包内的类和所有子类可见。使用对象：变量、方法。 同样不能修饰不在其他类里面的类。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>修饰符</th>\n<th>当前类</th>\n<th>同一包内</th>\n<th>子孙类（同一包）</th>\n<th>子孙类（不同包）</th>\n<th>其他类（不同包）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>private</td>\n<td>Y</td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n</tr>\n<tr>\n<td>protected</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n<td>需要说明</td>\n<td>N</td>\n</tr>\n<tr>\n<td>default</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n<td>N</td>\n<td>N</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>protected<br>\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xMzMzNTUw\">https://cloud.tencent.com/developer/article/1333550</span></p>\n</blockquote>\n<ol start=\"2\">\n<li>非访问修饰符</li>\n</ol>\n<ul>\n<li>static: 静态修饰符，静态成员变量和静态方法，静态块，静态内部类。静态方法和静态成员变量一样也是类所有的，不能使用类的非静态变量（实例），只能访问静态成员变量等</li>\n<li>final: final 修饰的类不能够被继承，修饰的方法不能被继承类 override，修饰的变量为常量，是不可修改的</li>\n<li>abstruct: 抽象类（不能被实例化，只能被继承）和抽象方法（没有具体的实现，只能被 override）类似于纯虚函数</li>\n<li>synchronized: 方法同一时间只能被一个线程访问</li>\n<li>translient: transient 修饰的变量不会被序列化（反序列化出来没有该变量）</li>\n<li>volatile: 同 c/cpp</li>\n</ul>\n<h1 id><a class=\"markdownIt-Anchor\" href=\"#\">#</a> </h1>\n",
            "tags": [
                "JAVA"
            ]
        },
        {
            "id": "http://example.com/2025/10/26/oop/note/",
            "url": "http://example.com/2025/10/26/oop/note/",
            "title": "C++相关",
            "date_published": "2025-10-25T16:00:00.000Z",
            "content_html": "<ol>\n<li>\n<p>面向对象 vs 面向过程<br>\n面向对象三大特性：封装、继承、多态<br>\n c++ 不是完全面向对象的语言<br>\n封装：把数据和方法打包成一个类，隐藏实现细节，只提供接口<br>\n继承：子类继承父类的属性和方法，子类可以扩展父类的功能，实现代码复用<br>\n多态：在运行时，根据对象的实际类型，调用对应的函数。主要通过虚函数和继承实现</p>\n</li>\n<li>\n<p>C++ 编译过程<br>\n预处理 -&gt; 编译 -&gt; 汇编 -&gt; 链接<br>\n预处理：预处理指令、宏定义、包含文件 (处理 #include, #define, 条件编译等)<br>\n 编译：把源代码编译成汇编代码 (将 .cpp 转为 .s)<br>\n 汇编：把汇编代码编译成机器码<br>\n链接：把多个对象文件链接成可执行文件 (将多个目标文件和库合并成可执行文件)<br>\n<mark> 第三方库就是在第 4 步 —— 链接（Linking）阶段加入的</mark><br>\n在 链接阶段，通过 -lxxx（如 -lcurl）告诉链接器：“我要用这个库”，然后链接器去找到对应的 静态库（.a 或 .lib）或动态库（.so 或 .dll）<br>\n静态库在在编译过程中（链接阶段）被载入可执行程序，生成的可执行文件体积较大<br>\n动态库是在运行时才载入内存，但更新库后需要重新编译。<mark>动态库是运行时库</mark></p>\n</li>\n<li>\n<p>静态链接和动态链接<br>\n静态链接：把所有用到的库文件都链接到可执行文件中，编译速度慢，但运行速度快<br>\n动态链接：把所有用到的库文件都放到一个单独的文件中，运行时再加载，编译速度快，但运行速度慢</p>\n</li>\n<li>\n<p>静态多态（编译时多态） 和 动态多态（运行时多态）</p>\n</li>\n</ol>\n<ul>\n<li>动态多态（Dynamic Polymorphism）—— 运行时多态<br>\n这是通过 继承 + 虚函数（virtual function） 实现的。动态多态是通过虚函数重写实现的，是在运行期间确定的多态，是一种<mark>晚绑定</mark>机制（或<mark>动态绑定</mark>），在运行期间才能确定调用哪一个函数</li>\n</ul>\n<blockquote>\n<p>基类中的虚函数：使用 virtual 关键字声明。<br>\n派生类重写（override）虚函数。<br>\n通过基类指针或引用调用虚函数。<br>\n必须通过 基类指针或引用 调用虚函数，涉及虚函数表（ <code>vtable</code> ）和虚指针（ <code>vptr</code> ）</p>\n</blockquote>\n<div class=\"note info\">\n<p>虚函数如何实现晚绑定？<br>\n每个有虚函数的类有一个 虚函数表（vtable），存函数指针。（编译时候产生的，放在静态存储区中）<br>\n每个对象构造时会有一个 虚指针（vptr），指向自己的 vtable。<br>\n调用虚函数时：<br>\n程序运行时，通过对象的 vptr 找到 vtable<br>\n 在 vtable 中查找对应函数地址<br>\n调用该函数<br>\n这个过程在运行时完成，所以是晚绑定。</p>\n</div>\n<ul>\n<li>静态多态（Static Polymorphism）—— 编译时多态<br>\n在编译期就确定了调用哪个函数，不涉及运行时开销，属于 “<mark>早绑定</mark>（Early Binding）”</li>\n</ul>\n<blockquote>\n<p>函数重载（Function Overloading）<br>\n运算符重载（Operator Overloading）<br>\n函数模板（Function Templates）</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>例子</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1. 函数重载</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Integer: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">double</span> x)</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Double: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; s)</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;String: &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&gt; 符号表如何支持函数重载？</span><br><span class=\"line\">在支持重载的语言（如 C++）中，符号表不会把同名函数合并成一个条目，而是为每个不同的函数签名单独存储一条记录，并将它们组织成一个“重载集合”，用的时候根据实参的类型和数量等样进行匹配，找到最匹配的函数调用。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 函数模板（泛型）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printGeneric</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; value)</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Generic: &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 运算符重载</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> x, y;</span><br><span class=\"line\">    <span class=\"built_in\">Point</span>(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y) : <span class=\"built_in\">x</span>(x), <span class=\"built_in\">y</span>(y) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Point <span class=\"keyword\">operator</span>+(<span class=\"type\">const</span> Point&amp; other) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Point</span>(x + other.x, y + other.y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"number\">42</span>);           <span class=\"comment\">// 调用 print(int)</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"number\">3.14</span>);         <span class=\"comment\">// 调用 print(double)</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hello&quot;</span>);      <span class=\"comment\">// 调用 print(string)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printGeneric</span>(<span class=\"number\">100</span>);   <span class=\"comment\">// 编译时生成 printGeneric&lt;int&gt;</span></span><br><span class=\"line\">    <span class=\"built_in\">printGeneric</span>(<span class=\"number\">2.5</span>);   <span class=\"comment\">// 生成 printGeneric&lt;double&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Point <span class=\"title\">p1</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span>, <span class=\"title\">p2</span><span class=\"params\">(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span></span>;</span><br><span class=\"line\">    Point p3 = p1 + p2;  <span class=\"comment\">// 使用重载的 +</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Point: (&quot;</span> &lt;&lt; p<span class=\"number\">3.</span>x &lt;&lt; <span class=\"string\">&quot;, &quot;</span> &lt;&lt; p<span class=\"number\">3.</span>y &lt;&lt; <span class=\"string\">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ol>\n<li>参数推导；2. 实例化具体函数 (在符号表中对应不同的条目); 3. 编译链接</li>\n</ol>\n</blockquote>\n<ol start=\"5\">\n<li>必须通过指针或引用调用 才能触发多态。如果直接用对象调用，会是静态绑定。<br>\n想用多态，必须用基类指针或基类引用去操作派生类对象</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>例子</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Animal speaks&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> : <span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Dog barks: 汪汪！&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过指针调用 → 触发多态（动态绑定）</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>1</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Dog dog;</span><br><span class=\"line\">    Animal* ptr = &amp;dog;  <span class=\"comment\">// 基类指针指向派生类对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ptr-&gt;<span class=\"built_in\">speak</span>();  <span class=\"comment\">// 输出 Dog barks: 汪汪！</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过引用调用 → 也触发多态</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>2</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">makeAnimalSpeak</span><span class=\"params\">(Animal&amp; animal)</span> </span>&#123;</span><br><span class=\"line\">    animal.<span class=\"built_in\">speak</span>();  <span class=\"comment\">// 动态绑定</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Dog dog;</span><br><span class=\"line\">    <span class=\"built_in\">makeAnimalSpeak</span>(dog);  <span class=\"comment\">// 输出：Dog barks: 汪汪！</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>直接对对象调用，静态绑定</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>3</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Dog dog;</span><br><span class=\"line\">    Animal a = dog;  <span class=\"comment\">// 把 Dog 对象赋值给 Animal 对象（会发生“对象切片”）</span></span><br><span class=\"line\"></span><br><span class=\"line\">    a.<span class=\"built_in\">speak</span>();  <span class=\"comment\">// 输出 Animal speaks</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>指针 vs 引用<br>\n引用是别名，指针是表示地址的变量<br>\n引用的特性：</li>\n</ol>\n<blockquote>\n<p>必须初始化，引用定义时必须绑定到一个变量<br>\n不能重新绑定，一旦绑定，就不能再指向其他变量<br>\n操作即原变量，对引用的所有操作都作用于原变量</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>引用</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>&amp; ref;     <span class=\"comment\">// 错误！未初始化</span></span><br><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">5</span>, b = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span>&amp; ref = a;</span><br><span class=\"line\">ref = b;      <span class=\"comment\">// 注意：这是赋值！不是重新绑定！a 变成 10，ref 仍绑定 a，此时a 和 ref 都是 10</span></span><br></pre></td></tr></table></figure>\n<p>引用的常见用法：</p>\n<blockquote>\n<p>函数参数传递：传递大对象（如 string、vector）<br>\n函数返回值（返回对象本身，支持链式调用）</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>引用</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyInt</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> value;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MyInt</span>(<span class=\"type\">int</span> v) : <span class=\"built_in\">value</span>(v) &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 返回引用，支持链式赋值</span></span><br><span class=\"line\">    MyInt&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> MyInt&amp; other) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != &amp;other) &#123;  <span class=\"comment\">// 自赋值检查</span></span><br><span class=\"line\">            value = other.value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;  <span class=\"comment\">// 返回当前对象的引用</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">MyInt <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">1</span>)</span>, <span class=\"title\">b</span><span class=\"params\">(<span class=\"number\">2</span>)</span>, <span class=\"title\">c</span><span class=\"params\">(<span class=\"number\">3</span>)</span></span>;</span><br><span class=\"line\">a = b = c;  <span class=\"comment\">// 链式赋值：b=c 返回 b 的引用，再赋给 a</span></span><br></pre></td></tr></table></figure>\n<div class=\"note danger\">\n<p>不能返回局部变量的引用</p>\n</div>\n<figure class=\"highlight c++\"><figcaption><span>错误</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span>&amp; <span class=\"title\">getRef</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;  <span class=\"comment\">// 错误！x 是局部变量，函数结束后销毁</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>遍历容器（避免拷贝元素）</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>遍历容器</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;string&gt; names = &#123;<span class=\"string\">&quot;Alice&quot;</span>, <span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Charlie&quot;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用引用遍历，避免拷贝字符串</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">const</span> string&amp; name : names) &#123;</span><br><span class=\"line\">    cout &lt;&lt; name &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或使用 auto&amp;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; name : names) &#123;</span><br><span class=\"line\">    name += <span class=\"string\">&quot; (modified)&quot;</span>;  <span class=\"comment\">// 如果想修改原元素</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>作为输出参数（替代指针）</p>\n</blockquote>\n<ol start=\"7\">\n<li>const 引用<br>\n引用是别名，const 引用是常量别名，不能修改别名指向的变量</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>const引用</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span>&amp; cref = x;  <span class=\"comment\">// cref 是 x 的常引用</span></span><br><span class=\"line\">cref = <span class=\"number\">20</span>;            <span class=\"comment\">// 错误！不能通过 cref 修改 x</span></span><br></pre></td></tr></table></figure>\n<p>可以用来绑定临时对象（延长生命周期）</p>\n<figure class=\"highlight c++\"><figcaption><span>常引用</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">3.14</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">double</span>&amp; r = <span class=\"built_in\">getValue</span>();  <span class=\"comment\">// 合法！临时对象生命周期延长到 r 结束</span></span><br><span class=\"line\">cout &lt;&lt; r;  <span class=\"comment\">// 输出 3.14</span></span><br></pre></td></tr></table></figure>\n<p>getValue () 的值在表达式结束就应该销毁了，但是当一个 const 引用绑定到临时对象时，这个临时对象的生命周期会被 “延长”，直到引用 r 结束为止。<br>\n用法：</p>\n<blockquote>\n<p>避免不必要的拷贝</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>引用</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> string&amp; s = <span class=\"string\">&quot;hello&quot;</span>;  <span class=\"comment\">// 不拷贝字符串</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>支持函数链式调用</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>引用</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> string&amp; result = <span class=\"built_in\">getPrefix</span>() + <span class=\"built_in\">getName</span>() + <span class=\"built_in\">getSuffix</span>();</span><br><span class=\"line\"><span class=\"comment\">// 临时 string 对象被 const 引用延长生命周期</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>STL 中使用</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>STL</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; item : vec) &#123; ... &#125;  <span class=\"comment\">// 避免拷贝，安全高效</span></span><br></pre></td></tr></table></figure>\n<ol start=\"8\">\n<li>左值引用 vs 右值引用<br>\n左值：有名字、能取地址的变量，可以放在赋值号左边，生命周期较长<br>\n右值：临时变量，不能取地址，生命周期较短，通常在表达式中 “用完就扔”</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>右值</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10</span>;                <span class=\"comment\">// 字面量，右值</span></span><br><span class=\"line\">x + <span class=\"number\">1</span>;             <span class=\"comment\">// 表达式结果，右值</span></span><br><span class=\"line\"><span class=\"built_in\">string</span>(<span class=\"string\">&quot;hello&quot;</span>);   <span class=\"comment\">// 临时 string 对象，右值</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>右值引用（T&amp;&amp;）就是一种可以绑定到右值（临时对象）的引用。</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>右值引用</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//类型&amp;&amp; 右值引用名 = 右值;</span></span><br><span class=\"line\"><span class=\"type\">int</span>&amp;&amp; rref = <span class=\"number\">10</span>;           <span class=\"comment\">// 10 是右值，rref 是它的右值引用</span></span><br><span class=\"line\"><span class=\"type\">int</span>&amp;&amp; rref2 = <span class=\"number\">5</span> + <span class=\"number\">3</span>;       <span class=\"comment\">// 表达式结果是右值</span></span><br><span class=\"line\">string&amp;&amp; sref = <span class=\"built_in\">string</span>(<span class=\"string\">&quot;临时字符串&quot;</span>);  <span class=\"comment\">// 绑定临时 string 对象</span></span><br></pre></td></tr></table></figure>\n<p>用法：对临时变量移动构造，避免深拷贝</p>\n<figure class=\"highlight c++\"><figcaption><span>移动构造</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// std:move(x) 将左值转换为右值引用，触发移动语义</span></span><br><span class=\"line\"><span class=\"function\">MyString <span class=\"title\">s1</span><span class=\"params\">(<span class=\"string\">&quot;hello&quot;</span>)</span></span>;</span><br><span class=\"line\">MyString s2 = std::<span class=\"built_in\">move</span>(s1);  <span class=\"comment\">// 告诉编译器：“s1 可以被移动了”</span></span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; s<span class=\"number\">1.</span>data;  <span class=\"comment\">// 可能是 nullptr！s1 处于“有效但不可用”状态</span></span><br></pre></td></tr></table></figure>\n<ol start=\"9\">\n<li>继承</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>继承</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    string name;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Animal</span>(string n) : <span class=\"built_in\">name</span>(n) &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span> </span>&#123; cout &lt;&lt; name &lt;&lt; <span class=\"string\">&quot; 在吃东西&quot;</span> &lt;&lt; endl; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Dog 继承 Animal，继承方式为 public</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> : <span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Dog</span>(string n) : <span class=\"built_in\">Animal</span>(n) &#123;&#125;  <span class=\"comment\">// 调用基类构造函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bark</span><span class=\"params\">()</span> </span>&#123; cout &lt;&lt; name &lt;&lt; <span class=\"string\">&quot; 汪汪叫！&quot;</span> &lt;&lt; endl; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Dog <span class=\"title\">d</span><span class=\"params\">(<span class=\"string\">&quot;小黄&quot;</span>)</span></span>;</span><br><span class=\"line\">    d.<span class=\"built_in\">eat</span>();   <span class=\"comment\">// 继承自 Animal</span></span><br><span class=\"line\">    d.<span class=\"built_in\">bark</span>();  <span class=\"comment\">// Dog 自己的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>继承方式</th>\n<th>基类 public 成员</th>\n<th>基类 protected 成员</th>\n<th>基类 private 成员</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public</td>\n<td>在派生类中仍是 public</td>\n<td>在派生类中是 protected</td>\n<td>不可访问</td>\n</tr>\n<tr>\n<td>protected</td>\n<td>在派生类中是 protected</td>\n<td>在派生类中是 protected</td>\n<td>不可访问</td>\n</tr>\n<tr>\n<td>private</td>\n<td>在派生类中是 private</td>\n<td>在派生类中是 private</td>\n<td>不可访问</td>\n</tr>\n</tbody>\n</table>\n<p>继承中的构造与析构顺序</p>\n<blockquote>\n<p>构造顺序：<br>\n基类构造函数<br>\n成员对象构造函数（按声明顺序）<br>\n派生类构造函数<br>\n析构顺序：与构造相反<br>\n派生类析构函数<br>\n成员对象析构函数（按声明逆序）<br>\n基类析构函数</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>继承中的构造与析构顺序</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Base</span>() &#123; cout &lt;&lt; <span class=\"string\">&quot;Base 构造\\n&quot;</span>; &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">Base</span>() &#123; cout &lt;&lt; <span class=\"string\">&quot;Base 析构\\n&quot;</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Member</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Member</span>() &#123; cout &lt;&lt; <span class=\"string\">&quot;Member 构造\\n&quot;</span>; &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">Member</span>() &#123; cout &lt;&lt; <span class=\"string\">&quot;Member 析构\\n&quot;</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\">    Member m;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Derived</span>() &#123; cout &lt;&lt; <span class=\"string\">&quot;Derived 构造\\n&quot;</span>; &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">Derived</span>() &#123; cout &lt;&lt; <span class=\"string\">&quot;Derived 析构\\n&quot;</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Derived d;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：<br>\nBase 构造<br>\n Member 构造<br>\n Derived 构造<br>\n Derived 析构<br>\n Member 析构<br>\n Base 析构</p>\n<p>继承是实现  <code>动态多态</code>  的基础。<br>\n条件：</p>\n<ul>\n<li>基类有  <code>virtual</code>  函数</li>\n<li>派生类  <code>override</code>  它</li>\n<li>通过  <code>基类指针或引用</code>  调用</li>\n</ul>\n<blockquote>\n<p>继承类不能访问基类的私有成员<br>\n构造函数不能继承，C++11 起支持  <code>using Base::Base;</code>  继承构造函数<br>\n析构函数应为虚函数：如果类可能被继承，析构函数必须是  <code>virtual</code> ，否则  <code>delete基类指针</code> 会只调用基类析构，导致派生类资源泄漏</p>\n</blockquote>\n<div class=\"note info\">\n<p>多重继承</p>\n</div>\n<p><mark>如果一个类可能被继承（作为基类），那么它的析构函数就应该声明为  <code>virtual</code> </mark><br>\n 否则，当用基类指针（或引用）删除派生类对象时，派生类的析构函数不会被调用，造成资源泄漏<br>\n原因：virtual 让析构函数变成动态绑定，delete 时，程序会通过虚函数表（vtable）找到实际对象的类型</p>\n<ol start=\"10\">\n<li>为什么构造函数不能是虚函数？<br>\n虚函数依赖对象的 vptr<br>\n 构造函数执行时，对象还没完全构造，vptr 还没初始化<br>\n每个有虚函数的类，编译器会生成一个 虚函数表（vtable），里面存着虚函数的地址。<br>\n每个对象内部有一个虚指针（vptr），指向自己的 vtable。<br>\n调用虚函数时：<br>\n对象 -&gt; vptr -&gt; vtable -&gt; 找到函数地址 -&gt; 调用</li>\n</ol>\n<ul>\n<li>构造函数执行时：</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>例子</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"string\">&quot;Animal sound\\n&quot;</span>; &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Animal</span>() &#123;  <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">        <span class=\"comment\">// 在这里，vptr 被设置为指向 Animal 的 vtable</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> : <span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123; cout &lt;&lt; <span class=\"string\">&quot;汪汪！\\n&quot;</span>; &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Dog</span>() &#123;  <span class=\"comment\">// Dog 的构造函数</span></span><br><span class=\"line\">        <span class=\"comment\">// 在这里，vptr 被更新为指向 Dog 的 vtable</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>调用 Dog dog;<br>\n 先调用 Animal 的构造函数<br>\n此时，dog 对象的 vptr 被初始化为指向 Animal 的 vtable<br>\n 再调用 Dog 的构造函数<br>\n vptr 被更新为指向 Dog 的 vtable</p>\n<div class=\"note danger\">\n<p>虚拟构造函数（后面在学）</p>\n</div>\n<ol start=\"11\">\n<li>重载（Overload）、重写（Override）、隐藏（Hiding）<br>\nOverload: 同一个作用域（通常是同一个类），函数名相同，参数列表不同（类型、个数、顺序），返回类型可以不同（但不能仅靠返回类型区分）<br>\nOverride: 发生在继承关系中，基类函数必须是 virtual，函数名、参数列表、返回类型（或协变）完全相同，派生类中使用 override<br>\nHiding: 两种情况① 函数名相同，参数不同；② 函数名相同，但基类函数不是 virtual</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>隐藏</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Animal speak&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">(string msg)</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Animal says: &quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> : <span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123;  <span class=\"comment\">// ✅ 重写 speak()</span></span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Dog barks&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 注意：speak(string) 被隐藏了！</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Dog d;</span><br><span class=\"line\">d.<span class=\"built_in\">speak</span>();           <span class=\"comment\">// 输出：Dog barks</span></span><br><span class=\"line\"><span class=\"comment\">// d.speak(&quot;hello&quot;); // 编译错误！speak(string) 被隐藏</span></span><br></pre></td></tr></table></figure>\n<p>解除隐藏：添加  <code>using Base::speak;</code></p>\n<ol start=\"12\">\n<li>深拷贝浅拷贝<br>\n深拷贝复制相同大小的内容到堆区，浅拷贝把源对象的指针赋给目标对象，多个对象的指针会指向同一块内存，容易导致双重释放</li>\n</ol>\n<p>类里面有动态分配的资源比如 <code>int*</code> ,  <code>char*</code>  必须进行深拷贝：</p>\n<ul>\n<li>析构函数</li>\n<li>构造函数和拷贝构造需要手动实现深拷贝（比如 strcpy）</li>\n<li><mark>重载赋值运算符</mark></li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>深拷贝</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyString</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">char</span>* data;  <span class=\"comment\">// 指向堆上的字符串</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 1️⃣ 构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">MyString</span>(<span class=\"type\">const</span> <span class=\"type\">char</span>* str = <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (str == <span class=\"literal\">nullptr</span> || str[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;\\0&#x27;</span>) &#123;</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"type\">char</span>[<span class=\"number\">1</span>];</span><br><span class=\"line\">            data[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"type\">char</span>[<span class=\"built_in\">strlen</span>(str) + <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(data, str);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2️⃣ 析构函数：释放资源</span></span><br><span class=\"line\">    ~<span class=\"built_in\">MyString</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] data;  <span class=\"comment\">// 释放堆内存</span></span><br><span class=\"line\">        data = <span class=\"literal\">nullptr</span>; <span class=\"comment\">// 防止悬空（可选）</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3️⃣ 拷贝构造函数：深拷贝</span></span><br><span class=\"line\">    <span class=\"built_in\">MyString</span>(<span class=\"type\">const</span> MyString&amp; other) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (other.data == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"type\">char</span>[<span class=\"built_in\">strlen</span>(other.data) + <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(data, other.data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 4️⃣ 拷贝赋值运算符：深拷贝赋值</span></span><br><span class=\"line\">    MyString&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> MyString&amp; other) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 自我赋值检查</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == &amp;other) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 先释放旧资源</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] data;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 分配新内存，深拷贝</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (other.data == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"type\">char</span>[<span class=\"built_in\">strlen</span>(other.data) + <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(data, other.data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 辅助函数：打印</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; (data ? data : <span class=\"string\">&quot;null&quot;</span>) &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ol start=\"13\">\n<li>\n<p>拷贝构造参数不是引用行吗？<br>\n拷贝构造的参数不是引用会导致无限递归，加 const 是为了避免通过形参修改实参</p>\n</li>\n<li>\n<p>堆和栈的区别？<br>\n堆是由程序员手动申请和释放的，可以使用 new 和 malloc 申请，释放使用 delete 和 free。内存空间较大，从低地址到高地址，访问速度较慢，有碎片问题，适合用于大对象、动态数组等<br>\n栈由编译器自动分配和释放，内存空间较小，从高地址到低地址，访问速度快，无碎片问题，适合用于局部变量、函数参数、返回地址</p>\n</li>\n</ol>\n<ul>\n<li>为什么栈快，堆慢？<br>\n栈：内存分配只是移动栈指针（esp），是 CPU 指令级操作，极快。<br>\n堆：需要调用操作系统 API，查找合适的内存块，维护空闲链表，效率较低。</li>\n</ul>\n<ol start=\"15\">\n<li>内联函数<br>\n请求编译器将函数体直接插入到调用处的机制，避免函数调用的开销<br>\n但是只是对编译器的建议，编译器不一定会实现<br>\n一般来说递归函数不适合内联，因为递归调用会生成临时变量，这些变量在函数退出时会被销毁，内联函数的临时变量会一直存在，导致内存泄漏；虚函数也不适合内联，内联函数在编译的时候确定代码，但虚函数是运行时多态</li>\n</ol>\n<ul>\n<li>使用 <code>inline</code>  关键字</li>\n<li>类内定义函数自动内联<br>\n内联函数比宏定义安全：</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>宏定义vs内联函数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAX(a,b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class=\"line\"><span class=\"type\">int</span> x = <span class=\"built_in\">MAX</span>(i++, j++);  <span class=\"comment\">// i 和 j 可能被 ++ 两次！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123; <span class=\"keyword\">return</span> a &gt; b ? a : b; &#125;</span><br><span class=\"line\"><span class=\"type\">int</span> x = <span class=\"built_in\">max</span>(i++, j++);  <span class=\"comment\">// 安全，参数只计算一次</span></span><br></pre></td></tr></table></figure>\n<p>定义写在类内不需要显式写 inline 关键字，定义在类外需要</p>\n<ol start=\"16\">\n<li>友元<br>\n允许某个函数或类 “突破封装”，访问另一个类的私有（private）和保护（protected）成员。</li>\n</ol>\n<ul>\n<li>将非成员函数声明为友元函数：非成员函数可以直接访问 <code>private</code>  和 <code>protected</code>  成员</li>\n<li>将其他类的成员函数声明为友元函数：其他类成员函数可以直接访问 <code>private</code>  和 <code>protected</code>  成员</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>友元</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"type\">void</span> <span class=\"title\">Student::show</span><span class=\"params\">(Address *addr)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>友元类：一个类声明为另一个类的友元类，则该类中的所有成员函数都可以访问该类的 <code>private</code>  和 <code>protected</code>  成员</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>友元类</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Address</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"> <span class=\"built_in\">Address</span>(<span class=\"type\">char</span> *province, <span class=\"type\">char</span> *city, <span class=\"type\">char</span> *district);</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"> <span class=\"comment\">//将Student类声明为Address类的友元类，Student类中的所有成员函数都可以访问Address类的private成员</span></span><br><span class=\"line\"> <span class=\"keyword\">friend</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Student</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\"> <span class=\"type\">char</span> *m_province; <span class=\"comment\">//省份</span></span><br><span class=\"line\"> <span class=\"type\">char</span> *m_city; <span class=\"comment\">//城市</span></span><br><span class=\"line\"> <span class=\"type\">char</span> *m_district; <span class=\"comment\">//区（市区）</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ol start=\"17\">\n<li>智能指针<br>\n new 了没有 delete —— 内存泄漏<br>\n delete 之后没有置为 nullptr / 指针指向的对象生命周期结束 —— 野指针<br>\n多个指针指向同一块内存 —— 悬空指针<br>\n<mark>智能指针本质是封装指针的类模板</mark><br>\n RAII（Resource Acquisition Is Initialization）原则：资源在构造时获取，在析构时释放。</li>\n</ol>\n<ul>\n<li><code>unique_ptr</code> ：独占指针，只能有一个指针指向一块内存，不能拷贝，不能赋值，析构时会自动释放内存。赋值只能用 <code>std::move()</code>  转移所有权，此时 <code>u1</code>  的所有权被转移给 <code>u3</code> ， <code>u1</code>  变成空指针。<br>\n <code>unique_ptr</code>  支持管理数组，它会使用 <code>delete[]</code>  来释放数组内存（区别于 <code>auto_ptr</code> ，它使用 <code>delete</code>  来释放内存）</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>unique_ptr</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::unique_ptr&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">u1</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"type\">int</span>(<span class=\"number\">10</span>))</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// std::unique_ptr&lt;int&gt; u2 = u1;  // 编译错误，不允许拷贝</span></span><br><span class=\"line\">std::unique_ptr&lt;<span class=\"type\">int</span>&gt; u3 = std::<span class=\"built_in\">move</span>(u1);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>shared_ptr</code> ：共享指针，多个指针可以指向一块内存，通过引用计数机制来管理对象的生命周期 。当一个 <code>shared_ptr</code>  指向对象时，引用计数加 1；当 <code>shared_ptr</code>  离开作用域或被重新赋值时，引用计数减 1，当引用计数为 0 时，对象会被自动释放<br>\n <code>shared_ptr</code>  在多线程环境中使用时，需要注意线程安全问题，因为引用计数的修改不是原子操作，可能会导致数据竞争 。为了解决这个问题，可以使用 <code>std::atomic</code>  来实现原子操作，或者使用互斥锁来保护引用计数的修改</li>\n<li><code>weak_ptr</code> ：不能访问指针指向的对象，不控制对象的生命周期，只能判断指针是否为空，不能赋值，析构时会自动释放内存。主要是用来解决两个 <code>shared_ptr</code>  对象之间形成循环引用的问题（循环引用计数永远不会归零，导致这两个对象永远无法被销毁），当一个 <code>shared_ptr</code>  对象被另一个 <code>shared_ptr</code>  对象所引用时，两个对象之间形成循环引用，导致内存泄漏。 <code>weak_ptr</code>  对象用来监视 <code>shared_ptr</code>  中管理的资源是否存在，可以判断指针是否为空，也可以获取指针指向的对象，但无法访问对象。 <code>weak_ptr</code>  对象可以通过 <code>lock()</code>  方法获取对应的 <code>shared_ptr</code>  对象，如果对象仍然存在，则返回对应的 <code>shared_ptr</code>  对象，否则返回一个空的 <code>shared_ptr</code>  对象。<br>\n使用 <code>weak_ptr</code>  时，需要通过 <code>lock</code>  函数将其提升为 <code>shared_ptr</code> ，才能访问对象 。如果对象已经被释放， <code>lock</code>  函数会返回一个空的 <code>shared_ptr</code></li>\n</ul>\n<ol start=\"18\">\n<li>模板<br>\n允许你写一份代码，编译器根据不同的类型自动生成对应的函数或类<br>\n比如 <code>swap</code> ：</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>模板</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">swap</span><span class=\"params\">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class=\"line\">    T temp = a;</span><br><span class=\"line\">    a = b;</span><br><span class=\"line\">    b = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>基本语法：</p>\n<figure class=\"highlight c++\"><figcaption><span>函数模板</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> U&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">add</span><span class=\"params\">(T a, U b)</span> -&gt; <span class=\"title\">decltype</span><span class=\"params\">(a + b)</span> </span>&#123; <span class=\"comment\">// auto表示返回值在后面指定，编译器会根据a+b的结果自动推导返回类型</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>类模板</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// template &lt;typename T1, typename T2, ...&gt;</span></span><br><span class=\"line\"><span class=\"comment\">// class ClassName &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     // 使用 T1, T2 等作为类型</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;;</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"type\">int</span> N&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Array</span> &#123;</span><br><span class=\"line\">    T data[N];</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    T&amp; <span class=\"keyword\">operator</span>[](<span class=\"type\">int</span> index) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> N; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>模板的实现（函数体）必须和声明放在同一个头文件中，STL 就是模板</p>\n<ol start=\"19\">\n<li>volatile<br>\n 原因：多处理器访问变量，缓存和主存可能存在不一致的问题<br>\n volatile 让变量的读写都从主存中读写，而不是从缓存中读写</li>\n</ol>\n<ul>\n<li>易变性（可见性）: … 可能不一致</li>\n<li>不可优化的：编译器不要做优化</li>\n</ul>\n<figure class=\"highlight c\"><figcaption><span>volatile</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"type\">int</span> a;</span><br><span class=\"line\">a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(%d, a);  </span><br></pre></td></tr></table></figure>\n<p>不加 <code>volatile</code>  的话编译器可能会优化成 `printf (% d, 1);</p>\n<ul>\n<li>顺序执行的：编译器会对无关的语句进行优化，可能会把 <code>printf</code>  放到 <code>a = 1</code>  的前面执行</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> j = <span class=\"number\">1</span></span><br><span class=\"line\">i += <span class=\"number\">1</span>;</span><br><span class=\"line\">j += <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>实际上执行顺序可能不是这样的（原因详见编译原理），写了 <code>volatile</code>  之后，编译器就不会改变顺序</p>\n<ul>\n<li>使用场景：多线程共享字段（标志位）且经常被修改；中断服务程序和硬件设备访问相关的情况（指针可以是 <code>volatile</code> ）</li>\n<li>误区： <code>volatile</code>  修饰的变量不能保证原子性，原子性需要通过原子操作或者锁来实现</li>\n</ul>\n<ol start=\"20\">\n<li>static<br>\nc 语言中：</li>\n</ol>\n<ul>\n<li>用于局部变量（函数内部）\n<ul>\n<li>作用：使局部变量具有静态存储期（即程序运行期间一直存在），但作用域仍限于当前括号之内。</li>\n<li>初始化：只在第一次进入函数时初始化一次。</li>\n<li>默认值：未显式初始化则为 0。</li>\n</ul>\n</li>\n<li>用于全局变量或函数\n<ul>\n<li>作用：将变量或函数的链接属性（linkage）设为内部链接（internal linkage），即仅在当前源文件中可见，其他文件无法访问。</li>\n<li>目的：实现封装，避免命名冲突。<br>\nc++ 中：<br>\n <code>C++</code>  继承了 <code>C</code>  中 <code>static</code>  的所有用法，还增加了面向对象场景下的新用途</li>\n</ul>\n</li>\n<li>静态成员变量：\n<ul>\n<li>属于类本身，而不是类的某个对象。</li>\n<li>所有对象共享同一个静态成员。</li>\n<li>必须在类外定义（C<ins>17 前），C</ins>17 起可用 inline static 在类内定义。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>static</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">int</span> count;       <span class=\"comment\">// 声明</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> MyClass::count = <span class=\"number\">0</span>;     <span class=\"comment\">// 定义（C++17 前必需）</span></span><br><span class=\"line\"><span class=\"comment\">// 或 C++17 起：</span></span><br><span class=\"line\"><span class=\"comment\">// inline static int count = 0;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>静态成员函数：\n<ul>\n<li>不属于任何对象，不能访问非静态成员（因为没有 this 指针）。</li>\n<li>可直接通过类名调用。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>static</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不能访问非静态成员</span></span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Static function\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">MyClass::<span class=\"built_in\">print</span>(); <span class=\"comment\">// 无需对象</span></span><br></pre></td></tr></table></figure>\n<p>C++11 起，static 局部变量的初始化自动线程安全，c 语言没有这种保证</p>\n<ol start=\"21\">\n<li>c 语言保证线程安全<br>\n C 语言标准库本身（C89/C99/C11 等）在早期版本中并不直接提供线程或锁操作，但 C11 标准（ISO/IEC 9899:2011）引入了多线程支持，包括锁（mutex）等同步原语。<br>\nC11 引入了 &lt;threads.h&gt; 头文件，提供了类似 POSIX 的线程和锁接口。</li>\n</ol>\n<figure class=\"highlight c\"><figcaption><span>mutex</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;threads.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 互斥锁类型</span></span><br><span class=\"line\"><span class=\"type\">mtx_t</span> mutex;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化锁</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">mtx_init</span><span class=\"params\">(<span class=\"type\">mtx_t</span> *mtx, <span class=\"type\">int</span> type)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加锁（阻塞）</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">mtx_lock</span><span class=\"params\">(<span class=\"type\">mtx_t</span> *mtx)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 尝试加锁（非阻塞）</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">mtx_trylock</span><span class=\"params\">(<span class=\"type\">mtx_t</span> *mtx)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解锁</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">mtx_unlock</span><span class=\"params\">(<span class=\"type\">mtx_t</span> *mtx)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 销毁锁</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">mtx_destroy</span><span class=\"params\">(<span class=\"type\">mtx_t</span> *mtx)</span>;</span><br></pre></td></tr></table></figure>\n<p>比如线程安全计数器</p>\n<figure class=\"highlight c\"><figcaption><span>mutex</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;threads.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> counter = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">mtx_t</span> mutex;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">increment</span><span class=\"params\">(<span class=\"type\">void</span>* arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++) &#123;</span><br><span class=\"line\">        mtx_lock(&amp;mutex);</span><br><span class=\"line\">        counter++;</span><br><span class=\"line\">        mtx_unlock(&amp;mutex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    mtx_init(&amp;mutex, mtx_plain);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">thrd_t</span> t1, t2;</span><br><span class=\"line\">    thrd_create(&amp;t1, increment, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    thrd_create(&amp;t2, increment, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    thrd_join(t1, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    thrd_join(t2, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Counter = %d\\n&quot;</span>, counter); <span class=\"comment\">// 应为 200000</span></span><br><span class=\"line\">    mtx_destroy(&amp;mutex);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实际上用得多的可能是 pthreads</p>\n<figure class=\"highlight c\"><figcaption><span>pthreads</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或动态初始化</span></span><br><span class=\"line\">pthread_mutex_init(&amp;mutex, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加锁</span></span><br><span class=\"line\">pthread_mutex_lock(&amp;mutex);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 尝试加锁</span></span><br><span class=\"line\">pthread_mutex_trylock(&amp;mutex);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解锁</span></span><br><span class=\"line\">pthread_mutex_unlock(&amp;mutex);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 销毁</span></span><br><span class=\"line\">pthread_mutex_destroy(&amp;mutex);</span><br></pre></td></tr></table></figure>\n<p>示例</p>\n<figure class=\"highlight c\"><figcaption><span>pthreads</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> counter = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span>* <span class=\"title function_\">increment</span><span class=\"params\">(<span class=\"type\">void</span>* arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++) &#123;</span><br><span class=\"line\">        pthread_mutex_lock(&amp;mutex);</span><br><span class=\"line\">        counter++;</span><br><span class=\"line\">        pthread_mutex_unlock(&amp;mutex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">pthread_t</span> t1, t2;</span><br><span class=\"line\">    pthread_create(&amp;t1, <span class=\"literal\">NULL</span>, increment, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    pthread_create(&amp;t2, <span class=\"literal\">NULL</span>, increment, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    pthread_join(t1, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    pthread_join(t2, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Counter = %d\\n&quot;</span>, counter);</span><br><span class=\"line\">    pthread_mutex_destroy(&amp;mutex);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"22\">\n<li>\n<p>typedef 和 define<br>\n#define 是 “文本替换”，像 Word 的 “查找替换”，预处理的时候替换；<br>\ntypedef 是 “类型定义” 的关键字，是编译器理解的真正类型别名。typedef 可以定义新的类型，也可以定义新的类型别名，但不能定义常量 / 宏函数，在编译的时候处理</p>\n</li>\n<li>\n<p>数组指针和指针数组<br>\n数组指针：<br>\n指向数组的指针</p>\n</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>array pointer</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> *p[<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> b[<span class=\"number\">12</span>] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>, <span class=\"number\">12</span>&#125;;</span><br><span class=\"line\">p = b;</span><br></pre></td></tr></table></figure>\n<p>指针数组：<br>\n数组的元素是指针</p>\n<figure class=\"highlight c++\"><figcaption><span>pointer array</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>* p[<span class=\"number\">4</span>];</span><br></pre></td></tr></table></figure>\n<ol start=\"24\">\n<li>函数指针<br>\n函数指针：<br>\n指向函数的指针</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>function pointer</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> (*p)(<span class=\"type\">int</span>, <span class=\"type\">int</span>); <span class=\"comment\">// 括号不能省略</span></span><br><span class=\"line\">p = add;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123; <span class=\"keyword\">return</span> a + b; &#125;</span><br><span class=\"line\"><span class=\"type\">int</span> result = <span class=\"built_in\">p</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, result); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>函数指针没有自增和自减运算</p>\n<blockquote>\n<p>区分 int *p 和 int (*p)<br>\n 前者是一个指向 int 类型的指针，后者有可能是一个数组指针或是返回 int 类型的函数指针</p>\n</blockquote>\n<ol start=\"25\">\n<li>如何保证线程安全？</li>\n</ol>\n<ul>\n<li>锁</li>\n<li>原子操作</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>atomic</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;atomic&gt;</span></span></span><br><span class=\"line\">std::atomic&lt;<span class=\"type\">int</span>&gt; counter;</span><br><span class=\"line\">counter.<span class=\"built_in\">fetch_add</span>(<span class=\"number\">1</span>);   <span class=\"comment\">// fetch_sub(), fetch_and(), fetch_or()...</span></span><br><span class=\"line\">counter.<span class=\"built_in\">load</span>();</span><br><span class=\"line\">counter.<span class=\"built_in\">store</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">counter.<span class=\"built_in\">exchange</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">counter.<span class=\"built_in\">compare_exchange_strong</span>(old_value, new_value);  <span class=\"comment\">// 如果old_value == counter，则将 counter 设为 new_value</span></span><br><span class=\"line\">counter.<span class=\"built_in\">compare_exchange_weak</span>(old_value, new_value);    <span class=\"comment\">// 区别：weak 版本允许虚假失败，需要循环</span></span><br><span class=\"line\">counter.<span class=\"built_in\">is_lock_free</span>();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>线程同步原语</li>\n</ul>\n<ol start=\"26\">\n<li><code>const</code>  用法</li>\n</ol>\n<ul>\n<li>常量变量<br>\n必须在定义时初始化</li>\n<li>常量指针 vs 指针常量：见上</li>\n<li>引用与 const：见上 <code>const 引用</code></li>\n<li>类中的 const:\n<ul>\n<li>const 成员函数：不能修改对象成员变量，不能调用非 const 成员函数</li>\n<li>const 对象：const 对象只能调用 const 成员函数</li>\n</ul>\n</li>\n</ul>\n<ol start=\"27\">\n<li>\n<p>多线程<br>\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucnVub29iLmNvbS9jcGx1c3BsdXMvY3BwLW11bHRpdGhyZWFkaW5nLmh0bWw=\"> https://www.runoob.com/cplusplus/cpp-multithreading.html</span></p>\n</li>\n<li>\n<p>协程</p>\n</li>\n</ol>\n",
            "tags": [
                "C++"
            ]
        }
    ]
}