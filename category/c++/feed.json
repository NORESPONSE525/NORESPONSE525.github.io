{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog • All posts by \"c++\" category",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/10/26/oop/note/",
            "url": "http://example.com/2025/10/26/oop/note/",
            "title": "C++相关",
            "date_published": "2025-10-25T16:00:00.000Z",
            "content_html": "<ol>\n<li>\n<p>面向对象 vs 面向过程<br>\n面向对象三大特性：封装、继承、多态<br>\n c++ 不是完全面向对象的语言<br>\n封装：把数据和方法打包成一个类，隐藏实现细节，只提供接口<br>\n继承：子类继承父类的属性和方法，子类可以扩展父类的功能，实现代码复用<br>\n多态：在运行时，根据对象的实际类型，调用对应的函数。主要通过虚函数和继承实现</p>\n</li>\n<li>\n<p>C++ 编译过程<br>\n预处理 -&gt; 编译 -&gt; 汇编 -&gt; 链接<br>\n预处理：预处理指令、宏定义、包含文件 (处理 #include, #define, 条件编译等)<br>\n 编译：把源代码编译成汇编代码 (将 .cpp 转为 .s)<br>\n 汇编：把汇编代码编译成机器码<br>\n链接：把多个对象文件链接成可执行文件 (将多个目标文件和库合并成可执行文件)<br>\n<mark> 第三方库就是在第 4 步 —— 链接（Linking）阶段加入的</mark><br>\n在 链接阶段，通过 -lxxx（如 -lcurl）告诉链接器：“我要用这个库”，然后链接器去找到对应的 静态库（.a 或 .lib）或动态库（.so 或 .dll）<br>\n静态库在在编译过程中（链接阶段）被载入可执行程序，生成的可执行文件体积较大<br>\n动态库是在运行时才载入内存，但更新库后需要重新编译。<mark>动态库是运行时库</mark></p>\n</li>\n<li>\n<p>静态链接和动态链接<br>\n静态链接：把所有用到的库文件都链接到可执行文件中，编译速度慢，但运行速度快<br>\n动态链接：把所有用到的库文件都放到一个单独的文件中，运行时再加载，编译速度快，但运行速度慢</p>\n</li>\n<li>\n<p>静态多态（编译时多态） 和 动态多态（运行时多态）</p>\n</li>\n</ol>\n<ul>\n<li>动态多态（Dynamic Polymorphism）—— 运行时多态<br>\n这是通过 继承 + 虚函数（virtual function） 实现的。动态多态是通过虚函数重写实现的，是在运行期间确定的多态，是一种<mark>晚绑定</mark>机制（或<mark>动态绑定</mark>），在运行期间才能确定调用哪一个函数</li>\n</ul>\n<blockquote>\n<p>基类中的虚函数：使用 virtual 关键字声明。<br>\n派生类重写（override）虚函数。<br>\n通过基类指针或引用调用虚函数。<br>\n必须通过 基类指针或引用 调用虚函数，涉及虚函数表（ <code>vtable</code> ）和虚指针（ <code>vptr</code> ）</p>\n</blockquote>\n<div class=\"note info\">\n<p>虚函数如何实现晚绑定？<br>\n每个有虚函数的类有一个 虚函数表（vtable），存函数指针。<br>\n每个对象有一个 虚指针（vptr），指向自己的 vtable。<br>\n调用虚函数时：<br>\n通过对象的 vptr 找到 vtable<br>\n 在 vtable 中查找对应函数地址<br>\n调用该函数<br>\n这个过程在运行时完成，所以是晚绑定。</p>\n</div>\n<ul>\n<li>静态多态（Static Polymorphism）—— 编译时多态<br>\n在编译期就确定了调用哪个函数，不涉及运行时开销，属于 “<mark>早绑定</mark>（Early Binding）”</li>\n</ul>\n<blockquote>\n<p>函数重载（Function Overloading）<br>\n运算符重载（Operator Overloading）<br>\n函数模板（Function Templates）</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>例子</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1. 函数重载</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Integer: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">double</span> x)</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Double: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; s)</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;String: &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&gt; 符号表如何支持函数重载？</span><br><span class=\"line\">在支持重载的语言（如 C++）中，符号表不会把同名函数合并成一个条目，而是为每个不同的函数签名单独存储一条记录，并将它们组织成一个“重载集合”，用的时候根据实参的类型和数量等样进行匹配，找到最匹配的函数调用。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 函数模板（泛型）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printGeneric</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; value)</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Generic: &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 运算符重载</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> x, y;</span><br><span class=\"line\">    <span class=\"built_in\">Point</span>(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y) : <span class=\"built_in\">x</span>(x), <span class=\"built_in\">y</span>(y) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Point <span class=\"keyword\">operator</span>+(<span class=\"type\">const</span> Point&amp; other) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Point</span>(x + other.x, y + other.y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"number\">42</span>);           <span class=\"comment\">// 调用 print(int)</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"number\">3.14</span>);         <span class=\"comment\">// 调用 print(double)</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hello&quot;</span>);      <span class=\"comment\">// 调用 print(string)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printGeneric</span>(<span class=\"number\">100</span>);   <span class=\"comment\">// 编译时生成 printGeneric&lt;int&gt;</span></span><br><span class=\"line\">    <span class=\"built_in\">printGeneric</span>(<span class=\"number\">2.5</span>);   <span class=\"comment\">// 生成 printGeneric&lt;double&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Point <span class=\"title\">p1</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span>, <span class=\"title\">p2</span><span class=\"params\">(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span></span>;</span><br><span class=\"line\">    Point p3 = p1 + p2;  <span class=\"comment\">// 使用重载的 +</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Point: (&quot;</span> &lt;&lt; p<span class=\"number\">3.</span>x &lt;&lt; <span class=\"string\">&quot;, &quot;</span> &lt;&lt; p<span class=\"number\">3.</span>y &lt;&lt; <span class=\"string\">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ol>\n<li>参数推导；2. 实例化具体函数 (在符号表中对应不同的条目); 3. 编译链接</li>\n</ol>\n</blockquote>\n<ol start=\"5\">\n<li>必须通过指针或引用调用 才能触发多态。如果直接用对象调用，会是静态绑定。<br>\n想用多态，必须用基类指针或基类引用去操作派生类对象</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>例子</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Animal speaks&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> : <span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Dog barks: 汪汪！&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过指针调用 → 触发多态（动态绑定）</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>1</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Dog dog;</span><br><span class=\"line\">    Animal* ptr = &amp;dog;  <span class=\"comment\">// 基类指针指向派生类对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ptr-&gt;<span class=\"built_in\">speak</span>();  <span class=\"comment\">// 输出 Dog barks: 汪汪！</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过引用调用 → 也触发多态</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>2</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">makeAnimalSpeak</span><span class=\"params\">(Animal&amp; animal)</span> </span>&#123;</span><br><span class=\"line\">    animal.<span class=\"built_in\">speak</span>();  <span class=\"comment\">// 动态绑定</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Dog dog;</span><br><span class=\"line\">    <span class=\"built_in\">makeAnimalSpeak</span>(dog);  <span class=\"comment\">// 输出：Dog barks: 汪汪！</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>直接对对象调用，静态绑定</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>3</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Dog dog;</span><br><span class=\"line\">    Animal a = dog;  <span class=\"comment\">// 把 Dog 对象赋值给 Animal 对象（会发生“对象切片”）</span></span><br><span class=\"line\"></span><br><span class=\"line\">    a.<span class=\"built_in\">speak</span>();  <span class=\"comment\">// 输出 Animal speaks</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>指针 vs 引用<br>\n引用是别名，指针是表示地址的变量<br>\n引用的特性：</li>\n</ol>\n<blockquote>\n<p>必须初始化，引用定义时必须绑定到一个变量<br>\n不能重新绑定，一旦绑定，就不能再指向其他变量<br>\n操作即原变量，对引用的所有操作都作用于原变量</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>引用</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>&amp; ref;     <span class=\"comment\">// 错误！未初始化</span></span><br><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">5</span>, b = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span>&amp; ref = a;</span><br><span class=\"line\">ref = b;      <span class=\"comment\">// 注意：这是赋值！不是重新绑定！a 变成 10，ref 仍绑定 a，此时a 和 ref 都是 10</span></span><br></pre></td></tr></table></figure>\n<p>引用的常见用法：</p>\n<blockquote>\n<p>函数参数传递：传递大对象（如 string、vector）<br>\n函数返回值（返回对象本身，支持链式调用）</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>引用</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyInt</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> value;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MyInt</span>(<span class=\"type\">int</span> v) : <span class=\"built_in\">value</span>(v) &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 返回引用，支持链式赋值</span></span><br><span class=\"line\">    MyInt&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> MyInt&amp; other) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != &amp;other) &#123;  <span class=\"comment\">// 自赋值检查</span></span><br><span class=\"line\">            value = other.value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;  <span class=\"comment\">// 返回当前对象的引用</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">MyInt <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">1</span>)</span>, <span class=\"title\">b</span><span class=\"params\">(<span class=\"number\">2</span>)</span>, <span class=\"title\">c</span><span class=\"params\">(<span class=\"number\">3</span>)</span></span>;</span><br><span class=\"line\">a = b = c;  <span class=\"comment\">// 链式赋值：b=c 返回 b 的引用，再赋给 a</span></span><br></pre></td></tr></table></figure>\n<div class=\"note danger\">\n<p>不能返回局部变量的引用</p>\n</div>\n<figure class=\"highlight c++\"><figcaption><span>错误</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span>&amp; <span class=\"title\">getRef</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;  <span class=\"comment\">// 错误！x 是局部变量，函数结束后销毁</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>遍历容器（避免拷贝元素）</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>遍历容器</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;string&gt; names = &#123;<span class=\"string\">&quot;Alice&quot;</span>, <span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Charlie&quot;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用引用遍历，避免拷贝字符串</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">const</span> string&amp; name : names) &#123;</span><br><span class=\"line\">    cout &lt;&lt; name &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或使用 auto&amp;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; name : names) &#123;</span><br><span class=\"line\">    name += <span class=\"string\">&quot; (modified)&quot;</span>;  <span class=\"comment\">// 如果想修改原元素</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>作为输出参数（替代指针）</p>\n</blockquote>\n<ol start=\"7\">\n<li>const 引用<br>\n引用是别名，const 引用是常量别名，不能修改别名指向的变量</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>const引用</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span>&amp; cref = x;  <span class=\"comment\">// cref 是 x 的常引用</span></span><br><span class=\"line\">cref = <span class=\"number\">20</span>;            <span class=\"comment\">// 错误！不能通过 cref 修改 x</span></span><br></pre></td></tr></table></figure>\n<p>可以用来绑定临时对象（延长生命周期）</p>\n<figure class=\"highlight c++\"><figcaption><span>常引用</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">3.14</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">double</span>&amp; r = <span class=\"built_in\">getValue</span>();  <span class=\"comment\">// 合法！临时对象生命周期延长到 r 结束</span></span><br><span class=\"line\">cout &lt;&lt; r;  <span class=\"comment\">// 输出 3.14</span></span><br></pre></td></tr></table></figure>\n<p>getValue () 的值在表达式结束就应该销毁了，但是当一个 const 引用绑定到临时对象时，这个临时对象的生命周期会被 “延长”，直到引用 r 结束为止。<br>\n用法：</p>\n<blockquote>\n<p>避免不必要的拷贝</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>引用</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> string&amp; s = <span class=\"string\">&quot;hello&quot;</span>;  <span class=\"comment\">// 不拷贝字符串</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>支持函数链式调用</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>引用</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> string&amp; result = <span class=\"built_in\">getPrefix</span>() + <span class=\"built_in\">getName</span>() + <span class=\"built_in\">getSuffix</span>();</span><br><span class=\"line\"><span class=\"comment\">// 临时 string 对象被 const 引用延长生命周期</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>STL 中使用</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>STL</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; item : vec) &#123; ... &#125;  <span class=\"comment\">// 避免拷贝，安全高效</span></span><br></pre></td></tr></table></figure>\n<ol start=\"8\">\n<li>左值引用 vs 右值引用<br>\n左值：有名字、能取地址的变量，可以放在赋值号左边，生命周期较长<br>\n右值：临时变量，不能取地址，生命周期较短，通常在表达式中 “用完就扔”</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>右值</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10</span>;                <span class=\"comment\">// 字面量，右值</span></span><br><span class=\"line\">x + <span class=\"number\">1</span>;             <span class=\"comment\">// 表达式结果，右值</span></span><br><span class=\"line\"><span class=\"built_in\">string</span>(<span class=\"string\">&quot;hello&quot;</span>);   <span class=\"comment\">// 临时 string 对象，右值</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>右值引用（T&amp;&amp;）就是一种可以绑定到右值（临时对象）的引用。</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>右值引用</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//类型&amp;&amp; 右值引用名 = 右值;</span></span><br><span class=\"line\"><span class=\"type\">int</span>&amp;&amp; rref = <span class=\"number\">10</span>;           <span class=\"comment\">// 10 是右值，rref 是它的右值引用</span></span><br><span class=\"line\"><span class=\"type\">int</span>&amp;&amp; rref2 = <span class=\"number\">5</span> + <span class=\"number\">3</span>;       <span class=\"comment\">// 表达式结果是右值</span></span><br><span class=\"line\">string&amp;&amp; sref = <span class=\"built_in\">string</span>(<span class=\"string\">&quot;临时字符串&quot;</span>);  <span class=\"comment\">// 绑定临时 string 对象</span></span><br></pre></td></tr></table></figure>\n<p>用法：对临时变量移动构造，避免深拷贝</p>\n<figure class=\"highlight c++\"><figcaption><span>移动构造</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// std:move(x) 将左值转换为右值引用，触发移动语义</span></span><br><span class=\"line\"><span class=\"function\">MyString <span class=\"title\">s1</span><span class=\"params\">(<span class=\"string\">&quot;hello&quot;</span>)</span></span>;</span><br><span class=\"line\">MyString s2 = std::<span class=\"built_in\">move</span>(s1);  <span class=\"comment\">// 告诉编译器：“s1 可以被移动了”</span></span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; s<span class=\"number\">1.</span>data;  <span class=\"comment\">// 可能是 nullptr！s1 处于“有效但不可用”状态</span></span><br></pre></td></tr></table></figure>\n<ol start=\"9\">\n<li>继承</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>继承</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    string name;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Animal</span>(string n) : <span class=\"built_in\">name</span>(n) &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span> </span>&#123; cout &lt;&lt; name &lt;&lt; <span class=\"string\">&quot; 在吃东西&quot;</span> &lt;&lt; endl; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Dog 继承 Animal，继承方式为 public</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> : <span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Dog</span>(string n) : <span class=\"built_in\">Animal</span>(n) &#123;&#125;  <span class=\"comment\">// 调用基类构造函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bark</span><span class=\"params\">()</span> </span>&#123; cout &lt;&lt; name &lt;&lt; <span class=\"string\">&quot; 汪汪叫！&quot;</span> &lt;&lt; endl; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Dog <span class=\"title\">d</span><span class=\"params\">(<span class=\"string\">&quot;小黄&quot;</span>)</span></span>;</span><br><span class=\"line\">    d.<span class=\"built_in\">eat</span>();   <span class=\"comment\">// 继承自 Animal</span></span><br><span class=\"line\">    d.<span class=\"built_in\">bark</span>();  <span class=\"comment\">// Dog 自己的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>继承方式</th>\n<th>基类 public 成员</th>\n<th>基类 protected 成员</th>\n<th>基类 private 成员</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public</td>\n<td>在派生类中仍是 public</td>\n<td>在派生类中是 protected</td>\n<td>不可访问</td>\n</tr>\n<tr>\n<td>protected</td>\n<td>在派生类中是 protected</td>\n<td>在派生类中是 protected</td>\n<td>不可访问</td>\n</tr>\n<tr>\n<td>private</td>\n<td>在派生类中是 private</td>\n<td>在派生类中是 private</td>\n<td>不可访问</td>\n</tr>\n</tbody>\n</table>\n<p>继承中的构造与析构顺序</p>\n<blockquote>\n<p>构造顺序：<br>\n基类构造函数<br>\n成员对象构造函数（按声明顺序）<br>\n派生类构造函数<br>\n析构顺序：与构造相反<br>\n派生类析构函数<br>\n成员对象析构函数（按声明逆序）<br>\n基类析构函数</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>继承中的构造与析构顺序</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Base</span>() &#123; cout &lt;&lt; <span class=\"string\">&quot;Base 构造\\n&quot;</span>; &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">Base</span>() &#123; cout &lt;&lt; <span class=\"string\">&quot;Base 析构\\n&quot;</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Member</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Member</span>() &#123; cout &lt;&lt; <span class=\"string\">&quot;Member 构造\\n&quot;</span>; &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">Member</span>() &#123; cout &lt;&lt; <span class=\"string\">&quot;Member 析构\\n&quot;</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\">    Member m;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Derived</span>() &#123; cout &lt;&lt; <span class=\"string\">&quot;Derived 构造\\n&quot;</span>; &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">Derived</span>() &#123; cout &lt;&lt; <span class=\"string\">&quot;Derived 析构\\n&quot;</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Derived d;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：<br>\nBase 构造<br>\n Member 构造<br>\n Derived 构造<br>\n Derived 析构<br>\n Member 析构<br>\n Base 析构</p>\n<p>继承是实现  <code>动态多态</code>  的基础。<br>\n条件：</p>\n<ul>\n<li>基类有  <code>virtual</code>  函数</li>\n<li>派生类  <code>override</code>  它</li>\n<li>通过  <code>基类指针或引用</code>  调用</li>\n</ul>\n<blockquote>\n<p>继承类不能访问基类的私有成员<br>\n构造函数不能继承，C++11 起支持  <code>using Base::Base;</code>  继承构造函数<br>\n析构函数应为虚函数：如果类可能被继承，析构函数必须是  <code>virtual</code> ，否则  <code>delete基类指针</code> 会只调用基类析构，导致派生类资源泄漏</p>\n</blockquote>\n<div class=\"note info\">\n<p>多重继承</p>\n</div>\n<p><mark>如果一个类可能被继承（作为基类），那么它的析构函数就应该声明为  <code>virtual</code> </mark><br>\n 否则，当用基类指针（或引用）删除派生类对象时，派生类的析构函数不会被调用，造成资源泄漏<br>\n原因：virtual 让析构函数变成动态绑定，delete 时，程序会通过虚函数表（vtable）找到实际对象的类型</p>\n<ol start=\"10\">\n<li>为什么构造函数不能是虚函数？<br>\n虚函数依赖对象的 vptr<br>\n 构造函数执行时，对象还没完全构造，vptr 还没初始化<br>\n每个有虚函数的类，编译器会生成一个 虚函数表（vtable），里面存着虚函数的地址。<br>\n每个对象内部有一个虚指针（vptr），指向自己的 vtable。<br>\n调用虚函数时：<br>\n对象 -&gt; vptr -&gt; vtable -&gt; 找到函数地址 -&gt; 调用</li>\n</ol>\n<ul>\n<li>构造函数执行时：</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>例子</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"string\">&quot;Animal sound\\n&quot;</span>; &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Animal</span>() &#123;  <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">        <span class=\"comment\">// 在这里，vptr 被设置为指向 Animal 的 vtable</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> : <span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123; cout &lt;&lt; <span class=\"string\">&quot;汪汪！\\n&quot;</span>; &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Dog</span>() &#123;  <span class=\"comment\">// Dog 的构造函数</span></span><br><span class=\"line\">        <span class=\"comment\">// 在这里，vptr 被更新为指向 Dog 的 vtable</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>调用 Dog dog;<br>\n 先调用 Animal 的构造函数<br>\n此时，dog 对象的 vptr 被初始化为指向 Animal 的 vtable<br>\n 再调用 Dog 的构造函数<br>\n vptr 被更新为指向 Dog 的 vtable</p>\n<div class=\"note danger\">\n<p>虚拟构造函数（后面在学）</p>\n</div>\n<ol start=\"11\">\n<li>重载（Overload）、重写（Override）、隐藏（Hiding）<br>\nOverload: 同一个作用域（通常是同一个类），函数名相同，参数列表不同（类型、个数、顺序），返回类型可以不同（但不能仅靠返回类型区分）<br>\nOverride: 发生在继承关系中，基类函数必须是 virtual，函数名、参数列表、返回类型（或协变）完全相同，派生类中使用 override<br>\nHiding: 两种情况① 函数名相同，参数不同；② 函数名相同，但基类函数不是 virtual</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>隐藏</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Animal speak&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">(string msg)</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Animal says: &quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> : <span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123;  <span class=\"comment\">// ✅ 重写 speak()</span></span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Dog barks&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 注意：speak(string) 被隐藏了！</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Dog d;</span><br><span class=\"line\">d.<span class=\"built_in\">speak</span>();           <span class=\"comment\">// 输出：Dog barks</span></span><br><span class=\"line\"><span class=\"comment\">// d.speak(&quot;hello&quot;); // 编译错误！speak(string) 被隐藏</span></span><br></pre></td></tr></table></figure>\n<p>解除隐藏：添加  <code>using Base::speak;</code></p>\n<ol start=\"12\">\n<li>深拷贝浅拷贝<br>\n深拷贝复制相同大小的内容到堆区，浅拷贝把源对象的指针赋给目标对象，多个对象的指针会指向同一块内存，容易导致双重释放</li>\n</ol>\n<p>类里面有动态分配的资源比如 <code>int*</code> ,  <code>char*</code>  必须进行深拷贝：</p>\n<ul>\n<li>析构函数</li>\n<li>构造函数和拷贝构造需要手动实现深拷贝（比如 strcpy）</li>\n<li><mark>重载赋值运算符</mark></li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>深拷贝</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyString</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">char</span>* data;  <span class=\"comment\">// 指向堆上的字符串</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 1️⃣ 构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">MyString</span>(<span class=\"type\">const</span> <span class=\"type\">char</span>* str = <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (str == <span class=\"literal\">nullptr</span> || str[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;\\0&#x27;</span>) &#123;</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"type\">char</span>[<span class=\"number\">1</span>];</span><br><span class=\"line\">            data[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"type\">char</span>[<span class=\"built_in\">strlen</span>(str) + <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(data, str);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2️⃣ 析构函数：释放资源</span></span><br><span class=\"line\">    ~<span class=\"built_in\">MyString</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] data;  <span class=\"comment\">// 释放堆内存</span></span><br><span class=\"line\">        data = <span class=\"literal\">nullptr</span>; <span class=\"comment\">// 防止悬空（可选）</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3️⃣ 拷贝构造函数：深拷贝</span></span><br><span class=\"line\">    <span class=\"built_in\">MyString</span>(<span class=\"type\">const</span> MyString&amp; other) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (other.data == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"type\">char</span>[<span class=\"built_in\">strlen</span>(other.data) + <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(data, other.data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 4️⃣ 拷贝赋值运算符：深拷贝赋值</span></span><br><span class=\"line\">    MyString&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> MyString&amp; other) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 自我赋值检查</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == &amp;other) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 先释放旧资源</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] data;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 分配新内存，深拷贝</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (other.data == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"type\">char</span>[<span class=\"built_in\">strlen</span>(other.data) + <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(data, other.data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 辅助函数：打印</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; (data ? data : <span class=\"string\">&quot;null&quot;</span>) &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ol start=\"13\">\n<li>\n<p>拷贝构造参数不是引用行吗？<br>\n拷贝构造的参数不是引用会导致无限递归，加 const 是为了避免通过形参修改实参</p>\n</li>\n<li>\n<p>堆和栈的区别？<br>\n堆是由程序员手动申请和释放的，可以使用 new 和 malloc 申请，释放使用 delete 和 free。内存空间较大，从低地址到高地址，访问速度较慢，有碎片问题，适合用于大对象、动态数组等<br>\n栈由编译器自动分配和释放，内存空间较小，从高地址到低地址，访问速度快，无碎片问题，适合用于局部变量、函数参数、返回地址</p>\n</li>\n</ol>\n<ul>\n<li>为什么栈快，堆慢？<br>\n栈：内存分配只是移动栈指针（esp），是 CPU 指令级操作，极快。<br>\n堆：需要调用操作系统 API，查找合适的内存块，维护空闲链表，效率较低。</li>\n</ul>\n<ol start=\"15\">\n<li>内联函数<br>\n请求编译器将函数体直接插入到调用处的机制，避免函数调用的开销<br>\n但是只是对编译器的建议，编译器不一定会实现<br>\n一般来说递归函数不适合内联，因为递归调用会生成临时变量，这些变量在函数退出时会被销毁，内联函数的临时变量会一直存在，导致内存泄漏；虚函数也不适合内联，内联函数在编译的时候确定代码，但虚函数是运行时多态</li>\n</ol>\n<ul>\n<li>使用 <code>inline</code>  关键字</li>\n<li>类内定义函数自动内联<br>\n内联函数比宏定义安全：</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>宏定义vs内联函数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAX(a,b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class=\"line\"><span class=\"type\">int</span> x = <span class=\"built_in\">MAX</span>(i++, j++);  <span class=\"comment\">// i 和 j 可能被 ++ 两次！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123; <span class=\"keyword\">return</span> a &gt; b ? a : b; &#125;</span><br><span class=\"line\"><span class=\"type\">int</span> x = <span class=\"built_in\">max</span>(i++, j++);  <span class=\"comment\">// 安全，参数只计算一次</span></span><br></pre></td></tr></table></figure>\n<p>定义写在类内不需要显式写 inline 关键字，定义在类外需要</p>\n<ol start=\"16\">\n<li>友元<br>\n允许某个函数或类 “突破封装”，访问另一个类的私有（private）和保护（protected）成员。</li>\n</ol>\n<ul>\n<li>将非成员函数声明为友元函数：非成员函数可以直接访问 <code>private</code>  和 <code>protected</code>  成员</li>\n<li>将其他类的成员函数声明为友元函数：其他类成员函数可以直接访问 <code>private</code>  和 <code>protected</code>  成员</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>友元</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"type\">void</span> <span class=\"title\">Student::show</span><span class=\"params\">(Address *addr)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>友元类：一个类声明为另一个类的友元类，则该类中的所有成员函数都可以访问该类的 <code>private</code>  和 <code>protected</code>  成员</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>友元类</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Address</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"> <span class=\"built_in\">Address</span>(<span class=\"type\">char</span> *province, <span class=\"type\">char</span> *city, <span class=\"type\">char</span> *district);</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"> <span class=\"comment\">//将Student类声明为Address类的友元类，Student类中的所有成员函数都可以访问Address类的private成员</span></span><br><span class=\"line\"> <span class=\"keyword\">friend</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Student</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\"> <span class=\"type\">char</span> *m_province; <span class=\"comment\">//省份</span></span><br><span class=\"line\"> <span class=\"type\">char</span> *m_city; <span class=\"comment\">//城市</span></span><br><span class=\"line\"> <span class=\"type\">char</span> *m_district; <span class=\"comment\">//区（市区）</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ol start=\"17\">\n<li>智能指针<br>\n new 了没有 delete —— 内存泄漏<br>\n delete 之后没有置为 nullptr / 指针指向的对象生命周期结束 —— 野指针<br>\n多个指针指向同一块内存 —— 悬空指针<br>\n<mark>智能指针本质是封装指针的类模板</mark><br>\n RAII（Resource Acquisition Is Initialization）原则：资源在构造时获取，在析构时释放。</li>\n</ol>\n<ul>\n<li><code>unique_ptr</code> ：独占指针，只能有一个指针指向一块内存，不能拷贝，不能赋值，析构时会自动释放内存。赋值只能用 <code>std::move()</code>  转移所有权，此时 <code>u1</code>  的所有权被转移给 <code>u3</code> ， <code>u1</code>  变成空指针。<br>\n <code>unique_ptr</code>  支持管理数组，它会使用 <code>delete[]</code>  来释放数组内存（区别于 <code>auto_ptr</code> ，它使用 <code>delete</code>  来释放内存）</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>unique_ptr</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::unique_ptr&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">u1</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"type\">int</span>(<span class=\"number\">10</span>))</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// std::unique_ptr&lt;int&gt; u2 = u1;  // 编译错误，不允许拷贝</span></span><br><span class=\"line\">std::unique_ptr&lt;<span class=\"type\">int</span>&gt; u3 = std::<span class=\"built_in\">move</span>(u1);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>shared_ptr</code> ：共享指针，多个指针可以指向一块内存，通过引用计数机制来管理对象的生命周期 。当一个 <code>shared_ptr</code>  指向对象时，引用计数加 1；当 <code>shared_ptr</code>  离开作用域或被重新赋值时，引用计数减 1，当引用计数为 0 时，对象会被自动释放<br>\n <code>shared_ptr</code>  在多线程环境中使用时，需要注意线程安全问题，因为引用计数的修改不是原子操作，可能会导致数据竞争 。为了解决这个问题，可以使用 <code>std::atomic</code>  来实现原子操作，或者使用互斥锁来保护引用计数的修改</li>\n<li><code>weak_ptr</code> ：不能访问指针指向的对象，不控制对象的生命周期，只能判断指针是否为空，不能赋值，析构时会自动释放内存。主要是用来解决两个 <code>shared_ptr</code>  对象之间形成循环引用的问题（循环引用计数永远不会归零，导致这两个对象永远无法被销毁），当一个 <code>shared_ptr</code>  对象被另一个 <code>shared_ptr</code>  对象所引用时，两个对象之间形成循环引用，导致内存泄漏。 <code>weak_ptr</code>  对象用来监视 <code>shared_ptr</code>  中管理的资源是否存在，可以判断指针是否为空，也可以获取指针指向的对象，但无法访问对象。 <code>weak_ptr</code>  对象可以通过 <code>lock()</code>  方法获取对应的 <code>shared_ptr</code>  对象，如果对象仍然存在，则返回对应的 <code>shared_ptr</code>  对象，否则返回一个空的 <code>shared_ptr</code>  对象。<br>\n使用 <code>weak_ptr</code>  时，需要通过 <code>lock</code>  函数将其提升为 <code>shared_ptr</code> ，才能访问对象 。如果对象已经被释放， <code>lock</code>  函数会返回一个空的 <code>shared_ptr</code></li>\n</ul>\n<ol start=\"18\">\n<li>模板<br>\n允许你写一份代码，编译器根据不同的类型自动生成对应的函数或类<br>\n比如 <code>swap</code> ：</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>模板</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">swap</span><span class=\"params\">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class=\"line\">    T temp = a;</span><br><span class=\"line\">    a = b;</span><br><span class=\"line\">    b = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>基本语法：</p>\n<figure class=\"highlight c++\"><figcaption><span>函数模板</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> U&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">add</span><span class=\"params\">(T a, U b)</span> -&gt; <span class=\"title\">decltype</span><span class=\"params\">(a + b)</span> </span>&#123; <span class=\"comment\">// auto表示返回值在后面指定，编译器会根据a+b的结果自动推导返回类型</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>类模板</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// template &lt;typename T1, typename T2, ...&gt;</span></span><br><span class=\"line\"><span class=\"comment\">// class ClassName &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     // 使用 T1, T2 等作为类型</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;;</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"type\">int</span> N&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Array</span> &#123;</span><br><span class=\"line\">    T data[N];</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    T&amp; <span class=\"keyword\">operator</span>[](<span class=\"type\">int</span> index) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> N; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>模板的实现（函数体）必须和声明放在同一个头文件中，STL 就是模板</p>\n<ol start=\"19\">\n<li>volatile<br>\n 原因：多处理器访问变量，缓存和主存可能存在不一致的问题<br>\n volatile 让变量的读写都从主存中读写，而不是从缓存中读写</li>\n</ol>\n<ul>\n<li>易变性（可见性）: … 可能不一致</li>\n<li>不可优化的：编译器不要做优化</li>\n</ul>\n<figure class=\"highlight c\"><figcaption><span>volatile</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"type\">int</span> a;</span><br><span class=\"line\">a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(%d, a);  </span><br></pre></td></tr></table></figure>\n<p>不加 <code>volatile</code>  的话编译器可能会优化成 `printf (% d, 1);</p>\n<ul>\n<li>顺序执行的：编译器会对无关的语句进行优化，可能会把 <code>printf</code>  放到 <code>a = 1</code>  的前面执行</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> j = <span class=\"number\">1</span></span><br><span class=\"line\">i += <span class=\"number\">1</span>;</span><br><span class=\"line\">j += <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>实际上执行顺序可能不是这样的（原因详见编译原理），写了 <code>volatile</code>  之后，编译器就不会改变顺序</p>\n<ul>\n<li>使用场景：多线程共享字段（标志位）且经常被修改；中断服务程序和硬件设备访问相关的情况（指针可以是 <code>volatile</code> ）</li>\n<li>误区： <code>volatile</code>  修饰的变量不能保证原子性，原子性需要通过原子操作或者锁来实现</li>\n</ul>\n<ol start=\"20\">\n<li>static<br>\nc 语言中：</li>\n</ol>\n<ul>\n<li>用于局部变量（函数内部）\n<ul>\n<li>作用：使局部变量具有静态存储期（即程序运行期间一直存在），但作用域仍限于当前括号之内。</li>\n<li>初始化：只在第一次进入函数时初始化一次。</li>\n<li>默认值：未显式初始化则为 0。</li>\n</ul>\n</li>\n<li>用于全局变量或函数\n<ul>\n<li>作用：将变量或函数的链接属性（linkage）设为内部链接（internal linkage），即仅在当前源文件中可见，其他文件无法访问。</li>\n<li>目的：实现封装，避免命名冲突。<br>\nc++ 中：<br>\n <code>C++</code>  继承了 <code>C</code>  中 <code>static</code>  的所有用法，还增加了面向对象场景下的新用途</li>\n</ul>\n</li>\n<li>静态成员变量：\n<ul>\n<li>属于类本身，而不是类的某个对象。</li>\n<li>所有对象共享同一个静态成员。</li>\n<li>必须在类外定义（C<ins>17 前），C</ins>17 起可用 inline static 在类内定义。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>static</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">int</span> count;       <span class=\"comment\">// 声明</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> MyClass::count = <span class=\"number\">0</span>;     <span class=\"comment\">// 定义（C++17 前必需）</span></span><br><span class=\"line\"><span class=\"comment\">// 或 C++17 起：</span></span><br><span class=\"line\"><span class=\"comment\">// inline static int count = 0;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>静态成员函数：\n<ul>\n<li>不属于任何对象，不能访问非静态成员（因为没有 this 指针）。</li>\n<li>可直接通过类名调用。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>static</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不能访问非静态成员</span></span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Static function\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">MyClass::<span class=\"built_in\">print</span>(); <span class=\"comment\">// 无需对象</span></span><br></pre></td></tr></table></figure>\n<p>C++11 起，static 局部变量的初始化自动线程安全，c 语言没有这种保证</p>\n<ol start=\"21\">\n<li>c 语言保证线程安全<br>\n C 语言标准库本身（C89/C99/C11 等）在早期版本中并不直接提供线程或锁操作，但 C11 标准（ISO/IEC 9899:2011）引入了多线程支持，包括锁（mutex）等同步原语。<br>\nC11 引入了 &lt;threads.h&gt; 头文件，提供了类似 POSIX 的线程和锁接口。</li>\n</ol>\n<figure class=\"highlight c\"><figcaption><span>mutex</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;threads.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 互斥锁类型</span></span><br><span class=\"line\"><span class=\"type\">mtx_t</span> mutex;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化锁</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">mtx_init</span><span class=\"params\">(<span class=\"type\">mtx_t</span> *mtx, <span class=\"type\">int</span> type)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加锁（阻塞）</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">mtx_lock</span><span class=\"params\">(<span class=\"type\">mtx_t</span> *mtx)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 尝试加锁（非阻塞）</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">mtx_trylock</span><span class=\"params\">(<span class=\"type\">mtx_t</span> *mtx)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解锁</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">mtx_unlock</span><span class=\"params\">(<span class=\"type\">mtx_t</span> *mtx)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 销毁锁</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">mtx_destroy</span><span class=\"params\">(<span class=\"type\">mtx_t</span> *mtx)</span>;</span><br></pre></td></tr></table></figure>\n<p>比如线程安全计数器</p>\n<figure class=\"highlight c\"><figcaption><span>mutex</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;threads.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> counter = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">mtx_t</span> mutex;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">increment</span><span class=\"params\">(<span class=\"type\">void</span>* arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++) &#123;</span><br><span class=\"line\">        mtx_lock(&amp;mutex);</span><br><span class=\"line\">        counter++;</span><br><span class=\"line\">        mtx_unlock(&amp;mutex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    mtx_init(&amp;mutex, mtx_plain);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">thrd_t</span> t1, t2;</span><br><span class=\"line\">    thrd_create(&amp;t1, increment, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    thrd_create(&amp;t2, increment, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    thrd_join(t1, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    thrd_join(t2, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Counter = %d\\n&quot;</span>, counter); <span class=\"comment\">// 应为 200000</span></span><br><span class=\"line\">    mtx_destroy(&amp;mutex);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实际上用得多的可能是 pthreads</p>\n<figure class=\"highlight c\"><figcaption><span>pthreads</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或动态初始化</span></span><br><span class=\"line\">pthread_mutex_init(&amp;mutex, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加锁</span></span><br><span class=\"line\">pthread_mutex_lock(&amp;mutex);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 尝试加锁</span></span><br><span class=\"line\">pthread_mutex_trylock(&amp;mutex);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解锁</span></span><br><span class=\"line\">pthread_mutex_unlock(&amp;mutex);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 销毁</span></span><br><span class=\"line\">pthread_mutex_destroy(&amp;mutex);</span><br></pre></td></tr></table></figure>\n<p>示例</p>\n<figure class=\"highlight c\"><figcaption><span>pthreads</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> counter = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span>* <span class=\"title function_\">increment</span><span class=\"params\">(<span class=\"type\">void</span>* arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++) &#123;</span><br><span class=\"line\">        pthread_mutex_lock(&amp;mutex);</span><br><span class=\"line\">        counter++;</span><br><span class=\"line\">        pthread_mutex_unlock(&amp;mutex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">pthread_t</span> t1, t2;</span><br><span class=\"line\">    pthread_create(&amp;t1, <span class=\"literal\">NULL</span>, increment, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    pthread_create(&amp;t2, <span class=\"literal\">NULL</span>, increment, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    pthread_join(t1, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    pthread_join(t2, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Counter = %d\\n&quot;</span>, counter);</span><br><span class=\"line\">    pthread_mutex_destroy(&amp;mutex);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"22\">\n<li>\n<p>typedef 和 define<br>\n#define 是 “文本替换”，像 Word 的 “查找替换”，预处理的时候替换；<br>\ntypedef 是 “类型定义” 的关键字，是编译器理解的真正类型别名。typedef 可以定义新的类型，也可以定义新的类型别名，但不能定义常量 / 宏函数，在编译的时候处理</p>\n</li>\n<li>\n<p>数组指针和指针数组<br>\n数组指针：<br>\n指向数组的指针</p>\n</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>array pointer</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> *p[<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> b[<span class=\"number\">12</span>] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>, <span class=\"number\">12</span>&#125;;</span><br><span class=\"line\">p = b;</span><br></pre></td></tr></table></figure>\n<p>指针数组：<br>\n数组的元素是指针</p>\n<figure class=\"highlight c++\"><figcaption><span>pointer array</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>* p[<span class=\"number\">4</span>];</span><br></pre></td></tr></table></figure>\n<ol start=\"24\">\n<li>函数指针<br>\n函数指针：<br>\n指向函数的指针</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>function pointer</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> (*p)(<span class=\"type\">int</span>, <span class=\"type\">int</span>); <span class=\"comment\">// 括号不能省略</span></span><br><span class=\"line\">p = add;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123; <span class=\"keyword\">return</span> a + b; &#125;</span><br><span class=\"line\"><span class=\"type\">int</span> result = <span class=\"built_in\">p</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, result); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>函数指针没有自增和自减运算</p>\n<blockquote>\n<p>区分 int *p 和 int (*p)<br>\n 前者是一个指向 int 类型的指针，后者有可能是一个数组指针或是返回 int 类型的函数指针</p>\n</blockquote>\n<ol start=\"25\">\n<li>如何保证线程安全？</li>\n</ol>\n<ul>\n<li>锁</li>\n<li>原子操作</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>atomic</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;atomic&gt;</span></span></span><br><span class=\"line\">std::atomic&lt;<span class=\"type\">int</span>&gt; counter;</span><br><span class=\"line\">counter.<span class=\"built_in\">fetch_add</span>(<span class=\"number\">1</span>);   <span class=\"comment\">// fetch_sub(), fetch_and(), fetch_or()...</span></span><br><span class=\"line\">counter.<span class=\"built_in\">load</span>();</span><br><span class=\"line\">counter.<span class=\"built_in\">store</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">counter.<span class=\"built_in\">exchange</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">counter.<span class=\"built_in\">compare_exchange_strong</span>(old_value, new_value);  <span class=\"comment\">// 如果old_value == counter，则将 counter 设为 new_value</span></span><br><span class=\"line\">counter.<span class=\"built_in\">compare_exchange_weak</span>(old_value, new_value);    <span class=\"comment\">// 区别：weak 版本允许虚假失败，需要循环</span></span><br><span class=\"line\">counter.<span class=\"built_in\">is_lock_free</span>();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>线程同步原语</li>\n</ul>\n<ol start=\"26\">\n<li><code>const</code>  用法</li>\n</ol>\n<ul>\n<li>常量变量<br>\n必须在定义时初始化</li>\n<li>常量指针 vs 指针常量：见上</li>\n<li>引用与 const：见上 <code>const 引用</code></li>\n<li>类中的 const:\n<ul>\n<li>const 成员函数：不能修改对象成员变量，不能调用非 const 成员函数</li>\n<li>const 对象：const 对象只能调用 const 成员函数</li>\n</ul>\n</li>\n</ul>\n<ol start=\"27\">\n<li>多线程<br>\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucnVub29iLmNvbS9jcGx1c3BsdXMvY3BwLW11bHRpdGhyZWFkaW5nLmh0bWw=\"> https://www.runoob.com/cplusplus/cpp-multithreading.html</span></li>\n</ol>\n",
            "tags": [
                "C++"
            ]
        }
    ]
}