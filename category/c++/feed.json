{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog • All posts by \"c++\" category",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/10/26/oop/note/",
            "url": "http://example.com/2025/10/26/oop/note/",
            "title": "C++八股",
            "date_published": "2025-10-25T16:00:00.000Z",
            "content_html": "<ol>\n<li>\n<p>面向对象 vs 面向过程<br>\n面向对象三大特性：封装、继承、多态<br>\n c++ 不是完全面向对象的语言<br>\n封装：把数据和方法打包成一个类，隐藏实现细节，只提供接口<br>\n继承：子类继承父类的属性和方法，子类可以扩展父类的功能，实现代码复用<br>\n多态：在运行时，根据对象的实际类型，调用对应的函数。主要通过虚函数和继承实现</p>\n</li>\n<li>\n<p>C++ 编译过程<br>\n预处理 -&gt; 编译 -&gt; 汇编 -&gt; 链接<br>\n预处理：预处理指令、宏定义、包含文件 (处理 #include, #define, 条件编译等)<br>\n 编译：把源代码编译成汇编代码 (将 .cpp 转为 .s)<br>\n 汇编：把汇编代码编译成机器码<br>\n链接：把多个对象文件链接成可执行文件 (将多个目标文件和库合并成可执行文件)<br>\n<mark> 第三方库就是在第 4 步 —— 链接（Linking）阶段加入的</mark><br>\n在 链接阶段，通过 -lxxx（如 -lcurl）告诉链接器：“我要用这个库”，然后链接器去找到对应的 静态库（.a 或 .lib）或动态库（.so 或 .dll）<br>\n静态库在在编译过程中（链接阶段）被载入可执行程序，生成的可执行文件体积较大<br>\n动态库是在运行时才载入内存，但更新库后需要重新编译。<mark>动态库是运行时库</mark></p>\n</li>\n<li>\n<p>静态链接和动态链接<br>\n静态链接：把所有用到的库文件都链接到可执行文件中，编译速度慢，但运行速度快<br>\n动态链接：把所有用到的库文件都放到一个单独的文件中，运行时再加载，编译速度快，但运行速度慢</p>\n</li>\n<li>\n<p>静态多态（编译时多态） 和 动态多态（运行时多态）</p>\n</li>\n</ol>\n<ul>\n<li>动态多态（Dynamic Polymorphism）—— 运行时多态<br>\n这是通过 继承 + 虚函数（virtual function） 实现的。动态多态是通过虚函数重写实现的，是在运行期间确定的多态，是一种<mark>晚绑定</mark>机制（或<mark>动态绑定</mark>），在运行期间才能确定调用哪一个函数</li>\n</ul>\n<blockquote>\n<p>基类中的虚函数：使用 virtual 关键字声明。<br>\n派生类重写（override）虚函数。<br>\n通过基类指针或引用调用虚函数。<br>\n必须通过 基类指针或引用 调用虚函数，涉及虚函数表（ <code>vtable</code> ）和虚指针（ <code>vptr</code> ）</p>\n</blockquote>\n<div class=\"note info\">\n<p>虚函数如何实现晚绑定？<br>\n每个有虚函数的类有一个 虚函数表（vtable），存函数指针。<br>\n每个对象有一个 虚指针（vptr），指向自己的 vtable。<br>\n调用虚函数时：<br>\n通过对象的 vptr 找到 vtable<br>\n 在 vtable 中查找对应函数地址<br>\n调用该函数<br>\n这个过程在运行时完成，所以是晚绑定。</p>\n</div>\n<ul>\n<li>静态多态（Static Polymorphism）—— 编译时多态<br>\n在编译期就确定了调用哪个函数，不涉及运行时开销，属于 “<mark>早绑定</mark>（Early Binding）”</li>\n</ul>\n<blockquote>\n<p>函数重载（Function Overloading）<br>\n运算符重载（Operator Overloading）<br>\n函数模板（Function Templates）</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>例子</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1. 函数重载</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Integer: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">double</span> x)</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Double: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; s)</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;String: &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 函数模板（泛型）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printGeneric</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; value)</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Generic: &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 运算符重载</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> x, y;</span><br><span class=\"line\">    <span class=\"built_in\">Point</span>(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y) : <span class=\"built_in\">x</span>(x), <span class=\"built_in\">y</span>(y) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Point <span class=\"keyword\">operator</span>+(<span class=\"type\">const</span> Point&amp; other) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Point</span>(x + other.x, y + other.y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"number\">42</span>);           <span class=\"comment\">// 调用 print(int)</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"number\">3.14</span>);         <span class=\"comment\">// 调用 print(double)</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hello&quot;</span>);      <span class=\"comment\">// 调用 print(string)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printGeneric</span>(<span class=\"number\">100</span>);   <span class=\"comment\">// 编译时生成 printGeneric&lt;int&gt;</span></span><br><span class=\"line\">    <span class=\"built_in\">printGeneric</span>(<span class=\"number\">2.5</span>);   <span class=\"comment\">// 生成 printGeneric&lt;double&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Point <span class=\"title\">p1</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span>, <span class=\"title\">p2</span><span class=\"params\">(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span></span>;</span><br><span class=\"line\">    Point p3 = p1 + p2;  <span class=\"comment\">// 使用重载的 +</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Point: (&quot;</span> &lt;&lt; p<span class=\"number\">3.</span>x &lt;&lt; <span class=\"string\">&quot;, &quot;</span> &lt;&lt; p<span class=\"number\">3.</span>y &lt;&lt; <span class=\"string\">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>必须通过指针或引用调用 才能触发多态。如果直接用对象调用，会是静态绑定。<br>\n想用多态，必须用基类指针或基类引用去操作派生类对象</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>例子</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Animal speaks&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> : <span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Dog barks: 汪汪！&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过指针调用 → 触发多态（动态绑定）</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>1</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Dog dog;</span><br><span class=\"line\">    Animal* ptr = &amp;dog;  <span class=\"comment\">// 基类指针指向派生类对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ptr-&gt;<span class=\"built_in\">speak</span>();  <span class=\"comment\">// 输出 Dog barks: 汪汪！</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过引用调用 → 也触发多态</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>2</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">makeAnimalSpeak</span><span class=\"params\">(Animal&amp; animal)</span> </span>&#123;</span><br><span class=\"line\">    animal.<span class=\"built_in\">speak</span>();  <span class=\"comment\">// 动态绑定</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Dog dog;</span><br><span class=\"line\">    <span class=\"built_in\">makeAnimalSpeak</span>(dog);  <span class=\"comment\">// 输出：Dog barks: 汪汪！</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>直接对对象调用，静态绑定</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>3</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Dog dog;</span><br><span class=\"line\">    Animal a = dog;  <span class=\"comment\">// 把 Dog 对象赋值给 Animal 对象（会发生“对象切片”）</span></span><br><span class=\"line\"></span><br><span class=\"line\">    a.<span class=\"built_in\">speak</span>();  <span class=\"comment\">// 输出 Animal speaks</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>指针 vs 引用<br>\n引用是别名，指针是表示地址的变量<br>\n引用的特性：</li>\n</ol>\n<blockquote>\n<p>必须初始化，引用定义时必须绑定到一个变量<br>\n不能重新绑定，一旦绑定，就不能再指向其他变量<br>\n操作即原变量，对引用的所有操作都作用于原变量</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>引用</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>&amp; ref;     <span class=\"comment\">// 错误！未初始化</span></span><br><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">5</span>, b = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span>&amp; ref = a;</span><br><span class=\"line\">ref = b;      <span class=\"comment\">// 注意：这是赋值！不是重新绑定！a 变成 10，ref 仍绑定 a，此时a 和 ref 都是 10</span></span><br></pre></td></tr></table></figure>\n<p>引用的常见用法：</p>\n<blockquote>\n<p>函数参数传递：传递大对象（如 string、vector）<br>\n函数返回值（返回对象本身，支持链式调用）</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>引用</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyInt</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> value;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MyInt</span>(<span class=\"type\">int</span> v) : <span class=\"built_in\">value</span>(v) &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 返回引用，支持链式赋值</span></span><br><span class=\"line\">    MyInt&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> MyInt&amp; other) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != &amp;other) &#123;  <span class=\"comment\">// 自赋值检查</span></span><br><span class=\"line\">            value = other.value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;  <span class=\"comment\">// 返回当前对象的引用</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">MyInt <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">1</span>)</span>, <span class=\"title\">b</span><span class=\"params\">(<span class=\"number\">2</span>)</span>, <span class=\"title\">c</span><span class=\"params\">(<span class=\"number\">3</span>)</span></span>;</span><br><span class=\"line\">a = b = c;  <span class=\"comment\">// 链式赋值：b=c 返回 b 的引用，再赋给 a</span></span><br></pre></td></tr></table></figure>\n<div class=\"note danger\">\n<p>不能返回局部变量的引用</p>\n</div>\n<figure class=\"highlight c++\"><figcaption><span>错误</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span>&amp; <span class=\"title\">getRef</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;  <span class=\"comment\">// 错误！x 是局部变量，函数结束后销毁</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>遍历容器（避免拷贝元素）</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>遍历容器</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;string&gt; names = &#123;<span class=\"string\">&quot;Alice&quot;</span>, <span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Charlie&quot;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用引用遍历，避免拷贝字符串</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">const</span> string&amp; name : names) &#123;</span><br><span class=\"line\">    cout &lt;&lt; name &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或使用 auto&amp;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; name : names) &#123;</span><br><span class=\"line\">    name += <span class=\"string\">&quot; (modified)&quot;</span>;  <span class=\"comment\">// 如果想修改原元素</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>作为输出参数（替代指针）</p>\n</blockquote>\n<ol start=\"7\">\n<li>const 引用<br>\n引用是别名，const 引用是常量别名，不能修改别名指向的变量</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>const引用</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span>&amp; cref = x;  <span class=\"comment\">// cref 是 x 的常引用</span></span><br><span class=\"line\">cref = <span class=\"number\">20</span>;            <span class=\"comment\">// 错误！不能通过 cref 修改 x</span></span><br></pre></td></tr></table></figure>\n<p>可以用来绑定临时对象（延长生命周期）</p>\n<figure class=\"highlight c++\"><figcaption><span>常引用</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">3.14</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">double</span>&amp; r = <span class=\"built_in\">getValue</span>();  <span class=\"comment\">// 合法！临时对象生命周期延长到 r 结束</span></span><br><span class=\"line\">cout &lt;&lt; r;  <span class=\"comment\">// 输出 3.14</span></span><br></pre></td></tr></table></figure>\n<p>getValue () 的值在表达式结束就应该销毁了，但是当一个 const 引用绑定到临时对象时，这个临时对象的生命周期会被 “延长”，直到引用 r 结束为止。<br>\n用法：</p>\n<blockquote>\n<p>避免不必要的拷贝</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>引用</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> string&amp; s = <span class=\"string\">&quot;hello&quot;</span>;  <span class=\"comment\">// 不拷贝字符串</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>支持函数链式调用</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>引用</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> string&amp; result = <span class=\"built_in\">getPrefix</span>() + <span class=\"built_in\">getName</span>() + <span class=\"built_in\">getSuffix</span>();</span><br><span class=\"line\"><span class=\"comment\">// 临时 string 对象被 const 引用延长生命周期</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>STL 中使用</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>STL</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; item : vec) &#123; ... &#125;  <span class=\"comment\">// 避免拷贝，安全高效</span></span><br></pre></td></tr></table></figure>\n<ol start=\"8\">\n<li>左值引用 vs 右值引用<br>\n左值：有名字、能取地址的变量，可以放在赋值号左边，生命周期较长<br>\n右值：临时变量，不能取地址，生命周期较短，通常在表达式中 “用完就扔”</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>右值</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10</span>;                <span class=\"comment\">// 字面量，右值</span></span><br><span class=\"line\">x + <span class=\"number\">1</span>;             <span class=\"comment\">// 表达式结果，右值</span></span><br><span class=\"line\"><span class=\"built_in\">string</span>(<span class=\"string\">&quot;hello&quot;</span>);   <span class=\"comment\">// 临时 string 对象，右值</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>右值引用（T&amp;&amp;）就是一种可以绑定到右值（临时对象）的引用。</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>右值引用</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//类型&amp;&amp; 右值引用名 = 右值;</span></span><br><span class=\"line\"><span class=\"type\">int</span>&amp;&amp; rref = <span class=\"number\">10</span>;           <span class=\"comment\">// 10 是右值，rref 是它的右值引用</span></span><br><span class=\"line\"><span class=\"type\">int</span>&amp;&amp; rref2 = <span class=\"number\">5</span> + <span class=\"number\">3</span>;       <span class=\"comment\">// 表达式结果是右值</span></span><br><span class=\"line\">string&amp;&amp; sref = <span class=\"built_in\">string</span>(<span class=\"string\">&quot;临时字符串&quot;</span>);  <span class=\"comment\">// 绑定临时 string 对象</span></span><br></pre></td></tr></table></figure>\n<p>用法：对临时变量移动构造，避免深拷贝</p>\n<figure class=\"highlight c++\"><figcaption><span>移动构造</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// std:move(x) 将左值转换为右值引用，触发移动语义</span></span><br><span class=\"line\"><span class=\"function\">MyString <span class=\"title\">s1</span><span class=\"params\">(<span class=\"string\">&quot;hello&quot;</span>)</span></span>;</span><br><span class=\"line\">MyString s2 = std::<span class=\"built_in\">move</span>(s1);  <span class=\"comment\">// 告诉编译器：“s1 可以被移动了”</span></span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; s<span class=\"number\">1.</span>data;  <span class=\"comment\">// 可能是 nullptr！s1 处于“有效但不可用”状态</span></span><br></pre></td></tr></table></figure>\n<ol start=\"9\">\n<li>继承</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>继承</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    string name;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Animal</span>(string n) : <span class=\"built_in\">name</span>(n) &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span> </span>&#123; cout &lt;&lt; name &lt;&lt; <span class=\"string\">&quot; 在吃东西&quot;</span> &lt;&lt; endl; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Dog 继承 Animal，继承方式为 public</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> : <span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Dog</span>(string n) : <span class=\"built_in\">Animal</span>(n) &#123;&#125;  <span class=\"comment\">// 调用基类构造函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bark</span><span class=\"params\">()</span> </span>&#123; cout &lt;&lt; name &lt;&lt; <span class=\"string\">&quot; 汪汪叫！&quot;</span> &lt;&lt; endl; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Dog <span class=\"title\">d</span><span class=\"params\">(<span class=\"string\">&quot;小黄&quot;</span>)</span></span>;</span><br><span class=\"line\">    d.<span class=\"built_in\">eat</span>();   <span class=\"comment\">// 继承自 Animal</span></span><br><span class=\"line\">    d.<span class=\"built_in\">bark</span>();  <span class=\"comment\">// Dog 自己的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>| — | — | — | — |<br>\n| 继承方式 | 基类 public 成员 | 基类 protected 成员 | 基类 private 成员 |<br>\n|public | 在派生类中仍是 public | 在派生类中是 protected | 不可访问 |<br>\n|protected | 在派生类中是 protected | 在派生类中是 protected | 不可访问 |<br>\n|private | 在派生类中是 private | 在派生类中是 private | 不可访问 |</p>\n<p>继承中的构造与析构顺序</p>\n<blockquote>\n<p>构造顺序：<br>\n基类构造函数<br>\n成员对象构造函数（按声明顺序）<br>\n派生类构造函数<br>\n析构顺序：与构造相反<br>\n派生类析构函数<br>\n成员对象析构函数（按声明逆序）<br>\n基类析构函数</p>\n</blockquote>\n<figure class=\"highlight c++\"><figcaption><span>继承中的构造与析构顺序</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Base</span>() &#123; cout &lt;&lt; <span class=\"string\">&quot;Base 构造\\n&quot;</span>; &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">Base</span>() &#123; cout &lt;&lt; <span class=\"string\">&quot;Base 析构\\n&quot;</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Member</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Member</span>() &#123; cout &lt;&lt; <span class=\"string\">&quot;Member 构造\\n&quot;</span>; &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">Member</span>() &#123; cout &lt;&lt; <span class=\"string\">&quot;Member 析构\\n&quot;</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\">    Member m;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Derived</span>() &#123; cout &lt;&lt; <span class=\"string\">&quot;Derived 构造\\n&quot;</span>; &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">Derived</span>() &#123; cout &lt;&lt; <span class=\"string\">&quot;Derived 析构\\n&quot;</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Derived d;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：<br>\nBase 构造<br>\n Member 构造<br>\n Derived 构造<br>\n Derived 析构<br>\n Member 析构<br>\n Base 析构</p>\n<p>继承是实现  <code>动态多态</code>  的基础。<br>\n条件：</p>\n<ul>\n<li>基类有  <code>virtual</code>  函数</li>\n<li>派生类  <code>override</code>  它</li>\n<li>通过  <code>基类指针或引用</code>  调用</li>\n</ul>\n<blockquote>\n<p>继承类不能访问基类的私有成员<br>\n构造函数不能继承，C++11 起支持  <code>using Base::Base;</code>  继承构造函数<br>\n析构函数应为虚函数：如果类可能被继承，析构函数必须是  <code>virtual</code> ，否则  <code>delete基类指针</code> 会只调用基类析构，导致派生类资源泄漏</p>\n</blockquote>\n<div class=\"note info\">\n<p>多重继承</p>\n</div>\n<p><mark>如果一个类可能被继承（作为基类），那么它的析构函数就应该声明为  <code>virtual</code> </mark><br>\n 否则，当用基类指针（或引用）删除派生类对象时，派生类的析构函数不会被调用，造成资源泄漏<br>\n原因：virtual 让析构函数变成动态绑定，delete 时，程序会通过虚函数表（vtable）找到实际对象的类型</p>\n<ol start=\"10\">\n<li>为什么构造函数不能是虚函数？<br>\n虚函数依赖对象的 vptr<br>\n 构造函数执行时，对象还没完全构造，vptr 还没初始化<br>\n每个有虚函数的类，编译器会生成一个 虚函数表（vtable），里面存着虚函数的地址。<br>\n每个对象内部有一个虚指针（vptr），指向自己的 vtable。<br>\n调用虚函数时：<br>\n对象 -&gt; vptr -&gt; vtable -&gt; 找到函数地址 -&gt; 调用</li>\n</ol>\n<ul>\n<li>构造函数执行时：</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>例子</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"string\">&quot;Animal sound\\n&quot;</span>; &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Animal</span>() &#123;  <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">        <span class=\"comment\">// 在这里，vptr 被设置为指向 Animal 的 vtable</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> : <span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123; cout &lt;&lt; <span class=\"string\">&quot;汪汪！\\n&quot;</span>; &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Dog</span>() &#123;  <span class=\"comment\">// Dog 的构造函数</span></span><br><span class=\"line\">        <span class=\"comment\">// 在这里，vptr 被更新为指向 Dog 的 vtable</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>调用 Dog dog;<br>\n 先调用 Animal 的构造函数<br>\n此时，dog 对象的 vptr 被初始化为指向 Animal 的 vtable<br>\n 再调用 Dog 的构造函数<br>\n vptr 被更新为指向 Dog 的 vtable</p>\n<div class=\"note danger\">\n<p>虚拟构造函数（后面在学）</p>\n</div>\n<ol start=\"11\">\n<li>重载（Overload）、重写（Override）、隐藏（Hiding）<br>\nOverload: 同一个作用域（通常是同一个类），函数名相同，参数列表不同（类型、个数、顺序），返回类型可以不同（但不能仅靠返回类型区分）<br>\nOverride: 发生在继承关系中，基类函数必须是 virtual，函数名、参数列表、返回类型（或协变）完全相同，派生类中使用 override<br>\nHiding: 两种情况① 函数名相同，参数不同；② 函数名相同，但基类函数不是 virtual</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>隐藏</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Animal speak&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">(string msg)</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Animal says: &quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> : <span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123;  <span class=\"comment\">// ✅ 重写 speak()</span></span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Dog barks&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 注意：speak(string) 被隐藏了！</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Dog d;</span><br><span class=\"line\">d.<span class=\"built_in\">speak</span>();           <span class=\"comment\">// 输出：Dog barks</span></span><br><span class=\"line\"><span class=\"comment\">// d.speak(&quot;hello&quot;); // 编译错误！speak(string) 被隐藏</span></span><br></pre></td></tr></table></figure>\n<p>解除隐藏：添加  <code>using Base::speak;</code></p>\n<ol start=\"12\">\n<li>深拷贝浅拷贝<br>\n深拷贝复制相同大小的内容到堆区，浅拷贝把源对象的指针赋给目标对象，多个对象的指针会指向同一块内存，容易导致双重释放</li>\n</ol>\n<p>类里面有动态分配的资源比如 <code>int*</code> ,  <code>char*</code>  必须进行深拷贝：</p>\n<ul>\n<li>析构函数</li>\n<li>构造函数和拷贝构造需要手动实现深拷贝（比如 strcpy）</li>\n<li><mark>重载赋值运算符</mark></li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>深拷贝</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyString</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">char</span>* data;  <span class=\"comment\">// 指向堆上的字符串</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 1️⃣ 构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">MyString</span>(<span class=\"type\">const</span> <span class=\"type\">char</span>* str = <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (str == <span class=\"literal\">nullptr</span> || str[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;\\0&#x27;</span>) &#123;</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"type\">char</span>[<span class=\"number\">1</span>];</span><br><span class=\"line\">            data[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"type\">char</span>[<span class=\"built_in\">strlen</span>(str) + <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(data, str);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2️⃣ 析构函数：释放资源</span></span><br><span class=\"line\">    ~<span class=\"built_in\">MyString</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] data;  <span class=\"comment\">// 释放堆内存</span></span><br><span class=\"line\">        data = <span class=\"literal\">nullptr</span>; <span class=\"comment\">// 防止悬空（可选）</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3️⃣ 拷贝构造函数：深拷贝</span></span><br><span class=\"line\">    <span class=\"built_in\">MyString</span>(<span class=\"type\">const</span> MyString&amp; other) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (other.data == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"type\">char</span>[<span class=\"built_in\">strlen</span>(other.data) + <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(data, other.data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 4️⃣ 拷贝赋值运算符：深拷贝赋值</span></span><br><span class=\"line\">    MyString&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> MyString&amp; other) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 自我赋值检查</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == &amp;other) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 先释放旧资源</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] data;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 分配新内存，深拷贝</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (other.data == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"type\">char</span>[<span class=\"built_in\">strlen</span>(other.data) + <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(data, other.data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 辅助函数：打印</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; (data ? data : <span class=\"string\">&quot;null&quot;</span>) &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ol start=\"13\">\n<li>\n<p>拷贝构造参数不是引用行吗？<br>\n拷贝构造的参数不是引用会导致无限递归，加 const 是为了避免通过形参修改实参</p>\n</li>\n<li>\n<p>堆和栈的区别？<br>\n堆是由程序员手动申请和释放的，可以使用 new 和 malloc 申请，释放使用 delete 和 free。内存空间较大，从低地址到高地址，访问速度较慢，有碎片问题，适合用于大对象、动态数组等<br>\n栈由编译器自动分配和释放，内存空间较小，从高地址到低地址，访问速度快，无碎片问题，适合用于局部变量、函数参数、返回地址</p>\n</li>\n</ol>\n<ul>\n<li>为什么栈快，堆慢？<br>\n栈：内存分配只是移动栈指针（esp），是 CPU 指令级操作，极快。<br>\n堆：需要调用操作系统 API，查找合适的内存块，维护空闲链表，效率较低。</li>\n</ul>\n<ol start=\"15\">\n<li>内联函数<br>\n请求编译器将函数体直接插入到调用处的机制，避免函数调用的开销<br>\n但是只是对编译器的建议，编译器不一定会实现<br>\n一般来说递归函数不适合内联，因为递归调用会生成临时变量，这些变量在函数退出时会被销毁，内联函数的临时变量会一直存在，导致内存泄漏；虚函数也不适合内联，内联函数在编译的时候确定代码，但虚函数是运行时多态</li>\n</ol>\n<ul>\n<li>使用 <code>inline</code>  关键字</li>\n<li>类内定义函数自动内联<br>\n内联函数比宏定义安全：</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>宏定义vs内联函数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAX(a,b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class=\"line\"><span class=\"type\">int</span> x = <span class=\"built_in\">MAX</span>(i++, j++);  <span class=\"comment\">// i 和 j 可能被 ++ 两次！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123; <span class=\"keyword\">return</span> a &gt; b ? a : b; &#125;</span><br><span class=\"line\"><span class=\"type\">int</span> x = <span class=\"built_in\">max</span>(i++, j++);  <span class=\"comment\">// 安全，参数只计算一次</span></span><br></pre></td></tr></table></figure>\n<p>定义写在类内不需要显式写 inline 关键字，定义在类外需要</p>\n<ol start=\"16\">\n<li>\n<p>友元</p>\n</li>\n<li>\n<p>智能指针<br>\n允许某个函数或类 “突破封装”，访问另一个类的私有（private）和保护（protected）成员。</p>\n</li>\n</ol>\n",
            "tags": [
                "C++"
            ]
        }
    ]
}