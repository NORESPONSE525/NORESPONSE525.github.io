{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog • All posts by \"编译原理\" category",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/06/15/computer-science/compile-principles/ch6/",
            "url": "http://example.com/2025/06/15/computer-science/compile-principles/ch6/",
            "title": "Ch6",
            "date_published": "2025-06-14T16:00:00.000Z",
            "content_html": "<h1 id=\"activation-recordstack-frame\"><a class=\"markdownIt-Anchor\" href=\"#activation-recordstack-frame\">#</a> Activation Record/Stack Frame</h1>\n<p>函数的栈帧是栈上用来放函数的局部变量、参数、返回地址以及其他临时变量的区域<br>\n stack 一般从高地址向低地址，heap 从低地址向高地址<br>\n layout:<br>\n<img data-src=\"f1.jpg\" alt></p>\n<ul>\n<li>incoming arguments: 存储 caller 传递给 callee 的参数</li>\n<li>frame pointer: 帧指针，用来访问 incoming arguments，从低向高是 argument 1, argument 2, …</li>\n<li>local variables: 存储函数的局部变量（还有一些保存在寄存器里）</li>\n<li>return address: 存储需要返回 caller 的哪里；non-leaf 过程会把 return address 写入栈帧里面</li>\n<li>temporaries: 存储临时变量，复杂表达式拆出来的中间变量放的地方</li>\n<li>saved registers</li>\n<li>outgoing arguments: 存储当前函数要传递给别的函数的参数</li>\n<li>stack pointer: 栈指针，从低向高</li>\n</ul>\n<h2 id=\"函数调用流程\"><a class=\"markdownIt-Anchor\" href=\"#函数调用流程\">#</a> 函数调用流程：</h2>\n<ul>\n<li>g 调用 f 的时候</li>\n</ul>\n<ol>\n<li>进入 f 的时候，保存旧的 FP (g 的 FP)</li>\n<li>把 FP 设置为原来的 SP，把 SP = SP - frame size<br>\n<img data-src=\"f2.jpg\" alt></li>\n</ol>\n<ul>\n<li>f 返回的时候</li>\n</ul>\n<ol>\n<li>让 SP = FP (恢复 g 的 SP)</li>\n<li>从内存中读出 g 的 FP 恢复回去</li>\n</ol>\n<p>如果栈帧大小固定就只需要 FP 不需要 SP 了，因为 FP = SP + frame size</p>\n<h2 id=\"saved-register\"><a class=\"markdownIt-Anchor\" href=\"#saved-register\">#</a> saved register</h2>\n<p>函数 g 调用 f 的时候，用到了寄存器 r，调用 f 的时候要把 r 保存在 saved register 中，等调用结束再恢复回去</p>\n<ul>\n<li>caller-saved register: 函数调用的时候用到的寄存器，调用结束后可以恢复</li>\n<li>callee-saved register: 函数调用的时候用不到的寄存器，调用结束后不能恢复<br>\n<mark> FP 是由 callee 保存和恢复的</mark></li>\n</ul>\n<h2 id=\"参数传递\"><a class=\"markdownIt-Anchor\" href=\"#参数传递\">#</a> 参数传递</h2>\n<p>一般约定把前 k (4 or 6) 个参数放在寄存器传递，剩下的参数放在栈中传递<br>\n四种传参方法：</p>\n<ol>\n<li>不给叶过程 (leaf procedure) 分配栈帧<br>\n叶过程是指不调用其他过程的过程。在这种情况下，可以不为叶过程分配栈帧</li>\n<li>过程间寄存器分配 (interprocedural register allocation)<br>\n 这种方法需要先分析代码中全部的函数，然后再根据分析结果来分配寄存器。<br>\n假设有一个程序包含多个函数，通过全局分析发现某些变量在多个函数之间频繁使用，可以为其分配固定的寄存器，避免频繁的内存读写</li>\n<li>若变量 x 不再被使用，可以直接写其寄存器，不需要再保存 x 到栈帧中<br>\n当一个变量在当前作用域内不再被使用时，可以直接将其值写入寄存器，而无需保存到栈帧中</li>\n</ol>\n<figure class=\"highlight c\"><figcaption><span>example</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">exampleFunction</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> y = x * <span class=\"number\">2</span>;  <span class=\"comment\">// 使用x后，x不再被使用</span></span><br><span class=\"line\">    <span class=\"comment\">// 直接将y的值写入寄存器，无需保存x到栈帧中</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Result: %d\\n&quot;</span>, y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>寄存器窗口技术 (register windows)<br>\n 在每次函数调用时，系统会自动切换到一组新的寄存器，称为寄存器窗口。这样，每个函数都可以独立地使用自己的寄存器，而不会影响其他函数的寄存器状态。</li>\n</ol>\n<figure class=\"highlight c\"><figcaption><span>example</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">functionA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用寄存器窗口A</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">functionB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用寄存器窗口B</span></span><br><span class=\"line\">    functionA();  <span class=\"comment\">// 调用functionA时，自动切换到寄存器窗口A</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"frame-resident-variables\"><a class=\"markdownIt-Anchor\" href=\"#frame-resident-variables\">#</a> Frame-Resident Variables</h2>\n<p>什么情况下要把变量写入栈帧里面？、</p>\n<ol>\n<li>the varibles will be passed by reference 变量传地址 / 引用</li>\n<li>变量被嵌套在函数内部的函数访问（不绝对）</li>\n<li>变量太大了没法直接放寄存器</li>\n<li>变量是一个数组</li>\n<li>传递参数</li>\n<li>有太多局部变量和临时变量放不下了</li>\n</ol>\n<ul>\n<li>escape 逃逸：如果一个变量需要传地址 / 取地址 / 被过程内部嵌套的函数访问，那么这个变量就会逃逸。</li>\n</ul>\n<h2 id=\"static-links\"><a class=\"markdownIt-Anchor\" href=\"#static-links\">#</a> static links</h2>\n<p>在嵌套的函数声明中，内层函数是有可能用到外层函数的局部变量的。</p>\n<ul>\n<li>static links 是指向上一层嵌套层级的栈帧的指针。内层嵌套函数调用外层定义的变量的时候需要用到 static links，否则无法寻址。<br>\n<img data-src=\"f3.jpg\" alt><br>\n<img data-src=\"f4.jpg\" alt><br>\n只有调用自身的时候才传递自己的 static link 作为 static link，其他的都是把外层函数的 fp 作为 static link<br>\n 如果要访问外层变量，就顺着 static 一层一层查上去直到找到了为止。<br>\n其他访问方法：</li>\n<li>嵌套层次显示表 (display)<br>\n 建立一个全局数组，位置 i 包含一个指针，指向最近一次进入的，其静态嵌套深度是 i 的过程的栈帧<br>\n<img data-src=\"f5.jpg\" alt><br>\n先给它们标上嵌套深度<br>\n直接把链表变成数组了，需要用到一个变量，就查看当前变量的嵌套深度 i 然后直接找那个数组 i 位置的座位 fp 地址来找</li>\n<li>lambda lifting<br>\ng 调用 f 时，g 中每一个实际（或被嵌套在 f 内的任意函数）访问了的变量，都将作为额外的参数传递给 f<br>\n 把内部的函数，从内往外进行改写，改写函数的参数实现 lambda lifting<br>\n<img data-src=\"f6.jpg\" alt></li>\n</ul>\n<h2 id=\"tiger编译器的栈帧\"><a class=\"markdownIt-Anchor\" href=\"#tiger编译器的栈帧\">#</a> tiger 编译器的栈帧</h2>\n<p>tiger 不支持高阶函数<br>\n看不完了。。再说吧</p>\n",
            "tags": [
                "活动记录"
            ]
        },
        {
            "id": "http://example.com/2025/06/15/computer-science/compile-principles/ch7/",
            "url": "http://example.com/2025/06/15/computer-science/compile-principles/ch7/",
            "title": "Ch7",
            "date_published": "2025-06-14T16:00:00.000Z",
            "content_html": "<h1 id=\"ir\"><a class=\"markdownIt-Anchor\" href=\"#ir\">#</a> IR</h1>\n<p>Intermediate Representation<br>\n 解决高级语言和目标机器汇编语言之间的转化<br>\n为什么需要 IR:</p>\n<ul>\n<li>更模块化、可迁移</li>\n<li>分层分析和优化<br>\n IR 可以有好多层：IR1-&gt;IR2-&gt;…-&gt;IRn</li>\n</ul>\n<details class=\"info\"><summary>编译流程划分</summary><div>\n<p>前端：源代码 -&gt; 词法分析 -&gt; 语法分析 -&gt; 语义分析（IR 之前的都是）<br>\n中端：基于 IR 的分析与变换（可能生成新 IR，可以做一些机器无关优化比如循环展开等）<br>\n后端：指令选择 -&gt; 寄存器分配 -&gt; 指令调度 -&gt; 机器码（IR 之后的）</p>\n</div></details>\n<h2 id=\"three-address-code\"><a class=\"markdownIt-Anchor\" href=\"#three-address-code\">#</a> Three-Address Code</h2>\n<p>最多有三个操作数<br>\n x = y op z<br>\n “地址” 可以具有如下形式</p>\n<ul>\n<li>源程序中的名字 (name)</li>\n<li>常量 (constant)</li>\n<li>临时变量 (temporary)<br>\n<img data-src=\"f1.jpg\" alt><br>\n 最常见的实现方法是将三地址代码作为四元组实现</li>\n</ul>\n<details class=\"info\"><summary>example</summary><div>\n<p>t1=x&gt;0                  (gt, x, 0, t1)<br>\nif_false t1 goto L1     (if_f, t1, L1, _)<br>\nfact=1                  (asn, 1, fact, _)<br>\nlabel L2                (lab, L2, _, _)</p>\n</div></details>\n<h2 id=\"ir-tree\"><a class=\"markdownIt-Anchor\" href=\"#ir-tree\">#</a> IR Tree</h2>\n<p>两大类节点：</p>\n<ol>\n<li>表达式 Exp</li>\n<li>语句 Stmt<br>\n 文法：<br>\n<img data-src=\"f2.jpg\" alt><br>\n表达式：</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Node</th>\n<th>Description</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CONST(i)</td>\n<td>整数常量 i</td>\n<td>CONST(42) → the value 42</td>\n</tr>\n<tr>\n<td>NAME(n)</td>\n<td>符号常量 n，通常是一个 label，值是 label 的地址</td>\n<td>NAME(L1) → address of label L1</td>\n</tr>\n<tr>\n<td>TEMP(t)</td>\n<td>临时变量 t (like register)</td>\n<td>TEMP(t123) → contents of temporary t123</td>\n</tr>\n<tr>\n<td>BINOP(o,e1,e2)</td>\n<td>对 e1 和 e2 执行二元操作 o</td>\n<td>BINOP(PLUS,TEMP(t1),CONST(1)) → t1+1</td>\n</tr>\n<tr>\n<td>MEM(e)</td>\n<td>Memory access</td>\n<td>MEM(CONST(100)) → contents at address 100</td>\n</tr>\n<tr>\n<td>CALL(f,l)</td>\n<td>Function call, l 是参数列表</td>\n<td>CALL(NAME(print),[TEMP(t1)]) → call print(t1)</td>\n</tr>\n<tr>\n<td>ESEQ(s,e)</td>\n<td>先执行语句 s，再求值表达式 e 并返回 e 的结果</td>\n<td>ESEQ(MOVE(TEMP(t),CONST(1)),TEMP(t)) → (t=1; t)</td>\n</tr>\n</tbody>\n</table>\n<p>语句：</p>\n<table>\n<thead>\n<tr>\n<th>Node</th>\n<th>Description</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>MOVE(TEMP t, e)</td>\n<td>将表达式 e 的值赋给临时变量 t</td>\n<td>MOVE(TEMP(t1), CONST(42)) → t1 = 42</td>\n</tr>\n<tr>\n<td>MOVE(MEM(e1), e2)</td>\n<td>将表达式 e2 的值存储到由 e1 指定的内存地址中</td>\n<td>MOVE(MEM(TEMP(t1)), CONST(42)) → *t1 = 42</td>\n</tr>\n<tr>\n<td>EXP(e)</td>\n<td>计算表达式 e 的值但不返回结果，通常用于有副作用的操作（如函数调用）</td>\n<td>EXP (CALL (NAME (print), …)) → 调用 print () 函数以产生效果</td>\n</tr>\n<tr>\n<td>JUMP(e, labs)</td>\n<td>无条件跳转到由 e 指定的地址</td>\n<td>JUMP(NAME(L1), [L1]) → goto L1</td>\n</tr>\n<tr>\n<td>CJUMP(o,e1,e2,t,f)</td>\n<td>条件跳转，根据操作 o 对 e1 和 e2 的结果决定跳转到 t 或 f</td>\n<td>CJUMP (LT, TEMP (t1), CONST (0), L1, L2) → 如果 t1 &lt; 0 则跳转到 L1，否则跳转到 L2</td>\n</tr>\n<tr>\n<td>SEQ(s1, s2)</td>\n<td>语句序列，先执行 s1 再执行 s2</td>\n<td>SEQ (MOVE (…), JUMP (…)) → 先赋值再跳转</td>\n</tr>\n<tr>\n<td>LABEL(n)</td>\n<td>定义一个标签</td>\n<td>LABEL(L1) → L1:</td>\n</tr>\n</tbody>\n</table>\n<p>例子：<br>\n<img data-src=\"f3.jpg\" alt><br>\nADD 那个地方写成 BINOP 的写法也可以</p>\n<h2 id=\"翻译ast成ir-tree\"><a class=\"markdownIt-Anchor\" href=\"#翻译ast成ir-tree\">#</a> 翻译 AST 成 IR Tree</h2>\n<p>把 AST 表达式分为三类：</p>\n<ul>\n<li>Ex: 有结果的 AST 表达式比如 a+b</li>\n<li>Nx：无结果的语句的比如 print</li>\n<li>Cx：条件语句，值为 bool 的 AST 表达式</li>\n</ul>\n<ol>\n<li>翻译简单变量：<br>\n在函数中访问一个局部变量实际上是访问它在当前栈帧中的位置，所以访问一个距离 fp 的 offset 为 k 的局部变量 v，其 IR Tree 表示为:</li>\n</ol>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>M</mi><mi>E</mi><mi>M</mi><mo stretchy=\"false\">(</mo><mi>B</mi><mi>I</mi><mi>N</mi><mi>O</mi><mi>P</mi><mo stretchy=\"false\">(</mo><mi>P</mi><mi>L</mi><mi>U</mi><mi>S</mi><mo separator=\"true\">,</mo><mi>T</mi><mi>E</mi><mi>M</mi><mi>P</mi><mi>f</mi><mi>p</mi><mo separator=\"true\">,</mo><mi>C</mi><mi>O</mi><mi>N</mi><mi>S</mi><mi>T</mi><mi>k</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">MEM(BINOP(PLUS, TEMP fp, CONST k))\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal\">L</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">p</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p><img data-src=\"f4.jpg\" alt><br>\n如果通过 static link 访问一个变量，就要嵌套好几层 MEM 和 BINOP<br>\n 比如这个访问嵌套两层外面的 x<br>\n 最内层使用 CONST (8)：是因为需要从 inner 函数的帧指针 FP 开始，偏移 8 字节来访问静态链，该静态链指向 middle 函数的帧。<br>\n中间层和最外层使用 CONST (0)：是因为它们分别通过静态链直接访问 outer 函数的帧和变量 x，不需要额外的偏移<br>\n<img data-src=\"f5.jpg\" alt></p>\n<div class=\"note danger\">\n<p>这个地方为什么内层是 8 中层是 0 存疑</p>\n</div>\n<p>左值和右值：= 左右的<br>\n MEM (addr) 可以是左值也可以是右值</p>\n<ul>\n<li>Scalar L-value (Tiger): 一个地址</li>\n<li>Structured L-value (Pascal/C): 一块内存</li>\n</ul>\n<ol start=\"2\">\n<li>翻译算术运算</li>\n</ol>\n<ul>\n<li>二元: BINOP (op, e1, e2)</li>\n<li>一元:\n<ul>\n<li>-x ==&gt; BINOP(MINUS, CONST(0), e_x)</li>\n<li>~x ==&gt; BINOP(XOR, e_x, CONST(-1))</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li>数组访问</li>\n</ol>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>M</mi><mi>E</mi><mi>M</mi><mo stretchy=\"false\">(</mo><mi>B</mi><mi>I</mi><mi>N</mi><mi>O</mi><mi>P</mi><mo stretchy=\"false\">(</mo><mi>P</mi><mi>L</mi><mi>U</mi><mi>S</mi><mo separator=\"true\">,</mo><mi>M</mi><mi>E</mi><mi>M</mi><mo stretchy=\"false\">(</mo><msub><mi>e</mi><mi>a</mi></msub><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>B</mi><mi>I</mi><mi>N</mi><mi>O</mi><mi>P</mi><mo stretchy=\"false\">(</mo><mi>M</mi><mi>U</mi><mi>L</mi><mo separator=\"true\">,</mo><msub><mi>e</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><mi>C</mi><mi>O</mi><mi>N</mi><mi>S</mi><mi>T</mi><mo stretchy=\"false\">(</mo><mi>W</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">MEM(BINOP(PLUS, MEM(e_a), BINOP(MUL, e_i, CONST(W))))\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal\">L</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<ul>\n<li><code>e_a</code>  是表示变量  <code>a</code>  的表达式，通常是 ==  <code>MEM(+(TEMP(fp), CONST(k_a)))</code> ==</li>\n<li><code>MEM(e_a)</code> ：<mark>获取存储在变量  <code>a</code>  中的值，即数组基地址</mark></li>\n<li><code>e_i</code>  是计算索引  <code>i</code>  的表达式</li>\n<li><code>BINOP(MUL, e_i, CONST(W))</code> ：计算偏移<br>\n<img data-src=\"f6.jpg\" alt></li>\n</ul>\n<p>记录字段 r.f 访问:</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>M</mi><mi>E</mi><mi>M</mi><mo stretchy=\"false\">(</mo><mi>B</mi><mi>I</mi><mi>N</mi><mi>O</mi><mi>P</mi><mo stretchy=\"false\">(</mo><mi>P</mi><mi>L</mi><mi>U</mi><mi>S</mi><mo separator=\"true\">,</mo><mi>M</mi><mi>E</mi><mi>M</mi><mo stretchy=\"false\">(</mo><msub><mi>e</mi><mi>r</mi></msub><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>B</mi><mi>I</mi><mi>N</mi><mi>O</mi><mi>P</mi><mo stretchy=\"false\">(</mo><mi>M</mi><mi>U</mi><mi>L</mi><mo separator=\"true\">,</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>C</mi><mi>O</mi><mi>N</mi><mi>S</mi><mi>T</mi><mo stretchy=\"false\">(</mo><mi>W</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">MEM(BINOP(PLUS, MEM(e_r), BINOP(MUL, n, CONST(W))))\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal\">L</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<ol start=\"4\">\n<li>翻译控制流<br>\n对于 if e1 op e2 then stmt1 else stmt2 翻译成</li>\n</ol>\n<figure class=\"highlight c\"><figcaption><span>IR</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 6个SEQ</span></span><br><span class=\"line\">SEQ(</span><br><span class=\"line\">    CJUMP(op, e1, e2, t, f),</span><br><span class=\"line\">    SEQ(</span><br><span class=\"line\">        LABEL(t),</span><br><span class=\"line\">        SEQ(</span><br><span class=\"line\">            stm1,</span><br><span class=\"line\">            SEQ(</span><br><span class=\"line\">                JUMP(NAME(end)),</span><br><span class=\"line\">                SEQ(</span><br><span class=\"line\">                    LABEL(f),</span><br><span class=\"line\">                    SEQ(stm2, LABEL(end))</span><br><span class=\"line\">                )</span><br><span class=\"line\">            )</span><br><span class=\"line\">        )</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>Tiger 的逻辑运算符 &amp;(and) 和 |(or) 需要实现短路求值：只计算必要的操作数<br>\n每个 Cx 是一个 Label</p>\n<ul>\n<li>逻辑与 (a &amp; b) 的短路规则：\n<ul>\n<li>计算 a<br>\n - 若 a 为假，直接得到假结果（不计算 b）<br>\n- 若 a 为真，继续计算 b，最终结果即为 b 的值</li>\n</ul>\n</li>\n<li>逻辑或 (a | b) 的短路规则：<br>\n- 计算 a<br>\n - 若 a 为真，直接得到真结果（不计算 b）\n<ul>\n<li>若 a 为假，继续计算 b，最终结果即为 b 的值</li>\n</ul>\n</li>\n</ul>\n<ol start=\"5\">\n<li>循环语句</li>\n</ol>\n<figure class=\"highlight c\"><figcaption><span>tiger</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> a &gt; <span class=\"number\">0</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">a := a - <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>翻译成</p>\n<figure class=\"highlight c\"><figcaption><span>IR</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SEQ(LABEL test, </span><br><span class=\"line\">    SEQ(CJUMP(GT, TEMP a, CONST <span class=\"number\">0</span>, body, done), </span><br><span class=\"line\">        SEQ(LABEL body, </span><br><span class=\"line\">            SEQ(MOVE(TEMP a, BINOP(MINUS, TEMP a, CONST <span class=\"number\">1</span>)), </span><br><span class=\"line\">                SEQ(JUMP(NAME(test), [test]), </span><br><span class=\"line\">                    LABEL done)))))</span><br></pre></td></tr></table></figure>\n<p>break 翻译为直接跳转到 done<br>\nfor 循环我懒得写了，也是一个道理</p>\n<ol start=\"6\">\n<li>翻译函数</li>\n</ol>\n",
            "tags": [
                "中间代码"
            ]
        },
        {
            "id": "http://example.com/2025/03/29/computer-science/compile-principles/ch4/",
            "url": "http://example.com/2025/03/29/computer-science/compile-principles/ch4/",
            "title": "Ch4",
            "date_published": "2025-03-28T16:00:00.000Z",
            "content_html": "",
            "tags": [
                "抽象语法"
            ]
        },
        {
            "id": "http://example.com/2025/03/23/computer-science/compile-principles/ch3/",
            "url": "http://example.com/2025/03/23/computer-science/compile-principles/ch3/",
            "title": "Ch3",
            "date_published": "2025-03-22T16:00:00.000Z",
            "content_html": "<h1 id=\"语法分析\"><a class=\"markdownIt-Anchor\" href=\"#语法分析\">#</a> 语法分析</h1>\n<h2 id=\"cfg\"><a class=\"markdownIt-Anchor\" href=\"#cfg\">#</a> CFG</h2>\n<p>见计算理论<br>\n Parse tree</p>\n<h3 id=\"ambiguous-grammars\"><a class=\"markdownIt-Anchor\" href=\"#ambiguous-grammars\">#</a> Ambiguous grammars</h3>\n<h2 id><a class=\"markdownIt-Anchor\" href=\"#\">#</a> </h2>\n",
            "tags": [
                "语法分析"
            ]
        },
        {
            "id": "http://example.com/2025/03/22/computer-science/compile-principles/ch2/",
            "url": "http://example.com/2025/03/22/computer-science/compile-principles/ch2/",
            "title": "Ch2",
            "date_published": "2025-03-21T16:00:00.000Z",
            "content_html": "<h1 id=\"ch2-词法分析\"><a class=\"markdownIt-Anchor\" href=\"#ch2-词法分析\">#</a> Ch2 词法分析</h1>\n<blockquote>\n<p>把 input 分解成一个个 token</p>\n</blockquote>\n<h2 id=\"regular-expression\"><a class=\"markdownIt-Anchor\" href=\"#regular-expression\">#</a> Regular Expression</h2>\n<ul>\n<li>Language: a set of strings</li>\n<li>String: a finite sequence of characters</li>\n</ul>\n<blockquote>\n<p>Regular Experssion Notations:<br>\n<img data-src=\"image-1.png\" alt></p>\n</blockquote>\n<div class=\"note info\">\n<p>DFA, NFA 相关 见计算理论</p>\n</div>\n<h2 id=\"re转nfa\"><a class=\"markdownIt-Anchor\" href=\"#re转nfa\">#</a> RE 转 NFA</h2>\n<div class=\"note info 方法：\">\n<ol>\n<li>画出初始态和终态</li>\n<li>分裂规则：<br>\n<img data-src=\"image-2.jpg\" alt></li>\n</ol>\n</div>\n<h2 id=\"nfa转dfa\"><a class=\"markdownIt-Anchor\" href=\"#nfa转dfa\">#</a> NFA 转 DFA</h2>\n<p>从初始状态的闭包开始，每次根据 \\epsilon 和当前状态的闭包，得到下一个状态的闭包，直到得到终态的闭包。</p>\n<details class=\"info\"><summary>example</summary><div>\n<div class=\"tab\" data-id=\"id3\" data-title=\"题目\">\n<p>🌰<br>\n把这个 NFA 转成等价的 DFA<br>\n<img data-src=\"image-3.png\" alt></p>\n</div>\n<div class=\"tab\" data-id=\"id3\" data-title=\"答案\">\n<p>初态的闭包是 1、2、6，1、2、6 经过 a 可以转移到 3、7，因为有 \\epsilon 转移，所以 3、7 的闭包是 3、4、7、8，同理 3、4、7、8 经过 b 可以到 5、8，由于 8 是终态，把所有包含 8 的圆圈画成终态的环。<br>\n<img data-src=\"image-4.png\" alt></p>\n</div>\n</div></details>\n<h2 id=\"最小化dfa\"><a class=\"markdownIt-Anchor\" href=\"#最小化dfa\">#</a> 最小化 DFA</h2>\n<p>含义：</p>\n<ol>\n<li>没有多余状态：</li>\n</ol>\n<ul>\n<li>从这个状态没有通路到达终态</li>\n<li>从开始状态出发，任何输入串也不能到达的那个状态</li>\n</ul>\n<ol start=\"2\">\n<li>没有两个状态相互等价</li>\n</ol>\n<div class=\"note info 方法：\">\n<ol>\n<li>多余状态直接删除<br>\n<img data-src=\"image-5.png\" alt></li>\n<li>合并等价状态</li>\n</ol>\n<ul>\n<li>将状态分为终态和非终态两个集合</li>\n<li>遍历每个集合，如果经过转换到达的状态都在当前集合里，则不用分，否则划分子集，直到划分不了为止</li>\n<li>🌰 例子</li>\n<li><img data-src=\"image-6.png\" alt></li>\n</ul>\n</div>\n",
            "tags": [
                "词法分析"
            ]
        },
        {
            "id": "http://example.com/2025/03/21/computer-science/compile-principles/ch1/",
            "url": "http://example.com/2025/03/21/computer-science/compile-principles/ch1/",
            "title": "Ch1",
            "date_published": "2025-03-20T16:00:00.000Z",
            "content_html": "<blockquote>\n<p>ZJU 2025 春夏编译原理 学习笔记</p>\n<p>主要基于虎书（<em>Modern Compiler Implementation in C</em>, Andrew W. Appel）</p>\n</blockquote>\n<h1 id=\"ch1-introduction\"><a class=\"markdownIt-Anchor\" href=\"#ch1-introduction\">#</a> CH1 Introduction</h1>\n<ul>\n<li>Two Important Concepts\n<ul>\n<li>Phases（阶段）</li>\n<li>Interfaces（接口）</li>\n</ul>\n</li>\n</ul>\n<p>方框里的是 phase，中间的是 interface<br>\n<img data-src=\"image.png\" alt><br>\n 各个阶段的描述<br>\n<img data-src=\"image-1.png\" alt><img data-src=\"image-2.png\" alt></p>\n",
            "tags": [
                "编译原理"
            ]
        },
        {
            "id": "http://example.com/2025/03/21/computer-science/compile-principles/ch5/",
            "url": "http://example.com/2025/03/21/computer-science/compile-principles/ch5/",
            "title": "Ch5",
            "date_published": "2025-03-20T16:00:00.000Z",
            "content_html": "<h1 id=\"语义分析\"><a class=\"markdownIt-Anchor\" href=\"#语义分析\">#</a> 语义分析</h1>\n<blockquote>\n<p>绑定，类型检查</p>\n</blockquote>\n<h2 id=\"symbol-table\"><a class=\"markdownIt-Anchor\" href=\"#symbol-table\">#</a> symbol table</h2>\n<ul>\n<li>Imperative style: 命令式风格\n<ul>\n<li>Modify <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>σ</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\sigma_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> until it becomes <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>σ</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\sigma_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>.</li>\n<li>While <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>σ</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\sigma_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> exists, we cannot look things up in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>σ</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\sigma_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>.</li>\n<li>When done with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>σ</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\sigma_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, can undo the modification to get <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>σ</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\sigma_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> back again.</li>\n</ul>\n</li>\n</ul>\n<details class=\"info\"><summary>方法：</summary><div>\n<p>Hashing<br>\n 插入：找到哈希值然后插入链表的表头<br>\n查找：找到哈希值然后遍历链表<br>\n pop: 找到哈希值然后把链表表头删掉  table [hash (key)] = table [hash (key)].next</p>\n</div></details>\n<ul>\n<li>Functional style: 函数式风格\n<ul>\n<li>To keep <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>σ</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\sigma_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> in pristine condition while creating create <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>σ</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\sigma_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>σ</mi><mn>3</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\sigma_3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></li>\n</ul>\n</li>\n</ul>\n<details class=\"info\"><summary>方法：</summary><div>\n<p>如果依旧用哈希，每次要复制一遍哈希表，开销太大了，不现实<br>\n<img data-src=\"f2.jpg\" alt><br>\n所以用 persistent BST<br>\n<img data-src=\"f1.jpg\" alt><br>\n 先遍历二叉搜索树找到要插入的位置，然后对于插入节点把它从根节点到它全都复制一遍然后插入</p>\n</div></details>\n<h2 id=\"tiger编译器中的符号\"><a class=\"markdownIt-Anchor\" href=\"#tiger编译器中的符号\">#</a> Tiger 编译器中的符号</h2>\n<p>对链表进行 lookup 的时候每一次都要进行 string compare，开销是很大的。所以使用新的数据结构将符号对象关联到一个整数上，因此对于任意给定字符串的所有不同出现，都会被转换成同一个符号对象。<br>\nSymbol 的实现：通过 hash 函数将字符串映射到一个 symbol 对象上<br>\n SymbolTable 的实现：beginScope () 和 endScope () 的实现</p>\n<ul>\n<li>beginScope ()：添加一个 marksym</li>\n<li>endScope ()：从符号表中不断 pop 直到 marksym</li>\n<li>引入一个 辅助栈 (Auxiliary stack) 来维护\n<ul>\n<li>符号入栈时，会将 binding 联动地插入对应 bucket 的链表头</li>\n<li>弹出栈顶符号时，对应 bucket 的链表头也会联动地被移除</li>\n<li>beginScope: 压入一个特殊标记到辅助栈中</li>\n<li>endScope: 一直弹出符号直到弹出了一个特殊标记</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"类型检查\"><a class=\"markdownIt-Anchor\" href=\"#类型检查\">#</a> 类型检查</h2>\n<h3 id=\"哪些类型表达式是合法非法的\"><a class=\"markdownIt-Anchor\" href=\"#哪些类型表达式是合法非法的\">#</a> 哪些类型表达式是合法 / 非法的</h3>\n<p>Tiger 的类型系统：</p>\n<ul>\n<li>两种 primitive type: int, string</li>\n<li>两种 constructed type: records, arrays</li>\n</ul>\n<p>文法</p>\n<ol>\n<li>typec → type type-id = ty\n<ul>\n<li>这表示定义一个类型。 <code>typec</code>  是一个类型定义的开始，它由关键字  <code>type</code> 、一个类型标识符  <code>type-id</code>  和一个等号  <code>=</code>  后跟类型定义  <code>ty</code>  组成。</li>\n</ul>\n</li>\n<li>ty → type-id\n<ul>\n<li>这表示类型  <code>ty</code>  可以直接是一个已定义的类型标识符  <code>type-id</code> 。</li>\n</ul>\n</li>\n<li>ty → ‘{’ tyfields ‘}’\n<ul>\n<li>这表示类型  <code>ty</code>  可以是一个记录（record），由花括号  <code>&#123;&#125;</code>  包围的一系列字段  <code>tyfields</code>  定义。</li>\n</ul>\n</li>\n<li>ty → array of type-id\n<ul>\n<li>这表示类型  <code>ty</code>  可以是一个数组，由关键字  <code>array of</code>  后跟一个类型标识符  <code>type-id</code>  定义。</li>\n</ul>\n</li>\n<li>tyfields → ε\n<ul>\n<li>这表示字段列表  <code>tyfields</code>  可以为空（ε 表示空串）。</li>\n</ul>\n</li>\n<li , id:type-id>tyfields → id: type-id\n<ul>\n<li>这表示字段列表  <code>tyfields</code>  由一个或多个字段组成，每个字段由一个标识符  <code>id</code>  和冒号  <code>:</code>  后跟一个类型标识符  <code>type-id</code>  定义，多个字段之间用逗号  <code>,</code>  分隔。</li>\n</ul>\n</li>\n</ol>\n<p>示例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let type a = &#123;x: int; y: int&#125;</span><br><span class=\"line\">    type b = a</span><br><span class=\"line\">    var i : a := ...</span><br><span class=\"line\">    var j : b := ...</span><br><span class=\"line\">in i := j</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<h3 id=\"类型等价\"><a class=\"markdownIt-Anchor\" href=\"#类型等价\">#</a> 类型等价</h3>\n<ul>\n<li>Name equivalence (NE): 必须声明是同一个类型才是同一类型</li>\n<li>Structure equivalence (SE): 如果两个类型的结构完全相同（即它们由相同的构造器以相同的顺序组成），那么它们就被认为是等价的，即使它们的名字不同</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type A = &#123;x: int; y: int&#125;</span><br><span class=\"line\">type B = &#123;x: int; y: int&#125; </span><br></pre></td></tr></table></figure>\n<p>Tiger 用的是 NE<br>\n 在 Tiger 编程语言中，存在两个独立的命名空间：一个用于类型（Types），另一个用于函数和变量（Functions and Variables）。所以类型和函数 / 变量可以存在相同的名字，但是函数和变量不能存在相同的名字。<br>\n所以需要两个 env</p>\n<ul>\n<li>Type env\n<ul>\n<li>symbol -&gt; Ty_ty</li>\n</ul>\n</li>\n<li>Value env\n<ul>\n<li>对于变量，symbol -&gt; Ty_ty</li>\n<li ty_tylist formals, ty_ty results>对于函数，symbol -&gt; struct</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"类型检查的rule\"><a class=\"markdownIt-Anchor\" href=\"#类型检查的rule\">#</a> 类型检查的 rule</h3>\n<p>类型检查分为两部分:</p>\n<ul>\n<li>Type-checking expressions: 对于每个表达式，根据当前的 Type 和 Value 环境来确定其类型，并检查是否符合语言的类型规则</li>\n<li>Type-checking declarations: 在 Tiger 语言中声明只可能在 let 语句中出现<br>\n好像就是讲了 transExp, transDec, transVar，AST 递归检查每个节点的类型然后一层一层往上传再检查</li>\n</ul>\n",
            "tags": [
                "语义分析"
            ]
        }
    ]
}