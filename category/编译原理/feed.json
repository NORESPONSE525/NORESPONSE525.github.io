{
    "version": "https://jsonfeed.org/version/1",
    "title": " • All posts by \"编译原理\" category",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/06/15/computer-science/compile-principles/ch6/",
            "url": "http://example.com/2025/06/15/computer-science/compile-principles/ch6/",
            "title": "Ch6",
            "date_published": "2025-06-14T16:00:00.000Z",
            "content_html": "<h1 id=\"activation-recordstack-frame\"><a class=\"markdownIt-Anchor\" href=\"#activation-recordstack-frame\">#</a> Activation Record/Stack Frame</h1>\n<p>函数的栈帧是栈上用来放函数的局部变量、参数、返回地址以及其他临时变量的区域<br>\n stack 一般从高地址像低地址，heap 从低地址向高地址<br>\n layout:<br>\n<img data-src=\"f1.jpg\" alt></p>\n<ul>\n<li>incoming arguments: 存储 caller 传递给 callee 的参数</li>\n<li>frame pointer: 帧指针，用来访问 incoming arguments，从低向高是 argument 1, argument 2, …</li>\n<li>local variables: 存储函数的局部变量（还有一些保存在寄存器里）</li>\n<li>return address: 存储需要返回 caller 的哪里</li>\n<li>temporaries: 存储临时变量，复杂表达式拆出来的中间变量放的地方</li>\n<li>saved registers</li>\n<li>outgoing arguments: 存储当前函数要传递给别的函数的参数</li>\n<li>stack pointer: 栈指针，从低向高</li>\n</ul>\n<h2 id=\"函数调用流程\"><a class=\"markdownIt-Anchor\" href=\"#函数调用流程\">#</a> 函数调用流程：</h2>\n<ul>\n<li>g 调用 f 的时候</li>\n</ul>\n<ol>\n<li>进入 f 的时候，保存旧的 FP (g 的 FP)</li>\n<li>把 FP 设置为原来的 SP，把 SP = SP - frame size<br>\n<img data-src=\"f2.jpg\" alt></li>\n</ol>\n<ul>\n<li>f 返回的时候</li>\n</ul>\n<ol>\n<li>让 SP = FP (恢复 g 的 SP)</li>\n<li>从内存中读出 g 的 FP 恢复回去</li>\n</ol>\n<p>如果栈帧大小固定就只需要 FP 不需要 SP 了，因为 FP = SP + frame size</p>\n<h2 id=\"saved-register\"><a class=\"markdownIt-Anchor\" href=\"#saved-register\">#</a> saved register</h2>\n<p>函数 g 调用 f 的时候，用到了寄存器 r，调用 f 的时候要把 r 保存在 saved register 中，等调用结束再恢复回去</p>\n<ul>\n<li>caller-saved register: 函数调用的时候用到的寄存器，调用结束后可以恢复</li>\n<li>callee-saved register: 函数调用的时候用不到的寄存器，调用结束后不能恢复<br>\n<mark> FP 是由 callee 保存和恢复的</mark></li>\n</ul>\n<h2 id=\"参数传递\"><a class=\"markdownIt-Anchor\" href=\"#参数传递\">#</a> 参数传递</h2>\n",
            "tags": [
                "活动记录"
            ]
        },
        {
            "id": "http://example.com/2025/03/29/computer-science/compile-principles/ch4/",
            "url": "http://example.com/2025/03/29/computer-science/compile-principles/ch4/",
            "title": "Ch4",
            "date_published": "2025-03-28T16:00:00.000Z",
            "content_html": "",
            "tags": [
                "抽象语法"
            ]
        },
        {
            "id": "http://example.com/2025/03/23/computer-science/compile-principles/ch3/",
            "url": "http://example.com/2025/03/23/computer-science/compile-principles/ch3/",
            "title": "Ch3",
            "date_published": "2025-03-22T16:00:00.000Z",
            "content_html": "<h1 id=\"语法分析\"><a class=\"markdownIt-Anchor\" href=\"#语法分析\">#</a> 语法分析</h1>\n<h2 id=\"cfg\"><a class=\"markdownIt-Anchor\" href=\"#cfg\">#</a> CFG</h2>\n<p>见计算理论<br>\n Parse tree</p>\n<h3 id=\"ambiguous-grammars\"><a class=\"markdownIt-Anchor\" href=\"#ambiguous-grammars\">#</a> Ambiguous grammars</h3>\n<h2 id><a class=\"markdownIt-Anchor\" href=\"#\">#</a> </h2>\n",
            "tags": [
                "语法分析"
            ]
        },
        {
            "id": "http://example.com/2025/03/22/computer-science/compile-principles/ch2/",
            "url": "http://example.com/2025/03/22/computer-science/compile-principles/ch2/",
            "title": "Ch2",
            "date_published": "2025-03-21T16:00:00.000Z",
            "content_html": "<h1 id=\"ch2-词法分析\"><a class=\"markdownIt-Anchor\" href=\"#ch2-词法分析\">#</a> Ch2 词法分析</h1>\n<blockquote>\n<p>把 input 分解成一个个 token</p>\n</blockquote>\n<h2 id=\"regular-expression\"><a class=\"markdownIt-Anchor\" href=\"#regular-expression\">#</a> Regular Expression</h2>\n<ul>\n<li>Language: a set of strings</li>\n<li>String: a finite sequence of characters</li>\n</ul>\n<blockquote>\n<p>Regular Experssion Notations:<br>\n<img data-src=\"image-1.png\" alt></p>\n</blockquote>\n<div class=\"note info\">\n<p>DFA, NFA 相关 见计算理论</p>\n</div>\n<h2 id=\"re转nfa\"><a class=\"markdownIt-Anchor\" href=\"#re转nfa\">#</a> RE 转 NFA</h2>\n<div class=\"note info 方法：\">\n<ol>\n<li>画出初始态和终态</li>\n<li>分裂规则：<br>\n<img data-src=\"image-2.jpg\" alt></li>\n</ol>\n</div>\n<h2 id=\"nfa转dfa\"><a class=\"markdownIt-Anchor\" href=\"#nfa转dfa\">#</a> NFA 转 DFA</h2>\n<p>从初始状态的闭包开始，每次根据 \\epsilon 和当前状态的闭包，得到下一个状态的闭包，直到得到终态的闭包。</p>\n<details class=\"info\"><summary>example</summary><div>\n<div class=\"tab\" data-id=\"id3\" data-title=\"题目\">\n<p>🌰<br>\n把这个 NFA 转成等价的 DFA<br>\n<img data-src=\"image-3.png\" alt></p>\n</div>\n<div class=\"tab\" data-id=\"id3\" data-title=\"答案\">\n<p>初态的闭包是 1、2、6，1、2、6 经过 a 可以转移到 3、7，因为有 \\epsilon 转移，所以 3、7 的闭包是 3、4、7、8，同理 3、4、7、8 经过 b 可以到 5、8，由于 8 是终态，把所有包含 8 的圆圈画成终态的环。<br>\n<img data-src=\"image-4.png\" alt></p>\n</div>\n</div></details>\n<h2 id=\"最小化dfa\"><a class=\"markdownIt-Anchor\" href=\"#最小化dfa\">#</a> 最小化 DFA</h2>\n<p>含义：</p>\n<ol>\n<li>没有多余状态：</li>\n</ol>\n<ul>\n<li>从这个状态没有通路到达终态</li>\n<li>从开始状态出发，任何输入串也不能到达的那个状态</li>\n</ul>\n<ol start=\"2\">\n<li>没有两个状态相互等价</li>\n</ol>\n<div class=\"note info 方法：\">\n<ol>\n<li>多余状态直接删除<br>\n<img data-src=\"image-5.png\" alt></li>\n<li>合并等价状态</li>\n</ol>\n<ul>\n<li>将状态分为终态和非终态两个集合</li>\n<li>遍历每个集合，如果经过转换到达的状态都在当前集合里，则不用分，否则划分子集，直到划分不了为止</li>\n<li>🌰 例子</li>\n<li><img data-src=\"image-6.png\" alt></li>\n</ul>\n</div>\n",
            "tags": [
                "词法分析"
            ]
        },
        {
            "id": "http://example.com/2025/03/21/computer-science/compile-principles/ch1/",
            "url": "http://example.com/2025/03/21/computer-science/compile-principles/ch1/",
            "title": "Ch1",
            "date_published": "2025-03-20T16:00:00.000Z",
            "content_html": "<blockquote>\n<p>ZJU 2025 春夏编译原理 学习笔记</p>\n<p>主要基于虎书（<em>Modern Compiler Implementation in C</em>, Andrew W. Appel）</p>\n</blockquote>\n<h1 id=\"ch1-introduction\"><a class=\"markdownIt-Anchor\" href=\"#ch1-introduction\">#</a> CH1 Introduction</h1>\n<ul>\n<li>Two Important Concepts\n<ul>\n<li>Phases（阶段）</li>\n<li>Interfaces（接口）</li>\n</ul>\n</li>\n</ul>\n<p>方框里的是 phase，中间的是 interface<br>\n<img data-src=\"image.png\" alt><br>\n 各个阶段的描述<br>\n<img data-src=\"image-1.png\" alt><img data-src=\"image-2.png\" alt></p>\n",
            "tags": [
                "编译原理"
            ]
        },
        {
            "id": "http://example.com/2025/03/21/computer-science/compile-principles/ch5/",
            "url": "http://example.com/2025/03/21/computer-science/compile-principles/ch5/",
            "title": "Ch5",
            "date_published": "2025-03-20T16:00:00.000Z",
            "content_html": "<h1 id=\"语义分析\"><a class=\"markdownIt-Anchor\" href=\"#语义分析\">#</a> 语义分析</h1>\n<blockquote>\n<p>绑定，类型检查</p>\n</blockquote>\n<h2 id=\"symbol-table\"><a class=\"markdownIt-Anchor\" href=\"#symbol-table\">#</a> symbol table</h2>\n<ul>\n<li>Imperative style: 命令式风格\n<ul>\n<li>Modify <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>σ</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\sigma_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> until it becomes <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>σ</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\sigma_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>.</li>\n<li>While <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>σ</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\sigma_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> exists, we cannot look things up in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>σ</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\sigma_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>.</li>\n<li>When done with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>σ</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\sigma_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, can undo the modification to get <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>σ</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\sigma_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> back again.</li>\n</ul>\n</li>\n</ul>\n<details class=\"info\"><summary>方法：</summary><div>\n<p>Hashing<br>\n 插入：找到哈希值然后插入链表的表头<br>\n查找：找到哈希值然后遍历链表<br>\n pop: 找到哈希值然后把链表表头删掉  table [hash (key)] = table [hash (key)].next</p>\n</div></details>\n<ul>\n<li>Functional style: 函数式风格\n<ul>\n<li>To keep <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>σ</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\sigma_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> in pristine condition while creating create <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>σ</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\sigma_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>σ</mi><mn>3</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\sigma_3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></li>\n</ul>\n</li>\n</ul>\n<details class=\"info\"><summary>方法：</summary><div>\n<p>如果依旧用哈希，每次要复制一遍哈希表，开销太大了，不现实<br>\n<img data-src=\"f2.jpg\" alt><br>\n所以用 persistent BST<br>\n<img data-src=\"f1.jpg\" alt><br>\n 先遍历二叉搜索树找到要插入的位置，然后对于插入节点把它从根节点到它全都复制一遍然后插入</p>\n</div></details>\n<h2 id=\"tiger编译器中的符号\"><a class=\"markdownIt-Anchor\" href=\"#tiger编译器中的符号\">#</a> Tiger 编译器中的符号</h2>\n<p>对链表进行 lookup 的时候每一次都要进行 string compare，开销是很大的。所以使用新的数据结构将符号对象关联到一个整数上，因此对于任意给定字符串的所有不同出现，都会被转换成同一个符号对象。<br>\nSymbol 的实现：通过 hash 函数将字符串映射到一个 symbol 对象上<br>\n SymbolTable 的实现：beginScope () 和 endScope () 的实现</p>\n<ul>\n<li>beginScope ()：添加一个 marksym</li>\n<li>endScope ()：从符号表中不断 pop 直到 marksym</li>\n<li>引入一个 辅助栈 (Auxiliary stack) 来维护\n<ul>\n<li>符号入栈时，会将 binding 联动地插入对应 bucket 的链表头</li>\n<li>弹出栈顶符号时，对应 bucket 的链表头也会联动地被移除</li>\n<li>beginScope: 压入一个特殊标记到辅助栈中</li>\n<li>endScope: 一直弹出符号直到弹出了一个特殊标记</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"类型检查\"><a class=\"markdownIt-Anchor\" href=\"#类型检查\">#</a> 类型检查</h2>\n<h3 id=\"哪些类型表达式是合法非法的\"><a class=\"markdownIt-Anchor\" href=\"#哪些类型表达式是合法非法的\">#</a> 哪些类型表达式是合法 / 非法的</h3>\n<p>Tiger 的类型系统：</p>\n<ul>\n<li>两种 primitive type: int, string</li>\n<li>两种 constructed type: records, arrays</li>\n</ul>\n<p>文法</p>\n<ol>\n<li>typec → type type-id = ty\n<ul>\n<li>这表示定义一个类型。 <code>typec</code>  是一个类型定义的开始，它由关键字  <code>type</code> 、一个类型标识符  <code>type-id</code>  和一个等号  <code>=</code>  后跟类型定义  <code>ty</code>  组成。</li>\n</ul>\n</li>\n<li>ty → type-id\n<ul>\n<li>这表示类型  <code>ty</code>  可以直接是一个已定义的类型标识符  <code>type-id</code> 。</li>\n</ul>\n</li>\n<li>ty → ‘{’ tyfields ‘}’\n<ul>\n<li>这表示类型  <code>ty</code>  可以是一个记录（record），由花括号  <code>&#123;&#125;</code>  包围的一系列字段  <code>tyfields</code>  定义。</li>\n</ul>\n</li>\n<li>ty → array of type-id\n<ul>\n<li>这表示类型  <code>ty</code>  可以是一个数组，由关键字  <code>array of</code>  后跟一个类型标识符  <code>type-id</code>  定义。</li>\n</ul>\n</li>\n<li>tyfields → ε\n<ul>\n<li>这表示字段列表  <code>tyfields</code>  可以为空（ε 表示空串）。</li>\n</ul>\n</li>\n<li , id:type-id>tyfields → id: type-id\n<ul>\n<li>这表示字段列表  <code>tyfields</code>  由一个或多个字段组成，每个字段由一个标识符  <code>id</code>  和冒号  <code>:</code>  后跟一个类型标识符  <code>type-id</code>  定义，多个字段之间用逗号  <code>,</code>  分隔。</li>\n</ul>\n</li>\n</ol>\n<p>示例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let type a = &#123;x: int; y: int&#125;</span><br><span class=\"line\">    type b = a</span><br><span class=\"line\">    var i : a := ...</span><br><span class=\"line\">    var j : b := ...</span><br><span class=\"line\">in i := j</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<h3 id=\"类型等价\"><a class=\"markdownIt-Anchor\" href=\"#类型等价\">#</a> 类型等价</h3>\n<ul>\n<li>Name equivalence (NE): 必须声明是同一个类型才是同一类型</li>\n<li>Structure equivalence (SE): 如果两个类型的结构完全相同（即它们由相同的构造器以相同的顺序组成），那么它们就被认为是等价的，即使它们的名字不同</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type A = &#123;x: int; y: int&#125;</span><br><span class=\"line\">type B = &#123;x: int; y: int&#125; </span><br></pre></td></tr></table></figure>\n<p>Tiger 用的是 NE<br>\n 在 Tiger 编程语言中，存在两个独立的命名空间：一个用于类型（Types），另一个用于函数和变量（Functions and Variables）。所以类型和函数 / 变量可以存在相同的名字，但是函数和变量不能存在相同的名字。<br>\n所以需要两个 env</p>\n<ul>\n<li>Type env\n<ul>\n<li>symbol -&gt; Ty_ty</li>\n</ul>\n</li>\n<li>Value env\n<ul>\n<li>对于变量，symbol -&gt; Ty_ty</li>\n<li ty_tylist formals, ty_ty results>对于函数，symbol -&gt; struct</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"类型检查的rule\"><a class=\"markdownIt-Anchor\" href=\"#类型检查的rule\">#</a> 类型检查的 rule</h3>\n<p>类型检查分为两部分:</p>\n<ul>\n<li>Type-checking expressions: 对于每个表达式，根据当前的 Type 和 Value 环境来确定其类型，并检查是否符合语言的类型规则</li>\n<li>Type-checking declarations: 在 Tiger 语言中声明只可能在 let 语句中出现<br>\n好像就是讲了 transExp, transDec, transVar，AST 递归检查每个节点的类型然后一层一层往上传再检查</li>\n</ul>\n",
            "tags": [
                "语义分析"
            ]
        }
    ]
}