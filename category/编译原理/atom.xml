<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title> • Posts by &#34;编译原理&#34; category</title>
    <link href="http://example.com" />
    <updated>2025-06-14T16:00:00.000Z</updated>
    <category term="人工智能" />
    <category term="编译原理" />
    <category term="词法分析" />
    <category term="语法分析" />
    <category term="活动记录" />
    <category term="抽象语法" />
    <category term="计算机网络" />
    <category term="语义分析" />
    <category term="计算机组成" />
    <category term="数据的表示与运算" />
    <entry>
        <id>http://example.com/2025/06/15/computer-science/compile-principles/ch6/</id>
        <title>Ch6</title>
        <link rel="alternate" href="http://example.com/2025/06/15/computer-science/compile-principles/ch6/"/>
        <content type="html">&lt;h1 id=&#34;activation-recordstack-frame&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#activation-recordstack-frame&#34;&gt;#&lt;/a&gt; Activation Record/Stack Frame&lt;/h1&gt;
&lt;p&gt;函数的栈帧是栈上用来放函数的局部变量、参数、返回地址以及其他临时变量的区域&lt;br&gt;
 stack 一般从高地址向低地址，heap 从低地址向高地址&lt;br&gt;
 layout:&lt;br&gt;
&lt;img data-src=&#34;f1.jpg&#34; alt&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;incoming arguments: 存储 caller 传递给 callee 的参数&lt;/li&gt;
&lt;li&gt;frame pointer: 帧指针，用来访问 incoming arguments，从低向高是 argument 1, argument 2, …&lt;/li&gt;
&lt;li&gt;local variables: 存储函数的局部变量（还有一些保存在寄存器里）&lt;/li&gt;
&lt;li&gt;return address: 存储需要返回 caller 的哪里&lt;/li&gt;
&lt;li&gt;temporaries: 存储临时变量，复杂表达式拆出来的中间变量放的地方&lt;/li&gt;
&lt;li&gt;saved registers&lt;/li&gt;
&lt;li&gt;outgoing arguments: 存储当前函数要传递给别的函数的参数&lt;/li&gt;
&lt;li&gt;stack pointer: 栈指针，从低向高&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;函数调用流程&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#函数调用流程&#34;&gt;#&lt;/a&gt; 函数调用流程：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;g 调用 f 的时候&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;进入 f 的时候，保存旧的 FP (g 的 FP)&lt;/li&gt;
&lt;li&gt;把 FP 设置为原来的 SP，把 SP = SP - frame size&lt;br&gt;
&lt;img data-src=&#34;f2.jpg&#34; alt&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;f 返回的时候&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;让 SP = FP (恢复 g 的 SP)&lt;/li&gt;
&lt;li&gt;从内存中读出 g 的 FP 恢复回去&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果栈帧大小固定就只需要 FP 不需要 SP 了，因为 FP = SP + frame size&lt;/p&gt;
&lt;h2 id=&#34;saved-register&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#saved-register&#34;&gt;#&lt;/a&gt; saved register&lt;/h2&gt;
&lt;p&gt;函数 g 调用 f 的时候，用到了寄存器 r，调用 f 的时候要把 r 保存在 saved register 中，等调用结束再恢复回去&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;caller-saved register: 函数调用的时候用到的寄存器，调用结束后可以恢复&lt;/li&gt;
&lt;li&gt;callee-saved register: 函数调用的时候用不到的寄存器，调用结束后不能恢复&lt;br&gt;
&lt;mark&gt; FP 是由 callee 保存和恢复的&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参数传递&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#参数传递&#34;&gt;#&lt;/a&gt; 参数传递&lt;/h2&gt;
&lt;p&gt;一般约定把前 k (4 or 6) 个参数放在寄存器传递，剩下的参数放在栈中传递&lt;br&gt;
四种传参方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不给叶过程 (leaf procedure) 分配栈帧&lt;br&gt;
叶过程是指不调用其他过程的过程。在这种情况下，可以不为叶过程分配栈帧&lt;/li&gt;
&lt;li&gt;过程间寄存器分配 (interprocedural register allocation)&lt;br&gt;
 这种方法需要先分析代码中全部的函数，然后再根据分析结果来分配寄存器。&lt;br&gt;
假设有一个程序包含多个函数，通过全局分析发现某些变量在多个函数之间频繁使用，可以为其分配固定的寄存器，避免频繁的内存读写&lt;/li&gt;
&lt;li&gt;若变量 x 不再被使用，可以直接写其寄存器，不需要再保存 x 到栈帧中&lt;br&gt;
当一个变量在当前作用域内不再被使用时，可以直接将其值写入寄存器，而无需保存到栈帧中&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;exampleFunction&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; x = &lt;span class=&#34;number&#34;&gt;5&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; y = x * &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;;  &lt;span class=&#34;comment&#34;&gt;// 使用x后，x不再被使用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 直接将y的值写入寄存器，无需保存x到栈帧中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;Result: %d\n&amp;quot;&lt;/span&gt;, y);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;寄存器窗口技术 (register windows)&lt;br&gt;
 在每次函数调用时，系统会自动切换到一组新的寄存器，称为寄存器窗口。这样，每个函数都可以独立地使用自己的寄存器，而不会影响其他函数的寄存器状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;functionA&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 使用寄存器窗口A&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;functionB&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 使用寄存器窗口B&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    functionA();  &lt;span class=&#34;comment&#34;&gt;// 调用functionA时，自动切换到寄存器窗口A&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&#34;frame-resident-variables&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#frame-resident-variables&#34;&gt;#&lt;/a&gt; Frame-Resident Variables&lt;/h2&gt;
</content>
        <category term="活动记录" />
        <updated>2025-06-14T16:00:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2025/03/29/computer-science/compile-principles/ch4/</id>
        <title>Ch4</title>
        <link rel="alternate" href="http://example.com/2025/03/29/computer-science/compile-principles/ch4/"/>
        <content type="html"></content>
        <category term="抽象语法" />
        <updated>2025-03-28T16:00:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2025/03/23/computer-science/compile-principles/ch3/</id>
        <title>Ch3</title>
        <link rel="alternate" href="http://example.com/2025/03/23/computer-science/compile-principles/ch3/"/>
        <content type="html">&lt;h1 id=&#34;语法分析&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#语法分析&#34;&gt;#&lt;/a&gt; 语法分析&lt;/h1&gt;
&lt;h2 id=&#34;cfg&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#cfg&#34;&gt;#&lt;/a&gt; CFG&lt;/h2&gt;
&lt;p&gt;见计算理论&lt;br&gt;
 Parse tree&lt;/p&gt;
&lt;h3 id=&#34;ambiguous-grammars&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#ambiguous-grammars&#34;&gt;#&lt;/a&gt; Ambiguous grammars&lt;/h3&gt;
&lt;h2 id&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#&#34;&gt;#&lt;/a&gt; &lt;/h2&gt;
</content>
        <category term="语法分析" />
        <updated>2025-03-22T16:00:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2025/03/22/computer-science/compile-principles/ch2/</id>
        <title>Ch2</title>
        <link rel="alternate" href="http://example.com/2025/03/22/computer-science/compile-principles/ch2/"/>
        <content type="html">&lt;h1 id=&#34;ch2-词法分析&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#ch2-词法分析&#34;&gt;#&lt;/a&gt; Ch2 词法分析&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;把 input 分解成一个个 token&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;regular-expression&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#regular-expression&#34;&gt;#&lt;/a&gt; Regular Expression&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Language: a set of strings&lt;/li&gt;
&lt;li&gt;String: a finite sequence of characters&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Regular Experssion Notations:&lt;br&gt;
&lt;img data-src=&#34;image-1.png&#34; alt&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;note info&#34;&gt;
&lt;p&gt;DFA, NFA 相关 见计算理论&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id=&#34;re转nfa&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#re转nfa&#34;&gt;#&lt;/a&gt; RE 转 NFA&lt;/h2&gt;
&lt;div class=&#34;note info 方法：&#34;&gt;
&lt;ol&gt;
&lt;li&gt;画出初始态和终态&lt;/li&gt;
&lt;li&gt;分裂规则：&lt;br&gt;
&lt;img data-src=&#34;image-2.jpg&#34; alt&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;h2 id=&#34;nfa转dfa&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#nfa转dfa&#34;&gt;#&lt;/a&gt; NFA 转 DFA&lt;/h2&gt;
&lt;p&gt;从初始状态的闭包开始，每次根据 \epsilon 和当前状态的闭包，得到下一个状态的闭包，直到得到终态的闭包。&lt;/p&gt;
&lt;details class=&#34;info&#34;&gt;&lt;summary&gt;example&lt;/summary&gt;&lt;div&gt;
&lt;div class=&#34;tab&#34; data-id=&#34;id3&#34; data-title=&#34;题目&#34;&gt;
&lt;p&gt;🌰&lt;br&gt;
把这个 NFA 转成等价的 DFA&lt;br&gt;
&lt;img data-src=&#34;image-3.png&#34; alt&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;tab&#34; data-id=&#34;id3&#34; data-title=&#34;答案&#34;&gt;
&lt;p&gt;初态的闭包是 1、2、6，1、2、6 经过 a 可以转移到 3、7，因为有 \epsilon 转移，所以 3、7 的闭包是 3、4、7、8，同理 3、4、7、8 经过 b 可以到 5、8，由于 8 是终态，把所有包含 8 的圆圈画成终态的环。&lt;br&gt;
&lt;img data-src=&#34;image-4.png&#34; alt&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/details&gt;
&lt;h2 id=&#34;最小化dfa&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#最小化dfa&#34;&gt;#&lt;/a&gt; 最小化 DFA&lt;/h2&gt;
&lt;p&gt;含义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;没有多余状态：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;从这个状态没有通路到达终态&lt;/li&gt;
&lt;li&gt;从开始状态出发，任何输入串也不能到达的那个状态&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;没有两个状态相互等价&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;note info 方法：&#34;&gt;
&lt;ol&gt;
&lt;li&gt;多余状态直接删除&lt;br&gt;
&lt;img data-src=&#34;image-5.png&#34; alt&gt;&lt;/li&gt;
&lt;li&gt;合并等价状态&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;将状态分为终态和非终态两个集合&lt;/li&gt;
&lt;li&gt;遍历每个集合，如果经过转换到达的状态都在当前集合里，则不用分，否则划分子集，直到划分不了为止&lt;/li&gt;
&lt;li&gt;🌰 例子&lt;/li&gt;
&lt;li&gt;&lt;img data-src=&#34;image-6.png&#34; alt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content>
        <category term="词法分析" />
        <updated>2025-03-21T16:00:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2025/03/21/computer-science/compile-principles/ch1/</id>
        <title>Ch1</title>
        <link rel="alternate" href="http://example.com/2025/03/21/computer-science/compile-principles/ch1/"/>
        <content type="html">&lt;blockquote&gt;
&lt;p&gt;ZJU 2025 春夏编译原理 学习笔记&lt;/p&gt;
&lt;p&gt;主要基于虎书（&lt;em&gt;Modern Compiler Implementation in C&lt;/em&gt;, Andrew W. Appel）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;ch1-introduction&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#ch1-introduction&#34;&gt;#&lt;/a&gt; CH1 Introduction&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Two Important Concepts
&lt;ul&gt;
&lt;li&gt;Phases（阶段）&lt;/li&gt;
&lt;li&gt;Interfaces（接口）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方框里的是 phase，中间的是 interface&lt;br&gt;
&lt;img data-src=&#34;image.png&#34; alt&gt;&lt;br&gt;
 各个阶段的描述&lt;br&gt;
&lt;img data-src=&#34;image-1.png&#34; alt&gt;&lt;img data-src=&#34;image-2.png&#34; alt&gt;&lt;/p&gt;
</content>
        <category term="编译原理" />
        <updated>2025-03-20T16:00:00.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2025/03/21/computer-science/compile-principles/ch5/</id>
        <title>Ch5</title>
        <link rel="alternate" href="http://example.com/2025/03/21/computer-science/compile-principles/ch5/"/>
        <content type="html">&lt;h1 id=&#34;语义分析&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#语义分析&#34;&gt;#&lt;/a&gt; 语义分析&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;绑定，类型检查&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;symbol-table&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#symbol-table&#34;&gt;#&lt;/a&gt; symbol table&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Imperative style: 命令式风格
&lt;ul&gt;
&lt;li&gt;Modify &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;σ&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\sigma_1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.58056em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.03588em;&#34;&gt;σ&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; until it becomes &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;σ&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\sigma_2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.58056em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.03588em;&#34;&gt;σ&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;While &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;σ&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\sigma_2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.58056em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.03588em;&#34;&gt;σ&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; exists, we cannot look things up in &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;σ&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\sigma_1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.58056em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.03588em;&#34;&gt;σ&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;When done with &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;σ&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\sigma_2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.58056em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.03588em;&#34;&gt;σ&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;, can undo the modification to get &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;σ&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\sigma_1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.58056em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.03588em;&#34;&gt;σ&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; back again.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;details class=&#34;info&#34;&gt;&lt;summary&gt;方法：&lt;/summary&gt;&lt;div&gt;
&lt;p&gt;Hashing&lt;br&gt;
 插入：找到哈希值然后插入链表的表头&lt;br&gt;
查找：找到哈希值然后遍历链表&lt;br&gt;
 pop: 找到哈希值然后把链表表头删掉  table [hash (key)] = table [hash (key)].next&lt;/p&gt;
&lt;/div&gt;&lt;/details&gt;
&lt;ul&gt;
&lt;li&gt;Functional style: 函数式风格
&lt;ul&gt;
&lt;li&gt;To keep &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;σ&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\sigma_1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.58056em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.03588em;&#34;&gt;σ&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; in pristine condition while creating create &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;σ&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\sigma_2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.58056em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.03588em;&#34;&gt;σ&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; and &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;σ&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\sigma_3&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.58056em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.03588em;&#34;&gt;σ&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;details class=&#34;info&#34;&gt;&lt;summary&gt;方法：&lt;/summary&gt;&lt;div&gt;
&lt;p&gt;如果依旧用哈希，每次要复制一遍哈希表，开销太大了，不现实&lt;br&gt;
&lt;img data-src=&#34;f2.jpg&#34; alt&gt;&lt;br&gt;
所以用 persistent BST&lt;br&gt;
&lt;img data-src=&#34;f1.jpg&#34; alt&gt;&lt;br&gt;
 先遍历二叉搜索树找到要插入的位置，然后对于插入节点把它从根节点到它全都复制一遍然后插入&lt;/p&gt;
&lt;/div&gt;&lt;/details&gt;
&lt;h2 id=&#34;tiger编译器中的符号&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#tiger编译器中的符号&#34;&gt;#&lt;/a&gt; Tiger 编译器中的符号&lt;/h2&gt;
&lt;p&gt;对链表进行 lookup 的时候每一次都要进行 string compare，开销是很大的。所以使用新的数据结构将符号对象关联到一个整数上，因此对于任意给定字符串的所有不同出现，都会被转换成同一个符号对象。&lt;br&gt;
Symbol 的实现：通过 hash 函数将字符串映射到一个 symbol 对象上&lt;br&gt;
 SymbolTable 的实现：beginScope () 和 endScope () 的实现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;beginScope ()：添加一个 marksym&lt;/li&gt;
&lt;li&gt;endScope ()：从符号表中不断 pop 直到 marksym&lt;/li&gt;
&lt;li&gt;引入一个 辅助栈 (Auxiliary stack) 来维护
&lt;ul&gt;
&lt;li&gt;符号入栈时，会将 binding 联动地插入对应 bucket 的链表头&lt;/li&gt;
&lt;li&gt;弹出栈顶符号时，对应 bucket 的链表头也会联动地被移除&lt;/li&gt;
&lt;li&gt;beginScope: 压入一个特殊标记到辅助栈中&lt;/li&gt;
&lt;li&gt;endScope: 一直弹出符号直到弹出了一个特殊标记&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;类型检查&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#类型检查&#34;&gt;#&lt;/a&gt; 类型检查&lt;/h2&gt;
&lt;h3 id=&#34;哪些类型表达式是合法非法的&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#哪些类型表达式是合法非法的&#34;&gt;#&lt;/a&gt; 哪些类型表达式是合法 / 非法的&lt;/h3&gt;
&lt;p&gt;Tiger 的类型系统：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两种 primitive type: int, string&lt;/li&gt;
&lt;li&gt;两种 constructed type: records, arrays&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;typec → type type-id = ty
&lt;ul&gt;
&lt;li&gt;这表示定义一个类型。 &lt;code&gt;typec&lt;/code&gt;  是一个类型定义的开始，它由关键字  &lt;code&gt;type&lt;/code&gt; 、一个类型标识符  &lt;code&gt;type-id&lt;/code&gt;  和一个等号  &lt;code&gt;=&lt;/code&gt;  后跟类型定义  &lt;code&gt;ty&lt;/code&gt;  组成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ty → type-id
&lt;ul&gt;
&lt;li&gt;这表示类型  &lt;code&gt;ty&lt;/code&gt;  可以直接是一个已定义的类型标识符  &lt;code&gt;type-id&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ty → ‘{’ tyfields ‘}’
&lt;ul&gt;
&lt;li&gt;这表示类型  &lt;code&gt;ty&lt;/code&gt;  可以是一个记录（record），由花括号  &lt;code&gt;&amp;#123;&amp;#125;&lt;/code&gt;  包围的一系列字段  &lt;code&gt;tyfields&lt;/code&gt;  定义。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ty → array of type-id
&lt;ul&gt;
&lt;li&gt;这表示类型  &lt;code&gt;ty&lt;/code&gt;  可以是一个数组，由关键字  &lt;code&gt;array of&lt;/code&gt;  后跟一个类型标识符  &lt;code&gt;type-id&lt;/code&gt;  定义。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;tyfields → ε
&lt;ul&gt;
&lt;li&gt;这表示字段列表  &lt;code&gt;tyfields&lt;/code&gt;  可以为空（ε 表示空串）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li , id:type-id&gt;tyfields → id: type-id
&lt;ul&gt;
&lt;li&gt;这表示字段列表  &lt;code&gt;tyfields&lt;/code&gt;  由一个或多个字段组成，每个字段由一个标识符  &lt;code&gt;id&lt;/code&gt;  和冒号  &lt;code&gt;:&lt;/code&gt;  后跟一个类型标识符  &lt;code&gt;type-id&lt;/code&gt;  定义，多个字段之间用逗号  &lt;code&gt;,&lt;/code&gt;  分隔。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;let type a = &amp;#123;x: int; y: int&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    type b = a&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    var i : a := ...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    var j : b := ...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;in i := j&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;类型等价&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#类型等价&#34;&gt;#&lt;/a&gt; 类型等价&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Name equivalence (NE): 必须声明是同一个类型才是同一类型&lt;/li&gt;
&lt;li&gt;Structure equivalence (SE): 如果两个类型的结构完全相同（即它们由相同的构造器以相同的顺序组成），那么它们就被认为是等价的，即使它们的名字不同&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;type A = &amp;#123;x: int; y: int&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;type B = &amp;#123;x: int; y: int&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Tiger 用的是 NE&lt;br&gt;
 在 Tiger 编程语言中，存在两个独立的命名空间：一个用于类型（Types），另一个用于函数和变量（Functions and Variables）。所以类型和函数 / 变量可以存在相同的名字，但是函数和变量不能存在相同的名字。&lt;br&gt;
所以需要两个 env&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Type env
&lt;ul&gt;
&lt;li&gt;symbol -&amp;gt; Ty_ty&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Value env
&lt;ul&gt;
&lt;li&gt;对于变量，symbol -&amp;gt; Ty_ty&lt;/li&gt;
&lt;li ty_tylist formals, ty_ty results&gt;对于函数，symbol -&amp;gt; struct&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;类型检查的rule&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#类型检查的rule&#34;&gt;#&lt;/a&gt; 类型检查的 rule&lt;/h3&gt;
&lt;p&gt;类型检查分为两部分:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Type-checking expressions: 对于每个表达式，根据当前的 Type 和 Value 环境来确定其类型，并检查是否符合语言的类型规则&lt;/li&gt;
&lt;li&gt;Type-checking declarations: 在 Tiger 语言中声明只可能在 let 语句中出现&lt;br&gt;
好像就是讲了 transExp, transDec, transVar，AST 递归检查每个节点的类型然后一层一层往上传再检查&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="语义分析" />
        <updated>2025-03-20T16:00:00.000Z</updated>
    </entry>
</feed>
