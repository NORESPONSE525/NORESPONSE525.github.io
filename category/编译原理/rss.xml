<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>NoResponse&#39;s Blog • Posts by &#34;编译原理&#34; category</title>
        <link>http://example.com</link>
        <description>成分复杂的CSer from ZJU</description>
        <language>en</language>
        <pubDate>Wed, 18 Jun 2025 00:00:00 +0800</pubDate>
        <lastBuildDate>Wed, 18 Jun 2025 00:00:00 +0800</lastBuildDate>
        <category>人工智能</category>
        <category>软件工程</category>
        <category>编译原理</category>
        <category>Liveness Analysis</category>
        <category>语法分析</category>
        <category>Register Allocation</category>
        <category>抽象语法</category>
        <category>词法分析</category>
        <category>中间代码</category>
        <category>活动记录</category>
        <category>语义分析</category>
        <category>Basic Blocks and Traces</category>
        <category>指令选择</category>
        <category>计算机网络</category>
        <category>计算机组成</category>
        <category>指令系统</category>
        <category>数据的表示与运算</category>
        <category>存储系统</category>
        <category>CPU</category>
        <category>错题</category>
        <item>
            <guid isPermalink="true">http://example.com/2025/06/18/computer-science/compile-principles/ch10/</guid>
            <title>Liveness Analysis</title>
            <link>http://example.com/2025/06/18/computer-science/compile-principles/ch10/</link>
            <category>Liveness Analysis</category>
            <pubDate>Wed, 18 Jun 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Liveness-Analysis-活跃变量分析&#34;&gt;&lt;a href=&#34;#Liveness-Analysis-活跃变量分析&#34; class=&#34;headerlink&#34; title=&#34;Liveness Analysis 活跃变量分析&#34;&gt;&lt;/a&gt;Liveness Analysis 活跃变量分析&lt;/h1&gt;&lt;p&gt;判断在程序执行的某个点上，一个变量的值是否可能在未来被使用，是寄存器分配、死代码消除的基础&lt;/p&gt;
&lt;h2 id=&#34;Compiler-Optimizations&#34;&gt;&lt;a href=&#34;#Compiler-Optimizations&#34; class=&#34;headerlink&#34; title=&#34;Compiler Optimizations&#34;&gt;&lt;/a&gt;Compiler Optimizations&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Local: 基于basic blocks&lt;/li&gt;
&lt;li&gt;Intraprocedural (or “global’): 基本块的控制流转移&lt;/li&gt;
&lt;li&gt;Interprocedural (or “whole-program”): Operate on &amp;gt; 1 procedure, up to whole program; Sometimes, at link time (LTO, link time optimization)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Analyze program to gather “facts”&lt;/li&gt;
&lt;li&gt;Apply transformation (e.g., optimizations)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Dataflow-Analysis&#34;&gt;&lt;a href=&#34;#Dataflow-Analysis&#34; class=&#34;headerlink&#34; title=&#34;Dataflow Analysis&#34;&gt;&lt;/a&gt;Dataflow Analysis&lt;/h2&gt;&lt;p&gt;Control Flow Graph: A directed graph 数据流图&lt;br&gt;– Nodes represent statements&lt;br&gt;– Edges represent control flow&lt;/p&gt;
&lt;p&gt;CFG的简化：基本块&lt;br&gt;&lt;img data-src=&#34;/f1.jpg&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;变量的活跃性：&#34;&gt;&lt;a href=&#34;#变量的活跃性：&#34; class=&#34;headerlink&#34; title=&#34;变量的活跃性：&#34;&gt;&lt;/a&gt;变量的活跃性：&lt;/h3&gt;&lt;p&gt;变量x在语句s处（执行s之前）处于活动状态，当且仅当满足以下三个条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;存在一个使用x的语句s’；&lt;/li&gt;
&lt;li&gt;存在从s到s’的路径；&lt;/li&gt;
&lt;li&gt;这条路径上没有对x进行任何赋值操作&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过分析liveness，我们可以实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Register Allocation&lt;/li&gt;
&lt;li&gt;Code Optimizations：Remove unused assignments&lt;/li&gt;
&lt;li&gt;IR Construction： Optimize the construction of SSA&lt;/li&gt;
&lt;li&gt;Security&amp;#x2F;Reliability: Detect the use of uninitialized variables&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;Dataflow-Equations-for-Liveness-构建数据流方程&#34;&gt;&lt;a href=&#34;#Dataflow-Equations-for-Liveness-构建数据流方程&#34; class=&#34;headerlink&#34; title=&#34;Dataflow Equations for Liveness 构建数据流方程&#34;&gt;&lt;/a&gt;Dataflow Equations for Liveness 构建数据流方程&lt;/h2&gt;&lt;p&gt;A CFG node has&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;out-edges: lead to successor nodes&lt;/li&gt;
&lt;li&gt;in-edges: come from predecessor nodes&lt;/li&gt;
&lt;li&gt;pred[n]: the predecessors of node n       前驱&lt;/li&gt;
&lt;li&gt;succ[n]: the successors of node n     后继&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;几个定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;use[n]: 在节点n被读取或使用(x &amp;#x3D; a + b的a和b, if(a &amp;lt; b)的a和b, return c的c)&lt;/li&gt;
&lt;li&gt;def[n]: 在节点n被定义(x &amp;#x3D; a + b的x)&lt;/li&gt;
&lt;li&gt;in[n]: 在节点n之前，所有活跃变量的集合&lt;/li&gt;
&lt;li&gt;out[n]: 在节点n之后，所有活跃变量的集合&lt;br&gt;三条活跃性规则：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;if $a \in in[n]$ then for $\all m \in pred[n]$ we have $a \in out[m]$&lt;/li&gt;
&lt;li&gt;if $a \in use[n]$ then $a \in in[n]$&lt;/li&gt;
&lt;li&gt;if $a \in out[n]$ and $a \notin def[n]$ then $a \in in[n]$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;得到以下两个数据流方程：&lt;br&gt;$$&lt;br&gt;out[n] &amp;#x3D; \cup_{s \in succ[n]} in[s]&lt;br&gt;$$&lt;br&gt; 一个节点在n的出口处活跃当且仅当在它后继的入口处是活跃的（活跃性的反向传播）&lt;br&gt;$$&lt;br&gt;in[n] &amp;#x3D; use[n] \cup (out[n] - def[n])&lt;br&gt;$$&lt;/p&gt;
&lt;h2 id=&#34;求解数据流方程&#34;&gt;&lt;a href=&#34;#求解数据流方程&#34; class=&#34;headerlink&#34; title=&#34;求解数据流方程&#34;&gt;&lt;/a&gt;求解数据流方程&lt;/h2&gt;&lt;p&gt;有了上面的两个数据流方程，就可以求解数据流方程了&lt;br&gt;算法：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;figcaption&gt;&lt;span&gt;pseudo&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;for each n&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    in[n] ←&amp;#123;&amp;#125;; out[n] ←&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;repeat&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    for each n&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        in′[n] ← in[n]; out′[n] ← out[n]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        in[n] ← use[n] ∪ (out[n] − def[n])&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        out[n] ← ⋃( ∈()**[+] in[s]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;until in′[n] = in[n] and out′[n] = out[n] for all n&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;将所有节点的 &lt;code&gt;in&lt;/code&gt; 和 &lt;code&gt;out&lt;/code&gt; 集合初始化为空集。&lt;/li&gt;
&lt;li&gt;写出&lt;code&gt;use[n]&lt;/code&gt;和&lt;code&gt;def[n]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用数据流方程更新&lt;code&gt;in&lt;/code&gt;和&lt;code&gt;out&lt;/code&gt;集合&lt;/li&gt;
&lt;li&gt;直到&lt;code&gt;in&lt;/code&gt;和&lt;code&gt;out&lt;/code&gt;集合不再改变为止&lt;br&gt;例：&lt;br&gt;&lt;img data-src=&#34;/f2.jpg&#34;&gt;&lt;br&gt;对于这个CFG&lt;br&gt;每一次迭代如图：&lt;br&gt;&lt;img data-src=&#34;/f3.jpg&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;Improvements&#34;&gt;&lt;a href=&#34;#Improvements&#34; class=&#34;headerlink&#34; title=&#34;Improvements&#34;&gt;&lt;/a&gt;Improvements&lt;/h2&gt;&lt;h3 id=&#34;Use-Basic-Block&#34;&gt;&lt;a href=&#34;#Use-Basic-Block&#34; class=&#34;headerlink&#34; title=&#34;Use Basic Block&#34;&gt;&lt;/a&gt;Use Basic Block&lt;/h3&gt;&lt;p&gt;后面有点懒得看，先放着&lt;/p&gt;
&lt;h2 id=&#34;集合的表示方法&#34;&gt;&lt;a href=&#34;#集合的表示方法&#34; class=&#34;headerlink&#34; title=&#34;集合的表示方法&#34;&gt;&lt;/a&gt;集合的表示方法&lt;/h2&gt;&lt;p&gt;对于in, out, use, def集合的表示和操作对性能有很大影响&lt;/p&gt;
&lt;h3 id=&#34;Bit-Arrays&#34;&gt;&lt;a href=&#34;#Bit-Arrays&#34; class=&#34;headerlink&#34; title=&#34;Bit Arrays&#34;&gt;&lt;/a&gt;Bit Arrays&lt;/h3&gt;&lt;p&gt;有点像bit map，适用于稠密集合（1比较多的，如果0太多就浪费了）&lt;/p&gt;
&lt;h3 id=&#34;Sorted-Lists&#34;&gt;&lt;a href=&#34;#Sorted-Lists&#34; class=&#34;headerlink&#34; title=&#34;Sorted Lists&#34;&gt;&lt;/a&gt;Sorted Lists&lt;/h3&gt;&lt;p&gt;适合稀疏集合（用一个链表存集合中的变量, Sorted by variable name&amp;#x2F;ID）&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/06/18/computer-science/compile-principles/ch11/</guid>
            <title>Register Allocation</title>
            <link>http://example.com/2025/06/18/computer-science/compile-principles/ch11/</link>
            <category>Register Allocation</category>
            <pubDate>Wed, 18 Jun 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Register-Allocation&#34;&gt;&lt;a href=&#34;#Register-Allocation&#34; class=&#34;headerlink&#34; title=&#34;Register Allocation&#34;&gt;&lt;/a&gt;Register Allocation&lt;/h1&gt;&lt;p&gt;目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Map temporaries to registers&lt;/li&gt;
&lt;li&gt;Preserve program semantics&lt;/li&gt;
&lt;li&gt;Optimize performance&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;图着色算法&#34;&gt;&lt;a href=&#34;#图着色算法&#34; class=&#34;headerlink&#34; title=&#34;图着色算法&#34;&gt;&lt;/a&gt;图着色算法&lt;/h2&gt;&lt;p&gt;冲突图是一个无向图，冲突图中，每个节点是一个变量（寄存器分配的候选对象）。&lt;br&gt;如果两个变量在同一时刻是活跃的（live），它们就有冲突边（interference edge），表示它们不能被分配到同一个寄存器&lt;br&gt;冲突信息可以用矩阵或者图来表示&lt;/p&gt;
&lt;h3 id=&#34;冲突图构建&#34;&gt;&lt;a href=&#34;#冲突图构建&#34; class=&#34;headerlink&#34; title=&#34;冲突图构建&#34;&gt;&lt;/a&gt;冲突图构建&lt;/h3&gt;&lt;p&gt;我们从一个中间代码的指令出发，根据live-out（就是out集合）添加冲突边：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;非 move 指令（不是a :&amp;#x3D; b这种）&lt;br&gt;比如a :&amp;#x3D; b1 + b2&lt;br&gt;对于每个bn和a之间都添加冲突边&lt;br&gt;比如下面这个例子：&lt;br&gt;&lt;img data-src=&#34;/f1.jpg&#34;&gt;&lt;br&gt;可以看到有ab ac同时live了，所以为a和b，a和c添加冲突边&lt;/li&gt;
&lt;li&gt;move指令&lt;br&gt;对于move指令，不添加冲突边：&lt;br&gt;比如对于第 2 条指令 d ← a，out[2] &amp;#x3D; {a, e}，那么只对d和e添加冲突边，对d和a不添加&lt;br&gt;但如果move之后又对d重新赋值了，那么还是要添加上d和a之间的冲突边&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;冲突图着色&#34;&gt;&lt;a href=&#34;#冲突图着色&#34; class=&#34;headerlink&#34; title=&#34;冲突图着色&#34;&gt;&lt;/a&gt;冲突图着色&lt;/h3&gt;&lt;p&gt;Vertex Coloring: 给图中的顶点着色，使得图中没有边连接相同颜色的顶点&lt;br&gt;K-Coloring: 颜色数小于K&lt;/p&gt;
&lt;h4 id=&#34;Kempe-简化&#34;&gt;&lt;a href=&#34;#Kempe-简化&#34; class=&#34;headerlink&#34; title=&#34;Kempe 简化&#34;&gt;&lt;/a&gt;Kempe 简化&lt;/h4&gt;&lt;p&gt;如果图中有一个节点 n 的度数 &amp;lt; K（也就是它的冲突数少于寄存器数），那我们可以“临时删掉”这个节点，并递归给剩下的图上色。之后再把这个节点加回来，它一定可以找到一个合法颜色。&lt;/p&gt;
&lt;p&gt;如果图中所有节点的度数都 ≥ K，那就可能要进入溢出（spill）处理&lt;br&gt;算法步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;build: 画冲突图&lt;/li&gt;
&lt;li&gt;simplify the nodes with insignificant degree: 选取degree &amp;lt; k的节点，压栈&lt;/li&gt;
&lt;li&gt;select (or color) while rebuilding the graph: 出栈，分配颜色&lt;br&gt;A vertex such that its degree &amp;lt; k is always k-colorable&lt;br&gt;Remove such vertices and push them to a stack until the graph becomes empty&lt;br&gt;移除顶点的同时移除相关边&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;Coalescing&#34;&gt;&lt;a href=&#34;#Coalescing&#34; class=&#34;headerlink&#34; title=&#34;Coalescing&#34;&gt;&lt;/a&gt;Coalescing&lt;/h4&gt;&lt;p&gt;遵循两种策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Briggs Criteria&lt;/strong&gt;: 如果将节点 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 合并后得到的新节点 &lt;code&gt;ab&lt;/code&gt;，其相邻节点中degree &amp;gt;&amp;#x3D; K 的节点（significant-degree neighbors）的数量 小于 K，则可以合并&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;George Criteria&lt;/strong&gt;: 如果对节点 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt;，对于 &lt;code&gt;a&lt;/code&gt; 的每一个邻居 &lt;code&gt;t&lt;/code&gt;， 满足二者其中之一，就能合并：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt; 本来就和 &lt;code&gt;b&lt;/code&gt; 有冲突&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt;的degree &amp;lt; K&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整体流程：&lt;br&gt;&lt;img data-src=&#34;/f2.jpg&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么要simplify non-move-related node: 保留move-related的后续可以合并&lt;/li&gt;
&lt;li&gt;freeze: 当我们遇到两个变量 a ← b 有 move 指令，但现在还不能安全合并，我们又不想立刻 spill，于是我们“冻结”这条 move 指令：不再试图合并 a 和 b，而是让其中一个变成非 move 相关（non-move-related），进入 Simplify 阶段继续处理&lt;/li&gt;
&lt;li&gt;spill规则：优先移除不被经常使用、degree大的节点&lt;ul&gt;
&lt;li&gt;实际溢出的priority计算，对于节点a：&lt;br&gt;$$&lt;br&gt;priority(t) &amp;#x3D; \frac{(use + def outside loop) + loop_num * (use + def inside loop)}{D}&lt;br&gt;$$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/06/17/computer-science/compile-principles/ch8/</guid>
            <title>Basic Blocks &amp; Traces</title>
            <link>http://example.com/2025/06/17/computer-science/compile-principles/ch8/</link>
            <category>Basic Blocks and Traces</category>
            <pubDate>Tue, 17 Jun 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Basic-Blocks-and-Traces&#34;&gt;&lt;a href=&#34;#Basic-Blocks-and-Traces&#34; class=&#34;headerlink&#34; title=&#34;Basic Blocks and Traces&#34;&gt;&lt;/a&gt;Basic Blocks and Traces&lt;/h1&gt;&lt;h2 id=&#34;Canonical-Form&#34;&gt;&lt;a href=&#34;#Canonical-Form&#34; class=&#34;headerlink&#34; title=&#34;Canonical Form&#34;&gt;&lt;/a&gt;Canonical Form&lt;/h2&gt;&lt;p&gt;IR存在一些与机器语言不能完全对应的情况，和与编译优化分析相冲突的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CJUMP能够转移到t或者f，但是真正的机器语言在条件为假的时候直接下降至下一条指令（条件为真才跳转）&lt;/li&gt;
&lt;li&gt;在表达式中使用ESEQ不太方便，会使子树不同的计算顺序产生不同的计算结果&lt;/li&gt;
&lt;li&gt;CALL调用CALL作为参数的时候会有寄存器冲突、语句副作用（修改全局变量、改变堆内存, etc.）等问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Linearize: Transform trees into a list of canonical&lt;br&gt;trees without SEQ or ESEQ nodes&lt;/li&gt;
&lt;li&gt;Basic blocks: Group statements into sequences with&lt;br&gt;no internal jumps&amp;#x2F;labels&lt;/li&gt;
&lt;li&gt;Trace schedule: Order basic blocks so every CJUMP is followed by its false label&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;线性化&#34;&gt;&lt;a href=&#34;#线性化&#34; class=&#34;headerlink&#34; title=&#34;线性化&#34;&gt;&lt;/a&gt;线性化&lt;/h3&gt;&lt;p&gt;&amp;#x3D;&amp;#x3D;规范树（Canonical Tree）定义：&amp;#x3D;&amp;#x3D;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无SEQ或ESEQ&lt;/li&gt;
&lt;li&gt;每一个CALL的父亲不是EXP(…)就是MOVE(TEMP t, …)&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;消除ESEQ&#34;&gt;&lt;a href=&#34;#消除ESEQ&#34; class=&#34;headerlink&#34; title=&#34;消除ESEQ&#34;&gt;&lt;/a&gt;消除ESEQ&lt;/h4&gt;&lt;h5 id=&#34;规则&#34;&gt;&lt;a href=&#34;#规则&#34; class=&#34;headerlink&#34; title=&#34;规则&#34;&gt;&lt;/a&gt;规则&lt;/h5&gt;&lt;p&gt;合并副作用，提升ESEQ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ESEQ(s1, ESEQ(s2,e)) &amp;#x3D;&amp;gt; ESEQ(SEQ(s1,s2),e)&lt;/li&gt;
&lt;li&gt;BINOP(op, ESEQ(s, e1), e2) ⇒ ESEQ(s, BINOP(op, e1, e2))&lt;/li&gt;
&lt;li&gt;MEM(ESEQ(s, e1)) ⇒ ESEQ(s, MEM(e1))&lt;/li&gt;
&lt;li&gt;JUMP(ESEQ(s, e1)) ⇒ SEQ(s, JUMP(e1))&lt;/li&gt;
&lt;li&gt;CJUMP(op, ESEQ(s, e1), e2, l1, l2) ⇒ SEQ(s, CJUMP(op, e1, e2, l1, l2))&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;Commutativity（重点）&#34;&gt;&lt;a href=&#34;#Commutativity（重点）&#34; class=&#34;headerlink&#34; title=&#34;Commutativity（重点）&#34;&gt;&lt;/a&gt;Commutativity（重点）&lt;/h5&gt;&lt;p&gt;当&lt;code&gt;ESEQ&lt;/code&gt;出现在&lt;code&gt;BINOP&lt;/code&gt;的右操作数，即$BINOP(op, e1, ESEQ(s, e2))$时，我们不能再像之前那样简单地把&lt;code&gt;s&lt;/code&gt;提升到整个&lt;code&gt;BINOP&lt;/code&gt;之前，因为&lt;code&gt;e1&lt;/code&gt;的求值在&lt;code&gt;e2&lt;/code&gt;之前，否则可能影响&lt;code&gt;e1&lt;/code&gt;的计算结果&lt;/p&gt;
&lt;p&gt;Commutativity：交换性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Commuting: s不影响e1的结果&lt;ul&gt;
&lt;li&gt;rule: $BINOP(op, e1, ESEQ(s, e2)) &amp;#x3D; ESEQ(s, BINOP(op, e1, e2))$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Non-commuting: s会影响e1的结果，把e1的结果显算出来放到临时变量t里，再提升s&lt;ul&gt;
&lt;li&gt;rule: $BINOP(op, ESEQ(s, e1), e2) &amp;#x3D; ESEQ(MOVE(TEMP t, e1), ESEQ(s, BINOP(op, TEMP t, e2)))$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;将CALL移到顶层&#34;&gt;&lt;a href=&#34;#将CALL移到顶层&#34; class=&#34;headerlink&#34; title=&#34;将CALL移到顶层&#34;&gt;&lt;/a&gt;将CALL移到顶层&lt;/h4&gt;&lt;p&gt;方法：立即将每一个返回值赋给一个新的临时寄存器&lt;br&gt;$$&lt;br&gt;CALL(fun, args) ⇒ ESEQ(MOVE(TEMP t, CALL(fun, args)), TEMP t)&lt;br&gt;$$&lt;/p&gt;
&lt;h4 id=&#34;消除SEQ&#34;&gt;&lt;a href=&#34;#消除SEQ&#34; class=&#34;headerlink&#34; title=&#34;消除SEQ&#34;&gt;&lt;/a&gt;消除SEQ&lt;/h4&gt;&lt;p&gt;$$&lt;br&gt;SEQ(SEQ(a, b), c) &amp;#x3D; SEQ(a, SEQ(b, c))&lt;br&gt;$$&lt;br&gt;把SEQ变成一个线性语句表：$SEQ(s_1, SEQ(s_2, …, SEQ(s_{n-1}, s_n) …))$&lt;br&gt;就可以认为是由语句组成的简单列表$s_1, s_2, …, s_n$&lt;/p&gt;
&lt;h3 id=&#34;处理CJUMP&#34;&gt;&lt;a href=&#34;#处理CJUMP&#34; class=&#34;headerlink&#34; title=&#34;处理CJUMP&#34;&gt;&lt;/a&gt;处理CJUMP&lt;/h3&gt;&lt;p&gt;重排CJUMP，使得每个$CJUMP(op, e_1, e_2, l_t, l_f)后面都紧跟着$LABEL(l_f)$&lt;br&gt;分两步：1. 取一列canonical tree由它们形成basic block 2. 对basic block进行排序形成trace&lt;/p&gt;
&lt;h4 id=&#34;Basic-Block&#34;&gt;&lt;a href=&#34;#Basic-Block&#34; class=&#34;headerlink&#34; title=&#34;Basic Block&#34;&gt;&lt;/a&gt;Basic Block&lt;/h4&gt;&lt;p&gt;一个基本块是一段连续的指令序列，即:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个语句是一个&lt;code&gt;LABEL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;最后一个语句是&lt;code&gt;JUMP&lt;/code&gt;或&lt;code&gt;CJUMP&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;没有其他的&lt;code&gt;LABEL&lt;/code&gt;, &lt;code&gt;JUMP&lt;/code&gt;或&lt;code&gt;CJUMP&lt;/code&gt;&lt;br&gt;划分方法：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;每一个&lt;code&gt;LABEL&lt;/code&gt;都对应一个基本块的开始&lt;/li&gt;
&lt;li&gt;每一个&lt;code&gt;JUMP&lt;/code&gt;或&lt;code&gt;CJUMP&lt;/code&gt;都对应一个基本块的结束&lt;/li&gt;
&lt;li&gt;如果遇到&lt;code&gt;LABEL1&lt;/code&gt; -&amp;gt; &lt;code&gt;LABEL2&lt;/code&gt;,就在&lt;code&gt;LABEL2&lt;/code&gt;前面加一个&lt;code&gt;JUMP&lt;/code&gt;到&lt;code&gt;LABEL2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果遇到开头没有&lt;code&gt;LABEL&lt;/code&gt;的，则加一个&lt;code&gt;LABEL&lt;/code&gt;（比如程序的开头）&lt;/li&gt;
&lt;li&gt;出口处理：添加一个LABEL &lt;code&gt;done&lt;/code&gt;表示出口处理的开始，并把$JUMP done$放最后一个block末尾&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;Trace&#34;&gt;&lt;a href=&#34;#Trace&#34; class=&#34;headerlink&#34; title=&#34;Trace&#34;&gt;&lt;/a&gt;Trace&lt;/h4&gt;&lt;p&gt;现在我们可以按任意顺序来安排这些基本块，并且程序执行的结果仍是相同的——因为无论怎么排序，每个基本块的末尾都能转移到一个正确的位置。我们可以利用这一点来选择适当的基本块排列顺序，以满足每个&lt;code&gt;CJUMP&lt;/code&gt;之后都跟随它的false标号这一条件。&lt;br&gt;与此同时，我们也可以安排基本块使得无条件转移&lt;code&gt;JUMP&lt;/code&gt;之后直接跟随的是它们的目标标号。这样便可以删除这些无条件转移，从而使编译生成的程序的执行速度更快。&lt;/p&gt;
&lt;p&gt;把basic block排成trace的方法也很简单：&amp;#x3D;&amp;#x3D;从每个基本块开始，追踪JUMP链，标记遇到的每一个未标记的基本快并添加到当前trace中，最终到达一个其后继都标记过的块，就是结束块。之后再选则一个未标记的基本块开始，重复上述过程。&amp;#x3D;&amp;#x3D;&lt;/p&gt;
&lt;p&gt;因为轨迹调度不可能覆盖所有情况，所以：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果CJUMP 后跟 true label: 条件取反，交换 true&amp;#x2F;false，改成：&lt;br&gt;$$&lt;br&gt;CJUMP(!cond, lf, lt)&lt;br&gt;$$&lt;/li&gt;
&lt;li&gt;CJUMP 后跟的不是 true 也不是 false: 创建中间 label，插入 JUMP&lt;br&gt;$$&lt;br&gt;CJUMP(cond, lt, lf) &amp;#x3D;&amp;gt; CJUMP(cond, lt, l’f) LABEL l’f   JUMP NAME(lf)&lt;br&gt;$$&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;最优轨迹-Optimal-Trace&#34;&gt;&lt;a href=&#34;#最优轨迹-Optimal-Trace&#34; class=&#34;headerlink&#34; title=&#34;最优轨迹(Optimal Trace)&#34;&gt;&lt;/a&gt;最优轨迹(Optimal Trace)&lt;/h4&gt;&lt;p&gt;对于basic block可能有不同的trace划分方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hot Path Prioritization（优先热路径）: 优先将**运行频率高的基本块（hot blocks）**合并在同一条轨迹（trace）里，减少跳转，提高局部性。&lt;br&gt;+++info example&lt;br&gt;假设 if-else 中 if 分支占 90% 执行概率，else 只有 10%：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;tiger&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; x &amp;gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt; then&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    a := a + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;   -- 热路径&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    a := a - &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;生成时应把 x &amp;gt; 0 为真的路径（包括 CJUMP 的 false 分支）安排成 fall-through，避免跳转开销出现在热路径上。&lt;br&gt;+++&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Locality Enhancement（增强局部性）: 把逻辑上相关联的代码块放得更近一些，让它们在内存中“邻近”。&lt;ul&gt;
&lt;li&gt;原因：&lt;ul&gt;
&lt;li&gt;更好地利用 CPU cache、预取机制。&lt;/li&gt;
&lt;li&gt;避免指令 cache miss 导致性能下降。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如：将循环体和循环条件代码块排在一起（而不是让条件跳到远处），从而保持指令流顺序性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Jump Minimization（最小化跳转）: 尽量减少无条件跳转（JUMP）和不必要的条件跳转（CJUMP），尤其在常走路径上，	减少分支预测失败。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;/f1.jpg&#34;&gt;&lt;br&gt;哪个划分比较好？&lt;br&gt;根据3，c比a好；&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/06/17/computer-science/compile-principles/ch9/</guid>
            <title>指令选择</title>
            <link>http://example.com/2025/06/17/computer-science/compile-principles/ch9/</link>
            <category>指令选择</category>
            <pubDate>Tue, 17 Jun 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;指令选择&#34;&gt;&lt;a href=&#34;#指令选择&#34; class=&#34;headerlink&#34; title=&#34;指令选择&#34;&gt;&lt;/a&gt;指令选择&lt;/h1&gt;&lt;p&gt;找出实现一个给定的IR Tree的恰当机器指令序列。Mapping IR into abstract assembly code&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Abstract assembly &amp;#x3D; assembly with infinite registers&lt;ul&gt;
&lt;li&gt;Invent new temporaries for intermediate results&lt;/li&gt;
&lt;li&gt;Map to actual registers later&lt;br&gt;Tree pattern, 也叫tile&lt;br&gt;本质上是pattern matching, 我们使用tree covering 来实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们&lt;code&gt;Jouette&lt;/code&gt;体系将树模式映射为指令:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;寄存器中可以存储数据或地址，每条指令可以访问任意寄存器&lt;/li&gt;
&lt;li&gt;寄存器r0的值永远是0&lt;/li&gt;
&lt;li&gt;每条指令的latency都是一周期（除了MOVEM的周期是m）&lt;/li&gt;
&lt;li&gt;每个周期执行一条指令&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;/f2.jpg&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/f1.jpg&#34;&gt;&lt;br&gt;将IR与后端的机器指令都转换为树结构。这样就把指令选择问题转换为机器指令树覆盖全IR Tree的问题。&lt;br&gt;一棵树可以有多种tiling方式&lt;/p&gt;
&lt;h2 id=&#34;Optimal-Tiling-Optimum-Tiling&#34;&gt;&lt;a href=&#34;#Optimal-Tiling-Optimum-Tiling&#34; class=&#34;headerlink&#34; title=&#34;Optimal Tiling &amp;amp; Optimum Tiling&#34;&gt;&lt;/a&gt;Optimal Tiling &amp;amp; Optimum Tiling&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Optimum Tiling：使得tiling数最少，是&amp;#x3D;&amp;#x3D;全局最优&amp;#x3D;&amp;#x3D;&lt;/li&gt;
&lt;li&gt;Optimal Tiling：No two adjacent tiles can be combined into a single tile of lower cost，是&amp;#x3D;&amp;#x3D;局部最优&amp;#x3D;&amp;#x3D;&lt;br&gt;一个optimum tiling必定是optimal tiling&lt;br&gt;&lt;img data-src=&#34;/f3.jpg&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Algorithms-for-Instruction-Selection&#34;&gt;&lt;a href=&#34;#Algorithms-for-Instruction-Selection&#34; class=&#34;headerlink&#34; title=&#34;Algorithms for Instruction Selection&#34;&gt;&lt;/a&gt;Algorithms for Instruction Selection&lt;/h2&gt;&lt;h3 id=&#34;Maximal-Munch-Find-an-optimal-tiling&#34;&gt;&lt;a href=&#34;#Maximal-Munch-Find-an-optimal-tiling&#34; class=&#34;headerlink&#34; title=&#34;Maximal Munch: Find an optimal tiling&#34;&gt;&lt;/a&gt;Maximal Munch: Find an optimal tiling&lt;/h3&gt;&lt;p&gt;最大匹配：贪心算法、自顶向下&lt;br&gt;方法：从IR树的根节点开始，用&amp;#x3D;&amp;#x3D;最大的&amp;#x3D;&amp;#x3D;tile覆盖当前节点（包含最多节点的），然后在子树中重复此过程&lt;/p&gt;
&lt;h3 id=&#34;DP&#34;&gt;&lt;a href=&#34;#DP&#34; class=&#34;headerlink&#34; title=&#34;DP&#34;&gt;&lt;/a&gt;DP&lt;/h3&gt;&lt;p&gt;动态规划：自底向上&lt;br&gt;方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;递归计算每个子树的最优平铺成本&lt;/li&gt;
&lt;li&gt;对于每个节点，考虑所有可能的匹配平铺&lt;/li&gt;
&lt;li&gt;对于每个匹配平铺，计算其成本如下：cost &amp;#x3D; tile_cost + sum（costs_of_children）&lt;/li&gt;
&lt;li&gt;选择成本最低的平铺&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;对于$CONST i$，它的代价为1( ADD r1, r0, i)&lt;/li&gt;
&lt;li&gt;对于这棵树，有三种匹配方法&lt;br&gt;&lt;img data-src=&#34;/f4.jpg&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/f5.jpg&#34;&gt;&lt;br&gt;因为2&amp;lt;3，所以我们从cost&amp;#x3D;2的两个任选一个&lt;br&gt;接下来对于MEM，用的都是LOAD，代价都是1，2&amp;lt;3所以选cost&amp;#x3D;2的&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;指令发射&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;function &lt;span class=&#34;title function_&#34;&gt;Emission&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(node n)&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    For each leaf l_i of the tile selected at node n:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;title function_&#34;&gt;Emission&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(l_i)&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    Emit the instruction matched at node n&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;最大匹配-vs-动态规划&#34;&gt;&lt;a href=&#34;#最大匹配-vs-动态规划&#34; class=&#34;headerlink&#34; title=&#34;最大匹配 vs 动态规划&#34;&gt;&lt;/a&gt;最大匹配 vs 动态规划&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;T&lt;/strong&gt; - tile的总种类数  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;K&lt;/strong&gt; - 一个matching tile平均覆盖的节点数  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;K’&lt;/strong&gt; - 需要检查的最大tile尺寸（即最大的瓦片包含的节点数）  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;T’&lt;/strong&gt; - 每个树节点平均能匹配上的tile数量  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;N&lt;/strong&gt; - 输入的中间表示IR Tree中的总节点数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两种算法的运行时间复杂度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;最大匹配（Maximal Munch）&lt;/strong&gt; - 其时间复杂度与&lt;br&gt;$$&lt;br&gt;\frac{(K’ + T’) * K}{K} * N &amp;#x3D; (K’ + T’) * N&lt;br&gt;$$&lt;br&gt;成正比&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;动态规划（Dynamic Programming）&lt;/strong&gt; - 其时间复杂度与&lt;br&gt;$$&lt;br&gt;(K’ + T’) * N&lt;br&gt;$$&lt;br&gt;成正比&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Tree-Grammar-树文法&#34;&gt;&lt;a href=&#34;#Tree-Grammar-树文法&#34; class=&#34;headerlink&#34; title=&#34;Tree Grammar 树文法&#34;&gt;&lt;/a&gt;Tree Grammar 树文法&lt;/h2&gt;&lt;p&gt;问题：对于具有复杂指令集和多种寄存器类型及寻址模式的机器，难以使用简单的tree pattern和tiling算法。&lt;br&gt;用一种文法来描述tiles，代替手写过程式匹配代码，支持自动化的指令选择，增强了可移植性&lt;br&gt;图没看懂，后面再回来研究&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/06/16/computer-science/compile-principles/ch7/</guid>
            <title>IR</title>
            <link>http://example.com/2025/06/16/computer-science/compile-principles/ch7/</link>
            <category>中间代码</category>
            <pubDate>Mon, 16 Jun 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;IR&#34;&gt;&lt;a href=&#34;#IR&#34; class=&#34;headerlink&#34; title=&#34;IR&#34;&gt;&lt;/a&gt;IR&lt;/h1&gt;&lt;p&gt;Intermediate Representation&lt;br&gt;解决高级语言和目标机器汇编语言之间的转化&lt;br&gt;为什么需要IR:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更模块化、可迁移&lt;/li&gt;
&lt;li&gt;分层分析和优化&lt;br&gt;IR可以有好多层：IR1-&amp;gt;IR2-&amp;gt;…-&amp;gt;IRn&lt;br&gt;+++info 编译流程划分&lt;br&gt;前端：源代码-&amp;gt;词法分析-&amp;gt;语法分析-&amp;gt;语义分析（IR之前的都是）&lt;br&gt;中端：基于IR的分析与变换（可能生成新IR，可以做一些机器无关优化比如循环展开等）&lt;br&gt;后端：指令选择-&amp;gt;寄存器分配-&amp;gt;指令调度-&amp;gt;机器码（IR之后的）&lt;br&gt;+++&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Three-Address-Code&#34;&gt;&lt;a href=&#34;#Three-Address-Code&#34; class=&#34;headerlink&#34; title=&#34;Three-Address Code&#34;&gt;&lt;/a&gt;Three-Address Code&lt;/h2&gt;&lt;p&gt;最多有三个操作数&lt;br&gt;x &amp;#x3D; y op z&lt;br&gt;“地址”可以具有如下形式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源程序中的名字(name)&lt;/li&gt;
&lt;li&gt;常量 (constant)&lt;/li&gt;
&lt;li&gt;临时变量(temporary)&lt;br&gt;&lt;img data-src=&#34;/f1.jpg&#34;&gt;&lt;br&gt;最常见的实现方法是将三地址代码作为四元组实现&lt;br&gt;+++info example&lt;br&gt;t1&amp;#x3D;x&amp;gt;0                  (gt, x, 0, t1)&lt;br&gt;if_false t1 goto L1     (if_f, t1, L1, _)&lt;br&gt;fact&amp;#x3D;1                  (asn, 1, fact, _)&lt;br&gt;label L2                (lab, L2, _, _)&lt;br&gt;+++&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;IR-Tree&#34;&gt;&lt;a href=&#34;#IR-Tree&#34; class=&#34;headerlink&#34; title=&#34;IR Tree&#34;&gt;&lt;/a&gt;IR Tree&lt;/h2&gt;&lt;p&gt;两大类节点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;表达式Exp&lt;/li&gt;
&lt;li&gt;语句Stmt&lt;br&gt;文法：&lt;br&gt;&lt;img data-src=&#34;/f2.jpg&#34;&gt;&lt;br&gt;表达式：&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Node&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;CONST(i)&lt;/td&gt;
&lt;td&gt;整数常量i&lt;/td&gt;
&lt;td&gt;CONST(42) → the value 42&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NAME(n)&lt;/td&gt;
&lt;td&gt;符号常量n，通常是一个label，值是label的地址&lt;/td&gt;
&lt;td&gt;NAME(L1) → address of label L1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TEMP(t)&lt;/td&gt;
&lt;td&gt;临时变量t (like register)&lt;/td&gt;
&lt;td&gt;TEMP(t123) → contents of temporary t123&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BINOP(o,e1,e2)&lt;/td&gt;
&lt;td&gt;对e1和e2执行二元操作o&lt;/td&gt;
&lt;td&gt;BINOP(PLUS,TEMP(t1),CONST(1)) → t1+1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MEM(e)&lt;/td&gt;
&lt;td&gt;Memory access&lt;/td&gt;
&lt;td&gt;MEM(CONST(100)) → contents at address 100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CALL(f,l)&lt;/td&gt;
&lt;td&gt;Function call, l是参数列表&lt;/td&gt;
&lt;td&gt;CALL(NAME(print),[TEMP(t1)]) → call print(t1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ESEQ(s,e)&lt;/td&gt;
&lt;td&gt;先执行语句s，再求值表达式e并返回e的结果&lt;/td&gt;
&lt;td&gt;ESEQ(MOVE(TEMP(t),CONST(1)),TEMP(t)) → (t&amp;#x3D;1; t)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;语句：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Node&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;MOVE(TEMP t, e)&lt;/td&gt;
&lt;td&gt;将表达式e的值赋给临时变量t&lt;/td&gt;
&lt;td&gt;MOVE(TEMP(t1), CONST(42)) → t1 &amp;#x3D; 42&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MOVE(MEM(e1), e2)&lt;/td&gt;
&lt;td&gt;将表达式e2的值存储到由e1指定的内存地址中&lt;/td&gt;
&lt;td&gt;MOVE(MEM(TEMP(t1)), CONST(42)) → *t1 &amp;#x3D; 42&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EXP(e)&lt;/td&gt;
&lt;td&gt;计算表达式e的值但不返回结果，通常用于有副作用的操作（如函数调用）&lt;/td&gt;
&lt;td&gt;EXP(CALL(NAME(print), …)) → 调用print()函数以产生效果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JUMP(e, labs)&lt;/td&gt;
&lt;td&gt;无条件跳转到由e指定的地址&lt;/td&gt;
&lt;td&gt;JUMP(NAME(L1), [L1]) → goto L1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CJUMP(o,e1,e2,t,f)&lt;/td&gt;
&lt;td&gt;条件跳转，根据操作o对e1和e2的结果决定跳转到t或f&lt;/td&gt;
&lt;td&gt;CJUMP(LT, TEMP(t1), CONST(0), L1, L2) → 如果t1 &amp;lt; 0则跳转到L1，否则跳转到L2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SEQ(s1, s2)&lt;/td&gt;
&lt;td&gt;语句序列，先执行s1再执行s2&lt;/td&gt;
&lt;td&gt;SEQ(MOVE(…), JUMP(…)) → 先赋值再跳转&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LABEL(n)&lt;/td&gt;
&lt;td&gt;定义一个标签&lt;/td&gt;
&lt;td&gt;LABEL(L1) → L1:&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;例子：&lt;br&gt;&lt;img data-src=&#34;/f3.jpg&#34;&gt;&lt;br&gt;ADD那个地方写成BINOP的写法也可以&lt;/p&gt;
&lt;h2 id=&#34;翻译AST成IR-Tree&#34;&gt;&lt;a href=&#34;#翻译AST成IR-Tree&#34; class=&#34;headerlink&#34; title=&#34;翻译AST成IR Tree&#34;&gt;&lt;/a&gt;翻译AST成IR Tree&lt;/h2&gt;&lt;p&gt;把AST表达式分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ex: 有结果的AST表达式比如a+b&lt;/li&gt;
&lt;li&gt;Nx：无结果的语句的比如print&lt;/li&gt;
&lt;li&gt;Cx：条件语句，值为bool的AST表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;translate-Exp&#34;&gt;&lt;a href=&#34;#translate-Exp&#34; class=&#34;headerlink&#34; title=&#34;translate Exp&#34;&gt;&lt;/a&gt;translate Exp&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;翻译简单变量：&lt;br&gt;在函数中访问一个局部变量实际上是访问它在当前栈帧中的位置，所以访问一个距离fp的offset为k的局部变量v，其IR Tree表示为:&lt;br&gt;$$&lt;br&gt;MEM(BINOP(PLUS, TEMP fp, CONST k))&lt;br&gt;$$&lt;br&gt;&lt;img data-src=&#34;/f4.jpg&#34;&gt;&lt;br&gt;如果通过static link访问一个变量，就要嵌套好几层MEM和BINOP&lt;br&gt;比如这个访问嵌套两层外面的x&lt;br&gt;最内层使用 CONST(8)：是因为需要从 inner 函数的帧指针 FP 开始，偏移 8 字节来访问静态链，该静态链指向 middle 函数的帧。&lt;br&gt;中间层和最外层使用 CONST(0)：是因为它们分别通过静态链直接访问 outer 函数的帧和变量 x，不需要额外的偏移&lt;br&gt;&lt;img data-src=&#34;/f5.jpg&#34;&gt;&lt;br&gt;:::danger&lt;br&gt;这个地方为什么内层是8中层是0存疑&lt;br&gt;:::&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;左值和右值：&amp;#x3D;左右的&lt;br&gt;MEM(addr)可以是左值也可以是右值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Scalar L-value(Tiger): 一个地址&lt;/li&gt;
&lt;li&gt;Structured L-value(Pascal&amp;#x2F;C): 一块内存&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;翻译算术运算&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;二元: BINOP(op, e1, e2)&lt;/li&gt;
&lt;li&gt;一元: &lt;ul&gt;
&lt;li&gt;-x &amp;#x3D;&amp;#x3D;&amp;gt; BINOP(MINUS, CONST(0), e_x)&lt;/li&gt;
&lt;li&gt;~x &amp;#x3D;&amp;#x3D;&amp;gt; BINOP(XOR, e_x, CONST(-1))&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;数组访问&lt;br&gt;$$&lt;br&gt;MEM(BINOP(PLUS, MEM(e_a), BINOP(MUL, e_i, CONST(W))))&lt;br&gt;$$&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;e_a&lt;/code&gt; 是表示变量 &lt;code&gt;a&lt;/code&gt; 的表达式，通常是&amp;#x3D;&amp;#x3D; &lt;code&gt;MEM(+(TEMP(fp), CONST(k_a)))&lt;/code&gt;&amp;#x3D;&amp;#x3D;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MEM(e_a)&lt;/code&gt;：&amp;#x3D;&amp;#x3D;获取存储在变量 &lt;code&gt;a&lt;/code&gt; 中的值，即数组基地址&amp;#x3D;&amp;#x3D;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;e_i&lt;/code&gt; 是计算索引 &lt;code&gt;i&lt;/code&gt; 的表达式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BINOP(MUL, e_i, CONST(W))&lt;/code&gt;：计算偏移&lt;br&gt;&lt;img data-src=&#34;/f6.jpg&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;记录字段r.f访问:&lt;br&gt;$$&lt;br&gt;MEM(BINOP(PLUS, MEM(e_r), BINOP(MUL, n, CONST(W))))&lt;br&gt;$$&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;翻译控制流&lt;br&gt;对于if e1 op e2 then stmt1 else stmt2翻译成&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;IR&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 6个SEQ&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;SEQ(&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    CJUMP(op, e1, e2, t, f),&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    SEQ(&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        LABEL(t),&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        SEQ(&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            stm1,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            SEQ(&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                JUMP(NAME(end)),&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                SEQ(&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    LABEL(f),&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    SEQ(stm2, LABEL(end))&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                )&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            )&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        )&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    )&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;Tiger的逻辑运算符&amp;amp;(and)和|(or)需要实现短路求值：只计算必要的操作数&lt;br&gt;每个Cx是一个Label&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;逻辑与 (a &amp;amp; b)的短路规则：&lt;ul&gt;
&lt;li&gt;计算a&lt;br&gt;  -若a为假，直接得到假结果（不计算b）&lt;br&gt;  -若a为真，继续计算b，最终结果即为b的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;逻辑或 (a | b)的短路规则：&lt;br&gt;  -计算a&lt;br&gt;  -若a为真，直接得到真结果（不计算b）&lt;ul&gt;
&lt;li&gt;若a为假，继续计算b，最终结果即为b的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;循环语句&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;tiger&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt; a &amp;gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;a := a - &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;翻译成&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;IR&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;SEQ(LABEL test, &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    SEQ(CJUMP(GT, TEMP a, CONST &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;, body, done), &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        SEQ(LABEL body, &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            SEQ(MOVE(TEMP a, BINOP(MINUS, TEMP a, CONST &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;)), &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                SEQ(JUMP(NAME(test), [test]), &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    LABEL done)))))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;break翻译为直接跳转到done&lt;br&gt;for循环我懒得写了，也是一个道理&lt;br&gt;和汇编差不多意思&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;翻译函数&lt;br&gt;$$&lt;br&gt;CALL(NAME(l_f), [sl, a_1, …, a_n])&lt;br&gt;$$&lt;br&gt;sl是static link。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;translate-Declaration&#34;&gt;&lt;a href=&#34;#translate-Declaration&#34; class=&#34;headerlink&#34; title=&#34;translate Declaration&#34;&gt;&lt;/a&gt;translate Declaration&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Variable declaration&lt;/li&gt;
&lt;li&gt;Type declaration&lt;/li&gt;
&lt;li&gt;Function declaration&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;翻译变量声明&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;tiger&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;let&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    var x := &lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    var y := x + &lt;span class=&#34;number&#34;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;in &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    x + y&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;IR&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;ESEQ( &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    SEQ( &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        MOVE(MEM(+(FP, CONST(x_offset))), CONST(&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;)), &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        MOVE(MEM(+(FP, CONST(y_offset))), &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        BINOP(PLUS, &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        MEM(+(FP, CONST(x_offset))), &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        CONST(&lt;span class=&#34;number&#34;&gt;5&lt;/span&gt;))) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    ), &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    BINOP(PLUS, &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    MEM(+(FP, CONST(x_offset))), &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    MEM(+(FP, CONST(y_offset)))) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;let body in e end翻译成ESEQ(body, e)&lt;br&gt;变量定义翻译成 MEM(+(FP, CONST(offset)))&lt;br&gt;初始化翻译成 MOVE(MEM(+(FP, CONST(offset))), CONST(value))&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;p&gt;类型声明&lt;br&gt;No need to generate any IR tree code&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数声明&lt;br&gt; – Prologue（序言）&lt;br&gt; – Body（函数体）&lt;br&gt; – Epilogue（尾声）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Prologue&lt;ul&gt;
&lt;li&gt;pseudo-instructions to announce the beginning of a function&lt;/li&gt;
&lt;li&gt;定义函数标签用于跳转&amp;#x2F;调用&lt;/li&gt;
&lt;li&gt;修改栈指针（SP），为新栈帧分配空间，一般是$SP :&amp;#x3D; SP - frame_size$&lt;/li&gt;
&lt;li&gt;保存被调用者需要保存的寄存器（callee-save），如 $s0-$s7；保存返回地址（RA）&lt;/li&gt;
&lt;li&gt;保存函数参数到栈中（尤其是传值调用时）；保存静态链（static link）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/06/15/computer-science/compile-principles/ch6/</guid>
            <title>活动记录</title>
            <link>http://example.com/2025/06/15/computer-science/compile-principles/ch6/</link>
            <category>活动记录</category>
            <pubDate>Sun, 15 Jun 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Activation-Record-Stack-Frame&#34;&gt;&lt;a href=&#34;#Activation-Record-Stack-Frame&#34; class=&#34;headerlink&#34; title=&#34;Activation Record&amp;#x2F;Stack Frame&#34;&gt;&lt;/a&gt;Activation Record&amp;#x2F;Stack Frame&lt;/h1&gt;&lt;p&gt;函数的栈帧是栈上用来放函数的局部变量、参数、返回地址以及其他临时变量的区域&lt;br&gt;stack一般从高地址向低地址，heap从低地址向高地址&lt;br&gt;layout:&lt;br&gt;&lt;img data-src=&#34;/f1.jpg&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;incoming arguments: 存储caller传递给callee的参数&lt;/li&gt;
&lt;li&gt;frame pointer: 帧指针，用来访问incoming arguments，从低向高是argument 1, argument 2, …&lt;/li&gt;
&lt;li&gt;local variables: 存储函数的局部变量（还有一些保存在寄存器里）&lt;/li&gt;
&lt;li&gt;return address: 存储需要返回caller的哪里；non-leaf过程会把return address写入栈帧里面&lt;/li&gt;
&lt;li&gt;temporaries: 存储临时变量，复杂表达式拆出来的中间变量放的地方&lt;/li&gt;
&lt;li&gt;saved registers&lt;/li&gt;
&lt;li&gt;outgoing arguments: 存储当前函数要传递给别的函数的参数&lt;/li&gt;
&lt;li&gt;stack pointer: 栈指针，从低向高&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;函数调用流程：&#34;&gt;&lt;a href=&#34;#函数调用流程：&#34; class=&#34;headerlink&#34; title=&#34;函数调用流程：&#34;&gt;&lt;/a&gt;函数调用流程：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;g调用f的时候&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;进入f的时候，保存旧的FP(g的FP)&lt;/li&gt;
&lt;li&gt;把FP设置为原来的SP，把SP &amp;#x3D; SP - frame size&lt;br&gt;&lt;img data-src=&#34;/f2.jpg&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;f返回的时候&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;让SP &amp;#x3D; FP(恢复g的SP)&lt;/li&gt;
&lt;li&gt;从内存中读出g的FP恢复回去&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果栈帧大小固定就只需要FP不需要SP了，因为FP &amp;#x3D; SP + frame size&lt;/p&gt;
&lt;h2 id=&#34;saved-register&#34;&gt;&lt;a href=&#34;#saved-register&#34; class=&#34;headerlink&#34; title=&#34;saved register&#34;&gt;&lt;/a&gt;saved register&lt;/h2&gt;&lt;p&gt;函数g调用f的时候，用到了寄存器r，调用f的时候要把r保存在saved register中，等调用结束再恢复回去&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;caller-saved register: 函数调用的时候用到的寄存器，调用结束后可以恢复&lt;/li&gt;
&lt;li&gt;callee-saved register: 函数调用的时候用不到的寄存器，调用结束后不能恢复&lt;br&gt;&amp;#x3D;&amp;#x3D;FP是由callee保存和恢复的&amp;#x3D;&amp;#x3D;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参数传递&#34;&gt;&lt;a href=&#34;#参数传递&#34; class=&#34;headerlink&#34; title=&#34;参数传递&#34;&gt;&lt;/a&gt;参数传递&lt;/h2&gt;&lt;p&gt;一般约定把前k(4 or 6)个参数放在寄存器传递，剩下的参数放在栈中传递&lt;br&gt;四种传参方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不给叶过程 (leaf procedure) 分配栈帧&lt;br&gt;叶过程是指不调用其他过程的过程。在这种情况下，可以不为叶过程分配栈帧&lt;/li&gt;
&lt;li&gt;过程间寄存器分配 (interprocedural register allocation)&lt;br&gt;这种方法需要先分析代码中全部的函数，然后再根据分析结果来分配寄存器。&lt;br&gt;假设有一个程序包含多个函数，通过全局分析发现某些变量在多个函数之间频繁使用，可以为其分配固定的寄存器，避免频繁的内存读写&lt;/li&gt;
&lt;li&gt;若变量 x 不再被使用，可以直接写其寄存器，不需要再保存 x 到栈帧中&lt;br&gt;当一个变量在当前作用域内不再被使用时，可以直接将其值写入寄存器，而无需保存到栈帧中&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;example&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;exampleFunction&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; x = &lt;span class=&#34;number&#34;&gt;5&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; y = x * &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;;  &lt;span class=&#34;comment&#34;&gt;// 使用x后，x不再被使用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 直接将y的值写入寄存器，无需保存x到栈帧中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;Result: %d\n&amp;quot;&lt;/span&gt;, y);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;寄存器窗口技术 (register windows)&lt;br&gt;在每次函数调用时，系统会自动切换到一组新的寄存器，称为寄存器窗口。这样，每个函数都可以独立地使用自己的寄存器，而不会影响其他函数的寄存器状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;example&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;functionA&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 使用寄存器窗口A&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;functionB&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 使用寄存器窗口B&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    functionA();  &lt;span class=&#34;comment&#34;&gt;// 调用functionA时，自动切换到寄存器窗口A&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&#34;Frame-Resident-Variables&#34;&gt;&lt;a href=&#34;#Frame-Resident-Variables&#34; class=&#34;headerlink&#34; title=&#34;Frame-Resident Variables&#34;&gt;&lt;/a&gt;Frame-Resident Variables&lt;/h2&gt;&lt;p&gt;什么情况下要把变量写入栈帧里面？、&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;the varibles will be passed by reference 变量传地址&amp;#x2F;引用&lt;/li&gt;
&lt;li&gt;变量被嵌套在函数内部的函数访问（不绝对）&lt;/li&gt;
&lt;li&gt;变量太大了没法直接放寄存器&lt;/li&gt;
&lt;li&gt;变量是一个数组&lt;/li&gt;
&lt;li&gt;传递参数&lt;/li&gt;
&lt;li&gt;有太多局部变量和临时变量放不下了&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;escape 逃逸：如果一个变量需要传地址&amp;#x2F;取地址&amp;#x2F;被过程内部嵌套的函数访问，那么这个变量就会逃逸。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;static-links&#34;&gt;&lt;a href=&#34;#static-links&#34; class=&#34;headerlink&#34; title=&#34;static links&#34;&gt;&lt;/a&gt;static links&lt;/h2&gt;&lt;p&gt;在嵌套的函数声明中，内层函数是有可能用到外层函数的局部变量的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;static links是指向上一层嵌套层级的栈帧的指针。内层嵌套函数调用外层定义的变量的时候需要用到static links，否则无法寻址。&lt;br&gt;&lt;img data-src=&#34;/f3.jpg&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/f4.jpg&#34;&gt;&lt;br&gt;只有调用自身的时候才传递自己的static link作为static link，其他的都是把外层函数的fp作为static link&lt;br&gt;如果要访问外层变量，就顺着static一层一层查上去直到找到了为止。&lt;br&gt;其他访问方法：&lt;/li&gt;
&lt;li&gt;嵌套层次显示表(display)&lt;br&gt;建立一个全局数组，位置i包含一个指针，指向最近一次进入的，其静态嵌套深度是i的过程的栈帧&lt;br&gt;&lt;img data-src=&#34;/f5.jpg&#34;&gt;&lt;br&gt;先给它们标上嵌套深度&lt;br&gt;直接把链表变成数组了，需要用到一个变量，就查看当前变量的嵌套深度i然后直接找那个数组i位置的座位fp地址来找&lt;/li&gt;
&lt;li&gt;lambda lifting&lt;br&gt;g调用f时，g中每一个实际（或被嵌套在f内的任意函数）访问了的变量，都将作为额外的参数传递给f&lt;br&gt;把内部的函数，从内往外进行改写，改写函数的参数实现lambda lifting&lt;br&gt;&lt;img data-src=&#34;/f6.jpg&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tiger编译器的栈帧&#34;&gt;&lt;a href=&#34;#tiger编译器的栈帧&#34; class=&#34;headerlink&#34; title=&#34;tiger编译器的栈帧&#34;&gt;&lt;/a&gt;tiger编译器的栈帧&lt;/h2&gt;&lt;p&gt;tiger不支持高阶函数&lt;br&gt;看不完了。。再说吧&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/03/30/computer-science/compile-principles/ch5/</guid>
            <title>语义分析</title>
            <link>http://example.com/2025/03/30/computer-science/compile-principles/ch5/</link>
            <category>语义分析</category>
            <pubDate>Sun, 30 Mar 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;语义分析&#34;&gt;&lt;a href=&#34;#语义分析&#34; class=&#34;headerlink&#34; title=&#34;语义分析&#34;&gt;&lt;/a&gt;语义分析&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;绑定，类型检查&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;symbol-table&#34;&gt;&lt;a href=&#34;#symbol-table&#34; class=&#34;headerlink&#34; title=&#34;symbol table&#34;&gt;&lt;/a&gt;symbol table&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Imperative style: 命令式风格&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Modify $\sigma_1$ until it becomes $\sigma_2$. &lt;/li&gt;
&lt;li&gt;While $\sigma_2$ exists, we cannot look things up in $\sigma_1$. &lt;/li&gt;
&lt;li&gt;When done with $\sigma_2$, can undo the modification to get $\sigma_1$ back again.&lt;br&gt;+++info 方法：&lt;br&gt;Hashing&lt;br&gt;插入：找到哈希值然后插入链表的表头&lt;br&gt;查找：找到哈希值然后遍历链表&lt;br&gt;pop: 找到哈希值然后把链表表头删掉  table[hash(key)] &amp;#x3D; table[hash(key)].next&lt;br&gt;+++&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Functional style: 函数式风格&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;To keep $\sigma_1$ in pristine condition while creating create $\sigma_2$ and $\sigma_3$&lt;br&gt;+++info 方法：&lt;br&gt;如果依旧用哈希，每次要复制一遍哈希表，开销太大了，不现实&lt;br&gt;&lt;img data-src=&#34;/f2.jpg&#34;&gt;&lt;br&gt;所以用persistent BST&lt;br&gt;&lt;img data-src=&#34;/f1.jpg&#34;&gt;&lt;br&gt;先遍历二叉搜索树找到要插入的位置，然后对于插入节点把它从根节点到它全都复制一遍然后插入&lt;br&gt;+++&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Tiger编译器中的符号&#34;&gt;&lt;a href=&#34;#Tiger编译器中的符号&#34; class=&#34;headerlink&#34; title=&#34;Tiger编译器中的符号&#34;&gt;&lt;/a&gt;Tiger编译器中的符号&lt;/h2&gt;&lt;p&gt;对链表进行lookup的时候每一次都要进行string compare，开销是很大的。所以使用新的数据结构将符号对象关联到一个整数上，因此对于任意给定字符串的所有不同出现，都会被转换成同一个符号对象。&lt;br&gt;Symbol的实现：通过hash函数将字符串映射到一个symbol对象上&lt;br&gt;SymbolTable的实现：beginScope()和endScope()的实现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;beginScope()：添加一个marksym&lt;/li&gt;
&lt;li&gt;endScope()：从符号表中不断pop直到marksym&lt;/li&gt;
&lt;li&gt;引入一个 辅助栈(Auxiliary stack) 来维护&lt;ul&gt;
&lt;li&gt;符号入栈时，会将binding联动地插入对应bucket的链表头&lt;/li&gt;
&lt;li&gt;弹出栈顶符号时，对应bucket的链表头也会联动地被移除&lt;/li&gt;
&lt;li&gt;beginScope: 压入一个特殊标记到辅助栈中&lt;/li&gt;
&lt;li&gt;endScope: 一直弹出符号直到弹出了一个特殊标记&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;类型检查&#34;&gt;&lt;a href=&#34;#类型检查&#34; class=&#34;headerlink&#34; title=&#34;类型检查&#34;&gt;&lt;/a&gt;类型检查&lt;/h2&gt;&lt;h3 id=&#34;哪些类型表达式是合法-非法的&#34;&gt;&lt;a href=&#34;#哪些类型表达式是合法-非法的&#34; class=&#34;headerlink&#34; title=&#34;哪些类型表达式是合法&amp;#x2F;非法的&#34;&gt;&lt;/a&gt;哪些类型表达式是合法&amp;#x2F;非法的&lt;/h3&gt;&lt;p&gt;Tiger的类型系统：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两种primitive type: int, string&lt;/li&gt;
&lt;li&gt;两种constructed type: records, arrays&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;typec → type type-id &amp;#x3D; ty&lt;ul&gt;
&lt;li&gt;这表示定义一个类型。&lt;code&gt;typec&lt;/code&gt; 是一个类型定义的开始，它由关键字 &lt;code&gt;type&lt;/code&gt;、一个类型标识符 &lt;code&gt;type-id&lt;/code&gt; 和一个等号 &lt;code&gt;=&lt;/code&gt; 后跟类型定义 &lt;code&gt;ty&lt;/code&gt; 组成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ty → type-id&lt;ul&gt;
&lt;li&gt;这表示类型 &lt;code&gt;ty&lt;/code&gt; 可以直接是一个已定义的类型标识符 &lt;code&gt;type-id&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ty → ‘{’ tyfields ‘}’&lt;ul&gt;
&lt;li&gt;这表示类型 &lt;code&gt;ty&lt;/code&gt; 可以是一个记录（record），由花括号 &lt;code&gt;&amp;#123;&amp;#125;&lt;/code&gt; 包围的一系列字段 &lt;code&gt;tyfields&lt;/code&gt; 定义。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ty → array of type-id&lt;ul&gt;
&lt;li&gt;这表示类型 &lt;code&gt;ty&lt;/code&gt; 可以是一个数组，由关键字 &lt;code&gt;array of&lt;/code&gt; 后跟一个类型标识符 &lt;code&gt;type-id&lt;/code&gt; 定义。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;tyfields → ε&lt;ul&gt;
&lt;li&gt;这表示字段列表 &lt;code&gt;tyfields&lt;/code&gt; 可以为空（ε 表示空串）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;tyfields → id: type-id {, id:type-id}&lt;ul&gt;
&lt;li&gt;这表示字段列表 &lt;code&gt;tyfields&lt;/code&gt; 由一个或多个字段组成，每个字段由一个标识符 &lt;code&gt;id&lt;/code&gt; 和冒号 &lt;code&gt;:&lt;/code&gt; 后跟一个类型标识符 &lt;code&gt;type-id&lt;/code&gt; 定义，多个字段之间用逗号 &lt;code&gt;,&lt;/code&gt; 分隔。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;let type a = &amp;#123;x: int; y: int&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    type b = a&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    var i : a := ...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    var j : b := ...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;in i := j&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;


&lt;h3 id=&#34;类型等价&#34;&gt;&lt;a href=&#34;#类型等价&#34; class=&#34;headerlink&#34; title=&#34;类型等价&#34;&gt;&lt;/a&gt;类型等价&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Name equivalence (NE): 必须声明是同一个类型才是同一类型&lt;/li&gt;
&lt;li&gt;Structure equivalence (SE): 如果两个类型的结构完全相同（即它们由相同的构造器以相同的顺序组成），那么它们就被认为是等价的，即使它们的名字不同&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;type A = &amp;#123;x: int; y: int&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;type B = &amp;#123;x: int; y: int&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Tiger用的是NE&lt;br&gt;在Tiger编程语言中，存在两个独立的命名空间：一个用于类型（Types），另一个用于函数和变量（Functions and Variables）。所以类型和函数&amp;#x2F;变量可以存在相同的名字，但是函数和变量不能存在相同的名字。&lt;br&gt;所以需要两个env&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Type env&lt;ul&gt;
&lt;li&gt;symbol -&amp;gt; Ty_ty&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Value env&lt;ul&gt;
&lt;li&gt;对于变量，symbol -&amp;gt; Ty_ty&lt;/li&gt;
&lt;li&gt;对于函数，symbol -&amp;gt; struct{Ty_tyList formals, Ty_ty results}&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;类型检查的rule&#34;&gt;&lt;a href=&#34;#类型检查的rule&#34; class=&#34;headerlink&#34; title=&#34;类型检查的rule&#34;&gt;&lt;/a&gt;类型检查的rule&lt;/h3&gt;&lt;p&gt;类型检查分为两部分:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Type-checking expressions: 对于每个表达式，根据当前的Type和Value环境来确定其类型，并检查是否符合语言的类型规则&lt;/li&gt;
&lt;li&gt;Type-checking declarations: 在Tiger语言中声明只可能在let语句中出现&lt;br&gt;好像就是讲了transExp, transDec, transVar，AST递归检查每个节点的类型然后一层一层往上传再检查&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/03/29/computer-science/compile-principles/ch4/</guid>
            <title>抽象语法</title>
            <link>http://example.com/2025/03/29/computer-science/compile-principles/ch4/</link>
            <category>抽象语法</category>
            <pubDate>Sat, 29 Mar 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[  ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/03/23/computer-science/compile-principles/ch3/</guid>
            <title>语法分析</title>
            <link>http://example.com/2025/03/23/computer-science/compile-principles/ch3/</link>
            <category>语法分析</category>
            <pubDate>Sun, 23 Mar 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;语法分析&#34;&gt;&lt;a href=&#34;#语法分析&#34; class=&#34;headerlink&#34; title=&#34;语法分析&#34;&gt;&lt;/a&gt;语法分析&lt;/h1&gt;&lt;h2 id=&#34;CFG&#34;&gt;&lt;a href=&#34;#CFG&#34; class=&#34;headerlink&#34; title=&#34;CFG&#34;&gt;&lt;/a&gt;CFG&lt;/h2&gt;&lt;p&gt;见计算理论&lt;br&gt;Parse tree&lt;/p&gt;
&lt;h3 id=&#34;Ambiguous-grammars&#34;&gt;&lt;a href=&#34;#Ambiguous-grammars&#34; class=&#34;headerlink&#34; title=&#34;Ambiguous grammars&#34;&gt;&lt;/a&gt;Ambiguous grammars&lt;/h3&gt;&lt;h2 id&gt;&lt;a href=&#34;#&#34; class=&#34;headerlink&#34; title&gt;&lt;/a&gt;&lt;/h2&gt; ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/03/22/computer-science/compile-principles/ch2/</guid>
            <title>词法分析</title>
            <link>http://example.com/2025/03/22/computer-science/compile-principles/ch2/</link>
            <category>词法分析</category>
            <pubDate>Sat, 22 Mar 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Ch2-词法分析&#34;&gt;&lt;a href=&#34;#Ch2-词法分析&#34; class=&#34;headerlink&#34; title=&#34;Ch2 词法分析&#34;&gt;&lt;/a&gt;Ch2 词法分析&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;把input分解成一个个token&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;Regular-Expression&#34;&gt;&lt;a href=&#34;#Regular-Expression&#34; class=&#34;headerlink&#34; title=&#34;Regular Expression&#34;&gt;&lt;/a&gt;Regular Expression&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Language: a set of strings&lt;/li&gt;
&lt;li&gt;String: a finite sequence of characters&lt;blockquote&gt;
&lt;p&gt;Regular Experssion Notations:&lt;br&gt;&lt;img data-src=&#34;/image-1.png&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;:::info&lt;br&gt;DFA, NFA相关 见计算理论&lt;br&gt;:::&lt;/p&gt;
&lt;h2 id=&#34;RE转NFA&#34;&gt;&lt;a href=&#34;#RE转NFA&#34; class=&#34;headerlink&#34; title=&#34;RE转NFA&#34;&gt;&lt;/a&gt;RE转NFA&lt;/h2&gt;&lt;p&gt;:::info 方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;画出初始态和终态&lt;/li&gt;
&lt;li&gt;分裂规则：&lt;br&gt;&lt;img data-src=&#34;/image-2.jpg&#34;&gt;&lt;br&gt;:::&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;NFA转DFA&#34;&gt;&lt;a href=&#34;#NFA转DFA&#34; class=&#34;headerlink&#34; title=&#34;NFA转DFA&#34;&gt;&lt;/a&gt;NFA转DFA&lt;/h2&gt;&lt;p&gt;从初始状态的闭包开始，每次根据\epsilon和当前状态的闭包，得到下一个状态的闭包，直到得到终态的闭包。&lt;/p&gt;
&lt;p&gt;+++info example&lt;br&gt;;;;id3 题目&lt;br&gt;:chestnut:&lt;br&gt;把这个NFA转成等价的DFA&lt;br&gt;&lt;img data-src=&#34;/image-3.png&#34;&gt;&lt;br&gt;;;;&lt;br&gt;;;;id3 答案&lt;br&gt;初态的闭包是1、2、6，1、2、6经过a可以转移到3、7，因为有\epsilon转移，所以3、7的闭包是3、4、7、8，同理3、4、7、8经过b可以到5、8，由于8是终态，把所有包含8的圆圈画成终态的环。&lt;br&gt;&lt;img data-src=&#34;/image-4.png&#34;&gt;&lt;br&gt;;;;&lt;br&gt;+++&lt;/p&gt;
&lt;h2 id=&#34;最小化DFA&#34;&gt;&lt;a href=&#34;#最小化DFA&#34; class=&#34;headerlink&#34; title=&#34;最小化DFA&#34;&gt;&lt;/a&gt;最小化DFA&lt;/h2&gt;&lt;p&gt;含义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;没有多余状态：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;从这个状态没有通路到达终态&lt;/li&gt;
&lt;li&gt;从开始状态出发，任何输入串也不能到达的那个状态&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;没有两个状态相互等价&lt;br&gt;:::info 方法：&lt;/li&gt;
&lt;li&gt;多余状态直接删除&lt;br&gt;&lt;img data-src=&#34;/image-5.png&#34;&gt;&lt;/li&gt;
&lt;li&gt;合并等价状态&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;将状态分为终态和非终态两个集合&lt;/li&gt;
&lt;li&gt;遍历每个集合，如果经过转换到达的状态都在当前集合里，则不用分，否则划分子集，直到划分不了为止&lt;/li&gt;
&lt;li&gt;:chestnut: 例子&lt;/li&gt;
&lt;li&gt;&lt;img data-src=&#34;/image-6.png&#34;&gt;&lt;br&gt;:::&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/03/21/computer-science/compile-principles/ch1/</guid>
            <title>Introduction</title>
            <link>http://example.com/2025/03/21/computer-science/compile-principles/ch1/</link>
            <category>编译原理</category>
            <pubDate>Fri, 21 Mar 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;blockquote&gt;
&lt;p&gt;ZJU 2025春夏编译原理 学习笔记&lt;/p&gt;
&lt;p&gt;主要基于虎书（&lt;em&gt;Modern Compiler Implementation in C&lt;/em&gt;, Andrew W. Appel）和好多老师的ppt（ldm, yps），还有lzx的智云&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;CH1-Introduction&#34;&gt;&lt;a href=&#34;#CH1-Introduction&#34; class=&#34;headerlink&#34; title=&#34;CH1 Introduction&#34;&gt;&lt;/a&gt;CH1 Introduction&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Two Important Concepts&lt;ul&gt;
&lt;li&gt;Phases（阶段）&lt;/li&gt;
&lt;li&gt;Interfaces（接口）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方框里的是phase，中间的是interface&lt;br&gt;&lt;img data-src=&#34;/image.png&#34;&gt;&lt;br&gt;各个阶段的描述&lt;br&gt;&lt;img data-src=&#34;/image-1.png&#34;&gt;&lt;img data-src=&#34;/image-2.png&#34;&gt;&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
