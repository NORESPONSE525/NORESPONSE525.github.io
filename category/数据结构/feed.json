{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog • All posts by \"数据结构\" category",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/10/05/computer-science/DS/ch4/",
            "url": "http://example.com/2025/10/05/computer-science/DS/ch4/",
            "title": "ch4",
            "date_published": "2025-10-04T16:00:00.000Z",
            "content_html": "<h1 id=\"ch4\"><a class=\"markdownIt-Anchor\" href=\"#ch4\">#</a> Ch4</h1>\n<h2 id=\"模式匹配\"><a class=\"markdownIt-Anchor\" href=\"#模式匹配\">#</a> 模式匹配</h2>\n<p>i: 主串当前待比较的字符位置<br>\n j: 模式串当前待比较的字符位置</p>\n<p>字符串模式匹配，在主串中找到与模式串相同的子串</p>\n<h3 id=\"暴力算法\"><a class=\"markdownIt-Anchor\" href=\"#暴力算法\">#</a> 暴力算法</h3>\n<p>遍历主串，从每个和第一个字符相同的位置开始，继续比较后继字符<br>\n时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(mn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>（主串长度 n，模式串长度 m）</p>\n<h3 id=\"kmp算法\"><a class=\"markdownIt-Anchor\" href=\"#kmp算法\">#</a> KMP 算法</h3>\n<p>前缀：除了最后一个字符外所有的头部子串<br>\n后缀：除了第一个字符外所有的尾部子串</p>\n<ul>\n<li>PM 数组<br>\n方法：算出所有前缀的前缀和后缀的最长公共子串，并保存在数组中（PM，部分匹配值）<br>\n从头开始，右滑位数 = 已匹配的字符数 - 对应的部分匹配值（最后一个匹配的字符的 PM）<br>\n<mark>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(m+n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></mark></li>\n<li>next 数组</li>\n</ul>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>P</mi><mi>M</mi><mo stretchy=\"false\">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">next[j] = PM[j-1] + 1 \n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span></span></p>\n<p>将模式串的 PM 表右移一位并整体 + 1，左边空缺用 0 来填充，右边溢出舍去</p>\n<div class=\"note info\">\n<p>在上面方法中，串的编号是从 1 开始的</p>\n</div>\n<p>当模式串在位置 j 与主串不匹配时，模式串应该向右滑动的位数 = j - next [j-1]</p>\n",
            "tags": [
                "串"
            ]
        },
        {
            "id": "http://example.com/2025/10/04/computer-science/DS/ch3/",
            "url": "http://example.com/2025/10/04/computer-science/DS/ch3/",
            "title": "ch3",
            "date_published": "2025-10-03T16:00:00.000Z",
            "content_html": "<h1 id=\"ch3\"><a class=\"markdownIt-Anchor\" href=\"#ch3\">#</a> Ch3</h1>\n<h2 id=\"栈\"><a class=\"markdownIt-Anchor\" href=\"#栈\">#</a> 栈</h2>\n<p>LIFO</p>\n<h3 id=\"顺序栈的实现\"><a class=\"markdownIt-Anchor\" href=\"#顺序栈的实现\">#</a> 顺序栈的实现</h3>\n<figure class=\"highlight c++\"><figcaption><span>定义</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 50</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    ElemType data[MaxSize];</span><br><span class=\"line\">    <span class=\"type\">int</span> top;</span><br><span class=\"line\">&#125;SqStack;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>初始化</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">InitStack</span><span class=\"params\">(SqStack &amp;S)</span></span>&#123;</span><br><span class=\"line\">    S.top = <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>判断空</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">StackEmpty</span><span class=\"params\">(SqStack S)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(S.top == <span class=\"number\">-1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>push</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Push</span><span class=\"params\">(SqStack &amp;S,ElemType x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(S.top == MaxSize - <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    S.data[++S.top] = x;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>pop</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Pop</span><span class=\"params\">(SqStack &amp;S,ElemType &amp;x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(S.top == <span class=\"number\">-1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    x = S.data[S.top--];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>gettop</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">GetTop</span><span class=\"params\">(SqStack S,ElemType &amp;x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(S.top == <span class=\"number\">-1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    x = S.data[S.top];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"共享栈\"><a class=\"markdownIt-Anchor\" href=\"#共享栈\">#</a> 共享栈</h3>\n<p>同时从两边向中间压栈</p>\n<h3 id=\"链栈\"><a class=\"markdownIt-Anchor\" href=\"#链栈\">#</a> 链栈</h3>\n<figure class=\"highlight c++\"><figcaption><span>定义</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">Linknode</span>&#123;</span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">Linknode</span> *next;</span><br><span class=\"line\">&#125;LiStack;</span><br></pre></td></tr></table></figure>\n<h2 id=\"队列\"><a class=\"markdownIt-Anchor\" href=\"#队列\">#</a> 队列</h2>\n<p>FIFO</p>\n<h3 id=\"顺序存储\"><a class=\"markdownIt-Anchor\" href=\"#顺序存储\">#</a> 顺序存储</h3>\n<figure class=\"highlight c++\"><figcaption><span>队列的实现</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 50</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    ElemType data[MaxSize];</span><br><span class=\"line\">    <span class=\"type\">int</span> front,rear;</span><br><span class=\"line\">&#125;SqQueue;</span><br></pre></td></tr></table></figure>\n<p>初始状态：front = rear = 0</p>\n<figure class=\"highlight c++\"><figcaption><span>队列判空</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">QueueEmpty</span><span class=\"params\">(SqQueue Q)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.front == Q.rear)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"循环队列\"><a class=\"markdownIt-Anchor\" href=\"#循环队列\">#</a> 循环队列</h4>\n<figure class=\"highlight c++\"><figcaption><span>初始化</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">InitQueue</span><span class=\"params\">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class=\"line\">    Q.front = Q.rear = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>队列判空</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">QueueEmpty</span><span class=\"params\">(SqQueue Q)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.front == Q.rear)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>队列判满</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">QueueFull</span><span class=\"params\">(SqQueue Q)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((Q.rear + <span class=\"number\">1</span>) % MaxSize == Q.front)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>入队</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">EnQueue</span><span class=\"params\">(SqQueue &amp;Q,ElemType x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">QueueFull</span>(Q))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    Q.data[Q.rear] = x;</span><br><span class=\"line\">    Q.rear = (Q.rear + <span class=\"number\">1</span>) % MaxSize;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>出队</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">DeQueue</span><span class=\"params\">(SqQueue &amp;Q,ElemType &amp;x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">QueueEmpty</span>(Q))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    x = Q.data[Q.front];</span><br><span class=\"line\">    Q.front = (Q.front + <span class=\"number\">1</span>) % MaxSize;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>求元素个数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">QueueLength</span><span class=\"params\">(SqQueue Q)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (Q.rear - Q.front + MaxSize) % MaxSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"链式存储\"><a class=\"markdownIt-Anchor\" href=\"#链式存储\">#</a> 链式存储</h3>\n<figure class=\"highlight c++\"><figcaption><span>链队列的实现</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">Linknode</span>&#123;</span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">Linknode</span> *next;</span><br><span class=\"line\">&#125;LinkNode;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    LinkNode *front,*rear;</span><br><span class=\"line\">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>\n<p>一般设计成带头结点的链队列</p>\n<figure class=\"highlight c\"><figcaption><span>初始化</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitQueue</span><span class=\"params\">(LinkQueue &amp;Q)</span>&#123;</span><br><span class=\"line\">    Q.front = Q.rear = (LinkNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LinkNode));</span><br><span class=\"line\">    Q.front-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><figcaption><span>队列判空</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">QueueEmpty</span><span class=\"params\">(LinkQueue Q)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.front == Q.rear)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><figcaption><span>入队</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">EnQueue</span><span class=\"params\">(LinkQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class=\"line\">    LinkNode *s = (LinkNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LinkNode));</span><br><span class=\"line\">    s-&gt;data = x;</span><br><span class=\"line\">    s-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    Q.rear-&gt;next = s;</span><br><span class=\"line\">    Q.rear = s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><figcaption><span>出队</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">DeQueue</span><span class=\"params\">(LinkQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.front == Q.rear)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    LinkNode *p = Q.front-&gt;next;</span><br><span class=\"line\">    x = p-&gt;data;</span><br><span class=\"line\">    Q.front-&gt;next = p-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.rear == p)</span><br><span class=\"line\">        Q.rear = Q.front;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"双端队列\"><a class=\"markdownIt-Anchor\" href=\"#双端队列\">#</a> 双端队列</h3>\n<ul>\n<li>输出受限的双端队列<br>\n允许在一端进行 push/pop 操作，另一端只能 push</li>\n<li>输入受限的双端队列<br>\n允许在一端进行 push/pop 操作，另一端只能 pop</li>\n</ul>\n<h2 id=\"栈和队列的应用\"><a class=\"markdownIt-Anchor\" href=\"#栈和队列的应用\">#</a> 栈和队列的应用</h2>\n<h3 id=\"栈-2\"><a class=\"markdownIt-Anchor\" href=\"#栈-2\">#</a> 栈</h3>\n<h4 id=\"表达式\"><a class=\"markdownIt-Anchor\" href=\"#表达式\">#</a> 表达式</h4>\n<ul>\n<li>括号匹配<br>\n左括号压栈，右括号出栈，判断是否匹配</li>\n<li>算术表达式<br>\n中缀表达式：左根右<br>\n前缀表达式：根左右<br>\n后缀表达式：左右根</li>\n</ul>\n<blockquote>\n<p>中缀转后缀</p>\n<ol>\n<li>加括号</li>\n<li>把运算符移到当前层的括号后面</li>\n<li>去掉括号<br>\n<strong>用栈实现中缀转后缀：</strong></li>\n</ol>\n</blockquote>\n<ol>\n<li>遇到操作数直接加入后缀表达式</li>\n<li>遇到括号，左括号入栈，右括号依次出栈加入后缀表达式直到遇到左括号位置，并删除左括号</li>\n<li>遇到运算符，判断优先级，如果栈为空或者栈顶为 “（” 或者栈顶运算符优先级低于当前运算符，则入栈，否则依次出栈加入后缀表达式，直到栈为空或者栈顶运算符优先级低于当前运算符（优先级相同的也要出栈），最后将当前运算符入栈<br>\n<mark>所以栈里面只存运算符和括号</mark></li>\n</ol>\n<blockquote>\n<p>后缀表达式求值<br>\n从左到右扫描表达式，遇到操作数压栈，遇到操作符就弹出两个操作数，计算结果压入栈中</p>\n</blockquote>\n<h4 id=\"递归\"><a class=\"markdownIt-Anchor\" href=\"#递归\">#</a> 递归</h4>\n<h3 id=\"队列-2\"><a class=\"markdownIt-Anchor\" href=\"#队列-2\">#</a> 队列</h3>\n<h4 id=\"层次遍历\"><a class=\"markdownIt-Anchor\" href=\"#层次遍历\">#</a> 层次遍历</h4>\n<p>根左右入队，依次 pop</p>\n<h4 id=\"队列的应用\"><a class=\"markdownIt-Anchor\" href=\"#队列的应用\">#</a> 队列的应用</h4>\n<ul>\n<li>缓冲区</li>\n<li>操作系统的请求队列</li>\n</ul>\n<h2 id=\"数组\"><a class=\"markdownIt-Anchor\" href=\"#数组\">#</a> 数组</h2>\n<p>特殊矩阵的压缩存储</p>\n<ul>\n<li>对称矩阵<br>\n只存下三角的元素，存在一维数组里</li>\n<li>三角矩阵<br>\n省略 0，摊平存在一维数组</li>\n<li>三对角<br>\n同理省略 0，存在一维数组里</li>\n<li>稀疏矩阵<br>\n行标，列标，值都成三元组，存储在线性表（数组或者十字链表），保存的同时要保存系数矩阵的行数、列数和非零元素的个数</li>\n</ul>\n",
            "tags": [
                "栈、队列和数组"
            ]
        },
        {
            "id": "http://example.com/2025/09/15/computer-science/DS/ch1/",
            "url": "http://example.com/2025/09/15/computer-science/DS/ch1/",
            "title": "ch1",
            "date_published": "2025-09-14T16:00:00.000Z",
            "content_html": "<h1 id=\"ch1-绪论\"><a class=\"markdownIt-Anchor\" href=\"#ch1-绪论\">#</a> Ch1 绪论</h1>\n<p>数据<br>\n数据元素是数据的基本单位<br>\n数据对象<br>\n数据类型：原子类型、结构类型、抽象数据类型<br>\n数据结构：三要素包括逻辑结构、存储结构和数据的运算</p>\n<ul>\n<li>逻辑结构：集合、线性结构、树形结构、图状或网状</li>\n<li>存储结构：顺序存储、链式存储、索引存储、散列存储</li>\n<li>数据的运算：定义针对逻辑结构，实现针对存储结构</li>\n</ul>\n<p>算法的特性：又穷行、确定性、可行性、输入、输出<br>\n好的算法还应该考虑：正确性、可读性、健壮性、高效率和低存储量需求</p>\n<p>复杂度：时间复杂度、空间复杂度</p>\n",
            "tags": [
                "数据结构"
            ]
        },
        {
            "id": "http://example.com/2025/09/15/computer-science/DS/ch2/",
            "url": "http://example.com/2025/09/15/computer-science/DS/ch2/",
            "title": "ch2",
            "date_published": "2025-09-14T16:00:00.000Z",
            "content_html": "<h1 id=\"ch2-线性表\"><a class=\"markdownIt-Anchor\" href=\"#ch2-线性表\">#</a> Ch2 线性表</h1>\n<p>存储结构：顺序表（数组），链表</p>\n<h2 id=\"顺序表\"><a class=\"markdownIt-Anchor\" href=\"#顺序表\">#</a> 顺序表</h2>\n<p>逻辑顺序和物理顺序一致，都连续<br>\n按下标访问 O (1)，插入操作平均移动 n/2，删除操作平均移动 (n-1)/2</p>\n<figure class=\"highlight c\"><figcaption><span>静态分配</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 50</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    ElemType data[MaxSize];</span><br><span class=\"line\">    <span class=\"type\">int</span> length;</span><br><span class=\"line\">&#125;SqList;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><figcaption><span>动态分配</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> InitSize 100</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    ElemType *data;</span><br><span class=\"line\">    <span class=\"type\">int</span> MaxSize, length;</span><br><span class=\"line\">&#125;SqList;</span><br></pre></td></tr></table></figure>\n<p>初始动态分配：</p>\n<figure class=\"highlight c\"><figcaption><span>c</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L.data = (ElemType*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(ElemType)*InitSize);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>c++</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L.data = <span class=\"keyword\">new</span> ElemType[InitSize];</span><br></pre></td></tr></table></figure>\n<h3 id=\"初始化\"><a class=\"markdownIt-Anchor\" href=\"#初始化\">#</a> 初始化</h3>\n<figure class=\"highlight c++\"><figcaption><span>静态分配初始化</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">InitList</span><span class=\"params\">(SqList &amp;L)</span></span>&#123;</span><br><span class=\"line\">    L.length = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>动态分配初始化</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">InitList</span><span class=\"params\">(SqList &amp;L)</span></span>&#123;</span><br><span class=\"line\">    L.data = (ElemType*)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span>(ElemType)*InitSize);</span><br><span class=\"line\">    L.MaxSize = InitSize;</span><br><span class=\"line\">    L.length = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"插入操作\"><a class=\"markdownIt-Anchor\" href=\"#插入操作\">#</a> 插入操作</h3>\n<p>在顺序表的第 i 个 <code>位置</code> 插入元素 e，注意是位置不是下标 (1&lt;=i&lt;=L.length+1)</p>\n<figure class=\"highlight c++\"><figcaption><span>插入操作</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">ListInsert</span><span class=\"params\">(SqList &amp;L, <span class=\"type\">int</span> i, ElemType e)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i&lt;<span class=\"number\">1</span> || i&gt;L.length<span class=\"number\">+1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L.length &gt;= L.MaxSize) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"built_in\">fot</span>(<span class=\"type\">int</span> j = L.length; j&gt;=i; j--)</span><br><span class=\"line\">        L.data[j] = L.data[j<span class=\"number\">-1</span>];</span><br><span class=\"line\">    L.data[i<span class=\"number\">-1</span>] = e;</span><br><span class=\"line\">    L.length++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>插入移动的平均次数为 n/2，插入算法的平均时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></p>\n<h3 id=\"删除操作\"><a class=\"markdownIt-Anchor\" href=\"#删除操作\">#</a> 删除操作</h3>\n<p>删除顺序表中第 i 个元素，返回删除的元素 e</p>\n<figure class=\"highlight c++\"><figcaption><span>删除操作</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">ListDelete</span><span class=\"params\">(SqList &amp;L, <span class=\"type\">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i&lt;<span class=\"number\">1</span> || i&gt;L.length) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    e = L.data[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = i; j&lt;L.length; j++)</span><br><span class=\"line\">        L.data[j<span class=\"number\">-1</span>] = L.data[j];</span><br><span class=\"line\">    L.length--;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>删除操作的平均移动此时是 (n-1)/2，平均时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></p>\n<h3 id=\"按值查找\"><a class=\"markdownIt-Anchor\" href=\"#按值查找\">#</a> 按值查找</h3>\n<figure class=\"highlight c++\"><figcaption><span>按值查找</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">LocateElem</span><span class=\"params\">(SqList L, ElemType e)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i&lt;L.length; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(L.data[i] == e)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i<span class=\"number\">+1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>平均需要访问 (n+1)/2 个元素，平均时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></p>\n<h2 id=\"单链表\"><a class=\"markdownIt-Anchor\" href=\"#单链表\">#</a> 单链表</h2>\n<h3 id=\"链表结构\"><a class=\"markdownIt-Anchor\" href=\"#链表结构\">#</a> 链表结构</h3>\n<figure class=\"highlight c++\"><figcaption><span>单链表结构</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">LNode</span>&#123;</span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">LNode</span> *next;</span><br><span class=\"line\">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure>\n<h3 id=\"初始化-2\"><a class=\"markdownIt-Anchor\" href=\"#初始化-2\">#</a> 初始化</h3>\n<figure class=\"highlight c++\"><figcaption><span>带头节点的初始化</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">InitList</span><span class=\"params\">(LinkList &amp;L)</span></span>&#123;</span><br><span class=\"line\">    L = (LNode*)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span>(LNode));</span><br><span class=\"line\">    L-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>不带头节点的初始化</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">InitList</span><span class=\"params\">(LinkList &amp;L)</span></span>&#123;</span><br><span class=\"line\">    L = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"求表长\"><a class=\"markdownIt-Anchor\" href=\"#求表长\">#</a> 求表长</h3>\n<p>从头开始遍历，每访问一个节点，长度加 1</p>\n<figure class=\"highlight c++\"><figcaption><span>求表长</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Length</span><span class=\"params\">(LinkList L)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    LNode *p = L;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        len++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"按序号查找\"><a class=\"markdownIt-Anchor\" href=\"#按序号查找\">#</a> 按序号查找</h3>\n<p>从头开始遍历直到找到第 i 个节点</p>\n<figure class=\"highlight c++\"><figcaption><span>按序号查找</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LNode* <span class=\"title\">GetElem</span><span class=\"params\">(LinkList L, <span class=\"type\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    LNode *p = L;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span> &amp;&amp; j&lt;i)&#123;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        j++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"按值查找-2\"><a class=\"markdownIt-Anchor\" href=\"#按值查找-2\">#</a> 按值查找</h3>\n<p>从头开始遍历，如果找到则返回该节点</p>\n<figure class=\"highlight c++\"><figcaption><span>按值查找</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LNode* <span class=\"title\">LocateElem</span><span class=\"params\">(LinkList L, ElemType e)</span></span>&#123;</span><br><span class=\"line\">    LNode *p = L-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span> &amp;&amp; p-&gt;data != e)&#123;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"插入操作-2\"><a class=\"markdownIt-Anchor\" href=\"#插入操作-2\">#</a> 插入操作</h3>\n<p>先把后继连到新节点的后继，再把前继节点的后继连到新节点</p>\n<figure class=\"highlight c++\"><figcaption><span>插入操作</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">ListInsert</span><span class=\"params\">(LinkList &amp;L, <span class=\"type\">int</span> i, ElemType e)</span></span>&#123;</span><br><span class=\"line\">    LNode p = L;</span><br><span class=\"line\">    <span class=\"type\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span> &amp;&amp; j&lt;i<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        j++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    LNode *s = (LNode*)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span>(LNode));</span><br><span class=\"line\">    s-&gt;data = e;</span><br><span class=\"line\">    s-&gt;next = p-&gt;next;</span><br><span class=\"line\">    p-&gt;next = s;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除操作-2\"><a class=\"markdownIt-Anchor\" href=\"#删除操作-2\">#</a> 删除操作</h3>\n<p>先找到待删除节点的前一个节点，再把前一个节点的 next 指向待删除节点的 next，然后释放待删除节点</p>\n<figure class=\"highlight c++\"><figcaption><span>删除操作</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">ListDelete</span><span class=\"params\">(LinkList &amp;L, <span class=\"type\">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class=\"line\">    LNode *p = L;</span><br><span class=\"line\">    <span class=\"type\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span> &amp;&amp; j&lt;i<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        j++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p-&gt;next == <span class=\"literal\">NULL</span> || j&gt;i<span class=\"number\">-1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    LNode *q = p-&gt;next;</span><br><span class=\"line\">    e = q-&gt;data;</span><br><span class=\"line\">    p-&gt;next = q-&gt;next;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(q);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"采用头插法建立单链表\"><a class=\"markdownIt-Anchor\" href=\"#采用头插法建立单链表\">#</a> 采用头插法建立单链表</h3>\n<p>先建立一个头结点，每次插入到头结点之后<br>\n可以用来实现链表逆序，总时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></p>\n<figure class=\"highlight c++\"><figcaption><span>采用头插法建立单链表</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LinkLisk <span class=\"title\">List_HeadInsert</span><span class=\"params\">(LinkList &amp;L)</span></span>&#123;</span><br><span class=\"line\">    LNode *s;</span><br><span class=\"line\">    <span class=\"type\">int</span> x;</span><br><span class=\"line\">    L = (*LNode)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span>(LNode));</span><br><span class=\"line\">    L-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;x);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x != <span class=\"number\">9999</span>)&#123;</span><br><span class=\"line\">        s = (LNode*)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span>(LNode));</span><br><span class=\"line\">        s-&gt;data = x;</span><br><span class=\"line\">        s-&gt;next = L-&gt;next;</span><br><span class=\"line\">        L-&gt;next = s;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"采用尾插法建立单链表\"><a class=\"markdownIt-Anchor\" href=\"#采用尾插法建立单链表\">#</a> 采用尾插法建立单链表</h3>\n<figure class=\"highlight c++\"><figcaption><span>采用尾插法建立单链表</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LinkList <span class=\"title\">List_TailInsert</span><span class=\"params\">(LinkList &amp;L)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x;</span><br><span class=\"line\">    L = (LNode*)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span>(LNode));</span><br><span class=\"line\">    LNode *s, *r = L;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;x);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x != <span class=\"number\">9999</span>)&#123;</span><br><span class=\"line\">        s = (LNode*)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span>(LNode));</span><br><span class=\"line\">        s-&gt;data = x;</span><br><span class=\"line\">        r-&gt;next = s;</span><br><span class=\"line\">        r = s;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    r-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"双链表\"><a class=\"markdownIt-Anchor\" href=\"#双链表\">#</a> 双链表</h2>\n<h3 id=\"双链表结构\"><a class=\"markdownIt-Anchor\" href=\"#双链表结构\">#</a> 双链表结构</h3>\n<figure class=\"highlight c++\"><figcaption><span>双链表结构</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">DNode</span>&#123;</span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">DNode</span> *prior, *next;</span><br><span class=\"line\">&#125;DNode, *DLinkList;</span><br></pre></td></tr></table></figure>\n<h3 id=\"双链表的插入\"><a class=\"markdownIt-Anchor\" href=\"#双链表的插入\">#</a> 双链表的插入</h3>\n<figure class=\"highlight c++\"><figcaption><span>双链表的插入</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s-&gt;next = p-&gt;next;</span><br><span class=\"line\">p-&gt;next-&gt;prior = s;</span><br><span class=\"line\">s-&gt;prior = p;</span><br><span class=\"line\">p-&gt;next = s;</span><br></pre></td></tr></table></figure>\n<h3 id=\"双链表的删除\"><a class=\"markdownIt-Anchor\" href=\"#双链表的删除\">#</a> 双链表的删除</h3>\n<figure class=\"highlight c++\"><figcaption><span>双链表的删除</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p-&gt;next = q-&gt;next;</span><br><span class=\"line\">q-next-&gt;prior = p;</span><br><span class=\"line\"><span class=\"built_in\">free</span>(q);</span><br></pre></td></tr></table></figure>\n<h2 id=\"循环链表\"><a class=\"markdownIt-Anchor\" href=\"#循环链表\">#</a> 循环链表</h2>\n<h3 id=\"循环单链表\"><a class=\"markdownIt-Anchor\" href=\"#循环单链表\">#</a> 循环单链表</h3>\n<h3 id=\"循环双链表\"><a class=\"markdownIt-Anchor\" href=\"#循环双链表\">#</a> 循环双链表</h3>\n<h2 id=\"静态链表\"><a class=\"markdownIt-Anchor\" href=\"#静态链表\">#</a> 静态链表</h2>\n<p>用数组来表示线性表的链式存储结构</p>\n<figure class=\"highlight c++\"><figcaption><span>静态链表结构</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 50</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"type\">int</span> next;   <span class=\"comment\">//下一个元素的数组下标</span></span><br><span class=\"line\">&#125; SlinkList[MaxSize];</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>next = -1 表示结束标志</p>\n</blockquote>\n<h2 id=\"顺序表和链表比较\"><a class=\"markdownIt-Anchor\" href=\"#顺序表和链表比较\">#</a> 顺序表和链表比较</h2>\n<ol>\n<li>存取<br>\n顺序表可以顺序存取 / 随机存取，链表只能顺序</li>\n<li>逻辑结构和物理结构<br>\n顺序表和链表的逻辑结构相同，顺序表物理结构存储连续，链表物理结构存储不一定连续</li>\n<li>删改查的复杂度<br>\n略</li>\n<li>空间分配<br>\n链表的空间分配比较灵活，但存储密度低</li>\n</ol>\n<ul>\n<li>难以估计线性表的长度时不宜采用顺序表</li>\n<li>按序号访问多选顺序表，插入删除多选链表</li>\n</ul>\n",
            "tags": [
                "线性表"
            ]
        }
    ]
}