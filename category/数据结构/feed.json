{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog • All posts by \"数据结构\" category",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/10/13/computer-science/DS/ch7/",
            "url": "http://example.com/2025/10/13/computer-science/DS/ch7/",
            "title": "ch7",
            "date_published": "2025-10-12T16:00:00.000Z",
            "content_html": "<h1 id=\"ch7\"><a class=\"markdownIt-Anchor\" href=\"#ch7\">#</a> Ch7</h1>\n",
            "tags": [
                "查找"
            ]
        },
        {
            "id": "http://example.com/2025/10/13/computer-science/DS/ch8/",
            "url": "http://example.com/2025/10/13/computer-science/DS/ch8/",
            "title": "ch8",
            "date_published": "2025-10-12T16:00:00.000Z",
            "content_html": "<h1 id=\"ch8\"><a class=\"markdownIt-Anchor\" href=\"#ch8\">#</a> Ch8</h1>\n<h2 id=\"冒泡排序\"><a class=\"markdownIt-Anchor\" href=\"#冒泡排序\">#</a> 冒泡排序</h2>\n<p>直接看代码</p>\n<figure class=\"highlight c++\"><figcaption><span>bubbleSort</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(<span class=\"type\">int</span> a[], <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; n - i - <span class=\"number\">1</span>; j++) &#123;   <span class=\"comment\">// j从0开始到n-i-1，原因是每次遍历之后第i大的元素已经被放到后面了，从后往前的顺序是对的</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a[j] &gt; a[j + <span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                <span class=\"built_in\">swap</span>(a[j], a[j + <span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，空间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></p>\n<h2 id=\"选择排序\"><a class=\"markdownIt-Anchor\" href=\"#选择排序\">#</a> 选择排序</h2>\n<p>每次找最小的和循环的第一个元素交换</p>\n<figure class=\"highlight c++\"><figcaption><span>selectionSort</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">selectionSort</span><span class=\"params\">(<span class=\"type\">int</span> a[], <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0l</span> i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> min_index = i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = i; j &lt; n; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a[j] &lt; a[min_index])&#123;</span><br><span class=\"line\">                min_index = j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(a[i], a[min_index]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，空间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></p>\n<h2 id=\"插入排序\"><a class=\"markdownIt-Anchor\" href=\"#插入排序\">#</a> 插入排序</h2>\n<p>将列表分为已排序部分和未排序部分。初始时，已排序部分只包含第一个元素，未排序部分包含剩余元素，从未排序部分中取出第一个元素，插入已排序部分合适位置。</p>\n<figure class=\"highlight c++\"><figcaption><span>insertionSort</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insertionSort</span><span class=\"params\">(<span class=\"type\">int</span> a[], <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> j = i;</span><br><span class=\"line\">        <span class=\"type\">int</span> key = a[i];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j &gt; <span class=\"number\">0</span> &amp;&amp; key &lt; a[j - <span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">            a[j] = a[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        a[j] = key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，空间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></p>\n<h2 id=\"希尔排序\"><a class=\"markdownIt-Anchor\" href=\"#希尔排序\">#</a> 希尔排序</h2>\n<p>将待排序的列表分成若干子列表，对每个子列表进行插入排序，逐步缩小子列表的间隔，常见的增量序列有希尔增量（n/2, n/4, …, 1）</p>\n<figure class=\"highlight c++\"><figcaption><span>shellSort</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shellSort</span><span class=\"params\">(<span class=\"type\">int</span> a[], <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> gap = n / <span class=\"number\">2</span>; gap &gt; <span class=\"number\">0</span>; gap /= <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = gap; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> j = i; </span><br><span class=\"line\">            <span class=\"type\">int</span> key = a[i];</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(j &gt;= gap &amp;&amp; key &lt; a[j - gap])&#123;</span><br><span class=\"line\">                a[j] = a[j - gap];</span><br><span class=\"line\">                j -= gap;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            a[j] = key;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>best time complexity<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(nlog_n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, worst time complexity<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，空间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></p>\n<h2 id=\"归并排序\"><a class=\"markdownIt-Anchor\" href=\"#归并排序\">#</a> 归并排序</h2>\n<p>每次分成两半，像把两个有序链表合并成一个有序链表一样，将两个有序的子序列合并成一个有序的序列，然后递归处理每个子序列，直到处理完所有元素</p>\n<figure class=\"highlight c++\"><figcaption><span>mergeSort</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(<span class=\"type\">int</span> &amp;a[], <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(nlog_n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, 空间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></p>\n<h2 id=\"快速排序\"><a class=\"markdownIt-Anchor\" href=\"#快速排序\">#</a> 快速排序</h2>\n<p>从列表中选择一个元素作为基准（pivot）。选择方式可以是第一个元素、最后一个元素、中间元素或随机元素，使得所有小于基准元素的元素都在基准的左侧，所有大于基准元素的元素都在基准的右侧</p>\n<ol>\n<li>选择 pivot</li>\n<li>分割列表：把小于 pivot 的元素放在 pivot 的左侧，大于 pivot 的元素放在 pivot 的右侧，最终 pivot 的位置是正确的</li>\n<li>递归处理</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>quickSort</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(<span class=\"type\">int</span> a[], <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &gt;= right) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> pivot = a[(left + right) / <span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> i = left, j = right;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt;= j) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (a[i] &lt; pivot) i++;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (a[j] &gt; pivot) j--;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt;= j) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 交换</span></span><br><span class=\"line\">            <span class=\"type\">int</span> temp = a[i];</span><br><span class=\"line\">            a[i] = a[j];</span><br><span class=\"line\">            a[j] = temp;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">quickSort</span>(a, left, j);</span><br><span class=\"line\">    <span class=\"built_in\">quickSort</span>(a, i, right);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(nlog_n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, 空间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log_n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></p>\n<h2 id=\"堆排序\"><a class=\"markdownIt-Anchor\" href=\"#堆排序\">#</a> 堆排序</h2>\n<p>建立一个堆，让它自己排序（shift_down 和 shift_up）<br>\n最大堆用于升序排序，最小堆用于降序排序</p>\n<figure class=\"highlight c++\"><figcaption><span>heapSort</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">heapSort</span><span class=\"params\">(<span class=\"type\">int</span> a[], <span class=\"type\">int</span> n)</span> </span>&#123;&#125;    <span class=\"comment\">// 有待补充</span></span><br></pre></td></tr></table></figure>\n<p>时间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(nlog_n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, 空间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></p>\n<h2 id=\"桶排序\"><a class=\"markdownIt-Anchor\" href=\"#桶排序\">#</a> 桶排序</h2>\n<p>将数据分到若干个桶中，每个桶再进行排序，最后将各个桶的元素合并</p>\n<figure class=\"highlight c++\"><figcaption><span>bucketSort</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bucketSort</span><span class=\"params\">(<span class=\"type\">int</span> a[], <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n+k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span>, 空间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n+k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span></p>\n",
            "tags": [
                "排序"
            ]
        },
        {
            "id": "http://example.com/2025/10/11/computer-science/DS/ch6/",
            "url": "http://example.com/2025/10/11/computer-science/DS/ch6/",
            "title": "ch6",
            "date_published": "2025-10-10T16:00:00.000Z",
            "content_html": "<h1 id=\"ch6\"><a class=\"markdownIt-Anchor\" href=\"#ch6\">#</a> Ch6</h1>\n<h2 id=\"概念\"><a class=\"markdownIt-Anchor\" href=\"#概念\">#</a> 概念</h2>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>V</mi><mo separator=\"true\">,</mo><mi>E</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G = (V, E)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>图的顶点至少要有一个，边可以没有<br>\n顶点数：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>V</mi><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">|V|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\">∣</span></span></span></span><br>\n 边数：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>E</mi><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">|E|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord\">∣</span></span></span></span></p>\n<ul>\n<li>有向图、无向图</li>\n<li>简单图（不存在重复边、不存在到自身的边）、多重图</li>\n<li>度、入度、出度</li>\n</ul>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>T</mi><mi>D</mi><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>I</mi><mi>D</mi><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>O</mi><mi>D</mi><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">TD(v) = ID(v) + OD(v)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<ul>\n<li>有向图所有顶点的入度和出度之和相等，且等于边数</li>\n<li>路径、路径长度、回路</li>\n<li>简单路径、简单回路（顶点不重复出现）</li>\n<li>距离（从 u 到 v 的最短路径的长度，若不存在路径则为无穷大）</li>\n<li>子图：由某几个顶点和某几条边组成的图</li>\n<li>连通、连通图和连通分量<br>\n<mark>无向图中</mark>从 v 到 w 有路径存在，则 v 和 w 是连通的<br>\n若图中任意两个顶点都连通，则该图是 <code>连通图</code> ，否则是非连通图<br>\n无向图中的极大连通子图称为 <code>连通分量</code></li>\n</ul>\n<blockquote>\n<p>有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个顶点的连通图中，至少存在<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 条边（边数小于<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 一定是非连通图）<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个顶点的非连通图，最多有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">n-2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span> 条边</p>\n</blockquote>\n<ul>\n<li>强连通图、强连通分量<br>\n在<mark>有向图中</mark>，若有一对顶点 v 和 w，从 v 到 w 有路径，从 w 到 v 有路径，则 v 和 w 是强连通的<br>\n若图中任意两个顶点都强连通，则该图是 <code>强连通图</code> ，否则是非强连通图<br>\n有向图中的极大强连通子图称为 <code>强连通分量</code></li>\n</ul>\n<blockquote>\n<p>一个有向图有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个顶点，如果它是强连通图，则至少有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 条边（环路）</p>\n</blockquote>\n<ul>\n<li>生成树、生成森林<br>\n连通图的生成树是包含所有顶点的极小连通子图（若有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个顶点则生成树有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 条边）</li>\n</ul>\n<blockquote>\n<p>极大连通子图 vs 极小连通子图<br>\n极大连通子图要求连通且包含尽可能多的顶点和边，极小联通子图要求保持连通且边数最少</p>\n</blockquote>\n<ul>\n<li>边的权、网和带权路径长度<br>\n带权图中，边有权值。路径上所有边的权值之和称为带权路径长度</li>\n<li>完全图（也称简单完全图）<br>\n无向图，有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个顶点，有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">n(n-1)/2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mord\">/</span><span class=\"mord\">2</span></span></span></span> 条边的，称为完全（无向）图（顶点两两之间都有边）<br>\n有向图，有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个顶点，有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">n(n-1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 条边的，称为完全（有向）图</li>\n<li>稠密图、稀疏图<br>\n当<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>E</mi><mi mathvariant=\"normal\">∣</mi><mo>&lt;</mo><mi mathvariant=\"normal\">∣</mi><mi>V</mi><mi mathvariant=\"normal\">∣</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mrow><mi mathvariant=\"normal\">∣</mi><mi>v</mi><mi mathvariant=\"normal\">∣</mi></mrow></mrow><annotation encoding=\"application/x-tex\">|E| &lt; |V|log_2{|v|}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord\">∣</span></span></span></span></span> 时，可以视为稀疏图</li>\n<li>有向树<br>\n一个顶点入度为 0，其他顶点入度均为 1 的有向图，称为有向树</li>\n</ul>\n<h2 id=\"图的存储及基本操作\"><a class=\"markdownIt-Anchor\" href=\"#图的存储及基本操作\">#</a> 图的存储及基本操作</h2>\n<h3 id=\"邻接矩阵法\"><a class=\"markdownIt-Anchor\" href=\"#邻接矩阵法\">#</a> 邻接矩阵法</h3>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mrow><mo fence=\"true\">{</mo><mtable rowspacing=\"0.3599999999999999em\" columnalign=\"left left\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mn>1</mn><mo separator=\"true\">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mtext>如果顶点 </mtext><mi>i</mi><mtext> 和顶点 </mtext><mi>j</mi><mtext> 之间有边</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mn>0</mn><mo separator=\"true\">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mtext>否则</mtext></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding=\"application/x-tex\">A[i][j] = \n\\begin{cases}\n1, &amp; \\text{如果顶点 } i \\text{ 和顶点 } j \\text{ 之间有边} \\\\\n0, &amp; \\text{否则}\n\\end{cases}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:3.0000299999999998em;vertical-align:-1.25003em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size4\">{</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"mpunct\">,</span></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"mpunct\">,</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.19em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:1em;\"></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord cjk_fallback\">如果顶点</span><span class=\"mord\"> </span></span><span class=\"mord mathnormal\">i</span><span class=\"mord text\"><span class=\"mord\"> </span><span class=\"mord cjk_fallback\">和顶点</span><span class=\"mord\"> </span></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mord text\"><span class=\"mord\"> </span><span class=\"mord cjk_fallback\">之间有边</span></span></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord cjk_fallback\">否则</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.19em;\"><span></span></span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p>带权图：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mrow><mo fence=\"true\">{</mo><mtable rowspacing=\"0.3599999999999999em\" columnalign=\"left left\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo separator=\"true\">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mtext>如果顶点 </mtext><mi>i</mi><mtext> 和 </mtext><mi>j</mi><mtext> 之间有边，权重为 </mtext><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mn>0</mn><mtext> 或 </mtext><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mtext>如果没有边</mtext></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding=\"application/x-tex\">A[i][j] = \n\\begin{cases}\nw_{ij}, &amp; \\text{如果顶点 } i \\text{ 和 } j \\text{ 之间有边，权重为 } w_{ij} \\\\\n0 \\text{ 或 } \\infty, &amp; \\text{如果没有边}\n\\end{cases}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:3.0000299999999998em;vertical-align:-1.25003em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size4\">{</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"mord text\"><span class=\"mord\"> </span><span class=\"mord cjk_fallback\">或</span><span class=\"mord\"> </span></span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.19em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:1em;\"></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord cjk_fallback\">如果顶点</span><span class=\"mord\"> </span></span><span class=\"mord mathnormal\">i</span><span class=\"mord text\"><span class=\"mord\"> </span><span class=\"mord cjk_fallback\">和</span><span class=\"mord\"> </span></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mord text\"><span class=\"mord\"> </span><span class=\"mord cjk_fallback\">之间有边，权重为</span><span class=\"mord\"> </span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-2.25em;\"><span class=\"pstrut\" style=\"height:3.008em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord cjk_fallback\">如果没有边</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.19em;\"><span></span></span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<figure class=\"highlight c++\"><figcaption><span>邻接矩阵</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxVertexNum 100</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">char</span> VertexType;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> EdgeType;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    VertexType vex[MaxVertexNum];   <span class=\"comment\">// 顶点表</span></span><br><span class=\"line\">    EdgeType edge[MaxVertexNum][MaxVertexNum];  <span class=\"comment\">// 邻接矩阵</span></span><br><span class=\"line\">    <span class=\"type\">int</span> vexnum, edgnum;</span><br><span class=\"line\">&#125;MGraph;</span><br></pre></td></tr></table></figure>\n<p>无向图的邻接矩阵一定是对称的，所以只需要存上三角（或下三角）就行</p>\n<blockquote>\n<p>对于无向图，邻接矩阵第<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 行非零元素的个数即为顶点<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 的度<br>\n对于有向图，邻接矩阵第<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 行非零元素的个数即为顶点<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 的出度，第<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 列非零元素的个数即为顶点<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 的入度<br>\n邻接矩阵适合稠密图</p>\n</blockquote>\n<h3 id=\"邻接表法\"><a class=\"markdownIt-Anchor\" href=\"#邻接表法\">#</a> 邻接表法</h3>\n<p>稀疏图适合用邻接表存储<br>\n<img data-src=\"f1.jpg\" alt></p>\n<figure class=\"highlight c++\"><figcaption><span>邻接表</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxVertexNum 100</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">ArcNode</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> adjvex;  <span class=\"comment\">// 邻接点</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">ArcNode</span> *nextarc;</span><br><span class=\"line\">&#125;ArcNode;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">VNode</span> &#123;</span><br><span class=\"line\">    VertexType data;</span><br><span class=\"line\">    ArcNode *firstarc;</span><br><span class=\"line\">&#125;VNode, AdjList[MaxVertexNum];</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    AdjList vertices;</span><br><span class=\"line\">    <span class=\"type\">int</span> vexnum, arcnum;</span><br><span class=\"line\">&#125;ALGraph;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>对于无向图，所需要的空间为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>V</mi><mi mathvariant=\"normal\">∣</mi><mo>+</mo><mn>2</mn><mi mathvariant=\"normal\">∣</mi><mi>E</mi><mi mathvariant=\"normal\">∣</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|V|+2|E|)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">2</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord\">∣</span><span class=\"mclose\">)</span></span></span></span>；若为有向图，空间为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>V</mi><mi mathvariant=\"normal\">∣</mi><mo>+</mo><mi mathvariant=\"normal\">∣</mi><mi>E</mi><mi mathvariant=\"normal\">∣</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|V|+|E|)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord\">∣</span><span class=\"mclose\">)</span></span></span></span></p>\n</blockquote>\n<h3 id=\"十字链表\"><a class=\"markdownIt-Anchor\" href=\"#十字链表\">#</a> 十字链表</h3>\n<p><mark>有向图</mark>的一种链式存储结构<br>\n每条弧、顶点都用结点表示<br>\n顶点结点<br>\n <code>firstIn</code>  表示进入这个结点的第一个弧节点， <code>firstOut</code>  表示出去这个结点的第一个弧节点<br>\n<img data-src=\"f2.png\" alt><br>\n<img data-src=\"f4.png\" alt><br>\n弧结点<br>\n <code>tailVexh</code>  和 <code>headVex</code>  存放弧尾和弧头在顶点数组的编号。 <code>hLink</code>  则表示指向弧头相同的下一条弧， <code>tLink</code>  则表示指向弧尾相同的下一条弧<br>\n<img data-src=\"f3.png\" alt></p>\n<div class=\"note danger\">\n<p>王道这里的弧头指的是箭头的头部，弧尾指的是箭头的尾部，王道这一部分不知道哪个天才写的，纯误导人，直接看英语就行了</p>\n</div>\n<details class=\"primary\"><summary>示例</summary><div>\n<p><img data-src=\"f5.png\" alt><br>\n<img data-src=\"f6.png\" alt></p>\n</div></details>\n<h3 id=\"邻接多重表\"><a class=\"markdownIt-Anchor\" href=\"#邻接多重表\">#</a> 邻接多重表</h3>\n<p>无向图的一种链式存储结构<br>\n边结点：<br>\n| ivex | ilink | jvex | jlink | (info) |<br>\n 顶点结点：<br>\n| data | firstedge |<br>\n 和十字链表差不多意思，只不过这个是无向图<br>\n<img data-src=\"f7.jpg\" alt></p>\n<h3 id=\"图的基本操作\"><a class=\"markdownIt-Anchor\" href=\"#图的基本操作\">#</a> 图的基本操作</h3>\n<h2 id=\"图的遍历\"><a class=\"markdownIt-Anchor\" href=\"#图的遍历\">#</a> 图的遍历</h2>\n<ol>\n<li>BFS<br>\n 用队列实现，入队的时候 visit，出队的时候检查邻接点</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>BFS邻接表实现</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">BFS</span><span class=\"params\">(ALGraph G, <span class=\"type\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">visit</span>(i);</span><br><span class=\"line\">    visited[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"built_in\">EnQueue</span>(Q, i);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!<span class=\"built_in\">IsEmpty</span>(Q))&#123;</span><br><span class=\"line\">        <span class=\"built_in\">Dequeue</span>(Q, v);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> p=G.vertices[v].firstarc; p; p=p-&gt;nextarc)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!visited[p-&gt;adjvex])&#123;</span><br><span class=\"line\">                <span class=\"built_in\">visit</span>(p-&gt;adjvex);</span><br><span class=\"line\">                visited[p-&gt;adjvex] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"built_in\">EnQueue</span>(Q, p-&gt;adjvex);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>V</mi><mi mathvariant=\"normal\">∣</mi><mo>+</mo><mi mathvariant=\"normal\">∣</mi><mi>E</mi><mi mathvariant=\"normal\">∣</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|V|+|E|)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord\">∣</span><span class=\"mclose\">)</span></span></span></span></p>\n<figure class=\"highlight c++\"><figcaption><span>BFS邻接矩阵实现</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">DFS</span><span class=\"params\">(MGraph G, <span class=\"type\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">visit</span>(i);</span><br><span class=\"line\">    visited[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"built_in\">EnQueue</span>(Q, i);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!<span class=\"built_in\">IsEmpty</span>(Q))&#123;</span><br><span class=\"line\">        <span class=\"built_in\">Dequeue</span>(Q, v);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;G.vexnum; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(G.edge[v][j] &amp;&amp; !visited[j])&#123;</span><br><span class=\"line\">                <span class=\"built_in\">visit</span>(j);</span><br><span class=\"line\">                visited[j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"built_in\">EnQueue</span>(Q, j);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>V</mi><msup><mi mathvariant=\"normal\">∣</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|V|^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\"><span class=\"mord\">∣</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></p>\n<ul>\n<li>BFS 求 <code>u</code>  到 <code>v</code>  的最短距离<br>\n在 BFS 基础上添加一个数组 <code>d</code> ，记录从 <code>u</code>  到 <code>v</code>  的最短距离；增加一个数组 <code>pre</code>  记录路径</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>BFS求最短路径</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">BFS_MIN_Distance</span><span class=\"params\">(ALGraph G, <span class=\"type\">int</span> u, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class=\"line\">        d[i] = INF;</span><br><span class=\"line\">        pre[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        visited[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">visit</span>(u);</span><br><span class=\"line\">    visited[u] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    d[u] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    pre[u] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">EnQueue</span>(Q, u);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!<span class=\"built_in\">IsEmpty</span>(Q)) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> v;</span><br><span class=\"line\">        <span class=\"built_in\">Dequeue</span>(Q, v);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (anto p = G.vertices[v].firstarc; p; p = p-&gt;nextarc) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> w = p-&gt;adjvex;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!visited[w]) &#123;</span><br><span class=\"line\">                visited[w] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"built_in\">visit</span>(w);</span><br><span class=\"line\">                d[w] = d[v] + <span class=\"number\">1</span>;  <span class=\"comment\">// 距离 = 前驱距离 + 1</span></span><br><span class=\"line\">                pre[w] = v;       <span class=\"comment\">// 记录前驱</span></span><br><span class=\"line\">                <span class=\"built_in\">EnQueue</span>(Q, w);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>DFS<br>\n 用栈实现</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>DFS邻接表实现</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">DFS</span><span class=\"params\">(ALGraph G, <span class=\"type\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">visit</span>(i);</span><br><span class=\"line\">    visited[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> p=G.vertices[i].firstarc; p; p=p-&gt;nextarc)&#123;</span><br><span class=\"line\">        j = p-&gt;adjvex;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!visited[j])&#123;</span><br><span class=\"line\">            <span class=\"built_in\">DFS</span>(G, j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>V</mi><mi mathvariant=\"normal\">∣</mi><mo>+</mo><mi mathvariant=\"normal\">∣</mi><mi>E</mi><mi mathvariant=\"normal\">∣</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|V|+|E|)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord\">∣</span><span class=\"mclose\">)</span></span></span></span></p>\n<figure class=\"highlight c++\"><figcaption><span>DFS邻接矩阵实现</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">DFS</span><span class=\"params\">(MGraph G, <span class=\"type\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">visit</span>(i);</span><br><span class=\"line\">    visited[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;G.vexnum; j++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(G.edge[i][j] &amp;&amp; !visited[j])&#123;</span><br><span class=\"line\">            <span class=\"built_in\">DFS</span>(G, j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>V</mi><msup><mi mathvariant=\"normal\">∣</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|V|^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\"><span class=\"mord\">∣</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span><br>\n 如果是非连通图，则需要多次调用 DFS（再扫描一次 visit 数组，找到未访问的顶点然后继续调用 DFS）</p>\n<h2 id=\"图的应用\"><a class=\"markdownIt-Anchor\" href=\"#图的应用\">#</a> 图的应用</h2>\n<h3 id=\"最小生成树-mst\"><a class=\"markdownIt-Anchor\" href=\"#最小生成树-mst\">#</a> 最小生成树 MST</h3>\n<p>最小生成树：从连通无向图中找出一棵树（包含所有 n 个节点和 n-1 条边），同时边的权重之和要最小</p>\n<ol>\n<li>Prim 算法<br>\n随便取一个根节点记作 visited，不断寻找 visited 节点和 unvisited 节点之间权重最小的边<br>\n初始的时候只有一个结点，<mark>从顶点开始每次找到和已有的结点距离最小的边</mark>，加入树中，直到树中顶点数等于顶点数（每次要保证树是连通的且没有回路）<br>\n时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>V</mi><msup><mi mathvariant=\"normal\">∣</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|V|^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\"><span class=\"mord\">∣</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，适用于求稠密图的最小生成树</li>\n<li>Kruskal 算法<br>\n每次找到距离最短的边，加入树中，直到所有顶点都在一个连通分量上<br>\n 1）创建一个队列，将边按权重排序，最小的在最上面；（2）从顶端不断 dequeue，如果符合不在同一棵树里就接受那条边</li>\n</ol>\n<h3 id=\"最短路径\"><a class=\"markdownIt-Anchor\" href=\"#最短路径\">#</a> 最短路径</h3>\n<ol>\n<li>\n<p>Dijkstra 算法<br>\n有权图的单源最短路算法<br>\n求从源点到其他点的最短路径：每次选距离最近的点，更新源点到其他点的最短距离<br>\n一开始和其他点的距离全都初始化为 <code>INF</code> ，和自己的距离为 0，每次在 unvisited 的结点中找距离最小的 visit，然后看这个结点的邻接点，新的距离比旧距离小则更新<br>\n画一个表，分别是是否 visit、编号、距离和路径，每次取 unvisited 里最小的</p>\n</li>\n<li>\n<p>Floyd 算法<br>\n多源最短路算法，求所有顶点之间的最短路径<br>\n递归产生一个 n 阶方阵序列<br>\n直接看例子：<br>\n<img data-src=\"f9.jpg\" alt><br>\n路径就是加起来的两个值的路径</p>\n</li>\n</ol>\n<h3 id=\"有向无环图描述表达式\"><a class=\"markdownIt-Anchor\" href=\"#有向无环图描述表达式\">#</a> 有向无环图描述表达式</h3>\n<p>有向图中不存在环，则称为有向无环图，DAG<br>\n<img data-src=\"f10.jpg\" alt><br>\n 先用树表示，然后把能合并的合并到一起，得到一个有向无环图</p>\n<details class=\"primary\"><summary></summary><div>\n<p><img data-src=\"f11.png\" alt><br>\n<img data-src=\"f12.png\" alt><br>\n<img data-src=\"f13.png\" alt></p>\n</div></details>\n<h3 id=\"拓扑排序\"><a class=\"markdownIt-Anchor\" href=\"#拓扑排序\">#</a> 拓扑排序</h3>\n<p>AOV 图顶点表示活动，边表示活动间的依赖关系</p>\n<ul>\n<li>拓扑排序<br>\n当且仅当一个有向图为有向无环图（directed acyclic graph，或称 DAG）时，才能得到对应于该图的拓扑排序。每一个有向无环图都至少存在一种拓扑排序。</li>\n</ul>\n<p>方法：不断寻找入度为 0 的节点 pop 出去，删除该节点和相关的边<br>\n采用邻接表时，时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>V</mi><mi mathvariant=\"normal\">∣</mi><mo>+</mo><mi mathvariant=\"normal\">∣</mi><mi>E</mi><mi mathvariant=\"normal\">∣</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|V|+|E|)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord\">∣</span><span class=\"mclose\">)</span></span></span></span>，采用邻接矩阵时，时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∣</mi><mi>V</mi><msup><mi mathvariant=\"normal\">∣</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(|V|^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\"><span class=\"mord\">∣</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span><br>\n 序列不唯一<br>\n<img data-src=\"f14.png\" alt></p>\n<ul>\n<li>\n<p>逆拓扑排序<br>\n<img data-src=\"f15.png\" alt><br>\n每次删除出度为 0 的顶点，并把该顶点的邻接点出度减 1<br>\n 序列不唯一</p>\n</li>\n<li>\n<p>用 dfs 实现拓扑排序<br>\n<img data-src=\"f16.jpg\" alt></p>\n</li>\n</ul>\n<h3 id=\"aoe网\"><a class=\"markdownIt-Anchor\" href=\"#aoe网\">#</a> AOE 网</h3>\n<p>边表示活动，顶点表示事件</p>\n<ol>\n<li>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始；</li>\n<li>只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生（所以事件的最早开始时间要取最大的）</li>\n</ol>\n<blockquote>\n<p>求事件的最早开始时间和最晚完成时间<br>\n<img data-src=\"f17.png\" alt><br>\n V 代表事件，a 代表活动</p>\n</blockquote>\n<p>先求事件（V）：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>V1</th>\n<th>V2</th>\n<th>V3</th>\n<th>V4</th>\n<th>V5</th>\n<th>V6</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>最早开始时间</td>\n<td>0</td>\n<td>3</td>\n<td>2</td>\n<td>6</td>\n<td>6</td>\n<td>8</td>\n</tr>\n<tr>\n<td>最晚完成时间</td>\n<td>0</td>\n<td>4</td>\n<td>2</td>\n<td>6</td>\n<td>7</td>\n<td>8</td>\n</tr>\n</tbody>\n</table>\n<p>最早开始时间<mark>从前往后取最大的</mark>（V1 填 0，V4 有 V1-&gt;V2-&gt;V4 和 V1-&gt;V3-&gt;V4 两条，取大的是 6）<br>\n最晚完成时间<mark>从后往前推 (用最早开始时间 - a），取最小的</mark>（V6 填 8，V5=V6-1，V3 有 V6-&gt;V3 和 V6-&gt;V4-&gt;V3 两条，取最小的 V4-4=2）</p>\n<p><mark>最早开始时间 = 最晚完成时间 —— 关键路径</mark></p>\n<p>活动（A）：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>a1</th>\n<th>a2</th>\n<th>a3</th>\n<th>a4</th>\n<th>a5</th>\n<th>a6</th>\n<th>a7</th>\n<th>a8</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>最早开始时间</td>\n<td>0</td>\n<td>0</td>\n<td>3</td>\n<td>3</td>\n<td>2</td>\n<td>2</td>\n<td>6</td>\n<td>6</td>\n</tr>\n<tr>\n<td>最晚完成时间</td>\n<td>1</td>\n<td>0</td>\n<td>4</td>\n<td>4</td>\n<td>2</td>\n<td>5</td>\n<td>6</td>\n<td>7</td>\n</tr>\n</tbody>\n</table>\n<p>最早开始时间取箭头的出发点的最早开始时间，最晚完成时间取箭头指向的点的最晚完成时间 - a</p>\n<p><mark>最早开始时间 = 最晚完成时间 —— 关键活动</mark></p>\n<h3 id=\"各种时间复杂度\"><a class=\"markdownIt-Anchor\" href=\"#各种时间复杂度\">#</a> 各种时间复杂度</h3>\n<p><img data-src=\"f18.jpg\" alt></p>\n",
            "tags": [
                "图论"
            ]
        },
        {
            "id": "http://example.com/2025/10/10/computer-science/DS/ch5/",
            "url": "http://example.com/2025/10/10/computer-science/DS/ch5/",
            "title": "ch5",
            "date_published": "2025-10-09T16:00:00.000Z",
            "content_html": "<h1 id=\"ch5\"><a class=\"markdownIt-Anchor\" href=\"#ch5\">#</a> Ch5</h1>\n<h2 id=\"树\"><a class=\"markdownIt-Anchor\" href=\"#树\">#</a> 树</h2>\n<p>树的性质：</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个节点的树有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 条边</li>\n<li>结点数<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 等于所以结点的度数和 + 1</li>\n<li>度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 的树中第<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 层上之多有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>m</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">m^{i-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.824664em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">m</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.824664em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span> 个结点</li>\n<li>高度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">h</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">h</span></span></span></span> 的<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 叉树中至多有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msup><mi>m</mi><mi>h</mi></msup><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(m^h-1)/(m-1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.099108em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">m</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">h</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mord\">/</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 个结点</li>\n<li>度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span>，具有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个结点的树的最小高度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">h</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">h</span></span></span></span></li>\n</ul>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msub><mi>h</mi><mi>min</mi><mo>⁡</mo></msub><mo>=</mo><mrow><mo fence=\"true\">⌈</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mi>m</mi></msub><mrow><mo fence=\"true\">(</mo><mo stretchy=\"false\">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo fence=\"true\">)</mo></mrow><mo fence=\"true\">⌉</mo></mrow></mrow><annotation encoding=\"application/x-tex\">h_{\\min} = \n\\left\\lceil \\log_m \\left( (m - 1)n + 1 \\right) \\right\\rceil\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31750199999999995em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mop mtight\"><span class=\"mtight\">m</span><span class=\"mtight\">i</span><span class=\"mtight\">n</span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">⌈</span><span class=\"mop\"><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.057252em;\"><span style=\"top:-2.4558600000000004em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24414em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">(</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">1</span><span class=\"mclose delimcenter\" style=\"top:0em;\">)</span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">⌉</span></span></span></span></span></span></p>\n<ul>\n<li>度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span>，具有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个结点的树的最大高度 h 为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-m-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span></li>\n<li>高度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">h</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">h</span></span></span></span>，度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 的树至少有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi><mo>+</mo><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">h+m-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 个结点</li>\n</ul>\n<h2 id=\"二叉树\"><a class=\"markdownIt-Anchor\" href=\"#二叉树\">#</a> 二叉树</h2>\n<p>二叉树：每个结点最多有两个子树，称为左子树和右子树<br>\n二叉树和度为 2 的有序树的区别：</p>\n<ol>\n<li>度为 2 的有序树至少有 3 个结点，二叉树可以为空</li>\n<li>二叉树不管有没有兄弟结点都需要区分是左子树还是右子树</li>\n</ol>\n<ul>\n<li>满二叉树：每层都满</li>\n<li>完全二叉树：除了最后一层外，其他层都是满二叉树，最后一层左边要是满的</li>\n<li>二叉排序树：每个结点都满足左子树小于该结点，右子树大于该结点</li>\n<li>平衡二叉树：任意结点的左右子树的高度差不超过 1</li>\n<li>正则二叉树：树中每个分支结点都有两个子结点，树中只有度为 0 或 2 的结点</li>\n</ul>\n<p>性质：</p>\n<ol>\n<li>非空二叉树上的叶结点数等于度为 2 的结点数加 1，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n_0 = n_2 + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.73333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span></li>\n<li>非空二叉树第 k 层最多有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">2^{k-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8491079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span> 个结点</li>\n<li>高度为 h 的二叉树最多有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2^h-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.932438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">h</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 个结点</li>\n<li>对完全二叉树按从上到下、从左到右的顺序依次编号，则<br>\n最后一个分支节点的编号为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo fence=\"true\">⌊</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo fence=\"true\">⌋</mo></mrow><annotation encoding=\"application/x-tex\">\\left\\lfloor \\frac{n}{2} \\right\\rfloor</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.20001em;vertical-align:-0.35001em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size1\">⌊</span></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.695392em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size1\">⌋</span></span></span></span></span></span>，如果<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 小于等于这个数就是分支节点，否则就是叶子结点<br>\n如果<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 为奇数，则每个分支节点都有左右孩子，如果是偶数就编号最大的分支只有左孩子<br>\n结点<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 的左孩子编号为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">2i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">i</span></span></span></span>，右孩子编号<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2i+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.74285em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span><br>\n 结点 i 所在的 depth 为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mo fence=\"true\">⌈</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>i</mi><mo fence=\"true\">⌉</mo></mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\left\\lceil \\log_2 i \\right\\rceil + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">⌈</span><span class=\"mop\"><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.20696799999999996em;\"><span style=\"top:-2.4558600000000004em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24414em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mclose delimcenter\" style=\"top:0em;\">⌉</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span></li>\n<li>具有 n 个结点的完全二叉树的高度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mo fence=\"true\">⌊</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo fence=\"true\">⌋</mo></mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\left\\lfloor \\log_2 n \\right\\rfloor + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">⌊</span><span class=\"mop\"><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.20696799999999996em;\"><span style=\"top:-2.4558600000000004em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24414em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose delimcenter\" style=\"top:0em;\">⌋</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 或者<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo fence=\"true\">⌈</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mo fence=\"true\">⌉</mo></mrow><annotation encoding=\"application/x-tex\">\\left\\lceil \\log_2 {n+1} \\right\\rceil</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">⌈</span><span class=\"mop\"><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.20696799999999996em;\"><span style=\"top:-2.4558600000000004em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24414em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">1</span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">⌉</span></span></span></span></span></li>\n</ol>\n<h3 id=\"二叉树的存储结构\"><a class=\"markdownIt-Anchor\" href=\"#二叉树的存储结构\">#</a> 二叉树的存储结构</h3>\n<ul>\n<li>完全二叉树可以存储在数组里，数组中第 i 个结点对应数组中的第 i 个元素，0 为空，就可以利用下标找到 parent/left child/right child</li>\n<li>普通的二叉树采用链式存储结构</li>\n</ul>\n<figure class=\"highlight c\"><figcaption><span>二叉树</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTNode</span>&#123;</span></span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTNode</span> *<span class=\"title\">lchild</span>, *<span class=\"title\">rchild</span>;</span></span><br><span class=\"line\">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二叉树的遍历和线索二叉树\"><a class=\"markdownIt-Anchor\" href=\"#二叉树的遍历和线索二叉树\">#</a> 二叉树的遍历和线索二叉树</h3>\n<ol>\n<li>PreOrder 先（前）序遍历：根左右</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>先序遍历</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">PreOrder</span><span class=\"params\">(BiTree T)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(T != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">Visit</span>(T);</span><br><span class=\"line\">        <span class=\"built_in\">PreOrder</span>(T-&gt;lchild);</span><br><span class=\"line\">        <span class=\"built_in\">PreOrder</span>(T-&gt;rchild);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>InOrder 中序遍历：左根右</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>中序遍历</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">InOrder</span><span class=\"params\">(BiTree T)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(T != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">InOrder</span>(T-&gt;lchild);</span><br><span class=\"line\">        <span class=\"built_in\">Visit</span>(T);</span><br><span class=\"line\">        <span class=\"built_in\">InOrder</span>(T-&gt;rchild);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>PostOrder 后序遍历：左右根</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>后序遍历</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">PostOrder</span><span class=\"params\">(BiTree T)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(T != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">PostOrder</span>(T-&gt;lchild);</span><br><span class=\"line\">        <span class=\"built_in\">PostOrder</span>(T-&gt;rchild);</span><br><span class=\"line\">        <span class=\"built_in\">Visit</span>(T);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div class=\"note info\">\n<p>以上三种遍历方式都是递归方式，栈的深度就是树的高度，时间复杂度都是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span><br>\n 最坏的情况下，二叉树是有 n 个结点且深度为 n 的单支树，此时空间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></p>\n</div>\n<ol start=\"4\">\n<li>LevelOrder 层序遍历：从上到下从左到右<br>\n需要借助一个队列，其实就是 bfs</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>层序遍历</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">LevelOrder</span><span class=\"params\">(BiTree T)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">initQueue</span>(Q);   <span class=\"comment\">//根节点入队</span></span><br><span class=\"line\">    BiTree p;</span><br><span class=\"line\">    <span class=\"built_in\">enQueue</span>(Q, T);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!<span class=\"built_in\">isEmpty</span>(Q))&#123; <span class=\"comment\">//若队列非空</span></span><br><span class=\"line\">        <span class=\"built_in\">DeQueue</span>(Q, p);  <span class=\"comment\">//出队</span></span><br><span class=\"line\">        <span class=\"built_in\">visit</span>(p);   <span class=\"comment\">//访问当前节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p-&gt;lchild != <span class=\"literal\">NULL</span>)   <span class=\"comment\">//左孩子入队</span></span><br><span class=\"line\">            <span class=\"built_in\">EnQueue</span>(Q, p-&gt;lchild);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p-&gt;rchild != <span class=\"literal\">NULL</span>)   <span class=\"comment\">//右孩子入队</span></span><br><span class=\"line\">            <span class=\"built_in\">EnQueue</span>(Q, p-&gt;rchild);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>由遍历序列构造二叉树<br>\n若已知 InOrder，再给出 PreOrder/PostOrder/LevelOrder 都可以唯一的确定一棵二叉树</li>\n</ol>\n<ul>\n<li>前序 + 中序<br>\n用先序遍历得到根节点，在中序遍历中找，根节点把中序遍历分为左右两段分别是左子树和右子树，递归构造左右子树</li>\n<li>后序 + 中序<br>\n和前序同理</li>\n<li>层序 + 中序<br>\n层序的第一个是根节点，然后在层序找到左右子树的根节点（如果有左子树，根后面第一个就是左子树的根节点，如果有右子树，下一个就是右子树的根节点）</li>\n</ul>\n<details class=\"primary\"><summary>例</summary><div>\n<p><img data-src=\"f1.jpg\" alt><br>\n<img data-src=\"f2.jpg\" alt></p>\n</div></details>\n<h3 id=\"线索二叉树\"><a class=\"markdownIt-Anchor\" href=\"#线索二叉树\">#</a> 线索二叉树</h3>\n<p>利用叶子结点和不满的结点的空指针存放指向其前驱或者后继的指针，若没有左子树，则 lchild 指向前驱结点，若没有右子树，则 rchild 指向后继结点。新增 ltag 和 rtag，如果为 0 表示指向左 / 右孩子，为 1 表示为线索指向前驱 / 后继结点</p>\n<figure class=\"highlight c++\"><figcaption><span>线索二叉树</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">ThreadNode</span>&#123;</span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">ThreadNode</span> *lchild, *rchild;</span><br><span class=\"line\">    <span class=\"type\">int</span> ltag, rtag;</span><br><span class=\"line\">&#125;ThreadNode, *ThreadTree;</span><br></pre></td></tr></table></figure>\n<p>方法就是找出遍历的序列，然后对每个不满的节点建立线索</p>\n<h4 id=\"中序线索二叉树\"><a class=\"markdownIt-Anchor\" href=\"#中序线索二叉树\">#</a> 中序线索二叉树：</h4>\n<figure class=\"highlight c++\"><figcaption><span>中序线索二叉树</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">InThread</span><span class=\"params\">(ThreadTree &amp;p, ThreadTree &amp;pre)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">InThread</span>(p-&gt;lchild, pre);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p-&gt;lchild == <span class=\"literal\">NULL</span>)&#123; </span><br><span class=\"line\">            p-&gt;lchild = pre;</span><br><span class=\"line\">            p-&gt;ltag = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pre != <span class=\"literal\">NULL</span> &amp;&amp; pre-&gt;rchild == <span class=\"literal\">NULL</span>)&#123; </span><br><span class=\"line\">            pre-&gt;rchild = p;</span><br><span class=\"line\">            pre-&gt;rtag = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre = p;</span><br><span class=\"line\">        <span class=\"built_in\">InThread</span>(p-&gt;rchild, pre);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">CreateInThread</span><span class=\"params\">(ThreadTree &amp;T)</span></span>&#123;</span><br><span class=\"line\">    ThreadTree pre = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(T != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">InThread</span>(T, pre);</span><br><span class=\"line\">    pre-&gt;rchild = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    pre-&gt;rtag = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了方便会增加一个 head 结点的 lchild 指向根节点，rchild 指向中序遍历的最后一个结点，令中序遍历第一个节点的 lchild 和最后一个节点的 rchild 指向 head</p>\n<figure class=\"highlight c++\"><figcaption><span>求中序线索二叉树中序序列下的第一个节点</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ThreadNode *<span class=\"title\">Firstnode</span><span class=\"params\">(ThreadNode *p)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p-&gt;ltag == <span class=\"number\">0</span>) p = p-&gt;lchild;  <span class=\"comment\">//找到最左下的节点但不一定是叶子</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>求节点p的后继结点</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ThreadNode *<span class=\"title\">Nextnode</span><span class=\"params\">(ThreadNode *p)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p-&gt;rtag == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">Firstnode</span>(p-&gt;rchild);   <span class=\"comment\">//如果有右孩子，则返回右孩子的最左下的节点</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> p-&gt;rchild;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>求中序线索二叉树的最后一个结点</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ThreadNode *<span class=\"title\">Lastnode</span><span class=\"params\">(ThreadNode *p)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p-&gt;rtag == <span class=\"number\">0</span>) p = p-&gt;rchild;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>求节点p的前驱结点</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ThreadNode *<span class=\"title\">Prevnode</span><span class=\"params\">(ThreadNode *p)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p-&gt;ltag == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">Lastnode</span>(p-&gt;lchild);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> p-&gt;lchild;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>不含头结点的中序线索二叉树的中序遍历</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">InOrder</span><span class=\"params\">(ThreadNode *T)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(ThreadNode *p = <span class=\"built_in\">Firstnode</span>(T); p != <span class=\"literal\">NULL</span>; p = <span class=\"built_in\">Nextnode</span>(p))</span><br><span class=\"line\">        <span class=\"built_in\">Visit</span>(p);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"先序线索二叉树\"><a class=\"markdownIt-Anchor\" href=\"#先序线索二叉树\">#</a> 先序线索二叉树</h4>\n<h4 id=\"后序线索二叉树\"><a class=\"markdownIt-Anchor\" href=\"#后序线索二叉树\">#</a> 后序线索二叉树</h4>\n<h2 id=\"树森林\"><a class=\"markdownIt-Anchor\" href=\"#树森林\">#</a> 树，森林</h2>\n<h3 id=\"树的存储结构\"><a class=\"markdownIt-Anchor\" href=\"#树的存储结构\">#</a> 树的存储结构</h3>\n<ol>\n<li>双亲表示法<br>\n用一个结构体数组来存，一个 node 包括数据域和 parent 域，parent 域的值是父节点的数组下标。根节点的 parent 域为 - 1</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>双亲表示法</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAX_TREE_SIZE 100</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"type\">int</span> parent;</span><br><span class=\"line\">&#125;PTNode;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    PTNode nodes[MAX_TREE_SIZE];</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">&#125;PTree;</span><br></pre></td></tr></table></figure>\n<p>优点：可以很快找到 parent，但求孩子需要遍历整个树<br>\n 2. 孩子表示法<br>\n将每个结点的孩子视为一个线性表，以单链表作为存储结构<br>\n 3. 孩子兄弟表示法<br>\n二叉树表示法，每个结点包括数据域，左孩子指针，右兄弟指针</p>\n<figure class=\"highlight c++\"><figcaption><span>孩子兄弟表示法</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">CSNode</span>&#123;</span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">CSNode</span> *firstchild, *nextsibling;</span><br><span class=\"line\">&#125;CSNode, *CSTree;</span><br></pre></td></tr></table></figure>\n<details class=\"primary\"><summary>图示</summary><div>\n<p><img data-src=\"f3.jpg\" alt><br>\n<img data-src=\"f4.jpg\" alt></p>\n</div></details>\n<h3 id=\"树-森林和二叉树的转换\"><a class=\"markdownIt-Anchor\" href=\"#树-森林和二叉树的转换\">#</a> 树、森林和二叉树的转换</h3>\n<ol>\n<li>树转二叉树<br>\n用孩子兄弟表示法（左孩子右兄弟）</li>\n<li>森林转二叉树<br>\n先讲森林中的每棵树转为二叉树，每棵树视为兄弟，将第二棵树对应的二叉树作为第一颗二叉树根的右子树……</li>\n</ol>\n<details class=\"primary\"><summary>例</summary><div>\n<p><img data-src=\"f5.jpg\" alt></p>\n</div></details>\n<ol start=\"3\">\n<li>二叉树转森林<br>\n把右子树分开，知道最后只剩一棵没有右子树的二叉树为止。和森林转二叉树相反</li>\n</ol>\n<h3 id=\"树和森林的遍历\"><a class=\"markdownIt-Anchor\" href=\"#树和森林的遍历\">#</a> 树和森林的遍历</h3>\n<ol>\n<li>树的遍历</li>\n</ol>\n<ul>\n<li>先根后子树，遍历序列和这棵树对应的二叉树的先序序列相同</li>\n<li>先子树后根，遍历序列和这棵树对应的二叉树的中序序列相同</li>\n</ul>\n<ol start=\"2\">\n<li>森林的遍历</li>\n</ol>\n<ul>\n<li>先序遍历：从第一棵树开始，先根，再子树</li>\n<li>中序遍历：从第一棵树开始，先子树，再根</li>\n</ul>\n<h2 id=\"树与二叉树的应用\"><a class=\"markdownIt-Anchor\" href=\"#树与二叉树的应用\">#</a> 树与二叉树的应用</h2>\n<h3 id=\"哈夫曼树\"><a class=\"markdownIt-Anchor\" href=\"#哈夫曼树\">#</a> 哈夫曼树</h3>\n<h4 id=\"定义\"><a class=\"markdownIt-Anchor\" href=\"#定义\">#</a> 定义</h4>\n<p>带权路径长度：根结点到该结点的路径长度 * 该结点的权值<br>\n树的带权路径长度</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>W</mi><mi>P</mi><mi>L</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>w</mi><mi>i</mi></msub><mo>∗</mo><msub><mi>l</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">WPL = \\sum_{i=1}^{n}w_i*l_i\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.929066em;vertical-align:-1.277669em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.6513970000000002em;\"><span style=\"top:-1.872331em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.050005em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∑</span></span></span><span style=\"top:-4.3000050000000005em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.277669em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span></p>\n<p>WPL 最小的二叉树称为哈夫曼树，也称最优二叉树</p>\n<h4 id=\"构造\"><a class=\"markdownIt-Anchor\" href=\"#构造\">#</a> 构造</h4>\n<ul>\n<li>构造方法：不断合并两个权值加起来最小的结点<br>\n<img data-src=\"f6.jpg\" alt></li>\n</ul>\n<h4 id=\"哈夫曼编码\"><a class=\"markdownIt-Anchor\" href=\"#哈夫曼编码\">#</a> 哈夫曼编码</h4>\n<p>可变长度编码，让频率高的字符编码长度短，频率低的字符编码长度长<br>\n用哈夫曼树构建哈夫曼编码，是前缀编码，因此每个编码都可以唯一区分一个字符（没有字符的编码是其他编码的前缀）<br>\n构造的方法是权值为频率，左分支为 0，右分支为 1（左边 1 右边 0 也可以，主要是看长度）<br>\n<img data-src=\"f7.jpg\" alt><br>\n编码方式不唯一，因为长度相同的字符编码方式是可以互换的</p>\n<h3 id=\"并查集-disjoint-set\"><a class=\"markdownIt-Anchor\" href=\"#并查集-disjoint-set\">#</a> 并查集 Disjoint Set</h3>\n<p>主要用来求等价关系<br>\n基本操作：</p>\n<ul>\n<li>初始化：所有元素都是单元素集合</li>\n<li>Union (S, Root1, Root2): 合并两个集合，把 Root2 的根节点连到 Root1 的根节点上</li>\n<li>Find (S, x): 查找 x 的根节点</li>\n</ul>\n<p>基本实现：</p>\n<figure class=\"highlight c++\"><figcaption><span>disjoint set</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SIZE 100</span></span><br><span class=\"line\"><span class=\"type\">int</span> UFSets[SIZE];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Initial</span><span class=\"params\">(<span class=\"type\">int</span> S[])</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; SIZE; i++)&#123;</span><br><span class=\"line\">        S[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"type\">int</span> S[], <span class=\"type\">int</span> x)</span></span>&#123;   <span class=\"comment\">//时间复杂度为O(d)，d为树的深度</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(S[x] &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        x = S[x];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Union</span><span class=\"params\">(<span class=\"type\">int</span> S[], <span class=\"type\">int</span> Root1, <span class=\"type\">int</span> Root2)</span></span>&#123;  <span class=\"comment\">//时间复杂度为O(1)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Root1 == Root2) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    S[Root2] = Root1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"并查集的优化\"><a class=\"markdownIt-Anchor\" href=\"#并查集的优化\">#</a> 并查集的优化</h4>\n<ol>\n<li>按高度求并 Union-by-Height</li>\n</ol>\n<ul>\n<li>用根节点的绝对值表示树的结点总数（根节点的值是负数）</li>\n<li>把小树合并到大树，能够保证所有树的深度最多是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(logn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>Union-by-Height</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Union</span><span class=\"params\">(<span class=\"type\">int</span> S[], <span class=\"type\">int</span> Root1, <span class=\"type\">int</span> Root2)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Root1 == Root2) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(S[Root2] &gt; S[Root1])&#123;    <span class=\"comment\">//Root2的深度小于Root1</span></span><br><span class=\"line\">        S[Root1] += S[Root2];</span><br><span class=\"line\">        S[Root2] = Root1;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        S[Root2] += S[Root1];</span><br><span class=\"line\">        S[Root1] = Root2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>路径压缩<br>\n为了减少深度，在 Find 操作时将从根到元素 x 路径上的所有元素都变成根的孩子</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>路径压缩</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"type\">int</span> S[], <span class=\"type\">int</span> x)</span></span>&#123;   <span class=\"comment\">//先搜一次找到根，再搜一次把路径上所有节点的父节点都改成根</span></span><br><span class=\"line\">    <span class=\"type\">int</span> root = x;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(S[root] &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        root = S[root];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x != root)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> temp = S[x];</span><br><span class=\"line\">        S[x] = root;</span><br><span class=\"line\">        x = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "树与二叉树"
            ]
        },
        {
            "id": "http://example.com/2025/10/05/computer-science/DS/ch4/",
            "url": "http://example.com/2025/10/05/computer-science/DS/ch4/",
            "title": "ch4",
            "date_published": "2025-10-04T16:00:00.000Z",
            "content_html": "<h1 id=\"ch4\"><a class=\"markdownIt-Anchor\" href=\"#ch4\">#</a> Ch4</h1>\n<h2 id=\"模式匹配\"><a class=\"markdownIt-Anchor\" href=\"#模式匹配\">#</a> 模式匹配</h2>\n<p>i: 主串当前待比较的字符位置<br>\n j: 模式串当前待比较的字符位置</p>\n<p>字符串模式匹配，在主串中找到与模式串相同的子串</p>\n<h3 id=\"暴力算法\"><a class=\"markdownIt-Anchor\" href=\"#暴力算法\">#</a> 暴力算法</h3>\n<p>遍历主串，从每个和第一个字符相同的位置开始，继续比较后继字符<br>\n时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(mn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>（主串长度 n，模式串长度 m）</p>\n<h3 id=\"kmp算法\"><a class=\"markdownIt-Anchor\" href=\"#kmp算法\">#</a> KMP 算法</h3>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVBENHkxbzduZC8/c3BtX2lkX2Zyb209MzMzLjEzODcuaG9tZXBhZ2UudmlkZW9fY2FyZC5jbGljayZhbXA7dmRfc291cmNlPTFhN2Q4ZjU5NmYzZGZlNDBmZWUzNGM4NThlZDQ3ZTcz\">https://www.bilibili.com/video/BV1PD4y1o7nd/?spm_id_from=333.1387.homepage.video_card.click&amp;vd_source=1a7d8f596f3dfe40fee34c858ed47e73</span><br>\n 这个讲得好</p>\n<div class=\"note danger\">\n<p>KMP 算法中 i 永远不递减</p>\n</div>\n<p>前缀：除了最后一个字符外所有的头部子串<br>\n后缀：除了第一个字符外所有的尾部子串</p>\n<ul>\n<li>PM 数组<br>\n方法：算出所有前缀的前缀和后缀的最长公共子串的长度，并保存在数组中（PM，部分匹配值）<br>\n从头开始，右滑位数 = 已匹配的字符数 - 对应的部分匹配值（最后一个匹配的字符的 PM）<br>\n<mark>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(m+n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></mark></li>\n<li>next 数组<br>\n next 数组代表匹配的时候子串中可以跳过匹配的字符个数</li>\n</ul>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>P</mi><mi>M</mi><mo stretchy=\"false\">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">next[j] = PM[j-1] + 1 \n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span></span></p>\n<p>将模式串的 PM 表右移一位并整体 + 1，左边空缺用 0 来填充，右边溢出舍去</p>\n<div class=\"note info\">\n<p>在上面方法中，串的编号是从 1 开始的</p>\n</div>\n<p>当模式串在位置 j 与主串不匹配时，模式串应该向右滑动的位数 = j - next [j-1]</p>\n<ul>\n<li>next 数组的一般公式</li>\n</ul>\n<ol>\n<li>第 1 个是 0，第 2 个是 1</li>\n<li>当前位置前面的串的相等的最长的前缀和后缀的长度 + 1</li>\n<li>前缀后缀都不相等，填 1</li>\n</ol>\n<p>直接看代码</p>\n<figure class=\"highlight c++\"><figcaption><span>KMP</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">get_next</span><span class=\"params\">(SString T, <span class=\"type\">int</span> nexxt[])</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">1</span>, j = <span class=\"number\">0</span>;   <span class=\"comment\">//i指向当前要计算next[i]的位置，j表示上一个最长前后缀长度</span></span><br><span class=\"line\">    next[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt; T.length)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j == <span class=\"number\">0</span> || T.ch[i] == T.ch[j])&#123;</span><br><span class=\"line\">            ++i;</span><br><span class=\"line\">            ++j;</span><br><span class=\"line\">            next[i] = j;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            j = next[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>next [0] 是不用的</p>\n<p>KMP 匹配算法</p>\n<figure class=\"highlight c++\"><figcaption><span>KMP</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">index_KMP</span><span class=\"params\">(SString S, SString T, <span class=\"type\">int</span> next[])</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">1</span>, j = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt;= S.length &amp;&amp; j &lt;= T.length)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j == <span class=\"number\">0</span> || S.ch[i] == T.ch[j])&#123;   <span class=\"comment\">//表示模式串已经回退到不能再回退的位置,此时必须让主串指针i前进一步，模式串从第一个字符重新开始匹配</span></span><br><span class=\"line\">            ++i;</span><br><span class=\"line\">            ++j;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            j = next[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(j &gt; T.length) <span class=\"keyword\">return</span> i - T.length;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>nextval 数组<br>\n如果<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>p</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">p_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> 和<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>p</mi><mrow><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow></msub></mrow><annotation encoding=\"application/x-tex\">p_{next[j]}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7857599999999999em;vertical-align:-0.3551999999999999em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mord mathnormal mtight\">e</span><span class=\"mord mathnormal mtight\">x</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mopen mtight\">[</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose mtight\">]</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span></span> 相等，让 next [j] 的值等于 next [next [j]]，一直递归下去<br>\n如果跳转后的位置字符和当前字符相同，那就直接跳到更前面的位置（即 nextval [j]），避免无效比较</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>nextval</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">get_nextval</span><span class=\"params\">(SString T, <span class=\"type\">int</span> nextval[])</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">1</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    nextval[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt; T.length)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j == <span class=\"number\">0</span> || T.ch[i] == T.ch[j])&#123;</span><br><span class=\"line\">            ++i;</span><br><span class=\"line\">            ++j;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(T.ch[i] != T.ch[j])</span><br><span class=\"line\">                nextval[i] = j;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> nextval[i] = nextval[j];</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            j = nextval[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "串"
            ]
        },
        {
            "id": "http://example.com/2025/10/04/computer-science/DS/ch3/",
            "url": "http://example.com/2025/10/04/computer-science/DS/ch3/",
            "title": "ch3",
            "date_published": "2025-10-03T16:00:00.000Z",
            "content_html": "<h1 id=\"ch3\"><a class=\"markdownIt-Anchor\" href=\"#ch3\">#</a> Ch3</h1>\n<h2 id=\"栈\"><a class=\"markdownIt-Anchor\" href=\"#栈\">#</a> 栈</h2>\n<p>LIFO</p>\n<h3 id=\"顺序栈的实现\"><a class=\"markdownIt-Anchor\" href=\"#顺序栈的实现\">#</a> 顺序栈的实现</h3>\n<figure class=\"highlight c++\"><figcaption><span>定义</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 50</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    ElemType data[MaxSize];</span><br><span class=\"line\">    <span class=\"type\">int</span> top;</span><br><span class=\"line\">&#125;SqStack;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>初始化</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">InitStack</span><span class=\"params\">(SqStack &amp;S)</span></span>&#123;</span><br><span class=\"line\">    S.top = <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>判断空</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">StackEmpty</span><span class=\"params\">(SqStack S)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(S.top == <span class=\"number\">-1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>push</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Push</span><span class=\"params\">(SqStack &amp;S,ElemType x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(S.top == MaxSize - <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    S.data[++S.top] = x;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>pop</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Pop</span><span class=\"params\">(SqStack &amp;S,ElemType &amp;x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(S.top == <span class=\"number\">-1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    x = S.data[S.top--];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>gettop</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">GetTop</span><span class=\"params\">(SqStack S,ElemType &amp;x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(S.top == <span class=\"number\">-1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    x = S.data[S.top];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"共享栈\"><a class=\"markdownIt-Anchor\" href=\"#共享栈\">#</a> 共享栈</h3>\n<p>同时从两边向中间压栈</p>\n<h3 id=\"链栈\"><a class=\"markdownIt-Anchor\" href=\"#链栈\">#</a> 链栈</h3>\n<figure class=\"highlight c++\"><figcaption><span>定义</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">Linknode</span>&#123;</span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">Linknode</span> *next;</span><br><span class=\"line\">&#125;LiStack;</span><br></pre></td></tr></table></figure>\n<h2 id=\"队列\"><a class=\"markdownIt-Anchor\" href=\"#队列\">#</a> 队列</h2>\n<p>FIFO</p>\n<h3 id=\"顺序存储\"><a class=\"markdownIt-Anchor\" href=\"#顺序存储\">#</a> 顺序存储</h3>\n<figure class=\"highlight c++\"><figcaption><span>队列的实现</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 50</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    ElemType data[MaxSize];</span><br><span class=\"line\">    <span class=\"type\">int</span> front,rear;</span><br><span class=\"line\">&#125;SqQueue;</span><br></pre></td></tr></table></figure>\n<p>初始状态：front = rear = 0</p>\n<figure class=\"highlight c++\"><figcaption><span>队列判空</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">QueueEmpty</span><span class=\"params\">(SqQueue Q)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.front == Q.rear)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"循环队列\"><a class=\"markdownIt-Anchor\" href=\"#循环队列\">#</a> 循环队列</h4>\n<figure class=\"highlight c++\"><figcaption><span>初始化</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">InitQueue</span><span class=\"params\">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class=\"line\">    Q.front = Q.rear = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>队列判空</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">QueueEmpty</span><span class=\"params\">(SqQueue Q)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.front == Q.rear)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>队列判满</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">QueueFull</span><span class=\"params\">(SqQueue Q)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((Q.rear + <span class=\"number\">1</span>) % MaxSize == Q.front)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>入队</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">EnQueue</span><span class=\"params\">(SqQueue &amp;Q,ElemType x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">QueueFull</span>(Q))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    Q.data[Q.rear] = x;</span><br><span class=\"line\">    Q.rear = (Q.rear + <span class=\"number\">1</span>) % MaxSize;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>出队</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">DeQueue</span><span class=\"params\">(SqQueue &amp;Q,ElemType &amp;x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">QueueEmpty</span>(Q))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    x = Q.data[Q.front];</span><br><span class=\"line\">    Q.front = (Q.front + <span class=\"number\">1</span>) % MaxSize;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>求元素个数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">QueueLength</span><span class=\"params\">(SqQueue Q)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (Q.rear - Q.front + MaxSize) % MaxSize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"链式存储\"><a class=\"markdownIt-Anchor\" href=\"#链式存储\">#</a> 链式存储</h3>\n<figure class=\"highlight c++\"><figcaption><span>链队列的实现</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">Linknode</span>&#123;</span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">Linknode</span> *next;</span><br><span class=\"line\">&#125;LinkNode;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    LinkNode *front,*rear;</span><br><span class=\"line\">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>\n<p>一般设计成带头结点的链队列</p>\n<figure class=\"highlight c\"><figcaption><span>初始化</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitQueue</span><span class=\"params\">(LinkQueue &amp;Q)</span>&#123;</span><br><span class=\"line\">    Q.front = Q.rear = (LinkNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LinkNode));</span><br><span class=\"line\">    Q.front-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><figcaption><span>队列判空</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">QueueEmpty</span><span class=\"params\">(LinkQueue Q)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.front == Q.rear)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><figcaption><span>入队</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">EnQueue</span><span class=\"params\">(LinkQueue &amp;Q,ElemType x)</span>&#123;</span><br><span class=\"line\">    LinkNode *s = (LinkNode*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LinkNode));</span><br><span class=\"line\">    s-&gt;data = x;</span><br><span class=\"line\">    s-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    Q.rear-&gt;next = s;</span><br><span class=\"line\">    Q.rear = s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><figcaption><span>出队</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">DeQueue</span><span class=\"params\">(LinkQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.front == Q.rear)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    LinkNode *p = Q.front-&gt;next;</span><br><span class=\"line\">    x = p-&gt;data;</span><br><span class=\"line\">    Q.front-&gt;next = p-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Q.rear == p)</span><br><span class=\"line\">        Q.rear = Q.front;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"双端队列\"><a class=\"markdownIt-Anchor\" href=\"#双端队列\">#</a> 双端队列</h3>\n<ul>\n<li>输出受限的双端队列<br>\n允许在一端进行 push/pop 操作，另一端只能 push</li>\n<li>输入受限的双端队列<br>\n允许在一端进行 push/pop 操作，另一端只能 pop</li>\n</ul>\n<h2 id=\"栈和队列的应用\"><a class=\"markdownIt-Anchor\" href=\"#栈和队列的应用\">#</a> 栈和队列的应用</h2>\n<h3 id=\"栈-2\"><a class=\"markdownIt-Anchor\" href=\"#栈-2\">#</a> 栈</h3>\n<h4 id=\"表达式\"><a class=\"markdownIt-Anchor\" href=\"#表达式\">#</a> 表达式</h4>\n<ul>\n<li>括号匹配<br>\n左括号压栈，右括号出栈，判断是否匹配</li>\n<li>算术表达式<br>\n中缀表达式：左根右<br>\n前缀表达式：根左右<br>\n后缀表达式：左右根</li>\n</ul>\n<blockquote>\n<p>中缀转后缀</p>\n<ol>\n<li>加括号</li>\n<li>把运算符移到当前层的括号后面</li>\n<li>去掉括号<br>\n<strong>用栈实现中缀转后缀：</strong></li>\n</ol>\n</blockquote>\n<ol>\n<li>遇到操作数直接加入后缀表达式</li>\n<li>遇到括号，左括号入栈，右括号依次出栈加入后缀表达式直到遇到左括号位置，并删除左括号</li>\n<li>遇到运算符，判断优先级，如果栈为空或者栈顶为 “（” 或者栈顶运算符优先级低于当前运算符，则入栈，否则依次出栈加入后缀表达式，直到栈为空或者栈顶运算符优先级低于当前运算符（优先级相同的也要出栈），最后将当前运算符入栈<br>\n<mark>所以栈里面只存运算符和括号</mark></li>\n</ol>\n<blockquote>\n<p>后缀表达式求值<br>\n从左到右扫描表达式，遇到操作数压栈，遇到操作符就弹出两个操作数，计算结果压入栈中</p>\n</blockquote>\n<h4 id=\"递归\"><a class=\"markdownIt-Anchor\" href=\"#递归\">#</a> 递归</h4>\n<h3 id=\"队列-2\"><a class=\"markdownIt-Anchor\" href=\"#队列-2\">#</a> 队列</h3>\n<h4 id=\"层次遍历\"><a class=\"markdownIt-Anchor\" href=\"#层次遍历\">#</a> 层次遍历</h4>\n<p>根左右入队，依次 pop</p>\n<h4 id=\"队列的应用\"><a class=\"markdownIt-Anchor\" href=\"#队列的应用\">#</a> 队列的应用</h4>\n<ul>\n<li>缓冲区</li>\n<li>操作系统的请求队列</li>\n</ul>\n<h2 id=\"数组\"><a class=\"markdownIt-Anchor\" href=\"#数组\">#</a> 数组</h2>\n<p>特殊矩阵的压缩存储</p>\n<ul>\n<li>对称矩阵<br>\n只存下三角的元素，存在一维数组里</li>\n<li>三角矩阵<br>\n省略 0，摊平存在一维数组</li>\n<li>三对角<br>\n同理省略 0，存在一维数组里</li>\n<li>稀疏矩阵<br>\n行标，列标，值都成三元组，存储在线性表（数组或者十字链表），保存的同时要保存系数矩阵的行数、列数和非零元素的个数</li>\n</ul>\n",
            "tags": [
                "栈、队列和数组"
            ]
        },
        {
            "id": "http://example.com/2025/09/15/computer-science/DS/Amortized%20Analysis/",
            "url": "http://example.com/2025/09/15/computer-science/DS/Amortized%20Analysis/",
            "title": "Amortized Analysis",
            "date_published": "2025-09-14T16:00:00.000Z",
            "content_html": "<ol>\n<li>Aggregate analysis<br>\na sequence of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> operations takes worst-case time <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> int total. In the worst-case, the average cost, or amortized cost, per operation is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">T(n)/n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">n</span></span></span></span>.</li>\n</ol>\n<blockquote>\n<p>example: stack with MultiPop(int k, Stack S)</p>\n</blockquote>\n<ol start=\"2\">\n<li>Accounting method<br>\nWhen an operation’s amortized cost is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><msub><mi>c</mi><mi>i</mi></msub><mo>^</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\hat{c_i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord accent\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.69444em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.25em;\"><span class=\"mord\">^</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span> exceeds its actural cost <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">c_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, we assign the dirrerence to specific objects in the data structure as credit. Credit can pay for the later operations whose amortized cost is less than their actual cost.<br>\n 实际成本优于均摊成本，把差额分配给数据结构中的特定对象，表示为 credit, credit 可以帮助支付后续操作的费用，这些操作的摊还成本小于实际成本<br>\n For all sequences of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> operations, we must assure:</li>\n</ol>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mover accent=\"true\"><msub><mi>c</mi><mi>i</mi></msub><mo>^</mo></mover><mo>≥</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\sum_{i=1}^n \\hat{c_i} \\geq \\sum_{i=1}^n c_i\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.929066em;vertical-align:-1.277669em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.6513970000000002em;\"><span style=\"top:-1.872331em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.050005em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∑</span></span></span><span style=\"top:-4.3000050000000005em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.277669em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord accent\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.69444em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.25em;\"><span class=\"mord\">^</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.929066em;vertical-align:-1.277669em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.6513970000000002em;\"><span style=\"top:-1.872331em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.050005em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∑</span></span></span><span style=\"top:-4.3000050000000005em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.277669em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span></p>\n<ul>\n<li>\n<p>当某次操作的 <strong>摊还代价 &gt; 实际代价</strong>（(\\hat {c}_i &gt; c_i)），<br>\n多出来的部分 (\\hat {c}_i - c_i) 被存为 <strong>credit（信用）</strong>，附着在数据结构的某些对象上。</p>\n</li>\n<li>\n<p>当后续某次操作 <strong>实际代价 &gt; 摊还代价</strong>（(c_j&gt; \\hat {c}_j)），<br>\n就用之前存下的 credit 来 “支付” 超出的部分。</p>\n</li>\n</ul>\n<p>但有一个<strong>硬性约束</strong>：</p>\n<blockquote>\n<p><strong>任何时候都不能透支 credit！</strong><br>\n也就是说，在任何前缀操作 (1…k) 中，累计的 credit 必须 ≥ 0。</p>\n</blockquote>\n<p>这等价于要求：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>k</mi><mo separator=\"true\">,</mo><mspace width=\"1em\"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><msub><mover accent=\"true\"><mi>c</mi><mo>^</mo></mover><mi>i</mi></msub><mo>≥</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><msub><mi>c</mi><mi>i</mi></msub></mspace></mrow><annotation encoding=\"application/x-tex\">\\forall k,\\quad \\sum_{i=1}^k \\hat{c}_i \\geq \\sum_{i=1}^k c_i\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:3.1137820000000005em;vertical-align:-1.277669em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.8361130000000003em;\"><span style=\"top:-1.872331em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.050005em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∑</span></span></span><span style=\"top:-4.3000050000000005em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.277669em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.69444em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">c</span></span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.19444em;\"><span class=\"mord\">^</span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:3.1137820000000005em;vertical-align:-1.277669em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.8361130000000003em;\"><span style=\"top:-1.872331em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.050005em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∑</span></span></span><span style=\"top:-4.3000050000000005em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.277669em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span></p>\n<p>特别地，对整个序列（(k = n)）就有：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mover accent=\"true\"><mi>c</mi><mo>^</mo></mover><mi>i</mi></msub><mo>≥</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\sum_{i=1}^n \\hat{c}_i \\geq \\sum_{i=1}^n c_i\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.929066em;vertical-align:-1.277669em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.6513970000000002em;\"><span style=\"top:-1.872331em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.050005em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∑</span></span></span><span style=\"top:-4.3000050000000005em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.277669em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.69444em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">c</span></span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.19444em;\"><span class=\"mord\">^</span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.929066em;vertical-align:-1.277669em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.6513970000000002em;\"><span style=\"top:-1.872331em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.050005em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∑</span></span></span><span style=\"top:-4.3000050000000005em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.277669em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span></p>\n<p><img data-src=\"1202-1.png\" alt><br>\n不同操作的摊还代价可能会不同，</p>\n<ol start=\"3\">\n<li>Potential method<br>\n<img data-src=\"12-5-1.png\" alt></li>\n</ol>\n<details class=\"info\"><summary></summary><div>\n<div class=\"tab\" data-id=\"id3\" data-title=\"例子\">\n<p>2-5 Consider the following buffer management problem. Initially the buffer size (the number of blocks) is one. Each block can accommodate exactly one item. As soon as a new item arrives, check if there is an available block. If yes, put the item into the block, induced a cost of one. Otherwise, the buffer size is doubled, and then the item is able to put into. Moreover, the old items have to be moved into the new buffer so it costs <em>k</em>+1 to make this insertion, where <em>k</em> is the number of old items. Clearly, if there are <em>N</em> items, the worst-case cost for one insertion can be Ω(<em>N</em>). To show that the average cost is <em>O</em>(1), let us turn to the amortized analysis. To simplify the problem, assume that the buffer is full after all the <em>N</em> items are placed. Which of the following potential functions works?</p>\n<p>A. The number of items currently in the buffer</p>\n<p>B. The opposite number of items currently in the buffer</p>\n<p>C. The number of available blocks currently in the buffer</p>\n<p>D. The opposite number of available blocks in the buffer</p>\n</div>\n<p>;;;<br>\nD.<mark> 势能函数需要保证摊还成本都为常数，一个一个试只能选 D</mark><br>\n<img data-src=\"hw.png\" alt><br>\n;;;</p>\n</div></details>\n",
            "tags": [
                "Amortized Analysis"
            ]
        },
        {
            "id": "http://example.com/2025/09/15/computer-science/DS/ch2/",
            "url": "http://example.com/2025/09/15/computer-science/DS/ch2/",
            "title": "ch2",
            "date_published": "2025-09-14T16:00:00.000Z",
            "content_html": "<h1 id=\"ch2-线性表\"><a class=\"markdownIt-Anchor\" href=\"#ch2-线性表\">#</a> Ch2 线性表</h1>\n<p>存储结构：顺序表（数组），链表</p>\n<h2 id=\"顺序表\"><a class=\"markdownIt-Anchor\" href=\"#顺序表\">#</a> 顺序表</h2>\n<p>逻辑顺序和物理顺序一致，都连续<br>\n按下标访问 O (1)，插入操作平均移动 n/2，删除操作平均移动 (n-1)/2</p>\n<figure class=\"highlight c\"><figcaption><span>静态分配</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 50</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    ElemType data[MaxSize];</span><br><span class=\"line\">    <span class=\"type\">int</span> length;</span><br><span class=\"line\">&#125;SqList;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><figcaption><span>动态分配</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> InitSize 100</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    ElemType *data;</span><br><span class=\"line\">    <span class=\"type\">int</span> MaxSize, length;</span><br><span class=\"line\">&#125;SqList;</span><br></pre></td></tr></table></figure>\n<p>初始动态分配：</p>\n<figure class=\"highlight c\"><figcaption><span>c</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L.data = (ElemType*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(ElemType)*InitSize);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>c++</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L.data = <span class=\"keyword\">new</span> ElemType[InitSize];</span><br></pre></td></tr></table></figure>\n<h3 id=\"初始化\"><a class=\"markdownIt-Anchor\" href=\"#初始化\">#</a> 初始化</h3>\n<figure class=\"highlight c++\"><figcaption><span>静态分配初始化</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">InitList</span><span class=\"params\">(SqList &amp;L)</span></span>&#123;</span><br><span class=\"line\">    L.length = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>动态分配初始化</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">InitList</span><span class=\"params\">(SqList &amp;L)</span></span>&#123;</span><br><span class=\"line\">    L.data = (ElemType*)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span>(ElemType)*InitSize);</span><br><span class=\"line\">    L.MaxSize = InitSize;</span><br><span class=\"line\">    L.length = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"插入操作\"><a class=\"markdownIt-Anchor\" href=\"#插入操作\">#</a> 插入操作</h3>\n<p>在顺序表的第 i 个 <code>位置</code> 插入元素 e，注意是位置不是下标 (1&lt;=i&lt;=L.length+1)</p>\n<figure class=\"highlight c++\"><figcaption><span>插入操作</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">ListInsert</span><span class=\"params\">(SqList &amp;L, <span class=\"type\">int</span> i, ElemType e)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i&lt;<span class=\"number\">1</span> || i&gt;L.length<span class=\"number\">+1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L.length &gt;= L.MaxSize) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"built_in\">fot</span>(<span class=\"type\">int</span> j = L.length; j&gt;=i; j--)</span><br><span class=\"line\">        L.data[j] = L.data[j<span class=\"number\">-1</span>];</span><br><span class=\"line\">    L.data[i<span class=\"number\">-1</span>] = e;</span><br><span class=\"line\">    L.length++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>插入移动的平均次数为 n/2，插入算法的平均时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></p>\n<h3 id=\"删除操作\"><a class=\"markdownIt-Anchor\" href=\"#删除操作\">#</a> 删除操作</h3>\n<p>删除顺序表中第 i 个元素，返回删除的元素 e</p>\n<figure class=\"highlight c++\"><figcaption><span>删除操作</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">ListDelete</span><span class=\"params\">(SqList &amp;L, <span class=\"type\">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i&lt;<span class=\"number\">1</span> || i&gt;L.length) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    e = L.data[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = i; j&lt;L.length; j++)</span><br><span class=\"line\">        L.data[j<span class=\"number\">-1</span>] = L.data[j];</span><br><span class=\"line\">    L.length--;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>删除操作的平均移动此时是 (n-1)/2，平均时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></p>\n<h3 id=\"按值查找\"><a class=\"markdownIt-Anchor\" href=\"#按值查找\">#</a> 按值查找</h3>\n<figure class=\"highlight c++\"><figcaption><span>按值查找</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">LocateElem</span><span class=\"params\">(SqList L, ElemType e)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i&lt;L.length; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(L.data[i] == e)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i<span class=\"number\">+1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>平均需要访问 (n+1)/2 个元素，平均时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></p>\n<h2 id=\"单链表\"><a class=\"markdownIt-Anchor\" href=\"#单链表\">#</a> 单链表</h2>\n<h3 id=\"链表结构\"><a class=\"markdownIt-Anchor\" href=\"#链表结构\">#</a> 链表结构</h3>\n<figure class=\"highlight c++\"><figcaption><span>单链表结构</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">LNode</span>&#123;</span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">LNode</span> *next;</span><br><span class=\"line\">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure>\n<h3 id=\"初始化-2\"><a class=\"markdownIt-Anchor\" href=\"#初始化-2\">#</a> 初始化</h3>\n<figure class=\"highlight c++\"><figcaption><span>带头节点的初始化</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">InitList</span><span class=\"params\">(LinkList &amp;L)</span></span>&#123;</span><br><span class=\"line\">    L = (LNode*)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span>(LNode));</span><br><span class=\"line\">    L-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>不带头节点的初始化</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">InitList</span><span class=\"params\">(LinkList &amp;L)</span></span>&#123;</span><br><span class=\"line\">    L = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"求表长\"><a class=\"markdownIt-Anchor\" href=\"#求表长\">#</a> 求表长</h3>\n<p>从头开始遍历，每访问一个节点，长度加 1</p>\n<figure class=\"highlight c++\"><figcaption><span>求表长</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Length</span><span class=\"params\">(LinkList L)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    LNode *p = L;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        len++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"按序号查找\"><a class=\"markdownIt-Anchor\" href=\"#按序号查找\">#</a> 按序号查找</h3>\n<p>从头开始遍历直到找到第 i 个节点</p>\n<figure class=\"highlight c++\"><figcaption><span>按序号查找</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LNode* <span class=\"title\">GetElem</span><span class=\"params\">(LinkList L, <span class=\"type\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    LNode *p = L;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span> &amp;&amp; j&lt;i)&#123;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        j++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"按值查找-2\"><a class=\"markdownIt-Anchor\" href=\"#按值查找-2\">#</a> 按值查找</h3>\n<p>从头开始遍历，如果找到则返回该节点</p>\n<figure class=\"highlight c++\"><figcaption><span>按值查找</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LNode* <span class=\"title\">LocateElem</span><span class=\"params\">(LinkList L, ElemType e)</span></span>&#123;</span><br><span class=\"line\">    LNode *p = L-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span> &amp;&amp; p-&gt;data != e)&#123;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"插入操作-2\"><a class=\"markdownIt-Anchor\" href=\"#插入操作-2\">#</a> 插入操作</h3>\n<p>先把后继连到新节点的后继，再把前继节点的后继连到新节点</p>\n<figure class=\"highlight c++\"><figcaption><span>插入操作</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">ListInsert</span><span class=\"params\">(LinkList &amp;L, <span class=\"type\">int</span> i, ElemType e)</span></span>&#123;</span><br><span class=\"line\">    LNode p = L;</span><br><span class=\"line\">    <span class=\"type\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span> &amp;&amp; j&lt;i<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        j++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    LNode *s = (LNode*)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span>(LNode));</span><br><span class=\"line\">    s-&gt;data = e;</span><br><span class=\"line\">    s-&gt;next = p-&gt;next;</span><br><span class=\"line\">    p-&gt;next = s;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除操作-2\"><a class=\"markdownIt-Anchor\" href=\"#删除操作-2\">#</a> 删除操作</h3>\n<p>先找到待删除节点的前一个节点，再把前一个节点的 next 指向待删除节点的 next，然后释放待删除节点</p>\n<figure class=\"highlight c++\"><figcaption><span>删除操作</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">ListDelete</span><span class=\"params\">(LinkList &amp;L, <span class=\"type\">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class=\"line\">    LNode *p = L;</span><br><span class=\"line\">    <span class=\"type\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span> &amp;&amp; j&lt;i<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        j++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p-&gt;next == <span class=\"literal\">NULL</span> || j&gt;i<span class=\"number\">-1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    LNode *q = p-&gt;next;</span><br><span class=\"line\">    e = q-&gt;data;</span><br><span class=\"line\">    p-&gt;next = q-&gt;next;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(q);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"采用头插法建立单链表\"><a class=\"markdownIt-Anchor\" href=\"#采用头插法建立单链表\">#</a> 采用头插法建立单链表</h3>\n<p>先建立一个头结点，每次插入到头结点之后<br>\n可以用来实现链表逆序，总时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></p>\n<figure class=\"highlight c++\"><figcaption><span>采用头插法建立单链表</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LinkLisk <span class=\"title\">List_HeadInsert</span><span class=\"params\">(LinkList &amp;L)</span></span>&#123;</span><br><span class=\"line\">    LNode *s;</span><br><span class=\"line\">    <span class=\"type\">int</span> x;</span><br><span class=\"line\">    L = (*LNode)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span>(LNode));</span><br><span class=\"line\">    L-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;x);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x != <span class=\"number\">9999</span>)&#123;</span><br><span class=\"line\">        s = (LNode*)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span>(LNode));</span><br><span class=\"line\">        s-&gt;data = x;</span><br><span class=\"line\">        s-&gt;next = L-&gt;next;</span><br><span class=\"line\">        L-&gt;next = s;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"采用尾插法建立单链表\"><a class=\"markdownIt-Anchor\" href=\"#采用尾插法建立单链表\">#</a> 采用尾插法建立单链表</h3>\n<figure class=\"highlight c++\"><figcaption><span>采用尾插法建立单链表</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LinkList <span class=\"title\">List_TailInsert</span><span class=\"params\">(LinkList &amp;L)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x;</span><br><span class=\"line\">    L = (LNode*)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span>(LNode));</span><br><span class=\"line\">    LNode *s, *r = L;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;x);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x != <span class=\"number\">9999</span>)&#123;</span><br><span class=\"line\">        s = (LNode*)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span>(LNode));</span><br><span class=\"line\">        s-&gt;data = x;</span><br><span class=\"line\">        r-&gt;next = s;</span><br><span class=\"line\">        r = s;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    r-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"双链表\"><a class=\"markdownIt-Anchor\" href=\"#双链表\">#</a> 双链表</h2>\n<h3 id=\"双链表结构\"><a class=\"markdownIt-Anchor\" href=\"#双链表结构\">#</a> 双链表结构</h3>\n<figure class=\"highlight c++\"><figcaption><span>双链表结构</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">DNode</span>&#123;</span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">DNode</span> *prior, *next;</span><br><span class=\"line\">&#125;DNode, *DLinkList;</span><br></pre></td></tr></table></figure>\n<h3 id=\"双链表的插入\"><a class=\"markdownIt-Anchor\" href=\"#双链表的插入\">#</a> 双链表的插入</h3>\n<figure class=\"highlight c++\"><figcaption><span>双链表的插入</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s-&gt;next = p-&gt;next;</span><br><span class=\"line\">p-&gt;next-&gt;prior = s;</span><br><span class=\"line\">s-&gt;prior = p;</span><br><span class=\"line\">p-&gt;next = s;</span><br></pre></td></tr></table></figure>\n<h3 id=\"双链表的删除\"><a class=\"markdownIt-Anchor\" href=\"#双链表的删除\">#</a> 双链表的删除</h3>\n<figure class=\"highlight c++\"><figcaption><span>双链表的删除</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p-&gt;next = q-&gt;next;</span><br><span class=\"line\">q-next-&gt;prior = p;</span><br><span class=\"line\"><span class=\"built_in\">free</span>(q);</span><br></pre></td></tr></table></figure>\n<h2 id=\"循环链表\"><a class=\"markdownIt-Anchor\" href=\"#循环链表\">#</a> 循环链表</h2>\n<h3 id=\"循环单链表\"><a class=\"markdownIt-Anchor\" href=\"#循环单链表\">#</a> 循环单链表</h3>\n<h3 id=\"循环双链表\"><a class=\"markdownIt-Anchor\" href=\"#循环双链表\">#</a> 循环双链表</h3>\n<h2 id=\"静态链表\"><a class=\"markdownIt-Anchor\" href=\"#静态链表\">#</a> 静态链表</h2>\n<p>用数组来表示线性表的链式存储结构</p>\n<figure class=\"highlight c++\"><figcaption><span>静态链表结构</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 50</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"type\">int</span> next;   <span class=\"comment\">//下一个元素的数组下标</span></span><br><span class=\"line\">&#125; SlinkList[MaxSize];</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>next = -1 表示结束标志</p>\n</blockquote>\n<h2 id=\"顺序表和链表比较\"><a class=\"markdownIt-Anchor\" href=\"#顺序表和链表比较\">#</a> 顺序表和链表比较</h2>\n<ol>\n<li>存取<br>\n顺序表可以顺序存取 / 随机存取，链表只能顺序</li>\n<li>逻辑结构和物理结构<br>\n顺序表和链表的逻辑结构相同，顺序表物理结构存储连续，链表物理结构存储不一定连续</li>\n<li>删改查的复杂度<br>\n略</li>\n<li>空间分配<br>\n链表的空间分配比较灵活，但存储密度低</li>\n</ol>\n<ul>\n<li>难以估计线性表的长度时不宜采用顺序表</li>\n<li>按序号访问多选顺序表，插入删除多选链表</li>\n</ul>\n",
            "tags": [
                "线性表"
            ]
        },
        {
            "id": "http://example.com/2025/09/15/computer-science/DS/ch1/",
            "url": "http://example.com/2025/09/15/computer-science/DS/ch1/",
            "title": "ch1",
            "date_published": "2025-09-14T16:00:00.000Z",
            "content_html": "<h1 id=\"ch1-绪论\"><a class=\"markdownIt-Anchor\" href=\"#ch1-绪论\">#</a> Ch1 绪论</h1>\n<p>数据<br>\n数据元素是数据的基本单位<br>\n数据对象<br>\n数据类型：原子类型、结构类型、抽象数据类型<br>\n数据结构：三要素包括逻辑结构、存储结构和数据的运算</p>\n<ul>\n<li>逻辑结构：集合、线性结构、树形结构、图状或网状</li>\n<li>存储结构：顺序存储、链式存储、索引存储、散列存储</li>\n<li>数据的运算：定义针对逻辑结构，实现针对存储结构</li>\n</ul>\n<p>算法的特性：又穷行、确定性、可行性、输入、输出<br>\n好的算法还应该考虑：正确性、可读性、健壮性、高效率和低存储量需求</p>\n<p>复杂度：时间复杂度、空间复杂度</p>\n",
            "tags": [
                "数据结构"
            ]
        },
        {
            "id": "http://example.com/2023/10/31/computer-science/DS/fds/",
            "url": "http://example.com/2023/10/31/computer-science/DS/fds/",
            "title": "fds课程笔记",
            "date_published": "2023-10-30T16:00:00.000Z",
            "content_html": "<h1 id=\"fds复习\"><a class=\"markdownIt-Anchor\" href=\"#fds复习\">#</a> FDS 复习</h1>\n<h2 id=\"期中模拟卷\"><a class=\"markdownIt-Anchor\" href=\"#期中模拟卷\">#</a> 期中模拟卷</h2>\n<h5 id=\"1sqrt-n-logn-is-on\"><a class=\"markdownIt-Anchor\" href=\"#1sqrt-n-logn-is-on\">#</a> 1.<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msqrt><mi>N</mi></msqrt><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">\\sqrt N logN</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.121105em;vertical-align:-0.19444em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9266650000000001em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;padding-left:0.833em;\">N</span></span><span style=\"top:-2.886665em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg width=\"400em\" height=\"1.08em\" viewbox=\"0 0 400000 1080\" preserveaspectratio=\"xMinYMin slice\"><path d=\"M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z\"/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.11333499999999996em;\"><span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>.</h5>\n<p>T</p>\n<h5 id=\"2in\"><a class=\"markdownIt-Anchor\" href=\"#2in\">#</a> <span class=\"exturl\" data-url=\"aHR0cDovLzIuSW4=\">2.In</span> <em>Union/Find</em> algorithm, if <em>Unions</em> are done by size, the depth of any node must be no more than N/2 , but not <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(logN)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>.</h5>\n<p>F</p>\n<p>每做一次归并，都会使得小的集合深度加 1，但是总的深度还是看大的集合。只有深度相同的归并才能使得总的深度加 1，2,2 归并，深度变为 3；3,3 归并深度变为 4。因此深度最大为 **<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">log_2 N+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>**.</p>\n<h5 id=\"3for-a-sequentially-stored-linear-list-of-length-n-the-time-complexities-for-query-and-insertion-are\"><a class=\"markdownIt-Anchor\" href=\"#3for-a-sequentially-stored-linear-list-of-length-n-the-time-complexities-for-query-and-insertion-are\">#</a> 3.For a  <code>sequentially stored</code>  linear list of length <em>N</em>, the time complexities for query and insertion are:</h5>\n<p>C.<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>,<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>.</p>\n<p>注意是顺序存储，因此查询只需要<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>, 插入需要调整后面的元素的位置，因此是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>.</p>\n<h5 id=\"4the-following-figure-shows-the-aoe-network-of-a-project-with-8-activities-the-earliest-and-the-latest-start-times-of-the-activity-d-are-__-respectively\"><a class=\"markdownIt-Anchor\" href=\"#4the-following-figure-shows-the-aoe-network-of-a-project-with-8-activities-the-earliest-and-the-latest-start-times-of-the-activity-d-are-__-respectively\">#</a> 4.The following figure shows the AOE network of a project with 8 activities. The earliest and the latest start times of the activity  <code>d</code>  are __, respectively.</h5>\n<p><img data-src=\"https://images.ptausercontent.com/28de33de-076f-4f94-b856-445865994fb0.jpg\" alt=\"GRE19-5.jpg\"></p>\n<p>还没学，下次再来补</p>\n<h5 id=\"5if-besides-finding-the-shortest-path-from-s-to-every-other-vertices-we-also-need-to-count-the-number-of-different-shortest-paths-we-can-modify-the-dijkstra-algorithm-in-the-following-way-add-an-array-count-so-that-countv-records-the-number-of-different-shortest-paths-from-s-to-v-then-countv-shall-be-initialized-as\"><a class=\"markdownIt-Anchor\" href=\"#5if-besides-finding-the-shortest-path-from-s-to-every-other-vertices-we-also-need-to-count-the-number-of-different-shortest-paths-we-can-modify-the-dijkstra-algorithm-in-the-following-way-add-an-array-count-so-that-countv-records-the-number-of-different-shortest-paths-from-s-to-v-then-countv-shall-be-initialized-as\">#</a> 5.If besides finding the shortest path from  <code>S</code>  to every other vertices, we also need to count the number of different shortest paths, we can modify the Dijkstra algorithm in the following way: add an array  <code>count[]</code>  so that  <code>count[V]</code>  records the number of different shortest paths from  <code>S</code>  to  <code>V</code> . Then  <code>count[V]</code>  shall be initialized as:</h5>\n<p>A. count[S]=1; and count[V]=0 for other V</p>\n<p>还没学应该不考，下次再来补</p>\n<h5 id=\"6程序填空题-reverse-linked-list\"><a class=\"markdownIt-Anchor\" href=\"#6程序填空题-reverse-linked-list\">#</a> 6. 程序填空题  Reverse Linked List</h5>\n<p>The function is to return the reverse linked list of  <code>L</code> , with a dummy head.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List <span class=\"title function_\">Reverse</span><span class=\"params\">( List L )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Position Old_head, New_head, Temp;</span><br><span class=\"line\">    New_head = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    Old_head = L-&gt;Next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( Old_head )  &#123;</span><br><span class=\"line\">        Temp = Old_head-&gt;Next;</span><br><span class=\"line\">        Old_head-&gt;Next = New_head;</span><br><span class=\"line\">        New_head = Old_head;  </span><br><span class=\"line\">        Old_head = Temp; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    L-&gt;Next = New_head;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>先把下一个节点用 temp 存起来，然后把当前节点指向上一个节点，然后移动上一个节点的指针到当前节点，把当前节点指针移动到下一节点。</p>\n<h5 id=\"7程序填空题-minheap-deletion\"><a class=\"markdownIt-Anchor\" href=\"#7程序填空题-minheap-deletion\">#</a> 7. 程序填空题  MinHeap Deletion</h5>\n<p>Please fill in the blanks in the program which deletes a given element at position  <code>p</code>  from a min-heap  <code>H</code> .</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Deletion ( PriorityQueue H,  <span class=\"type\">int</span> p )  <span class=\"comment\">/* delete the element H-&gt;Elements[p] */</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   ElementType temp;</span><br><span class=\"line\">   <span class=\"type\">int</span> child;</span><br><span class=\"line\"></span><br><span class=\"line\">   temp = H-&gt; Elements[ H-&gt;Size-- ];</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( temp &lt; H-&gt;Elements[p] ) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> ( (p != <span class=\"number\">1</span>) &amp;&amp; (temp &lt; H-&gt;Elements[p/<span class=\"number\">2</span>]) ) &#123; </span><br><span class=\"line\">         H-&gt;Elements[p] = H-&gt;Elements[p/<span class=\"number\">2</span>]；</span><br><span class=\"line\">         p /= <span class=\"number\">2</span>;</span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">while</span>( (child = <span class=\"number\">2</span>*p) &lt;= H-&gt;Size) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> ( child != H-&gt;Size &amp;&amp; H-&gt;Elements[child] &lt; H-&gt;Elements[child + <span class=\"number\">1</span>] )</span><br><span class=\"line\">            child ++;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> ( temp &gt; H-&gt;Elements[child] ) &#123;</span><br><span class=\"line\">            H-&gt;Elements[p] = H-&gt;Elements[child];</span><br><span class=\"line\">            p = child;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   H-&gt;Elements[p] = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"hw1\"><a class=\"markdownIt-Anchor\" href=\"#hw1\">#</a> HW1</h2>\n<h5 id=\"1-2-the-fibonacci-number-sequence-f_n-is-defined-as-f_00f_11-f_nf_n-1f_n-2-n2-3-the-time-complexity-of-the-function-which-calculates-f_n-recursively-is-thetan\"><a class=\"markdownIt-Anchor\" href=\"#1-2-the-fibonacci-number-sequence-f_n-is-defined-as-f_00f_11-f_nf_n-1f_n-2-n2-3-the-time-complexity-of-the-function-which-calculates-f_n-recursively-is-thetan\">#</a> 1-2 The Fibonacci number sequence {<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>F</mi><mi>N</mi></msub></mrow><annotation encoding=\"application/x-tex\">F_N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>} is defined as: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>F</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn><mo separator=\"true\">,</mo><msub><mi>F</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn><mo separator=\"true\">,</mo></mrow><annotation encoding=\"application/x-tex\">F_0=0,F_1=1,</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span></span></span></span> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>F</mi><mi>N</mi></msub><mo>=</mo><msub><mi>F</mi><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>F</mi><mrow><mi>N</mi><mo>−</mo><mn>2</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">F_N=F_{N-1}+F_{N-2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.891661em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.328331em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.891661em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.328331em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span>, <em>N</em>=2, 3, … The time complexity of the function which calculates <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>F</mi><mi>N</mi></msub></mrow><annotation encoding=\"application/x-tex\">F_N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> recursively is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Θ</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">!</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\Theta(N!)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">Θ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">!</span><span class=\"mclose\">)</span></span></span></span>.</h5>\n<p>F</p>\n<p>递归求斐波那契数的时间复杂度是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mn>2</mn><mi>N</mi></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(2^N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0913309999999998em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>.</p>\n<p>二叉树的高度是 n-1，一个高度为 k 的二叉树最多可以由 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2^k-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.932438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 个叶子节点，也就是递归过程函数调用的次数，所以时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mn>2</mn><mi>N</mi></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(2^N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0913309999999998em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，而空间复杂度就是树的高度 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">S(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>.</p>\n<h5 id=\"2-1-given-the-following-four-algorithms-with-their-runtimes-for-problem-size-100-and-their-time-complexities\"><a class=\"markdownIt-Anchor\" href=\"#2-1-given-the-following-four-algorithms-with-their-runtimes-for-problem-size-100-and-their-time-complexities\">#</a> 2-1 Given the following four algorithms with their runtimes for problem size 100 and their time complexities:</h5>\n<table>\n<thead>\n<tr>\n<th>Algorithm</th>\n<th>Runtime</th>\n<th>Time Complexity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A</td>\n<td>100</td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></td>\n</tr>\n<tr>\n<td>B</td>\n<td>50</td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></td>\n</tr>\n<tr>\n<td>C</td>\n<td>2</td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>N</mi><mn>3</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N^3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></td>\n</tr>\n<tr>\n<td>D</td>\n<td>10</td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>N</mi><mn>4</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N^4)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></td>\n</tr>\n</tbody>\n</table>\n<p><strong>Which algorithm is the fastest for problem size 200?</strong></p>\n<p>D</p>\n<p>200 = 100*2</p>\n<p>A 100*2 = 200</p>\n<p>B 50 * <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">2^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>=200</p>\n<p>C 25*<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup></mrow><annotation encoding=\"application/x-tex\">2^3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span></span></span></span>=200</p>\n<p><mark>D 10*<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>4</mn></msup></mrow><annotation encoding=\"application/x-tex\">2^4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span></span></span></span></span></span></span></span>=160 最快</mark></p>\n<h5 id=\"2-3-the-recurrent-equations-for-the-time-complexities-of-programs-p1-and-p2-are\"><a class=\"markdownIt-Anchor\" href=\"#2-3-the-recurrent-equations-for-the-time-complexities-of-programs-p1-and-p2-are\">#</a> 2-3 The recurrent equations for the time complexities of programs P1 and P2 are:</h5>\n<ul>\n<li>P1: <em>T</em>(1)=1,<em>T</em>(<em>N</em>)=<em>T</em>(<em>N</em>/3)+1</li>\n<li>P2: <em>T</em>(1)=1,<em>T</em>(<em>N</em>)=3<em>T</em>(<em>N</em>/3)+1</li>\n</ul>\n<p>Then the correct conclusion about their time complexities is:</p>\n<p>A.they are both <em>O</em>(log<em>N</em>)</p>\n<p>B.O*(log*N) for P1, <em>O</em>(<em>N</em>) for P2</p>\n<p>C.they are both <em>O</em>(<em>N</em>)</p>\n<p>D.<em>O</em>(log<em>N</em>) for P1, <em>O</em>(<em>N</em>log<em>N</em>) for P2</p>\n<p><strong>B</strong></p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mi mathvariant=\"normal\">/</mi><mn>3</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mi mathvariant=\"normal\">/</mi><mn>3</mn><mi mathvariant=\"normal\">/</mi><mn>3</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>=</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo>=</mo><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T(N)=T(N/3)+1=T(N/3/3)+1+1=...=O(logN)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord\">/</span><span class=\"mord\">3</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord\">/</span><span class=\"mord\">3</span><span class=\"mord\">/</span><span class=\"mord\">3</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>3</mn><mi>T</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mi mathvariant=\"normal\">/</mi><mn>3</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn><mo stretchy=\"false\">(</mo><mn>3</mn><mi>T</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mi mathvariant=\"normal\">/</mi><mn>3</mn><mi mathvariant=\"normal\">/</mi><mn>3</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo>=</mo><msup><mn>3</mn><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>3</mn></msub><mi>N</mi></mrow></msup><mo>=</mo><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T(N)=3T(N/3)+1=3(3T(N/3/3)+1)+1=...=3^{log_3N}=O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">3</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord\">/</span><span class=\"mord\">3</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">3</span><span class=\"mopen\">(</span><span class=\"mord\">3</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord\">/</span><span class=\"mord\">3</span><span class=\"mord\">/</span><span class=\"mord\">3</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8491079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">3</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31731428571428577em;\"><span style=\"top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></p>\n<h5 id=\"r1-2-logn2is-on\"><a class=\"markdownIt-Anchor\" href=\"#r1-2-logn2is-on\">#</a> R1-2 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><msup><mo stretchy=\"false\">)</mo><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">(logN)^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>.</h5>\n<p>T</p>\n<p>记住即可</p>\n<h5 id=\"r1-3-the-time-comlexity-of-selection-sort-will-be-the-same-no-matter-we-store-the-elements-in-an-array-or-a-linked-list\"><a class=\"markdownIt-Anchor\" href=\"#r1-3-the-time-comlexity-of-selection-sort-will-be-the-same-no-matter-we-store-the-elements-in-an-array-or-a-linked-list\">#</a> R1-3 The time comlexity of Selection Sort will be the same no matter we store the elements in an array or a linked list.</h5>\n<p>T</p>\n<h2 id=\"hw2\"><a class=\"markdownIt-Anchor\" href=\"#hw2\">#</a> HW2</h2>\n<h5 id=\"1-1-for-a-sequentially-stored-linear-list-of-length-n-the-time-complexities-for-deleting-the-first-element-and-inserting-the-last-element-are-o1-and-on-respectively\"><a class=\"markdownIt-Anchor\" href=\"#1-1-for-a-sequentially-stored-linear-list-of-length-n-the-time-complexities-for-deleting-the-first-element-and-inserting-the-last-element-are-o1-and-on-respectively\">#</a> 1-1 For a  <code>sequentially stored</code>  linear list of length <em>N</em>, the time complexities for deleting the first element and inserting the last element are <em>O</em>(1) and <em>O</em>(<em>N</em>), respectively.</h5>\n<p>F</p>\n<p>注意是顺序存储的。删除第一个节点需要把后面的都往前移动一个位置，所以是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>，插入最后一个节点是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<p>对于顺序存储的长度为 N 的线性表，访问节点的时间复杂度是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>（线性存储，直接按标号访问就可以了），插入的时间复杂度是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>（要调整后面的元素的位置）。</p>\n<h5 id=\"2-3-to-merge-two-singly-linked-ascending-lists-both-with-n-nodes-into-one-singly-linked-ascending-list-the-minimum-possible-number-of-comparisons-is\"><a class=\"markdownIt-Anchor\" href=\"#2-3-to-merge-two-singly-linked-ascending-lists-both-with-n-nodes-into-one-singly-linked-ascending-list-the-minimum-possible-number-of-comparisons-is\">#</a> 2-3 To merge two singly linked ascending lists, both with <em>N</em> nodes, into one singly linked ascending list, the minimum possible number of comparisons is:</h5>\n<p>B.<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></p>\n<p>最少比较的次数就是第一个链表的每个节点都和第二个链表的头节点比较一次，所以是 N</p>\n<h4 id=\"函数题\"><a class=\"markdownIt-Anchor\" href=\"#函数题\">#</a> 函数题</h4>\n<h5 id=\"6-1-add-two-polynomials\"><a class=\"markdownIt-Anchor\" href=\"#6-1-add-two-polynomials\">#</a> 6-1 Add Two Polynomials</h5>\n<p>Write a function to add two polynomials. Do not destroy the input. Use a linked list implementation with a dummy head node.<br>\nNote: The zero polynomial is represented by an empty list with only the dummy head node.</p>\n<h3 id=\"format-of-functions\"><a class=\"markdownIt-Anchor\" href=\"#format-of-functions\">#</a> Format of functions:</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Polynomial <span class=\"title function_\">Add</span><span class=\"params\">( Polynomial a, Polynomial b )</span>;</span><br></pre></td></tr></table></figure>\n<p>where  <code>Polynomial</code>  is defined as the following:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> *<span class=\"title\">PtrToNode</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> Coefficient;</span><br><span class=\"line\">    <span class=\"type\">int</span> Exponent;</span><br><span class=\"line\">    PtrToNode Next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToNode Polynomial;</span><br><span class=\"line\"><span class=\"comment\">/* Nodes are sorted in decreasing order of exponents.*/</span>  </span><br></pre></td></tr></table></figure>\n<p>The function  <code>Add</code>  is supposed to return a polynomial which is the sum of  <code>a</code>  and  <code>b</code> .</p>\n<h3 id=\"sample-program-of-judge\"><a class=\"markdownIt-Anchor\" href=\"#sample-program-of-judge\">#</a> Sample program of judge:</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> *<span class=\"title\">PtrToNode</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>  &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> Coefficient;</span><br><span class=\"line\">    <span class=\"type\">int</span> Exponent;</span><br><span class=\"line\">    PtrToNode Next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToNode Polynomial;</span><br><span class=\"line\"></span><br><span class=\"line\">Polynomial <span class=\"title function_\">Read</span><span class=\"params\">()</span>; <span class=\"comment\">/* details omitted */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Print</span><span class=\"params\">( Polynomial p )</span>; <span class=\"comment\">/* details omitted */</span></span><br><span class=\"line\">Polynomial <span class=\"title function_\">Add</span><span class=\"params\">( Polynomial a, Polynomial b )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Polynomial a, b, s;</span><br><span class=\"line\">    a = Read();</span><br><span class=\"line\">    b = Read();</span><br><span class=\"line\">    s = Add(a, b);</span><br><span class=\"line\">    Print(s);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Your function will be put here */</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"sample-input\"><a class=\"markdownIt-Anchor\" href=\"#sample-input\">#</a> Sample Input:</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4</span><br><span class=\"line\">3 4 -5 2 6 1 -2 0</span><br><span class=\"line\">3</span><br><span class=\"line\">5 20 -7 4 3 1</span><br></pre></td></tr></table></figure>\n<h3 id=\"sample-output\"><a class=\"markdownIt-Anchor\" href=\"#sample-output\">#</a> Sample Output:</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5 20 -4 4 -5 2 9 1 -2 0</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Polynomial <span class=\"title function_\">Add</span><span class=\"params\">( Polynomial a, Polynomial b )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//如果有一个为空则直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(b==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    <span class=\"comment\">//head用于保存头结点，pre用于遍历，tmp用于产生新节点</span></span><br><span class=\"line\">    Polynomial head,pre,tmp;</span><br><span class=\"line\">    pre=(<span class=\"keyword\">struct</span> Node*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> Node));<span class=\"comment\">//申请内存</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    head=pre;<span class=\"comment\">//head保存头结点</span></span><br><span class=\"line\">    a=a-&gt;Next;<span class=\"comment\">//因为有头结点，所以需要next一下寻找第一个元素</span></span><br><span class=\"line\">    b=b-&gt;Next;<span class=\"comment\">//因为有头结点，所以需要next一下寻找第一个元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(a!=<span class=\"literal\">NULL</span>&amp;&amp;b!=<span class=\"literal\">NULL</span>)&#123;<span class=\"comment\">//两多项式都没遍历完</span></span><br><span class=\"line\">    </span><br><span class=\"line\">        tmp=(Polynomial)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Polynomial));  </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a-&gt;Exponent == b-&gt;Exponent)&#123;</span><br><span class=\"line\">            tmp-&gt;Exponent=a-&gt;Exponent;</span><br><span class=\"line\">            tmp-&gt;Coefficient=a-&gt;Coefficient+b-&gt;Coefficient;</span><br><span class=\"line\">            a=a-&gt;Next;</span><br><span class=\"line\">            b=b-&gt;Next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp-&gt;Coefficient==<span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;<span class=\"comment\">//系数可能为0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a-&gt;Exponent&gt;b-&gt;Exponent)&#123;</span><br><span class=\"line\">            tmp-&gt;Exponent=a-&gt;Exponent;</span><br><span class=\"line\">            tmp-&gt;Coefficient=a-&gt;Coefficient;</span><br><span class=\"line\">            a=a-&gt;Next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            tmp-&gt;Exponent=b-&gt;Exponent;</span><br><span class=\"line\">            tmp-&gt;Coefficient=b-&gt;Coefficient;</span><br><span class=\"line\">            b=b-&gt;Next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        tmp-&gt;Next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        pre-&gt;Next=tmp;<span class=\"comment\">//pre遍历</span></span><br><span class=\"line\">        pre=tmp;<span class=\"comment\">//遍历</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//其中一个多项式遍历完了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a!=<span class=\"literal\">NULL</span>&amp;&amp;b==<span class=\"literal\">NULL</span>) pre-&gt;Next=a;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a==<span class=\"literal\">NULL</span>&amp;&amp;b!=<span class=\"literal\">NULL</span>) pre-&gt;Next=b;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h5 id=\"6-2-reverse-linked-list\"><a class=\"markdownIt-Anchor\" href=\"#6-2-reverse-linked-list\">#</a> 6-2 Reverse Linked List</h5>\n<p>Write a nonrecursive procedure to reverse a singly linked list in <em>O</em>(<em>N</em>) time using constant extra space.</p>\n<h3 id=\"format-of-functions-2\"><a class=\"markdownIt-Anchor\" href=\"#format-of-functions-2\">#</a> Format of functions:</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List <span class=\"title function_\">Reverse</span><span class=\"params\">( List L )</span>;</span><br></pre></td></tr></table></figure>\n<p>where  <code>List</code>  is defined as the following:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> *PtrToNode;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToNode List;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToNode Position;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">    ElementType Element;</span><br><span class=\"line\">    Position Next;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>The function  <code>Reverse</code>  is supposed to return the reverse linked list of  <code>L</code> , with a dummy header.</p>\n<h3 id=\"sample-program-of-judge-2\"><a class=\"markdownIt-Anchor\" href=\"#sample-program-of-judge-2\">#</a> Sample program of judge:</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> ElementType;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> *<span class=\"title\">PtrToNode</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToNode List;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToNode Position;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">    ElementType Element;</span><br><span class=\"line\">    Position Next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">List <span class=\"title function_\">Read</span><span class=\"params\">()</span>; <span class=\"comment\">/* details omitted */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Print</span><span class=\"params\">( List L )</span>; <span class=\"comment\">/* details omitted */</span></span><br><span class=\"line\">List <span class=\"title function_\">Reverse</span><span class=\"params\">( List L )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    List L1, L2;</span><br><span class=\"line\">    L1 = Read();</span><br><span class=\"line\">    L2 = Reverse(L1);</span><br><span class=\"line\">    Print(L1);</span><br><span class=\"line\">    Print(L2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Your function will be put here */</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"sample-input-2\"><a class=\"markdownIt-Anchor\" href=\"#sample-input-2\">#</a> Sample Input:</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">1 3 4 5 2</span><br></pre></td></tr></table></figure>\n<h3 id=\"sample-output-2\"><a class=\"markdownIt-Anchor\" href=\"#sample-output-2\">#</a> Sample Output:</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2 5 4 3 1</span><br><span class=\"line\">2 5 4 3 1</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List <span class=\"title function_\">Reverse</span><span class=\"params\">( List L )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    PtrToNode p = <span class=\"literal\">NULL</span>, q = <span class=\"literal\">NULL</span>, r = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    p = L-&gt;Next;</span><br><span class=\"line\">    r = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L-&gt;Next == <span class=\"literal\">NULL</span> || p-&gt;Next == <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> L;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p)&#123;</span><br><span class=\"line\">        q = p-&gt;Next;</span><br><span class=\"line\">        p-&gt;Next = r;</span><br><span class=\"line\">        r = p;</span><br><span class=\"line\">        p = q;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    L-&gt;Next = r;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>见期中模拟卷</p>\n<h3 id=\"线性表\"><a class=\"markdownIt-Anchor\" href=\"#线性表\">#</a> <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODAyNTMxNS9hcnRpY2xlL2RldGFpbHMvMTE5Nzc4MDY4\">线性表</span></h3>\n<h4 id=\"线性表的定义与操作顺序表\"><a class=\"markdownIt-Anchor\" href=\"#线性表的定义与操作顺序表\">#</a> 线性表的定义与操作–顺序表</h4>\n<p>顺序表是用一段<strong>物理地址连续的存储单元</strong>依次存储数据元素的线性结构，一般情况下采用数组存储。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> Position;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">List</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> &#123;</span> </span><br><span class=\"line\">    ElementType Data[MAXSIZE];</span><br><span class=\"line\">    Position Last;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 初始化 */</span></span><br><span class=\"line\">List <span class=\"title function_\">MakeEmpty</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    List L; </span><br><span class=\"line\">    L = (List)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> LNode)); </span><br><span class=\"line\">    L-&gt;Last = <span class=\"number\">-1</span>; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> L;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 查找 */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ERROR -1</span></span><br><span class=\"line\">Position <span class=\"title function_\">Find</span><span class=\"params\">( List L, ElementType X )</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    Position i = <span class=\"number\">0</span>; </span><br><span class=\"line\">    <span class=\"keyword\">while</span>( i &lt;= L-&gt;Last &amp;&amp; L-&gt;Data[i]!= X ) </span><br><span class=\"line\">        i++; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( i &gt; L-&gt;Last ) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ERROR; <span class=\"comment\">/* 如果没找到，返回错误信息 */</span> </span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> i; <span class=\"comment\">/* 找到后返回的是存储位置 */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 插入 */</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Insert</span><span class=\"params\">( List L, ElementType X, Position P )</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    <span class=\"comment\">/* 在L的指定位置P前插入一个新元素X */</span> </span><br><span class=\"line\">    Position i; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( L-&gt;Last == MAXSIZE<span class=\"number\">-1</span>) &#123; <span class=\"comment\">/* 表空间已满，不能插入 */</span> </span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;表满&quot;</span>); </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( P&lt;<span class=\"number\">0</span> || P&gt;L-&gt;Last+<span class=\"number\">1</span> ) &#123; <span class=\"comment\">/* 检查插入位置的合法性 */</span> </span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;位置不合法&quot;</span>); </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">for</span>( i=L-&gt;Last; i&gt;=P; i-- ) </span><br><span class=\"line\">        L-&gt;Data[i+<span class=\"number\">1</span>] = L-&gt;Data[i]; <span class=\"comment\">/* 将位置P及以后的元素顺序向后移动 */</span> </span><br><span class=\"line\">    L-&gt;Data[P] = X; <span class=\"comment\">/* 新元素插入 */</span> </span><br><span class=\"line\">    L-&gt;Last++; <span class=\"comment\">/* Last仍指向最后元素 */</span> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 删除 */</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Delete</span><span class=\"params\">( List L, Position P )</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    <span class=\"comment\">/* 从L中删除指定位置P的元素 */</span> </span><br><span class=\"line\">    Position i; </span><br><span class=\"line\">    <span class=\"keyword\">if</span>( P&lt;<span class=\"number\">0</span> || P&gt;L-&gt;Last ) &#123; <span class=\"comment\">/* 检查空表及删除位置的合法性 */</span> </span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;位置%d不存在元素&quot;</span>, P ); </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">for</span>( i=P+<span class=\"number\">1</span>; i&lt;=L-&gt;Last; i++ ) </span><br><span class=\"line\">        L-&gt;Data[i<span class=\"number\">-1</span>] = L-&gt;Data[i]; <span class=\"comment\">/* 将位置P+1及以后的元素顺序向前移动 */</span> </span><br><span class=\"line\">    L-&gt;Last--; <span class=\"comment\">/* Last仍指向最后元素 */</span> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"线性表的定义与操作链表\"><a class=\"markdownIt-Anchor\" href=\"#线性表的定义与操作链表\">#</a> 线性表的定义与操作–<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Vkd2FyZF9Bc2lhL2FydGljbGUvZGV0YWlscy8xMjA4NzYzMTQ=\">链表</span></h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">PtrToLNode</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> &#123;</span> </span><br><span class=\"line\">    ElementType Data; </span><br><span class=\"line\">    PtrToLNode Next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToLNode Position;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToLNode List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 查找 */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ERROR NULL</span></span><br><span class=\"line\">Position <span class=\"title function_\">Find</span><span class=\"params\">( List L, ElementType X )</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    Position p = L; <span class=\"comment\">/* p指向L的第1个结点 */</span> </span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( p &amp;&amp; p-&gt;Data!=X ) </span><br><span class=\"line\">        p = p-&gt;Next; </span><br><span class=\"line\">    <span class=\"comment\">/* 下列语句可以用 return p; 替换 */</span> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( p ) <span class=\"keyword\">return</span> p; </span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 带头结点的插入 */</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Insert</span><span class=\"params\">( List L, ElementType X, Position P )</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    <span class=\"comment\">/* 这里默认L有头结点 */</span> </span><br><span class=\"line\">    Position tmp, pre; </span><br><span class=\"line\">    <span class=\"comment\">/* 查找P的前一个结点 */</span> </span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( pre=L; pre&amp;&amp;pre-&gt;Next!=P; pre=pre-&gt;Next ) ; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( pre==<span class=\"literal\">NULL</span> ) &#123; </span><br><span class=\"line\">        <span class=\"comment\">/* P所指的结点不在L中 */</span> </span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;插入位置参数错误\\n&quot;</span>); </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">/* 找到了P的前一个结点pre */</span> </span><br><span class=\"line\">        <span class=\"comment\">/* 在P前插入新结点 */</span> </span><br><span class=\"line\">        tmp = (Position)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> LNode)); </span><br><span class=\"line\">        <span class=\"comment\">/* 申请、填装结点 */</span> </span><br><span class=\"line\">        tmp-&gt;Data = X; </span><br><span class=\"line\">        tmp-&gt;Next = P; </span><br><span class=\"line\">        pre-&gt;Next = tmp; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 带头结点的删除 */</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Delete</span><span class=\"params\">( List L, Position P )</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    <span class=\"comment\">/* 这里默认L有头结点 */</span> </span><br><span class=\"line\">    Position pre; </span><br><span class=\"line\">    <span class=\"comment\">/* 查找P的前一个结点 */</span> </span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( pre=L; pre&amp;&amp;pre-&gt;Next!=P; pre=pre-&gt;Next ) ; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( pre==<span class=\"literal\">NULL</span> || P==<span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* P所指的结点不在L中 */</span> </span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;删除位置参数错误\\n&quot;</span>); </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">/* 找到了P的前一个结点pre */</span> </span><br><span class=\"line\">        <span class=\"comment\">/* 将P位置的结点删除 */</span> </span><br><span class=\"line\">        pre-&gt;Next = P-&gt;Next; </span><br><span class=\"line\">        <span class=\"built_in\">free</span>(P); </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>If N numbers are stored in a singly linked list in increasing order, then the average time complexity for binary search is O(logN).</strong></p>\n<p>F</p>\n<p>链表不能用二分查找，只能从头开始遍历</p>\n<h2 id=\"hw3\"><a class=\"markdownIt-Anchor\" href=\"#hw3\">#</a> HW3</h2>\n<h5 id=\"2-1-push-5-characters-ooops-onto-a-stack-in-how-many-different-ways-that-we-can-pop-these-characters-and-still-obtain-ooops\"><a class=\"markdownIt-Anchor\" href=\"#2-1-push-5-characters-ooops-onto-a-stack-in-how-many-different-ways-that-we-can-pop-these-characters-and-still-obtain-ooops\">#</a> 2-1 Push 5 characters  <code>ooops</code>  onto a stack. In how many different ways that we can pop these characters and still obtain  <code>ooops</code> ?</h5>\n<p>C.5</p>\n<p>stack-FILO</p>\n<p>queue-FIFO</p>\n<h5 id=\"2-3-suppose-that-an-array-of-size-6-is-used-to-store-a-circular-queue-and-the-values-of-front-and-rear-are-0-and-4-respectively-now-after-2-dequeues-and-2-enqueues-what-will-the-values-of-front-and-rear-be\"><a class=\"markdownIt-Anchor\" href=\"#2-3-suppose-that-an-array-of-size-6-is-used-to-store-a-circular-queue-and-the-values-of-front-and-rear-are-0-and-4-respectively-now-after-2-dequeues-and-2-enqueues-what-will-the-values-of-front-and-rear-be\">#</a> 2-3 Suppose that an array of size 6 is used to store a circular queue, and the values of  <code>front</code>  and  <code>rear</code>  are 0 and 4, respectively. Now after 2 dequeues and 2 enqueues, what will the values of  <code>front</code>  and  <code>rear</code>  be?</h5>\n<pre class=\"mermaid\">graph LR;\n0-->1;\n1-->2;\n2-->3;\n3-->4;\n4-->5;\n5-->0;</pre>\n<p>In circular queue:</p>\n<p>Rear = 0, front = 1</p>\n<p>Empty: Rear = front-1</p>\n<p>When enqueue, rear ++</p>\n<p>When dequeue, front++</p>\n<p>front = 0 + 2 = 2</p>\n<p>rear = (4 + 2)%6 = 0</p>\n<h4 id=\"编程题\"><a class=\"markdownIt-Anchor\" href=\"#编程题\">#</a> 编程题</h4>\n<h5 id=\"7-1-pop-sequence\"><a class=\"markdownIt-Anchor\" href=\"#7-1-pop-sequence\">#</a> 7-1 Pop Sequence</h5>\n<p>Given a stack which can keep <em>M</em> numbers at most. Push <em>N</em> numbers in the order of 1, 2, 3, …, <em>N</em> and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if <em>M</em> is 5 and <em>N</em> is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.</p>\n<h3 id=\"input-specification\"><a class=\"markdownIt-Anchor\" href=\"#input-specification\">#</a> Input Specification:</h3>\n<p>Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): <em>M</em> (the maximum capacity of the stack), <em>N</em> (the length of push sequence), and <em>K</em> (the number of pop sequences to be checked). Then <em>K</em> lines follow, each contains a pop sequence of <em>N</em> numbers. All the numbers in a line are separated by a space.</p>\n<h3 id=\"output-specification\"><a class=\"markdownIt-Anchor\" href=\"#output-specification\">#</a> Output Specification:</h3>\n<p>For each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not.</p>\n<h3 id=\"sample-input-3\"><a class=\"markdownIt-Anchor\" href=\"#sample-input-3\">#</a> Sample Input:</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5 7 5</span><br><span class=\"line\">1 2 3 4 5 6 7</span><br><span class=\"line\">3 2 1 7 5 6 4</span><br><span class=\"line\">7 6 5 4 3 2 1</span><br><span class=\"line\">5 6 4 3 7 2 1</span><br><span class=\"line\">1 7 6 5 4 3 2</span><br></pre></td></tr></table></figure>\n<h3 id=\"sample-output-3\"><a class=\"markdownIt-Anchor\" href=\"#sample-output-3\">#</a> Sample Output:</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">YES</span><br><span class=\"line\">NO</span><br><span class=\"line\">NO</span><br><span class=\"line\">YES</span><br><span class=\"line\">NO</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> m, n, k;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d %d&quot;</span>,&amp;m, &amp;n, &amp;k);</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"built_in\">stack</span>[n], pop[n], result[k];</span><br><span class=\"line\">    <span class=\"type\">int</span> i, j;</span><br><span class=\"line\">    <span class=\"type\">int</span> ptr_s = <span class=\"number\">0</span>, ptr_p = <span class=\"number\">0</span>, element = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i&lt;k; i++)&#123;</span><br><span class=\"line\">        ptr_s =<span class=\"number\">0</span>, ptr_p = <span class=\"number\">0</span>, element = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; j&lt;n; j++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;pop[j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(ptr_p&lt;n)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(element == pop[ptr_p]&amp;&amp;ptr_s&lt;m)&#123;</span><br><span class=\"line\">                element++;</span><br><span class=\"line\">                ptr_p++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">stack</span>[ptr_s<span class=\"number\">-1</span>] == pop[ptr_p] &amp;&amp; ptr_s&gt;=<span class=\"number\">0</span> &amp;&amp; ptr_s&lt;=m)&#123;</span><br><span class=\"line\">                ptr_p++;</span><br><span class=\"line\">                ptr_s--;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(element&lt;=n &amp;&amp; ptr_s&lt;=m)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">stack</span>[ptr_s] = element;</span><br><span class=\"line\">                ptr_s++;</span><br><span class=\"line\">                element++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ptr_p&lt;n)&#123;</span><br><span class=\"line\">            result[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            result[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i&lt;k; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(result[i] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;NO\\n&quot;</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;YES\\n&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>新开一个栈用来存 1234567，然后依次比较用来 pop 栈顶元素和 popseq 的栈的元素，相等就 pop。</p>\n<h2 id=\"hw4\"><a class=\"markdownIt-Anchor\" href=\"#hw4\">#</a> HW4</h2>\n<h5 id=\"1-1-it-is-always-possible-to-represent-a-tree-by-a-one-dimensional-integer-array\"><a class=\"markdownIt-Anchor\" href=\"#1-1-it-is-always-possible-to-represent-a-tree-by-a-one-dimensional-integer-array\">#</a> 1-1 It is always possible to represent a tree by a one-dimensional integer array.</h5>\n<p>T</p>\n<p>二叉树可以经过前序遍历、中序遍历、后序遍历得到一维数组。其他 degree 的树也同理。</p>\n<h5 id=\"1-2-there-exists-a-binary-tree-with-2016-nodes-in-total-and-with-16-nodes-having-only-one-child\"><a class=\"markdownIt-Anchor\" href=\"#1-2-there-exists-a-binary-tree-with-2016-nodes-in-total-and-with-16-nodes-having-only-one-child\">#</a> 1-2 There exists a binary tree with 2016 nodes in total, and with 16 nodes having only one child.</h5>\n<p>F</p>\n<p>假设没有孩子的结点（叶结点）个数为 n₀，只有一个孩子的结点（度为 1 的结点）个数为 n₁，有两个孩子的结点（度为 2 的结点）个数为 n₂。<br>\n则 n₀+n₁+n₂=2016<br>\n<mark>∵n₀=n₂+1（二叉树的性质：叶结点个数等于度为 2 的结点个数加 1）</mark><br>\n∴n₀+n₁+n₂=2016<br>\n⇨n₂+1+16+n₂=2016<br>\n⇨2n₂=1999<br>\nn₂除不尽，所以答案错误。</p>\n<p>【 Theorem 】 A tree with n vertices has n-1 edges.</p>\n<p>【 Theorem 】 edge = 1/2(sum of degree)</p>\n<p>【 Theorem 】A full m-ary tree with i internal vertices contains n=mi+1 vertices.</p>\n<p><mark><strong>For a full binary tree,</strong> <strong>l= i +1</strong>, <strong>e</strong> <strong>=</strong> <strong>v</strong> <strong>- 1.</strong></mark></p>\n<p>对于二叉树来说，叶子结点的个数等于中间节点个数 + 1，边数等于节点数 - 1</p>\n<h5 id=\"2-1-given-a-tree-of-degree-3-suppose-that-there-are-3-nodes-of-degree-2-and-2-nodes-of-degree-3-then-the-number-of-leaf-nodes-must-be-____\"><a class=\"markdownIt-Anchor\" href=\"#2-1-given-a-tree-of-degree-3-suppose-that-there-are-3-nodes-of-degree-2-and-2-nodes-of-degree-3-then-the-number-of-leaf-nodes-must-be-____\">#</a> 2-1 Given a tree of degree 3. Suppose that there are 3 nodes of degree 2 and 2 nodes of degree 3. Then the number of leaf nodes must be ____.</h5>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><msub><mi>n</mi><mn>0</mn></msub><mo>+</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><msub><mi>n</mi><mn>3</mn></msub></mrow><annotation encoding=\"application/x-tex\">n=n_0+n_1+n_2+n_3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.73333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.73333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.73333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi><mo>=</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>=</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><mn>2</mn><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>3</mn><msub><mi>n</mi><mn>3</mn></msub></mrow><annotation encoding=\"application/x-tex\">e=n-1=n_1+2n_2+3n_3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.73333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.79444em;vertical-align:-0.15em;\"></span><span class=\"mord\">2</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.79444em;vertical-align:-0.15em;\"></span><span class=\"mord\">3</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mo>−</mo><mo>&gt;</mo><msub><mi>n</mi><mn>0</mn></msub><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>2</mn><msub><mi>n</mi><mn>3</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">--&gt;n_0=n_2+2n_3+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">−</span><span class=\"mord\">−</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.73333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.79444em;vertical-align:-0.15em;\"></span><span class=\"mord\">2</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span></p>\n<p>直接画一棵树</p>\n<pre class=\"mermaid\">graph TD;\n0-->1;\n0-->2;\n1-->3;\n1-->4;\n2-->5;\n2-->6;\n3-->7;\n3-->8;\n3-->9;\n5-->10;\n5-->11;\n5-->12;</pre>\n<h5 id=\"2-2-if-a-general-tree-t-is-converted-into-a-binary-tree-bt-then-which-of-the-following-bt-traversals-gives-the-same-sequence-as-that-of-the-post-order-traversal-of-t\"><a class=\"markdownIt-Anchor\" href=\"#2-2-if-a-general-tree-t-is-converted-into-a-binary-tree-bt-then-which-of-the-following-bt-traversals-gives-the-same-sequence-as-that-of-the-post-order-traversal-of-t\">#</a> 2-2 If a general tree <em>T</em> is converted into a binary tree <em>BT</em>, then which of the following <em>BT</em> traversals gives the same sequence as that of the post-order traversal of <em>T</em>?</h5>\n<p>B. In-order traversal</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV2ZXJfZHJlYW1zL2FydGljbGUvZGV0YWlscy84MTAzMjg2MT9vcHNfcmVxdWVzdF9taXNjPSZhbXA7cmVxdWVzdF9pZD0mYW1wO2Jpel9pZD0xMDImYW1wO3V0bV90ZXJtPSVFNiU5OSVBRSVFOSU4MCU5QSVFNiVBMCU5MSVFOCVCRCVBQyVFNSU4QyU5NiVFNiU4OCU5MCVFNCVCQSU4QyVFNSU4RiU4OSVFNiVBMCU5MSZhbXA7dXRtX21lZGl1bT1kaXN0cmlidXRlLnBjX3NlYXJjaF9yZXN1bHQubm9uZS10YXNrLWJsb2ctMn5hbGx+c29iYWlkdXdlYn5kZWZhdWx0LTMtODEwMzI4NjEubm9uZWNhc2UmYW1wO3NwbT0xMDE4LjIyMjYuMzAwMS40MTg3\">普通树转二叉树</span></p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">将树的根节点直接作为二叉树的根节点</span><br><span class=\"line\">将树的根节点的第一个子节点作为根节点的左儿子，若该子节点存在兄弟节点，则将该子节点的第一个兄弟节点（方向从左往右）作为该子节点的右儿子</span><br><span class=\"line\">将树中的剩余节点按照上一步的方式，依序添加到二叉树中，直到树中所有的节点都在二叉树中</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://img-blog.csdn.net/20180713160942112?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV2ZXJfZHJlYW1z/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"img\"></p>\n<p>T：<br>\n前序 preorder：ABEICFDGJH<br>\n 中序无（多节点没法定义中序）<br>\n后序：IEBFCJGHDA</p>\n<p>BT：<br>\n前序 preorder: ABEICFDGJH<br>\n 中序 inorder：IEBFCJGHDA<br>\n 后序 postorder:IEBFJHGDCBA<br>\n 层级 levelorder：ABECIFDGJH</p>\n<p><strong>结论：</strong></p>\n<p><strong>T 的 preorder = BT 的 preorder<br>\nT 的 postorder = BT 的 inorder</strong></p>\n<p>preorder - 根左右  inorder - 左根右  postorder - 左右根</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">还可以这样理解普通树转换成二叉树（实际上是一样的）：</span><br><span class=\"line\"></span><br><span class=\"line\">在所有兄弟结点之间加一连线</span><br><span class=\"line\">对每个结点，除了保留与其第一个儿子的连线外，去掉该结点与其它孩子的连线</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://img-blog.csdn.net/20180724230432154?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV2ZXJfZHJlYW1z/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"img\"></p>\n<h5 id=\"2-3-given-the-shape-of-a-binary-tree-shown-by-the-figure-below-if-its-inorder-traversal-sequence-is-e-a-d-b-f-h-c-g-then-the-node-on-the-same-level-of-c-must-be\"><a class=\"markdownIt-Anchor\" href=\"#2-3-given-the-shape-of-a-binary-tree-shown-by-the-figure-below-if-its-inorder-traversal-sequence-is-e-a-d-b-f-h-c-g-then-the-node-on-the-same-level-of-c-must-be\">#</a> 2-3 Given the shape of a binary tree shown by the figure below. If its inorder traversal sequence is { E, A, D, B, F, H, C, G }, then the node on the same level of C must be:</h5>\n<p><img data-src=\"https://images.ptausercontent.com/19185355-2b08-4b74-9bb7-8262720437bd.jpg\" alt=\"未标题-2.jpg\"></p>\n<p>B.E</p>\n<pre class=\"mermaid\">graph TD\nF-->E\nF-->C\nE-->_\nE-->D\nD-->A\nD-->B\nC-->H\nC-->G</pre>\n<p>中序遍历：左根右</p>\n<h5 id=\"2-4-among-the-following-threaded-binary-trees-the-threads-are-represented-by-dotted-curves-which-one-is-the-postorder-threaded-tree\"><a class=\"markdownIt-Anchor\" href=\"#2-4-among-the-following-threaded-binary-trees-the-threads-are-represented-by-dotted-curves-which-one-is-the-postorder-threaded-tree\">#</a> 2-4 Among the following threaded binary trees (the threads are represented by dotted curves), which one is the postorder threaded tree?</h5>\n<p>A. <img data-src=\"https://images.ptausercontent.com/64\" alt=\"64\"></p>\n<p>B. <img data-src=\"https://images.ptausercontent.com/65\" alt=\"65\"></p>\n<p>C. <img data-src=\"https://images.ptausercontent.com/66\" alt=\"66\"></p>\n<p>D. <img data-src=\"https://images.ptausercontent.com/67\" alt=\"67\"></p>\n<p><strong>B</strong></p>\n<p>thread tree 线索二叉树</p>\n<p>下面这个树，<strong>后序排序</strong>是：dbca<br>\n 前驱就是前面的，比如 b 的前驱是 d, d 的前驱是 Null<br>\n 后驱就是后面的，比如 d 的后驱是 b，a 的后驱是 Null<br>\nd 有两个指针没有用，左边指向前驱 Null，右边指向 b（然后就选出来 B 了）<br>\nb 的右节点有用的（已经指向 d 了），左节点指向其前驱，也就是 d<br>\nc 前驱是 b，后驱是 a，所以左指向 b，右指向 a<br>\na 没有指针可用了（已经左为 b 右为 c）了<br>\n所以选 B。</p>\n<h5 id=\"expression-trees-syntax-trees\"><a class=\"markdownIt-Anchor\" href=\"#expression-trees-syntax-trees\">#</a> Expression Trees (syntax trees)</h5>\n<p>prefix/infix/postfix 分别对应前序遍历、中序遍历、后序遍历</p>\n<h5 id=\"6-1-isomorphic\"><a class=\"markdownIt-Anchor\" href=\"#6-1-isomorphic\">#</a> <strong>6-1 Isomorphic</strong></h5>\n<p>Two trees,  <code>T1</code>  and  <code>T2</code> , are <strong>isomorphic</strong> if  <code>T1</code>  can be transformed into  <code>T2</code>  by swapping left and right children of (some of the) nodes in  <code>T1</code> . For instance, the two trees in Figure 1 are isomorphic because they are the same if the children of A, B, and G, but not the other nodes, are swapped. Give a polynomial time algorithm to decide if two trees are isomorphic.</p>\n<p><img data-src=\"https://images.ptausercontent.com/37\" alt=\"37\"></p>\n<h3 id=\"format-of-functions-3\"><a class=\"markdownIt-Anchor\" href=\"#format-of-functions-3\">#</a> Format of functions:</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Isomorphic</span><span class=\"params\">( Tree T1, Tree T2 )</span></span>;</span><br></pre></td></tr></table></figure>\n<p>where  <code>Tree</code>  is defined as the following:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">TreeNode</span> *Tree;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TreeNode</span> &#123;</span><br><span class=\"line\">    ElementType Element;</span><br><span class=\"line\">    Tree  Left;</span><br><span class=\"line\">    Tree  Right;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>The function is supposed to return 1 if  <code>T1</code>  and  <code>T2</code>  are indeed isomorphic, or 0 if not.</p>\n<h3 id=\"sample-program-of-judge-3\"><a class=\"markdownIt-Anchor\" href=\"#sample-program-of-judge-3\">#</a> Sample program of judge:</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">char</span> ElementType;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">TreeNode</span> *Tree;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TreeNode</span> &#123;</span><br><span class=\"line\">    ElementType Element;</span><br><span class=\"line\">    Tree  Left;</span><br><span class=\"line\">    Tree  Right;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Tree <span class=\"title\">BuildTree</span><span class=\"params\">()</span></span>; <span class=\"comment\">/* details omitted */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Isomorphic</span><span class=\"params\">( Tree T1, Tree T2 )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Tree T1, T2;</span><br><span class=\"line\">    T1 = <span class=\"built_in\">BuildTree</span>();</span><br><span class=\"line\">    T2 = <span class=\"built_in\">BuildTree</span>();</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(“%d\\n”, <span class=\"built_in\">Isomorphic</span>(T1, T2));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Your function will be put here */</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"sample-output-1-for-the-trees-shown-in-figure-1\"><a class=\"markdownIt-Anchor\" href=\"#sample-output-1-for-the-trees-shown-in-figure-1\">#</a> Sample Output 1 (for the trees shown in Figure 1):</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n<h3 id=\"sample-output-2-for-the-trees-shown-in-figure-2\"><a class=\"markdownIt-Anchor\" href=\"#sample-output-2-for-the-trees-shown-in-figure-2\">#</a> Sample Output 2 (for the trees shown in Figure 2):</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://images.ptausercontent.com/38\" alt=\"img\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Isomorphic</span><span class=\"params\">(Tree T1,Tree T2)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> \t<span class=\"keyword\">if</span>((T1 == <span class=\"literal\">NULL</span>) &amp;&amp; (T2 == <span class=\"literal\">NULL</span>))  <span class=\"comment\">//树都为空树，视为同构 </span></span><br><span class=\"line\"> \t    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"> \t<span class=\"keyword\">if</span>(((T1 == <span class=\"literal\">NULL</span>)&amp;&amp;(T2 != <span class=\"literal\">NULL</span>)) || ((T1 != <span class=\"literal\">NULL</span>)&amp;&amp;(T2 == <span class=\"literal\">NULL</span>)))  <span class=\"comment\">//两树其中之一为空树,不同构 </span></span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(T1-&gt;Element != T2-&gt;Element)  <span class=\"comment\">//若两树都非空的话，比较根结点 </span></span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>((T1-&gt;Left == <span class=\"literal\">NULL</span>) &amp;&amp; (T2-&gt;Left == <span class=\"literal\">NULL</span>))  <span class=\"comment\">//左子树都为空，比较右子树 </span></span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> Isomorphic(T1-&gt;Right,T2-&gt;Right);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((T1-&gt;Left != <span class=\"literal\">NULL</span>)&amp;&amp;(T2-&gt;Left != <span class=\"literal\">NULL</span>) &amp;&amp; (T1-&gt;Left-&gt;Element == T2-&gt;Left-&gt;Element))</span><br><span class=\"line\">    <span class=\"comment\">/*左子树非空，并且左子树根结点相同，递归比较左右子树*/</span> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> (Isomorphic(T1-&gt;Left,T2-&gt;Left) &amp;&amp; Isomorphic(T1-&gt;Right,T2-&gt;Right));</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (Isomorphic(T1-&gt;Left,T2-&gt;Right) &amp;&amp; Isomorphic(T1-&gt;Right,T2-&gt;Left));</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"hw5\"><a class=\"markdownIt-Anchor\" href=\"#hw5\">#</a> HW5</h2>\n<h5 id=\"1-2-in-a-binary-search-tree-which-contains-several-integer-keys-including-4-5-and-6-if-4-and-6-are-on-the-same-level-then-5-must-be-their-parent\"><a class=\"markdownIt-Anchor\" href=\"#1-2-in-a-binary-search-tree-which-contains-several-integer-keys-including-4-5-and-6-if-4-and-6-are-on-the-same-level-then-5-must-be-their-parent\">#</a> 1-2 In a binary search tree which contains several integer keys including 4, 5, and 6, if 4 and 6 are on the same level, then 5 must be their parent.</h5>\n<p>F</p>\n<p>不一定是父节点，可能是祖先节点。</p>\n<h5 id=\"2-2-given-the-structure-of-a-binary-search-tree-as-shown-in-the-figure-which-one-of-the-following-insertion-sequences-is-impossible\"><a class=\"markdownIt-Anchor\" href=\"#2-2-given-the-structure-of-a-binary-search-tree-as-shown-in-the-figure-which-one-of-the-following-insertion-sequences-is-impossible\">#</a> 2-2 Given the structure of a binary search tree (as shown in the figure), which one of the following insertion sequences is impossible?</h5>\n<p><img data-src=\"https://images.ptausercontent.com/84984823-130d-462a-ad9e-ee6457b1ce56.jpg\" alt=\"206.jpg\"></p>\n<p>A.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">83 67 91 98 20 75</span><br></pre></td></tr></table></figure>\n<p>B.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">83 67 75 91 20 98</span><br></pre></td></tr></table></figure>\n<p>C.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">83 91 75 67 20 98</span><br></pre></td></tr></table></figure>\n<p>D.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">83 91 98 67 75 20</span><br></pre></td></tr></table></figure>\n<p><strong>C</strong></p>\n<h5 id=\"binary-search-tree\"><a class=\"markdownIt-Anchor\" href=\"#binary-search-tree\">#</a> Binary Search Tree</h5>\n<p>二叉搜索树（BST，Binary Search Tree），也称二叉排序树或二叉查找树。<br>\n二叉搜索树：一棵二叉树，可以为空；如果不为空，满足以下性质：</p>\n<ol>\n<li>非空左子树的所有键值小于其根结点的键值。</li>\n<li>非空右子树的所有键值大于其根结点的键值。</li>\n<li>左、右子树都是二叉搜索树。</li>\n</ol>\n<p><strong>定义：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> ElementType;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TNode</span> *<span class=\"title\">Position</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> Position BinTree; <span class=\"comment\">/* 二叉树类型 */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TNode</span>&#123;</span> <span class=\"comment\">/* 树结点定义 */</span></span><br><span class=\"line\">    ElementType Data; <span class=\"comment\">/* 结点数据 */</span></span><br><span class=\"line\">    BinTree Left;     <span class=\"comment\">/* 指向左子树 */</span></span><br><span class=\"line\">    BinTree Right;    <span class=\"comment\">/* 指向右子树 */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>查找</strong></p>\n<p>（1）查找从根结点开始，如果树为空，返回 NULL<br>\n（2）若搜索树非空，则根结点关键字和 X 进行比较，并进行不同处理：<br>\n  ① 若 X 小于根结点键值，只需在左子树中继续搜索；<br>\n  ② 如果 X 大于根结点的键值，在右子树中进行继续搜索；<br>\n  ③若两者比较结果是相等，搜索完成，返回指向此结点的指针。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Position <span class=\"title function_\">Find</span><span class=\"params\">( ElementType X, BinTree BST )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>( !BST ) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>; <span class=\"comment\">/*查找失败*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>( X &gt; BST-&gt;Data )</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Find( X, BST-&gt;Right ); <span class=\"comment\">/*在右子树中继续查找*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>( X &lt; BST-&gt;Data )</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Find( X, BST-&gt;Left ); <span class=\"comment\">/*在左子树中继续查找*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"comment\">/* X == BST-&gt;Data */</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> BST; <span class=\"comment\">/*查找成功，返回结点的找到结点的地址*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>查找最小（递归法）</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Position <span class=\"title function_\">FindMin</span><span class=\"params\">( BinTree BST )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t <span class=\"keyword\">if</span>( !BST ) </span><br><span class=\"line\">\t \t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>; <span class=\"comment\">/*空的二叉搜索树，返回NULL*/</span></span><br><span class=\"line\">\t <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>( !BST-&gt;Left )</span><br><span class=\"line\">\t \t<span class=\"keyword\">return</span> BST; <span class=\"comment\">/*找到最左叶结点并返回*/</span></span><br><span class=\"line\">\t <span class=\"keyword\">else</span></span><br><span class=\"line\">\t \t<span class=\"keyword\">return</span> FindMin( BST-&gt;Left ); <span class=\"comment\">/*沿左分支继续查找*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>查找最大（迭代法）</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Position <span class=\"title function_\">FindMax</span><span class=\"params\">( BinTree BST )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t <span class=\"keyword\">if</span>(BST )</span><br><span class=\"line\">\t \t<span class=\"keyword\">while</span>( BST-&gt;Right )  <span class=\"comment\">/*沿右分支继续查找，直到最右叶结点*/</span></span><br><span class=\"line\">\t \t\tBST = BST-&gt;Right;</span><br><span class=\"line\">\t <span class=\"keyword\">return</span> BST;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p><strong>插入</strong></p>\n<p>从根节点开始比较，大的插右边，小的插左边</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BinTree <span class=\"title function_\">Insert</span><span class=\"params\">( BinTree BST, ElementType X )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( !BST )&#123; <span class=\"comment\">/* 若原树为空，生成并返回一个结点的二叉搜索树 */</span></span><br><span class=\"line\">        BST = (BinTree)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> TNode));</span><br><span class=\"line\">        BST-&gt;Data = X;</span><br><span class=\"line\">        BST-&gt;Left = BST-&gt;Right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123; <span class=\"comment\">/* 开始找要插入元素的位置 */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>( X &lt; BST-&gt;Data )</span><br><span class=\"line\">            BST-&gt;Left = Insert( BST-&gt;Left, X );   <span class=\"comment\">/*递归插入左子树*/</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>  <span class=\"keyword\">if</span>( X &gt; BST-&gt;Data )</span><br><span class=\"line\">            BST-&gt;Right = Insert( BST-&gt;Right, X ); <span class=\"comment\">/*递归插入右子树*/</span></span><br><span class=\"line\">        <span class=\"comment\">/* else X已经存在，什么都不做 */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BST;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>删除</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BinTree <span class=\"title function_\">Delete</span><span class=\"params\">( BinTree BST, ElementType X )</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    Position Tmp; </span><br><span class=\"line\">    <span class=\"keyword\">if</span>( !BST ) </span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;要删除的元素未找到&quot;</span>); </span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( X &lt; BST-&gt;Data ) </span><br><span class=\"line\">            BST-&gt;Left = Delete( BST-&gt;Left, X );   <span class=\"comment\">/* 从左子树递归删除 */</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>( X &gt; BST-&gt;Data ) </span><br><span class=\"line\">            BST-&gt;Right = Delete( BST-&gt;Right, X ); <span class=\"comment\">/* 从右子树递归删除 */</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> </span><br><span class=\"line\">        &#123; <span class=\"comment\">/* BST就是要删除的结点 */</span></span><br><span class=\"line\">            <span class=\"comment\">/* 如果被删除结点有左右两个子结点 */</span> </span><br><span class=\"line\">            <span class=\"keyword\">if</span>( BST-&gt;Left &amp;&amp; BST-&gt;Right ) </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">/* 从右子树中找最小的元素填充删除结点 */</span></span><br><span class=\"line\">                Tmp = FindMin( BST-&gt;Right );</span><br><span class=\"line\">                BST-&gt;Data = Tmp-&gt;Data;</span><br><span class=\"line\">                <span class=\"comment\">/* 从右子树中删除最小元素 */</span></span><br><span class=\"line\">                BST-&gt;Right = Delete( BST-&gt;Right, BST-&gt;Data );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> </span><br><span class=\"line\">            &#123; <span class=\"comment\">/* 被删除结点有一个或无子结点 */</span></span><br><span class=\"line\">                Tmp = BST; </span><br><span class=\"line\">                <span class=\"keyword\">if</span>( !BST-&gt;Left )       <span class=\"comment\">/* 只有右孩子或无子结点 */</span></span><br><span class=\"line\">                    BST = BST-&gt;Right; </span><br><span class=\"line\">                <span class=\"keyword\">else</span>                   <span class=\"comment\">/* 只有左孩子 */</span></span><br><span class=\"line\">                    BST = BST-&gt;Left;</span><br><span class=\"line\">                <span class=\"built_in\">free</span>( Tmp );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BST;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"given-a-binary-search-tree-with-its-preorder-traversal-sequence-8-2-15-10-12-21-if-8-is-deleted-from-the-tree-which-one-of-the-following-statements-is-false\"><a class=\"markdownIt-Anchor\" href=\"#given-a-binary-search-tree-with-its-preorder-traversal-sequence-8-2-15-10-12-21-if-8-is-deleted-from-the-tree-which-one-of-the-following-statements-is-false\">#</a> Given a binary search tree with its preorder traversal sequence { 8, 2, 15, 10, 12, 21 }. If 8 is deleted from the tree, which one of the following statements is FALSE?</h5>\n<p 21 2, 15, 10, 12,>A. One possible preprder traversal sequence of the resulting tree may be</p>\n<p 21 10, 2, 15, 12,>B. One possible preprder traversal sequence of the resulting tree may be</p>\n<p 21 15, 10, 2, 12,>C. One possible preprder traversal sequence of the resulting tree may be</p>\n<p>D. It is possible that the new root may have 2 children</p>\n<p>C</p>\n<p>8 是根节点，删除之后根可能是左子树最大的元素或者右子树最小的元素</p>\n<pre class=\"mermaid\">graph TD\n8-->2\n8-->15\n15-->10\n10-->_\n10-->12\n15-->21</pre>\n<p>delete 8:</p>\n<pre class=\"mermaid\">graph TD\n2-->15\n15-->10\n10-->-\n10-->12\n15-->21</pre>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">10--&gt;2</span><br><span class=\"line\">10--&gt;15</span><br><span class=\"line\">15--&gt;12</span><br><span class=\"line\">15--&gt;21</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-4-insert-5-2-7-3-4-1-6-one-by-one-into-an-initially-empty-binary-search-tree-the-postorder-traversal-sequence-of-the-resulting-tree-is\"><a class=\"markdownIt-Anchor\" href=\"#2-4-insert-5-2-7-3-4-1-6-one-by-one-into-an-initially-empty-binary-search-tree-the-postorder-traversal-sequence-of-the-resulting-tree-is\">#</a> 2-4 Insert {5, 2, 7, 3, 4, 1, 6} one by one into an initially empty binary search tree. The postorder traversal sequence of the resulting tree is:</h5>\n<p>A. 1, 2, 3, 4, 6, 7, 5</p>\n<p>B. 1, 4, 2, 6, 3, 7, 5</p>\n<p>C. 1, 4, 3, 2, 6, 7, 5</p>\n<p>D. 5, 4, 3, 7, 6, 2, 1</p>\n<p>注意是<mark> one by one</mark>，所以选 C</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">5--&gt;2</span><br><span class=\"line\">5--&gt;7</span><br><span class=\"line\">2--&gt;1</span><br><span class=\"line\">2--&gt;3</span><br><span class=\"line\">3--&gt;_</span><br><span class=\"line\">3--&gt;4</span><br><span class=\"line\">7--&gt;6</span><br><span class=\"line\">7--&gt;-</span><br></pre></td></tr></table></figure>\n<p>后序遍历：1 4 3 2 6 7 5</p>\n<h5 id=\"2-5-among-the-following-binary-trees-which-one-can-possibly-be-the-decision-tree-the-external-nodes-are-excluded-for-binary-search\"><a class=\"markdownIt-Anchor\" href=\"#2-5-among-the-following-binary-trees-which-one-can-possibly-be-the-decision-tree-the-external-nodes-are-excluded-for-binary-search\">#</a> 2-5 Among the following binary trees, which one can possibly be the decision tree (the external nodes are excluded) for binary search?</h5>\n<p>A.</p>\n<p><img data-src=\"https://images.ptausercontent.com/282\" alt=\"img\"></p>\n<p>B.</p>\n<p><img data-src=\"https://images.ptausercontent.com/283\" alt=\"img\"></p>\n<p>C.</p>\n<p><img data-src=\"https://images.ptausercontent.com/284\" alt=\"img\"></p>\n<p>D.</p>\n<p><img data-src=\"https://images.ptausercontent.com/285\" alt=\"img\"></p>\n<p><strong>A</strong></p>\n<p>决策树：左子树总是大于等于右子树或者右子树总是大于等于左子树才符合。</p>\n<p>用排除法可得 A</p>\n<h5 id=\"2-6-for-a-binary-search-tree-in-which-order-of-traversal-that-we-can-obtain-a-non-decreasing-sequence\"><a class=\"markdownIt-Anchor\" href=\"#2-6-for-a-binary-search-tree-in-which-order-of-traversal-that-we-can-obtain-a-non-decreasing-sequence\">#</a> 2-6 For a binary search tree, in which order of traversal that we can obtain a non-decreasing sequence?</h5>\n<p>A. preorder traversal</p>\n<p>B. postorder traversal</p>\n<p>C. inorder traversal</p>\n<p>D. level-order traversal</p>\n<p><strong>C</strong></p>\n<p>中序遍历得到的序列是非递减的，前序遍历和后序遍历得到的都是无序的。</p>\n<h2 id=\"hw6\"><a class=\"markdownIt-Anchor\" href=\"#hw6\">#</a> HW6</h2>\n<h5 id=\"1-1-if-a-complete-binary-tree-with-137-nodes-is-stored-in-an-array-root-at-position-1-then-the-nodes-at-positions-128-and-137-are-at-the-same-level\"><a class=\"markdownIt-Anchor\" href=\"#1-1-if-a-complete-binary-tree-with-137-nodes-is-stored-in-an-array-root-at-position-1-then-the-nodes-at-positions-128-and-137-are-at-the-same-level\">#</a> 1-1 If a complete binary tree with 137 nodes is stored in an array (root at position 1), then the nodes at positions 128 and 137 are at the same level.</h5>\n<p>T</p>\n<p>完全二叉树：若二叉树的深度为 h，则除第 h 层外，其他层的结点全部达到最大值，且第 h 层的所有结点都集中在左子树。</p>\n<p>满二叉树：满二叉树是一种特殊的的完全二叉树，所有层的结点都是最大值。</p>\n<p><a href=\"https://blog.csdn.net/xiaomucgwlmx/article/details/103522410\"><strong>堆（heap)</strong></a></p>\n<p>堆（英语：heap) 是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质：</p>\n<p>堆中某个节点的值总是不大于或不小于其父节点的值；</p>\n<p>堆总是一棵完全二叉树。</p>\n<p>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。</p>\n<p>堆是非线性数据结构，相当于一维数组，有两个直接后继。</p>\n<p><strong>注意： 在二叉树中，若当前节点的下标为 i， 则其父节点的下标为 i/2，其左子节点的下标为 i*2，其右子节点的下标为 i*2+1；</strong></p>\n<h5 id=\"1-2-the-inorder-traversal-sequence-of-any-min-heap-must-be-in-sorted-order\"><a class=\"markdownIt-Anchor\" href=\"#1-2-the-inorder-traversal-sequence-of-any-min-heap-must-be-in-sorted-order\">#</a> 1-2 The inorder traversal sequence of any min-heap must be in sorted order.</h5>\n<p><strong>F</strong></p>\n<p>在最小堆中，虽然父节点的值小于或等于其子节点的值，但是并没有要求兄弟节点之间的大小关系。因此，在进行中序遍历时，并不能保证得到一个有序的序列。（完全二叉树 vs 二叉搜索树）</p>\n<h5 id=\"2-1-in-a-max-heap-with-n-1-elements-the-array-index-of-the-minimum-key-may-be-__\"><a class=\"markdownIt-Anchor\" href=\"#2-1-in-a-max-heap-with-n-1-elements-the-array-index-of-the-minimum-key-may-be-__\">#</a> 2-1 In a max-heap with <em>n</em> (&gt;1) elements, the array index of the minimum key may be __.</h5>\n<p>A. 1</p>\n<p>B. ⌊<em>n</em>/2⌋−1</p>\n<p>C. ⌊<em>n</em>/2⌋</p>\n<p>D. ⌊<em>n</em>/2⌋+2</p>\n<p><strong>D</strong></p>\n<p>最大堆最小的元素在叶子结点上，⌊<em>n</em>/2⌋有子节点是⌊<em>n</em>⌋，所以肯定不是最小的元素，只能选 D</p>\n<h5 id=\"2-2-using-the-linear-algorithm-to-build-a-min-heap-from-the-sequence-15-26-32-8-7-20-12-13-5-19-and-then-insert-6-which-one-of-the-following-statements-is-false\"><a class=\"markdownIt-Anchor\" href=\"#2-2-using-the-linear-algorithm-to-build-a-min-heap-from-the-sequence-15-26-32-8-7-20-12-13-5-19-and-then-insert-6-which-one-of-the-following-statements-is-false\">#</a> 2-2 Using the linear algorithm to build a min-heap from the sequence {15, 26, 32, 8, 7, 20, 12, 13, 5, 19}, and then insert 6. Which one of the following statements is FALSE?</h5>\n<p>A. The root is 5</p>\n<p 26 5, 6, 8,>B. The path from the root to 26 is</p>\n<p>C. 32 is the left child of 12</p>\n<p>D. 7 is the parent of 19 and 15</p>\n<p><strong>C</strong></p>\n<p>先按 level order 建堆，然后从第一个父节点开始上滤，直到得到 MinHeap</p>\n<p>插入 6：插入之后依旧是完全二叉树，然后上滤</p>\n<p><strong>堆的插入</strong></p>\n<p>插入到最后一层最左侧的位置，然后和父节点比较，如果最小堆插入的元素比父节点小就和父节点交换位置，一直换到比父节点大为止，复杂度 O (logn)。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span>  <span class=\"title function_\">Insert</span><span class=\"params\">( ElementType  X,  PriorityQueue  H )</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">     <span class=\"type\">int</span>  i; </span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">if</span> ( IsFull( H ) ) </span><br><span class=\"line\">     &#123; </span><br><span class=\"line\">\t\tError( <span class=\"string\">&quot;Priority queue is full&quot;</span> ); </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>; </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">\t<span class=\"comment\">/*首先确定初始位置是堆的个数+1，这个位置到根的路径是i/2*/</span></span><br><span class=\"line\">     <span class=\"keyword\">for</span> ( i = ++H-&gt;Size; H-&gt;Elements[ i / <span class=\"number\">2</span> ] &gt; X; i /= <span class=\"number\">2</span> ) </span><br><span class=\"line\">\t\tH-&gt;Elements[ i ] = H-&gt;Elements[ i / <span class=\"number\">2</span> ]; </span><br><span class=\"line\">\t\t<span class=\"comment\">/*当第(i/2)个大于X的时候，就往后移动，i/2小于X的时候，就让孩子i变成X*/</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">     H-&gt;Elements[ i ] = X; <span class=\"comment\">//</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>堆的删除</strong></p>\n<p>堆中每次都只能删除堆顶元素。为了便于重建堆，实际的操作是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整 (shift_down)。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ElementType  <span class=\"title function_\">DeleteMin</span><span class=\"params\">( PriorityQueue  H )</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    <span class=\"type\">int</span>  i, Child; </span><br><span class=\"line\">    ElementType  MinElement, LastElement; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( IsEmpty( H ) ) </span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">         Error( <span class=\"string\">&quot;Priority queue is empty&quot;</span> ); </span><br><span class=\"line\">         <span class=\"keyword\">return</span>  H-&gt;Elements[ <span class=\"number\">0</span> ];   </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    MinElement = H-&gt;Elements[ <span class=\"number\">1</span> ];  <span class=\"comment\">/* save the min element */</span></span><br><span class=\"line\">    LastElement = H-&gt;Elements[ H-&gt;Size-- ];  <span class=\"comment\">/* take last and reset size */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( i = <span class=\"number\">1</span>; i * <span class=\"number\">2</span> &lt;= H-&gt;Size; i = Child ) </span><br><span class=\"line\">    &#123;  <span class=\"comment\">/* Find smaller child */</span> </span><br><span class=\"line\">         Child = i * <span class=\"number\">2</span>; </span><br><span class=\"line\">         <span class=\"keyword\">if</span> (Child != H-&gt;Size &amp;&amp; H-&gt;Elements[Child+<span class=\"number\">1</span>] &lt; H-&gt;Elements[Child]) </span><br><span class=\"line\">\t       Child++;     <span class=\"comment\">/*如果child+1更小，让child指向child+1*/</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> ( LastElement &gt; H-&gt;Elements[ Child ] )   <span class=\"comment\">/* Percolate one level */</span> </span><br><span class=\"line\">\t     \tH-&gt;Elements[ i ] = H-&gt;Elements[ Child ]; <span class=\"comment\">/*把child放在i的位置，和最后一句对应*/</span></span><br><span class=\"line\">         <span class=\"keyword\">else</span></span><br><span class=\"line\">         \t<span class=\"keyword\">break</span>;   <span class=\"comment\">/* find the proper position */</span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    H-&gt;Elements[ i ] = LastElement; <span class=\"comment\">/*把本来的最后一个元素放在i的位置，和上面那句对应*/</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>  MinElement; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>建堆</strong></p>\n<p>1) 首先把数组按照层序（level order）放在一个空堆中<br>\n (2) 从最后一个父节点开始，让父节点，右孩子，左孩子中最小的放在父节点的位置。<br>\n(3) 如果父节点被换下去了，那么必须执行 shiftdown 操作，即被换下去的结点与当前的子节点比较，并交换，直到符合比任何一个子节点大的条件。<br>\n对于 2-2</p>\n<pre class=\"mermaid\">graph TD;\n15-->26;\n15-->32;\n26-->8;\n26-->7;\n32-->20;\n32-->12;\n8-->13;\n8-->5;\n7-->19;</pre>\n<p>一开始按层序遍历建堆，接下来从第一个父节点 7 开始执行 shift_down，不变</p>\n<p>然后对 8shift_down，交换 8 和 5</p>\n<pre class=\"mermaid\">graph TD;\n15-->26;\n15-->32;\n26-->5;\n26-->7;\n32-->20;\n32-->12;\n5-->13;\n5-->8;\n7-->19;</pre>\n<p>以此类推</p>\n<p>总的过程：</p>\n<p>对 7shiftdown: 不变<br>\n对 8shiftdown:15 26 32 5 7 20 12 13 8 19<br>\n 对 32shiftdown:15 26 12 5 7 20 32 13 8 19<br>\n 对 26shiftdown:15 5 12 8 7 20 32 13 26 19<br>\n 对 15shiftdown: 5 7 12 8 15 20 32 13 26 19<br>\n 插入 6: 6 12 8 7 20 32 13 20 19 15</p>\n<h5 id=\"2-3-if-a-d-heap-is-stored-as-an-array-for-an-entry-located-in-position-i-the-parent-the-first-child-and-the-last-child-are-at\"><a class=\"markdownIt-Anchor\" href=\"#2-3-if-a-d-heap-is-stored-as-an-array-for-an-entry-located-in-position-i-the-parent-the-first-child-and-the-last-child-are-at\">#</a> 2-3 If a <em>d</em>-heap is stored as an array, for an entry located in position <em>i</em>, the parent, the first child and the last child are at:</h5>\n<p>A. ⌈(<em>i</em>+<em>d</em>−2)/<em>d</em>⌉, (<em>i</em>−2)<em>d</em>+2, and (<em>i</em>−1)<em>d</em>+1</p>\n<p>B. ⌈(<em>i</em>+<em>d</em>−1)/<em>d</em>⌉, (<em>i</em>−2)<em>d</em>+1, and (<em>i</em>−1)<em>d</em></p>\n<p>C. ⌊(<em>i</em>+<em>d</em>−2)/<em>d</em>⌋, (<em>i</em>−1)<em>d</em>+2, and <em>id</em>+1</p>\n<p>D. ⌊(<em>i</em>+<em>d</em>−1)/<em>d</em>⌋, (<em>i</em>−1)<em>d</em>+1, and <em>id</em></p>\n<p><strong>C</strong></p>\n<h5 id=\"2-6-if-a-binary-search-tree-of-n-nodes-is-complete-which-one-of-the-following-statements-is-false\"><a class=\"markdownIt-Anchor\" href=\"#2-6-if-a-binary-search-tree-of-n-nodes-is-complete-which-one-of-the-following-statements-is-false\">#</a> 2-6 If a binary search tree of <em>N</em> nodes is complete, which one of the following statements is FALSE?</h5>\n<p>A. the average search time for all nodes is <em>O</em>(log<em>N</em>)</p>\n<p>二叉搜索的时间复杂度是 O (logN)，对</p>\n<p>B. the minimum key must be at a leaf node</p>\n<p>最左边的节点</p>\n<p>C. the maximum key must be at a leaf node</p>\n<p>最大值可能在上一层的最右边的结点（此节点只有 leftchildren），错</p>\n<p>D. the median node must either be the root or in the left subtree</p>\n<h4 id=\"函数题-2\"><a class=\"markdownIt-Anchor\" href=\"#函数题-2\">#</a> 函数题</h4>\n<p><strong>6-1 Percolate Up and Down</strong></p>\n<p>Write the routines to do a “percolate up” and a “percolate down” in a binary min-heap.</p>\n<h3 id=\"format-of-functions-4\"><a class=\"markdownIt-Anchor\" href=\"#format-of-functions-4\">#</a> Format of functions:</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">PercolateUp</span><span class=\"params\">( <span class=\"type\">int</span> p, PriorityQueue H )</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">PercolateDown</span><span class=\"params\">( <span class=\"type\">int</span> p, PriorityQueue H )</span>;</span><br></pre></td></tr></table></figure>\n<p>where  <code>int p</code>  is the position of the element, and  <code>PriorityQueue</code>  is defined as the following:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HeapStruct</span> *<span class=\"title\">PriorityQueue</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HeapStruct</span> &#123;</span></span><br><span class=\"line\">    ElementType  *Elements;</span><br><span class=\"line\">    <span class=\"type\">int</span> Capacity;</span><br><span class=\"line\">    <span class=\"type\">int</span> Size;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"sample-program-of-judge-4\"><a class=\"markdownIt-Anchor\" href=\"#sample-program-of-judge-4\">#</a> Sample program of judge:</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> ElementType;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MinData -1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HeapStruct</span> *<span class=\"title\">PriorityQueue</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HeapStruct</span> &#123;</span></span><br><span class=\"line\">    ElementType  *Elements;</span><br><span class=\"line\">    <span class=\"type\">int</span> Capacity;</span><br><span class=\"line\">    <span class=\"type\">int</span> Size;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">PriorityQueue <span class=\"title function_\">Initialize</span><span class=\"params\">( <span class=\"type\">int</span> MaxElements )</span>; <span class=\"comment\">/* details omitted */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">PercolateUp</span><span class=\"params\">( <span class=\"type\">int</span> p, PriorityQueue H )</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">PercolateDown</span><span class=\"params\">( <span class=\"type\">int</span> p, PriorityQueue H )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Insert</span><span class=\"params\">( ElementType X, PriorityQueue H )</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> p = ++H-&gt;Size;</span><br><span class=\"line\">    H-&gt;Elements[p] = X;</span><br><span class=\"line\">    PercolateUp( p, H );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ElementType <span class=\"title function_\">DeleteMin</span><span class=\"params\">( PriorityQueue H )</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    ElementType MinElement; </span><br><span class=\"line\">    MinElement = H-&gt;Elements[<span class=\"number\">1</span>];</span><br><span class=\"line\">    H-&gt;Elements[<span class=\"number\">1</span>] = H-&gt;Elements[H-&gt;Size--];</span><br><span class=\"line\">    PercolateDown( <span class=\"number\">1</span>, H );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MinElement; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n, i, op, X;</span><br><span class=\"line\">    PriorityQueue H;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">    H = Initialize(n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( i=<span class=\"number\">0</span>; i&lt;n; i++ ) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;op);</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>( op ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;X);</span><br><span class=\"line\">            Insert(X, H);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, DeleteMin(H));</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\nInside H:&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( i=<span class=\"number\">1</span>; i&lt;=H-&gt;Size; i++ )</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; %d&quot;</span>, H-&gt;Elements[i]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Your function will be put here */</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"sample-input-4\"><a class=\"markdownIt-Anchor\" href=\"#sample-input-4\">#</a> Sample Input:</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">9</span><br><span class=\"line\">1 10</span><br><span class=\"line\">1 5</span><br><span class=\"line\">1 2</span><br><span class=\"line\">0</span><br><span class=\"line\">1 9</span><br><span class=\"line\">1 1</span><br><span class=\"line\">1 4</span><br><span class=\"line\">0</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n<h3 id=\"sample-output-4\"><a class=\"markdownIt-Anchor\" href=\"#sample-output-4\">#</a> Sample Output:</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2 1 4 </span><br><span class=\"line\">Inside H: 5 10 9</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">PercolateUp</span><span class=\"params\">( <span class=\"type\">int</span> p, PriorityQueue H )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p&gt;<span class=\"number\">1</span> &amp;&amp; H-&gt;Elements[p] &lt; H-&gt;Elements[p/<span class=\"number\">2</span>])&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> temp;</span><br><span class=\"line\">        temp = H-&gt;Elements[p];</span><br><span class=\"line\">        H-&gt;Elements[p] = H-&gt;Elements[p/<span class=\"number\">2</span>];</span><br><span class=\"line\">        H-&gt;Elements[p/<span class=\"number\">2</span>] = temp;</span><br><span class=\"line\">        p = p/<span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">PercolateDown</span><span class=\"params\">( <span class=\"type\">int</span> p, PriorityQueue H )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p*<span class=\"number\">2</span>&lt;=H-&gt;Size &amp;&amp; H-&gt;Elements[p*<span class=\"number\">2</span>] &lt; H-&gt;Elements[p])&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> temp;</span><br><span class=\"line\">        temp = H-&gt;Elements[p];</span><br><span class=\"line\">        H-&gt;Elements[p] = H-&gt;Elements[p*<span class=\"number\">2</span>];</span><br><span class=\"line\">        H-&gt;Elements[p*<span class=\"number\">2</span>] = temp;</span><br><span class=\"line\">        p = p*<span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>PercolateUp 就是和父节点比较，如果比父节点小就交换，直到根节点或者比父节点大为止；</p>\n<p>PercolateDown 就是和子节点比较，同理。</p>\n<h2 id=\"hw7\"><a class=\"markdownIt-Anchor\" href=\"#hw7\">#</a> HW7</h2>\n<p>并查集（disjoint set)</p>\n<p><strong>查找</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SetType  <span class=\"title function_\">Find</span> <span class=\"params\">( ElementType X, </span></span><br><span class=\"line\"><span class=\"params\">                           DisjSet S )</span></span><br><span class=\"line\">&#123;   <span class=\"keyword\">for</span> ( ; S[X] &gt; <span class=\"number\">0</span>; X = S[X] )   ;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>  X ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Please fill in the blanks in the program which performs  <code>Find</code>  as a Union/Find operation with path compression.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SetType <span class=\"title function_\">Find</span> <span class=\"params\">( ElementType X, DisjSet S )</span></span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">   ElementType root, trail, lead;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">for</span> ( root = X; S[root] &gt; <span class=\"number\">0</span>; root=S[root] );  <span class=\"comment\">//查找</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> ( trail = X; trail != root; trail = lead ) &#123;</span><br><span class=\"line\">      lead = S[trail];   </span><br><span class=\"line\">       S[trail]=root;</span><br><span class=\"line\">   &#125; <span class=\"comment\">//路径压缩</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>合并</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Union</span><span class=\"params\">( ElementType i, ElementType j, DisjSet S )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> root1, root2;</span><br><span class=\"line\">    root1 = Find(i);</span><br><span class=\"line\">    root2 = Find(j);</span><br><span class=\"line\">    S[root2] = root1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Union by size:</strong></p>\n<p>Union by size 是一种基于并查集（Disjoint Set）的合并策略，用于在合并两个集合时选择根节点。该策略<strong>将小集合合并到大集合中</strong>，以减少合并后的树高度，提高查找效率。</p>\n<p>具体来说，在 Union by size 策略中，每个集合的大小都可以表示为其根节点的负值，即 S [root] 的值是集合的大小。因此，当要将两个集合合并时，首先找到它们各自的根节点 root1 和 root2，并比较两个根节点所代表的集合大小。如果 S [root1] 大于 S [root2]，则将 root2 的父节点设为 root1，同时将 root1 的大小更新为两个集合的大小之和；否则，将 root1 的父节点设为 root2，同时将 root2 的大小更新为两个集合的大小之和。</p>\n<p>这样做的原理是，将小集合合并到大集合中可以减少树的高度，从而提高了查找效率。因为树的高度越低，查找元素的时间复杂度就越小，路径压缩也更容易实现。</p>\n<p>1-1 In <em>Union/Find</em> algorithm, if <em>Unions</em> are done by size, the depth of any node must be no more than <em>N</em>/2, but not $$O(logN)$$.</p>\n<p>F</p>\n<pre class=\"mermaid\">graph TD\n0-->1\n0-->2\n2-->3\n2-->4\n4-->5\n4-->6</pre>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo><mo>&lt;</mo><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">height(T)&lt;=log_2N+1\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span></span></p>\n<h5 id=\"2-3-let-t-be-a-tree-created-by-union-by-size-with-n-nodes-then-the-height-of-t-can-be\"><a class=\"markdownIt-Anchor\" href=\"#2-3-let-t-be-a-tree-created-by-union-by-size-with-n-nodes-then-the-height-of-t-can-be\">#</a> 2-3 Let <em>T</em> be a tree created by union-by-size with <em>N</em> nodes, then the height of <em>T</em> can be .</h5>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL0EuYXQ=\">A.at</span> most $$log_2N+1$$</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL0IuYXQ=\">B.at</span> least $$log_2N+1$$</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL0MuYXM=\">C.as</span> large as $$N$$</p>\n<p>D.anything that is greater than 1</p>\n<p><strong>A</strong></p>\n<h2 id=\"hw8\"><a class=\"markdownIt-Anchor\" href=\"#hw8\">#</a> HW8</h2>\n<p><strong>一些定义：</strong></p>\n<p>Complete graph:  a graph that has the maximum number of edges.</p>\n<p>An undirected graph G is <strong>connected</strong> if every pair of distinct vi and vj are connected.</p>\n<p>(Connected) <strong>Component</strong> of an undirected G ::= the maximal connected subgraph—— 联通分量</p>\n<p>最大联通分量</p>\n<p>A tree ::= a graph that is connected and acyclic (无环的)</p>\n<p>A DAG ::= a directed acyclic graph</p>\n<p>Strongly connected directed graph G ::= for every pair of vi and vj in V( G ), there exist directed paths from vi to vj and from vj to vi.  If the graph is connected without direction to the edges, then it is said to be weakly connected.</p>\n<p>强联通：有向图的每一对顶点之间都有路径</p>\n<p>弱连通：有向图底下的无向图之间都是联通的</p>\n<p>边数最小的联通图是树，E=V-1</p>\n<h5 id=\"2-3-given-the-adjacency-list-of-a-directed-graph-as-shown-by-the-figure-there-isare-__-strongly-connected-components\"><a class=\"markdownIt-Anchor\" href=\"#2-3-given-the-adjacency-list-of-a-directed-graph-as-shown-by-the-figure-there-isare-__-strongly-connected-components\">#</a> 2-3 Given the adjacency list of a directed graph as shown by the figure. There is(are) __ strongly connected component(s).</h5>\n<p><img data-src=\"https://images.ptausercontent.com/119\" alt=\"img\"></p>\n\nA. 4 {{0, 1, 5}, {2}, {3}, {4}}\n\nB. 3 {{2}, {4}, {0, 1, 3, 5}}\n\nC. 1 {0, 1, 2, 3, 4, 5}\n\nD. 1 {0, 5, 1, 3}\n\n<p><strong>B</strong></p>\n<pre class=\"mermaid\">graph LR;\n0-->5;\n1-->0;\n1-->3;\n2-->1;\n2-->4;\n3-->0;\n3-->4;\n5-->1;</pre>\n<p>强联通分量</p>\n<p>在有向图 G 中，如果两个顶点 vi,vj 间（vi&gt;vj）有一条从 vi 到 vj 的有向路径，同时还有一条从 vj 到 vi 的有向路径，则称两个顶点强连通 (strongly connected)。如果有向图 G 的每两个顶点都强连通，称 G 是一个强连通图。有向图的极大强连通子图，称为强连通分量 (strongly connected components)，也就是说是图 G 的一些特殊子集。</p>\n<h5 id=\"1-3-if-a-directed-graph-gv-e-is-weakly-connected-then-there-must-be-at-least-v-edges-in-g\"><a class=\"markdownIt-Anchor\" href=\"#1-3-if-a-directed-graph-gv-e-is-weakly-connected-then-there-must-be-at-least-v-edges-in-g\">#</a> 1-3 If a directed graph G=(V, E) is weakly connected, then there must be at least |V| edges in G.</h5>\n<p>F</p>\n<p>至少 | V|-1</p>\n<h5 id=\"2-1-if-graph-g-is-not-connected-and-has-35-edges-then-it-must-have-at-least-____-vertices\"><a class=\"markdownIt-Anchor\" href=\"#2-1-if-graph-g-is-not-connected-and-has-35-edges-then-it-must-have-at-least-____-vertices\">#</a> 2-1 If graph G is NOT connected and has 35 edges, then it must have <mark>at least</mark> ____ vertices.</h5>\n<p>A.7</p>\n<p>B.8</p>\n<p>C.9</p>\n<p>D.10</p>\n<p>D</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mn>9</mn><mo>×</mo><mn>8</mn></mrow><mn>2</mn></mfrac><mo>=</mo><mn>36</mn><mo>&gt;</mo><mn>35</mn></mrow><annotation encoding=\"application/x-tex\">\\frac{9×8}{2}=36&gt;35\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.00744em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.32144em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">2</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">9</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">8</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68354em;vertical-align:-0.0391em;\"></span><span class=\"mord\">3</span><span class=\"mord\">6</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span><span class=\"mord\">5</span></span></span></span></span></p>\n<p>9+1=10</p>\n<p><mark>重点区分：</mark></p>\n<h5 id=\"2-2-a-graph-with-90-vertices-and-20-edges-must-have-at-least-__-connected-components\"><a class=\"markdownIt-Anchor\" href=\"#2-2-a-graph-with-90-vertices-and-20-edges-must-have-at-least-__-connected-components\">#</a> 2-2 A graph with 90 vertices and 20 edges must have <mark>at least</mark> __ connected component(s).</h5>\n<p>A.69</p>\n<p><mark>B.70</mark></p>\n<p>C.84</p>\n<p>D.85</p>\n<p>【解析】20×2=40，90-40+20=70</p>\n<h5 id=\"区分a-graph-with-90-vertices-and-20-edges-must-have-at-most-__-connected-components\"><a class=\"markdownIt-Anchor\" href=\"#区分a-graph-with-90-vertices-and-20-edges-must-have-at-most-__-connected-components\">#</a> 【区分】：A graph with 90 vertices and 20 edges must have <mark>at most</mark> __ connected component(s).</h5>\n<p>A.69</p>\n<p>B.70</p>\n<p><mark>C.84</mark></p>\n<p>D.85</p>\n<p>【解析】 (7×6)/2=21，90-7+1=84</p>\n<h5 id=\"2-4-given-an-undirected-graph-g-with-16-edges-where-3-vertices-are-of-degree-4-4-vertices-are-of-degree-3-and-all-the-other-vertices-are-of-degrees-less-than-3-then-g-must-have-at-least-__-vertices\"><a class=\"markdownIt-Anchor\" href=\"#2-4-given-an-undirected-graph-g-with-16-edges-where-3-vertices-are-of-degree-4-4-vertices-are-of-degree-3-and-all-the-other-vertices-are-of-degrees-less-than-3-then-g-must-have-at-least-__-vertices\">#</a> 2-4 Given an undirected graph G with 16 edges, where 3 vertices are of degree 4, 4 vertices are of degree 3, and all the other vertices are of degrees less than 3. Then G must have at least __ vertices.</h5>\n<p>A.10</p>\n<p>B.11</p>\n<p>C.13</p>\n<p>D.15</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>e</mi><mo>=</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><mn>2</mn><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>3</mn><mo>×</mo><mn>4</mn><mo>+</mo><mn>4</mn><mo>×</mo><mn>3</mn><mo>=</mo><mn>16</mn><mo>×</mo><mn>2</mn><mo>=</mo><mn>32</mn></mrow><annotation encoding=\"application/x-tex\">e=n_1+2n_2+3×4+4×3=16×2=32\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.73333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.79444em;vertical-align:-0.15em;\"></span><span class=\"mord\">2</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mord\">6</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span><span class=\"mord\">2</span></span></span></span></span></p>\n<p>因为要求至少有几个，所以假设剩下的都是度为 2 的节点，32-24=8，8÷2=4，4+3+4=11</p>\n<p><strong>拓扑排序</strong></p>\n<p>拓扑排序存在的前提：</p>\n<p>当且仅当一个有向图为有向无环图（directed acyclic graph，或称 DAG）时，才能得到对应于该图的拓扑排序。每一个有向无环图都至少存在一种拓扑排序。</p>\n<p>方法：不断寻找入度为 0 的节点 pop 出去，删除该节点和相关的边</p>\n<p><strong>6-1 Is Topological Order</strong></p>\n<p>Write a program to test if a give sequence  <code>Seq</code>  is a topological order of a given graph  <code>Graph</code> .</p>\n<h3 id=\"format-of-functions-5\"><a class=\"markdownIt-Anchor\" href=\"#format-of-functions-5\">#</a> Format of functions:</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">IsTopSeq</span><span class=\"params\">( LGraph Graph, Vertex Seq[] )</span></span>;</span><br></pre></td></tr></table></figure>\n<p>where  <code>LGraph</code>  is defined as the following:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">AdjVNode</span> *PtrToAdjVNode; </span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">AdjVNode</span>&#123;</span><br><span class=\"line\">    Vertex AdjV;</span><br><span class=\"line\">    PtrToAdjVNode Next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">Vnode</span>&#123;</span><br><span class=\"line\">    PtrToAdjVNode FirstEdge;</span><br><span class=\"line\">&#125; AdjList[MaxVertexNum];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">GNode</span> *PtrToGNode;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">GNode</span>&#123;  </span><br><span class=\"line\">    <span class=\"type\">int</span> Nv;</span><br><span class=\"line\">    <span class=\"type\">int</span> Ne;</span><br><span class=\"line\">    AdjList G;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToGNode LGraph;</span><br></pre></td></tr></table></figure>\n<p>The function  <code>IsTopSeq</code>  must return  <code>true</code>  if  <code>Seq</code>  does correspond to a topological order; otherwise return  <code>false</code> .</p>\n<p><strong>Note:</strong> Although the vertices are numbered from 1 to MaxVertexNum, they are <strong>indexed from 0</strong> in the LGraph structure.</p>\n<h3 id=\"sample-program-of-judge-5\"><a class=\"markdownIt-Anchor\" href=\"#sample-program-of-judge-5\">#</a> Sample program of judge:</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span> &#123;</span><span class=\"literal\">false</span>, <span class=\"literal\">true</span>&#125; <span class=\"type\">bool</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxVertexNum 10  <span class=\"comment\">/* maximum number of vertices */</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> Vertex;      <span class=\"comment\">/* vertices are numbered from 1 to MaxVertexNum */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AdjVNode</span> *<span class=\"title\">PtrToAdjVNode</span>;</span> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AdjVNode</span>&#123;</span></span><br><span class=\"line\">    Vertex AdjV;</span><br><span class=\"line\">    PtrToAdjVNode Next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Vnode</span>&#123;</span></span><br><span class=\"line\">    PtrToAdjVNode FirstEdge;</span><br><span class=\"line\">&#125; AdjList[MaxVertexNum];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GNode</span> *<span class=\"title\">PtrToGNode</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GNode</span>&#123;</span>  </span><br><span class=\"line\">    <span class=\"type\">int</span> Nv;</span><br><span class=\"line\">    <span class=\"type\">int</span> Ne;</span><br><span class=\"line\">    AdjList G;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToGNode LGraph;</span><br><span class=\"line\"></span><br><span class=\"line\">LGraph <span class=\"title function_\">ReadG</span><span class=\"params\">()</span>; <span class=\"comment\">/* details omitted */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">IsTopSeq</span><span class=\"params\">( LGraph Graph, Vertex Seq[] )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i, j, N;</span><br><span class=\"line\">    Vertex Seq[MaxVertexNum];</span><br><span class=\"line\">    LGraph G = ReadG();</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;N);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;N; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j=<span class=\"number\">0</span>; j&lt;G-&gt;Nv; j++)</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;Seq[j]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( IsTopSeq(G, Seq)==<span class=\"literal\">true</span> ) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;yes\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;no\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Your function will be put here */</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"sample-input-for-the-graph-shown-in-the-figure\"><a class=\"markdownIt-Anchor\" href=\"#sample-input-for-the-graph-shown-in-the-figure\">#</a> Sample Input (for the graph shown in the figure):</h3>\n<p><img data-src=\"https://images.ptausercontent.com/5373e878-196d-45dd-a82f-555b1fea6929.JPG\" alt=\"topord.JPG\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6 8</span><br><span class=\"line\">1 2</span><br><span class=\"line\">1 3</span><br><span class=\"line\">5 2</span><br><span class=\"line\">5 4</span><br><span class=\"line\">2 3</span><br><span class=\"line\">2 6</span><br><span class=\"line\">3 4</span><br><span class=\"line\">6 4</span><br><span class=\"line\">5</span><br><span class=\"line\">1 5 2 3 6 4</span><br><span class=\"line\">5 1 2 6 3 4</span><br><span class=\"line\">5 1 2 3 6 4</span><br><span class=\"line\">5 2 1 6 3 4</span><br><span class=\"line\">1 2 3 4 5 6</span><br></pre></td></tr></table></figure>\n<h3 id=\"sample-output-5\"><a class=\"markdownIt-Anchor\" href=\"#sample-output-5\">#</a> Sample Output:</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yes</span><br><span class=\"line\">yes</span><br><span class=\"line\">yes</span><br><span class=\"line\">no</span><br><span class=\"line\">no</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">IsTopSeq</span><span class=\"params\">( LGraph Graph, Vertex Seq[] )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Vertex InDegree[<span class=\"number\">9999</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i&lt;<span class=\"number\">9999</span>; i++)&#123;</span><br><span class=\"line\">        InDegree[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    PtrToAdjVNode p;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; Graph-&gt;Nv; i++)&#123;</span><br><span class=\"line\">        p = Graph-&gt;G[i].FirstEdge;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            InDegree[p-&gt;AdjV]++;</span><br><span class=\"line\">            p = p-&gt;Next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; Graph-&gt;Nv; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(InDegree[Seq[i]<span class=\"number\">-1</span>] != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        InDegree[Seq[i]<span class=\"number\">-1</span>] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        p = Graph-&gt;G[Seq[i]<span class=\"number\">-1</span>].FirstEdge;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            InDegree[p-&gt;AdjV]--;</span><br><span class=\"line\">            p = p-&gt;Next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Hamiltonian Cycle: 无向图中包含所有顶点的<strong>回路</strong></p>\n<p>Hamiltonian Path: 无向图中包含所有顶点的<strong>路径</strong></p>\n<p>哈密顿图：具有哈密顿回路的无向图</p>\n<h2 id=\"hw9\"><a class=\"markdownIt-Anchor\" href=\"#hw9\">#</a> HW9</h2>\n<p>无权图的单源最短路算法（BFS）</p>\n<p><strong>无权图的建立：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AdjVNode</span> *<span class=\"title\">PtrToAdjVNode</span>;</span> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AdjVNode</span>&#123;</span></span><br><span class=\"line\">    Vertex AdjV;</span><br><span class=\"line\">    PtrToAdjVNode Next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Vnode</span>&#123;</span></span><br><span class=\"line\">    PtrToAdjVNode FirstEdge;</span><br><span class=\"line\">&#125; AdjList[MaxVertexNum];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GNode</span> *<span class=\"title\">PtrToGNode</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GNode</span>&#123;</span>  </span><br><span class=\"line\">    <span class=\"type\">int</span> Nv;</span><br><span class=\"line\">    <span class=\"type\">int</span> Ne;</span><br><span class=\"line\">    AdjList G;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> PtrToGNode LGraph;</span><br></pre></td></tr></table></figure>\n<p>跟 hw8 的一样</p>\n<p><strong>求从顶点 S 到任意一个顶点的最短路径</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Unweighted</span><span class=\"params\">( Graph G, Queue Q, <span class=\"type\">int</span> dist[], <span class=\"type\">int</span> path[], Vertex S )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  Vertex V, U;</span><br><span class=\"line\">  NodePtr ptr;</span><br><span class=\"line\"></span><br><span class=\"line\">  dist[S] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  Enqueue(S, Q);</span><br><span class=\"line\">  <span class=\"keyword\">while</span> ( !IsEmpty(Q) ) &#123;</span><br><span class=\"line\">    V = Dequeue( Q ); <span class=\"comment\">//弹出队列的第一个元素</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( ptr=G-&gt;List[V].FirstEdge; ptr; ptr=ptr-&gt;Next) &#123; <span class=\"comment\">//找到V的邻接点</span></span><br><span class=\"line\">      U = ptr-&gt;AdjV;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( dist[U] == INFINITY ) &#123;</span><br><span class=\"line\">         dist[U] = dist[V] + <span class=\"number\">1</span>; <span class=\"comment\">//路径长度等于前一个点的路经长度+1</span></span><br><span class=\"line\">         path[U] = V; <span class=\"comment\">//把前一个点记录在当前点的path上</span></span><br><span class=\"line\">         Enqueue(U, Q); <span class=\"comment\">//把当前点入队</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有权图的单源最短路算法</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaWNvdXJzZTE2My5vcmcvbGVhcm4vWkpVLTkzMDAxP3RpZD0xNDcxMjE4NDkxIy9sZWFybi9jb250ZW50P3R5cGU9ZGV0YWlsJmFtcDtpZD0xMjU2MTgxNzU5JmFtcDtjaWQ9MTI4ODk5NDcxMCZhbXA7cmVwbGF5PXRydWU=\">Dijkstra 算法</span></p>\n<p>多源最短路算法</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaWNvdXJzZTE2My5vcmcvbGVhcm4vWkpVLTkzMDAxP3RpZD0xNDcxMjE4NDkxIy9sZWFybi9jb250ZW50P3R5cGU9ZGV0YWlsJmFtcDtpZD0xMjU2MTgxNzU5JmFtcDtjaWQ9MTI4ODk5NDcxMSZhbXA7Y29udGVudGlkPTE4NDAwMTU=\">Floyd 算法</span></p>\n<h5 id=\"2-3-if-besides-finding-the-shortest-path-from-s-to-every-other-vertices-we-also-need-to-count-the-number-of-different-shortest-paths-we-can-modify-the-dijkstra-algorithm-in-the-following-way-add-an-array-count-so-that-countv-records-the-number-of-different-shortest-paths-from-s-to-v-then-countv-shall-be-initialized-as\"><a class=\"markdownIt-Anchor\" href=\"#2-3-if-besides-finding-the-shortest-path-from-s-to-every-other-vertices-we-also-need-to-count-the-number-of-different-shortest-paths-we-can-modify-the-dijkstra-algorithm-in-the-following-way-add-an-array-count-so-that-countv-records-the-number-of-different-shortest-paths-from-s-to-v-then-countv-shall-be-initialized-as\">#</a> 2-3 If besides finding the shortest path from  <code>S</code>  to every other vertices, we also need to count the number of different shortest paths, we can modify the Dijkstra algorithm in the following way: add an array  <code>count[]</code>  so that  <code>count[V]</code>  records the number of different shortest paths from  <code>S</code>  to  <code>V</code> . Then  <code>count[V]</code>  shall be initialized as:</h5>\n<p>A. <code>count[S]=1; </code>  and  <code>count[V]=0</code>  for other  <code>V</code></p>\n<p>B. <code>count[S]=0; </code>  and  <code>count[V]=1</code>  for other  <code>V</code></p>\n<p>C. <code>count[V]=1</code>  for all vertices</p>\n<p>D. <code>count[V]=0</code>  for all vertices</p>\n<p><strong>A</strong></p>\n<h1 id=\"hw10\"><a class=\"markdownIt-Anchor\" href=\"#hw10\">#</a> HW10</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMW1WNHkxZTdCNS8/c3BtX2lkX2Zyb209MzMzLjEwMDcudG9wX3JpZ2h0X2Jhcl93aW5kb3dfaGlzdG9yeS5jb250ZW50LmNsaWNrJmFtcDt2ZF9zb3VyY2U9MWE3ZDhmNTk2ZjNkZmU0MGZlZTM0Yzg1OGVkNDdlNzM=\">AOE 网</span></p>\n<p>最早开始时间和最晚结束时间</p>\n<p><img data-src=\"image-20240116202502513.png\" alt></p>\n<p>V 代表事件，a 代表活动</p>\n<p>事件（V）：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>V1</th>\n<th>V2</th>\n<th>V3</th>\n<th>V4</th>\n<th>V5</th>\n<th>V6</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>最早开始时间</td>\n<td>0</td>\n<td>3</td>\n<td>2</td>\n<td>6</td>\n<td>6</td>\n<td>8</td>\n</tr>\n<tr>\n<td>最晚完成时间</td>\n<td>0</td>\n<td>4</td>\n<td>2</td>\n<td>6</td>\n<td>7</td>\n<td>8</td>\n</tr>\n</tbody>\n</table>\n<p>最早开始时间从前往后取最大的</p>\n<p>最晚完成时间从后往前推 (用最早开始时间 - a），取最小的</p>\n<p><mark>最早开始时间 = 最晚完成时间 —— 关键路径</mark></p>\n<p>活动（A）：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>a1</th>\n<th>a2</th>\n<th>a3</th>\n<th>a4</th>\n<th>a5</th>\n<th>a6</th>\n<th>a7</th>\n<th>a8</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>最早开始时间</td>\n<td>0</td>\n<td>0</td>\n<td>3</td>\n<td>3</td>\n<td>2</td>\n<td>2</td>\n<td>6</td>\n<td>6</td>\n</tr>\n<tr>\n<td>最晚完成时间</td>\n<td>1</td>\n<td>0</td>\n<td>4</td>\n<td>4</td>\n<td>2</td>\n<td>5</td>\n<td>6</td>\n<td>7</td>\n</tr>\n</tbody>\n</table>\n<p>最早开始时间取箭头的出发点的最早开始时间，最晚完成时间取箭头指向的点的最晚完成时间 - a</p>\n<p><mark>最早开始时间 = 最晚完成时间 —— 关键活动</mark></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVB2NDExNTd4aC8/cD05JmFtcDtzcG1faWRfZnJvbT1wYWdlRHJpdmVy\">Ford-Fulkerson Algorithm 寻找网络最大流</span></p>\n<p>用 Residual Graph 添加反向路径，然后用原图减去 Residual Graph</p>\n<p>worst-case time complexity: O (f*m)\t\tf 是最大流的大小，m 是边数</p>\n<p><strong>最小生成树</strong></p>\n<p>最小生成树：从连通无向图中找出一棵树（包含所有 n 个节点和 n-1 条边），同时边的权重之和要最小</p>\n<p>Prim 算法：随便取一个根节点记作 visited，不断寻找 visited 节点和 unvisited 节点之间权重最小的边</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUE1NDExTTd6Yy8/c3BtX2lkX2Zyb209cGFnZURyaXZlciZhbXA7dmRfc291cmNlPTFhN2Q4ZjU5NmYzZGZlNDBmZWUzNGM4NThlZDQ3ZTcz\">Prim 算法 寻找最小生成树</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVN2NDExVjc4MS8/c3BtX2lkX2Zyb209MzMzLjc4OCZhbXA7dmRfc291cmNlPTFhN2Q4ZjU5NmYzZGZlNDBmZWUzNGM4NThlZDQ3ZTcz\">Kruskal 算法：</span>（1）创建一个队列，将边按权重排序，最小的在最上面；（2）从顶端不断 dequeue，如果符合就在图中圈出那条边</p>\n<p>—— 并查集</p>\n<p><strong>一句话：Prim 算法对点做操作，Kruskal 算法对边做操作</strong></p>\n<h1 id=\"hw11\"><a class=\"markdownIt-Anchor\" href=\"#hw11\">#</a> HW11</h1>\n<h5 id=\"1-1-for-a-graph-if-each-vertex-has-an-even-degree-or-only-two-vertexes-have-odd-degree-we-can-find-a-cycle-that-visits-every-edge-exactly-once\"><a class=\"markdownIt-Anchor\" href=\"#1-1-for-a-graph-if-each-vertex-has-an-even-degree-or-only-two-vertexes-have-odd-degree-we-can-find-a-cycle-that-visits-every-edge-exactly-once\">#</a> 1-1 For a graph, if each vertex has an even degree or only two vertexes have odd degree, we can find a cycle that visits every edge exactly once</h5>\n<p>F</p>\n<p>欧拉回路：当且仅当图中每个顶点的度数都为偶数，并且图是连通的（一笔画）</p>\n<p>欧拉路径：当且仅当图中恰有两个顶点的度数为奇数，其余顶点的度数都为偶数，并且图是连通的</p>\n<p>哈密顿 Cycle：经过所有节点的环</p>\n<p>哈密顿 Path：经过所有节点的回路</p>\n<p>DFS: 寻路–回溯</p>\n<h5 id=\"2-1-apply-dfs-to-a-directed-acyclic-graph-and-output-the-vertex-before-the-end-of-each-recursion-the-output-sequence-will-be\"><a class=\"markdownIt-Anchor\" href=\"#2-1-apply-dfs-to-a-directed-acyclic-graph-and-output-the-vertex-before-the-end-of-each-recursion-the-output-sequence-will-be\">#</a> 2-1 Apply DFS to a directed acyclic graph, and output the vertex before the end of each recursion. The output sequence will be:</h5>\n<p>A.unsorted</p>\n<p><mark>B.topologically sorted</mark></p>\n<p>C.reversely topologically sorted</p>\n<p>D.None of the above</p>\n<p>Biconnected:（重连通）</p>\n<p><img data-src=\"image-20240116215902974.png\" alt><br>\n<img data-src=\"image-20240116221328431.png\" alt></p>\n<p>插入排序：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InsertionSort</span><span class=\"params\">( ElementType A[], <span class=\"type\">int</span> N )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> j, P;</span><br><span class=\"line\">    ElementType Tmp;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(P=<span class=\"number\">1</span>; P&lt;N; P++)&#123;</span><br><span class=\"line\">        Tmp = A[P];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j=P; j&gt;<span class=\"number\">0</span> &amp;&amp; A[j<span class=\"number\">-1</span>]&gt;Tmp; j--)&#123;</span><br><span class=\"line\">            A[j]=A[j<span class=\"number\">-1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        A[j]=Tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>worst-case time complexity: $$O(N^2)$$</p>\n<p>best-case time complexity: $$O(N)$$</p>\nT(N,I) = O(I+N)$$ —— I:逆序对\n\n对于任意一个交换相邻元素的排序算法，平均时间复杂度都是$$\\Omega(N^2)$$.\n\n\n\n**ShellSort**\n\n**希尔排序**\n\n5-sort\n\n3-sort\n\n1-sort\n\n每一步都是插入排序\n\n（1）Define an increment sequence h1 < h2 < … < ht  ( h1 = 1 )\n\n（2）Define an $$h_k-sort$$ at each phase for k = t, t - 1, …, 1\n\n**Shell’s increment sequence：$$h_t=\\lfloor N \\rfloor$$, $$h_k = \\lfloor h_k+1 / 2\\rfloor $$**\n\nworst-case time complexity: $$\\theta(N^2)\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Shellsort</span><span class=\"params\">( ElementType A[ ], <span class=\"type\">int</span> N )</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">      <span class=\"type\">int</span>  i, j, Increment; </span><br><span class=\"line\">      ElementType  Tmp; </span><br><span class=\"line\">      <span class=\"keyword\">for</span> ( Increment = N / <span class=\"number\">2</span>; Increment &gt; <span class=\"number\">0</span>; Increment /= <span class=\"number\">2</span> )  </span><br><span class=\"line\">\t<span class=\"comment\">/*h sequence */</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( i = Increment; i &lt; N; i++ ) &#123; <span class=\"comment\">/* insertion sort */</span></span><br><span class=\"line\">\t      Tmp = A[ i ]; </span><br><span class=\"line\">\t      <span class=\"keyword\">for</span> ( j = i; j &gt;= Increment; j - = Increment ) </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>( Tmp &lt; A[ j - Increment ] ) </span><br><span class=\"line\">\t\t      A[ j ] = A[ j - Increment ]; </span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> </span><br><span class=\"line\">\t\t      <span class=\"keyword\">break</span>; </span><br><span class=\"line\">\t\tA[ j ] = Tmp; </span><br><span class=\"line\">\t&#125; <span class=\"comment\">/* end for-I and for-Increment loops */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>**Hibbard’s Increment Sequence: ** $$h_k = 2^k-1$$</p>\n<p>worst-case time complexity: $$\\theta(N$$<sup>2/3</sup>$$)$$</p>\n<p>in-place 不需要申请其余的空间</p>\n<p>stability （插入排序稳定，希尔排序不稳定）</p>\n<p><strong>HeapSort</strong></p>\n<p><strong>堆排序</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Heapsort</span><span class=\"params\">( ElementType A[ ], <span class=\"type\">int</span> N )</span> </span><br><span class=\"line\">&#123;  <span class=\"type\">int</span> i; </span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( i = N / <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i - - ) <span class=\"comment\">/* BuildHeap */</span> </span><br><span class=\"line\">        PercDown( A, i, N ); </span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( i = N - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i - - ) &#123; </span><br><span class=\"line\">        Swap( &amp;A[ <span class=\"number\">0</span> ], &amp;A[ i ] ); <span class=\"comment\">/* DeleteMax */</span> </span><br><span class=\"line\">        PercDown( A, <span class=\"number\">0</span>, i ); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度 $$O (NlogN)$$</p>\n<p>归并排序</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(NlogN)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>快排</p>\n",
            "tags": [
                "fds"
            ]
        }
    ]
}