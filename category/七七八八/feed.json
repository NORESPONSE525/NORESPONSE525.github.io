{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog • All posts by \"七七八八\" category",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/10/15/note/20251015/",
            "url": "http://example.com/2025/10/15/note/20251015/",
            "title": "20251015力扣刷题笔记",
            "date_published": "2025-10-14T16:00:00.000Z",
            "content_html": "<h2 id=\"一-c-常用容器总览\"><a class=\"markdownIt-Anchor\" href=\"#一-c-常用容器总览\">#</a> 一、C++ 常用容器总览</h2>\n<table>\n<thead>\n<tr>\n<th>容器</th>\n<th>类型</th>\n<th>底层结构</th>\n<th>是否有序</th>\n<th>是否去重</th>\n<th>主要用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>vector</code></td>\n<td>序列容器</td>\n<td>动态数组</td>\n<td>否</td>\n<td>否</td>\n<td>动态数组，随机访问</td>\n</tr>\n<tr>\n<td><code>deque</code></td>\n<td>序列容器</td>\n<td>双端队列（分段连续）</td>\n<td>否</td>\n<td>否</td>\n<td>首尾高效插入</td>\n</tr>\n<tr>\n<td><code>list</code></td>\n<td>序列容器</td>\n<td>双向链表</td>\n<td>否</td>\n<td>否</td>\n<td>频繁中间插入 / 删除</td>\n</tr>\n<tr>\n<td><code>forward_list</code></td>\n<td>序列容器</td>\n<td>单向链表</td>\n<td>否</td>\n<td>否</td>\n<td>节省内存的链表</td>\n</tr>\n<tr>\n<td><code>array</code></td>\n<td>序列容器</td>\n<td>静态数组</td>\n<td>否</td>\n<td>否</td>\n<td>固定大小数组</td>\n</tr>\n<tr>\n<td><code>stack</code></td>\n<td>容器适配器</td>\n<td><code>deque</code> （默认）</td>\n<td>否</td>\n<td>否</td>\n<td>栈（LIFO）</td>\n</tr>\n<tr>\n<td><code>queue</code></td>\n<td>容器适配器</td>\n<td><code>deque</code> （默认）</td>\n<td>否</td>\n<td>否</td>\n<td>队列（FIFO）</td>\n</tr>\n<tr>\n<td><code>priority_queue</code></td>\n<td>容器适配器</td>\n<td><code>vector</code> （默认）</td>\n<td>是（堆序）</td>\n<td>否</td>\n<td>优先队列</td>\n</tr>\n<tr>\n<td><code>set</code></td>\n<td>关联容器</td>\n<td>红黑树</td>\n<td>是（升序）</td>\n<td>是</td>\n<td>有序唯一集合</td>\n</tr>\n<tr>\n<td><code>multiset</code></td>\n<td>关联容器</td>\n<td>红黑树</td>\n<td>是</td>\n<td>否</td>\n<td>有序可重复集合</td>\n</tr>\n<tr>\n<td><code>map</code></td>\n<td>关联容器</td>\n<td>红黑树</td>\n<td>是</td>\n<td>是（按键）</td>\n<td>有序键值对</td>\n</tr>\n<tr>\n<td><code>multimap</code></td>\n<td>关联容器</td>\n<td>红黑树</td>\n<td>是</td>\n<td>否</td>\n<td>有序可重复键值对</td>\n</tr>\n<tr>\n<td><code>unordered_set</code></td>\n<td>无序关联容器</td>\n<td>哈希表</td>\n<td>否</td>\n<td>是</td>\n<td>无序唯一集合</td>\n</tr>\n<tr>\n<td><code>unordered_multiset</code></td>\n<td>无序关联容器</td>\n<td>哈希表</td>\n<td>否</td>\n<td>否</td>\n<td>无序可重复集合</td>\n</tr>\n<tr>\n<td><code>unordered_map</code></td>\n<td>无序关联容器</td>\n<td>哈希表</td>\n<td>否</td>\n<td>是（按键）</td>\n<td>无序键值对</td>\n</tr>\n<tr>\n<td><code>unordered_multimap</code></td>\n<td>无序关联容器</td>\n<td>哈希表</td>\n<td>否</td>\n<td>否</td>\n<td>无序可重复键值对</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"二-各容器操作复杂度对比\"><a class=\"markdownIt-Anchor\" href=\"#二-各容器操作复杂度对比\">#</a> 二、各容器操作复杂度对比</h2>\n<h3 id=\"1-vectort\"><a class=\"markdownIt-Anchor\" href=\"#1-vectort\">#</a> 1.  <code>vector&lt;T&gt;</code></h3>\n<ul>\n<li><strong>底层</strong>：动态数组（连续内存）</li>\n<li><strong>特点</strong>：支持随机访问，尾部操作快，中间插入慢。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>复杂度</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>push_back()</code></td>\n<td>平均 O (1)，最坏 O (n)</td>\n<td>扩容时复制</td>\n</tr>\n<tr>\n<td><code>pop_back()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>insert(it, x)</code></td>\n<td>O(n)</td>\n<td>中间插入需移动</td>\n</tr>\n<tr>\n<td><code>erase(it)</code></td>\n<td>O(n)</td>\n<td>删除后需移动</td>\n</tr>\n<tr>\n<td><code>operator[]</code>  /  <code>at()</code></td>\n<td>O(1)</td>\n<td>随机访问</td>\n</tr>\n<tr>\n<td><code>size()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>begin()</code>  /  <code>end()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>适合：频繁随机访问、尾部增删<br>\n不适合：频繁中间插入 / 删除</p>\n</blockquote>\n<hr>\n<h3 id=\"2-dequet双端队列\"><a class=\"markdownIt-Anchor\" href=\"#2-dequet双端队列\">#</a> 2.  <code>deque&lt;T&gt;</code> （双端队列）</h3>\n<ul>\n<li><strong>底层</strong>：分段连续数组（多个小数组）</li>\n<li><strong>特点</strong>：首尾操作都快，支持随机访问。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>复杂度</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>push_front()</code>  /  <code>push_back()</code></td>\n<td>O(1)</td>\n<td>首尾插入都快</td>\n</tr>\n<tr>\n<td><code>pop_front()</code>  /  <code>pop_back()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>insert()</code>  /  <code>erase()</code> （中间）</td>\n<td>O(n)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>operator[]</code>  /  <code>at()</code></td>\n<td>O(1)</td>\n<td>支持随机访问</td>\n</tr>\n<tr>\n<td><code>size()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>适合：需要首尾高效插入的场景（如滑动窗口）<br>\n注意：迭代器失效规则比  <code>vector</code>  复杂</p>\n</blockquote>\n<hr>\n<h3 id=\"3-listt双向链表\"><a class=\"markdownIt-Anchor\" href=\"#3-listt双向链表\">#</a> 3.  <code>list&lt;T&gt;</code> （双向链表）</h3>\n<ul>\n<li><strong>底层</strong>：双向链表</li>\n<li><strong>特点</strong>：任意位置插入 / 删除 O (1)，但不支持随机访问。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>复杂度</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>push_front()</code>  /  <code>push_back()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>insert(it, x)</code></td>\n<td>O(1)</td>\n<td>已知位置</td>\n</tr>\n<tr>\n<td><code>erase(it)</code></td>\n<td>O(1)</td>\n<td>已知位置</td>\n</tr>\n<tr>\n<td><code>operator[]</code></td>\n<td>不支持</td>\n<td></td>\n</tr>\n<tr>\n<td><code>find()</code></td>\n<td>O(n)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>size()</code></td>\n<td>C++11 起 O (1)，之前 O (n)</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>适合：频繁中间插入 / 删除<br>\n不适合：随机访问、缓存不友好</p>\n</blockquote>\n<hr>\n<h3 id=\"4-forward_listt单向链表\"><a class=\"markdownIt-Anchor\" href=\"#4-forward_listt单向链表\">#</a> 4.  <code>forward_list&lt;T&gt;</code> （单向链表）</h3>\n<ul>\n<li><strong>底层</strong>：单向链表</li>\n<li><strong>特点</strong>：比  <code>list</code>  更省内存，但只能单向遍历。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>复杂度</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>push_front()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>insert_after()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>erase_after()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td>不支持  <code>push_back()</code></td>\n<td>—</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>适合：内存敏感、只需前向遍历的场景</p>\n</blockquote>\n<hr>\n<h3 id=\"5-arrayt-n\"><a class=\"markdownIt-Anchor\" href=\"#5-arrayt-n\">#</a> 5.  <code>array&lt;T, N&gt;</code></h3>\n<ul>\n<li><strong>底层</strong>：静态数组（栈上内存）</li>\n<li><strong>特点</strong>：大小固定，性能极高。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>复杂度</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>operator[]</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>at()</code></td>\n<td>O(1)</td>\n<td>带边界检查</td>\n</tr>\n<tr>\n<td><code>size()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td>所有操作</td>\n<td>O(1)</td>\n<td>固定大小</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>适合：小数据、固定大小、高性能场景</p>\n</blockquote>\n<hr>\n<h3 id=\"6-sett-mapkv\"><a class=\"markdownIt-Anchor\" href=\"#6-sett-mapkv\">#</a> 6.  <code>set&lt;T&gt;</code>  /  <code>map&lt;K,V&gt;</code></h3>\n<ul>\n<li><strong>底层</strong>：<strong>红黑树</strong>（自平衡二叉搜索树）</li>\n<li><strong>特点</strong>：自动排序、自动去重（ <code>set</code>  和  <code>map</code>  键唯一）</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>复杂度</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>insert()</code></td>\n<td>O(log n)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>find()</code></td>\n<td>O(log n)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>erase()</code></td>\n<td>O(log n)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>size()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td>遍历</td>\n<td>O(n)</td>\n<td>有序输出</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>适合：需要有序、去重、查找的场景</p>\n</blockquote>\n<hr>\n<h3 id=\"7-unordered_sett-unordered_mapkv\"><a class=\"markdownIt-Anchor\" href=\"#7-unordered_sett-unordered_mapkv\">#</a> 7.  <code>unordered_set&lt;T&gt;</code>  /  <code>unordered_map&lt;K,V&gt;</code></h3>\n<ul>\n<li><strong>底层</strong>：<strong>哈希表</strong>（开链法或开放寻址）</li>\n<li><strong>特点</strong>：平均极快，但无序，最坏 O (n)</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>复杂度</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>insert()</code></td>\n<td>平均 O (1)，最坏 O (n)</td>\n<td>哈希冲突时退化</td>\n</tr>\n<tr>\n<td><code>find()</code></td>\n<td>平均 O (1)，最坏 O (n)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>erase()</code></td>\n<td>平均 O (1)，最坏 O (n)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>size()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td>负载因子</td>\n<td>影响性能</td>\n<td>可调  <code>max_load_factor()</code></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>适合：大数据、高频查找、不在乎顺序<br>\n不适合：需要有序输出</p>\n</blockquote>\n<h3 id=\"8-容器适配器stack-queue-priority_queue\"><a class=\"markdownIt-Anchor\" href=\"#8-容器适配器stack-queue-priority_queue\">#</a> 8. 容器适配器（ <code>stack</code> ,  <code>queue</code> ,  <code>priority_queue</code> ）</h3>\n<table>\n<thead>\n<tr>\n<th>容器</th>\n<th>默认底层</th>\n<th>特点</th>\n<th>操作复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>stack&lt;T&gt;</code></td>\n<td><code>deque</code></td>\n<td>后进先出（LIFO）</td>\n<td><code>push</code> / <code>pop</code> / <code>top</code> : O(1)</td>\n</tr>\n<tr>\n<td><code>queue&lt;T&gt;</code></td>\n<td><code>deque</code></td>\n<td>先进先出（FIFO）</td>\n<td><code>push</code> / <code>pop</code> / <code>front</code> : O(1)</td>\n</tr>\n<tr>\n<td><code>priority_queue&lt;T&gt;</code></td>\n<td><code>vector</code>  + 堆</td>\n<td>最大 / 最小元素在顶</td>\n<td><code>push</code> : O(log n),  <code>top</code> : O(1),  <code>pop</code> : O(log n)</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>它们<strong>不是真正容器</strong>，而是基于其他容器的封装，接口受限。</p>\n</blockquote>\n<h2 id=\"选择\"><a class=\"markdownIt-Anchor\" href=\"#选择\">#</a> 选择</h2>\n<table>\n<thead>\n<tr>\n<th>需求</th>\n<th>推荐容器</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>动态数组，随机访问</td>\n<td><code>vector</code></td>\n</tr>\n<tr>\n<td>首尾都能高效插入</td>\n<td><code>deque</code></td>\n</tr>\n<tr>\n<td>频繁中间插入 / 删除</td>\n<td><code>list</code></td>\n</tr>\n<tr>\n<td>固定大小数组</td>\n<td><code>array</code></td>\n</tr>\n<tr>\n<td>快速查找、去重（不在乎顺序）</td>\n<td><code>unordered_set</code>  /  <code>unordered_map</code></td>\n</tr>\n<tr>\n<td>需要有序输出、去重</td>\n<td><code>set</code>  /  <code>map</code></td>\n</tr>\n<tr>\n<td>栈操作</td>\n<td><code>stack</code></td>\n</tr>\n<tr>\n<td>队列操作</td>\n<td><code>queue</code></td>\n</tr>\n<tr>\n<td>找最大 / 最小元素（堆）</td>\n<td><code>priority_queue</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h2>\n<table>\n<thead>\n<tr>\n<th>口诀</th>\n<th>对应容器</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>“要快用 unordered”</strong></td>\n<td><code>unordered_set/map</code> （平均 O (1)）</td>\n</tr>\n<tr>\n<td><strong>“要序用 set/map”</strong></td>\n<td><code>set/map</code> （O (log n)，有序）</td>\n</tr>\n<tr>\n<td><strong>“通用选 vector”</strong></td>\n<td><code>vector</code> （最常用）</td>\n</tr>\n<tr>\n<td><strong>“首尾快用 deque”</strong></td>\n<td><code>deque</code> （双端高效）</td>\n</tr>\n<tr>\n<td><strong>“中间删用 list”</strong></td>\n<td><code>list</code> （任意位置 O (1) 删除）</td>\n</tr>\n<tr>\n<td><strong>“最大最小用堆”</strong></td>\n<td><code>priority_queue</code></td>\n</tr>\n</tbody>\n</table>\n",
            "tags": [
                "容器"
            ]
        },
        {
            "id": "http://example.com/2025/08/02/note/20250802/",
            "url": "http://example.com/2025/08/02/note/20250802/",
            "title": "20250802阅读论文",
            "date_published": "2025-08-01T16:00:00.000Z",
            "content_html": "<blockquote>\n<p><strong>标题</strong>：Self-supervised representation learning from 12-lead ECG data<br>\n<strong> 作者</strong>：Temesgen Mehari, Nils Strodthoff<br>\n<strong> 期刊</strong>：<em>Computers in Biology and Medicine</em>, 2022<br>\n<strong>DOI</strong>: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2kub3JnLzEwLjEwMTYvai5jb21wYmlvbWVkLjIwMjEuMTA1MTE0\">10.1016/j.compbiomed.2021.105114</span><br>\n<strong> 关键词</strong>：自监督学习、对比学习、心电图（ECG）、时间序列分析、深度学习</p>\n</blockquote>\n<p>12-lead ECG 是常见生物信号，但高质量标注数据稀缺，标注依赖专家，成本高，尤其对罕见病或睡眠相关心血管事件更难获取标签，然而，无标签 ECG 数据海量存在，因此利用自监督学习从大量无标签 ECG 中预训练模型，学习通用特征表示，再用于下游任务微调，提升性能与标签效率。</p>\n<p>本文采用  <code>xresnet1d50</code>  作为主干网络，对比了不同的自监督学习方法。</p>\n<h2 id=\"xresnet1d\"><a class=\"markdownIt-Anchor\" href=\"#xresnet1d\">#</a> xresnet1d</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly90aW1lc2VyaWVzYWkuZ2l0aHViLmlvL3RzYWkvbW9kZWxzLnhyZXNuZXQxZC5odG1s\">https://timeseriesai.github.io/tsai/models.xresnet1d.html</span></p>\n<h2 id=\"instance-discrimination\"><a class=\"markdownIt-Anchor\" href=\"#instance-discrimination\">#</a> Instance Discrimination</h2>\n<h3 id=\"simclr\"><a class=\"markdownIt-Anchor\" href=\"#simclr\">#</a> SimCLR</h3>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzIwMDIuMDU3MDk=\">T. Chen, S. Kornblith, M. Norouzi, G. Hinton, A simple framework for contrastive learning of visual representations, in: International Conference on Machine Learning, 2020.</span></p>\n<h3 id=\"byol\"><a class=\"markdownIt-Anchor\" href=\"#byol\">#</a> BYOL</h3>\n<h3 id=\"swav\"><a class=\"markdownIt-Anchor\" href=\"#swav\">#</a> SwAV</h3>\n<h3 id=\"cpc\"><a class=\"markdownIt-Anchor\" href=\"#cpc\">#</a> CPC</h3>\n<h2 id=\"latent-forecasting\"><a class=\"markdownIt-Anchor\" href=\"#latent-forecasting\">#</a> Latent Forecasting</h2>\n",
            "tags": [
                "自监督学习"
            ]
        }
    ]
}