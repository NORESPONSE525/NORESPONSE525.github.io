{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog • All posts by \"七七八八\" category",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/12/11/note/20251211/",
            "url": "http://example.com/2025/12/11/note/20251211/",
            "title": "杂项",
            "date_published": "2025-12-10T16:00:00.000Z",
            "content_html": "<h1 id=\"默认构造-拷贝构造-移动构造以及赋值运算符重载\"><a class=\"markdownIt-Anchor\" href=\"#默认构造-拷贝构造-移动构造以及赋值运算符重载\">#</a> 默认构造、拷贝构造、移动构造以及赋值运算符重载</h1>\n<figure class=\"highlight c++\"><figcaption><span>构造函数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span>* data;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>(): <span class=\"built_in\">data</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">MyClass</span>() &#123; <span class=\"keyword\">delete</span> data; &#125;</span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>(<span class=\"type\">const</span> MyClass&amp; other): <span class=\"built_in\">data</span>(<span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (other.data != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>(*other.data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>(MyClass&amp;&amp; other) <span class=\"keyword\">noexcept</span>: <span class=\"built_in\">data</span>(<span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        data = other.data;</span><br><span class=\"line\">        other.data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 拷贝赋值运算符</span></span><br><span class=\"line\">    MyClass&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> MyClass&amp; other) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == &amp;other) &#123;      <span class=\"comment\">// 自赋值检查</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> data;              <span class=\"comment\">// 释放当前资源</span></span><br><span class=\"line\">        data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (other.data != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>(*other.data); <span class=\"comment\">// 深拷贝</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 移动赋值运算符</span></span><br><span class=\"line\">    MyClass&amp; <span class=\"keyword\">operator</span>=(MyClass&amp;&amp; other) <span class=\"keyword\">noexcept</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == &amp;other) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> data;               <span class=\"comment\">// 释放当前资源</span></span><br><span class=\"line\">        data = other.data;         <span class=\"comment\">// 接管</span></span><br><span class=\"line\">        other.data = <span class=\"literal\">nullptr</span>;      <span class=\"comment\">// 置空</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>下面用动态数组示例补全拷贝 / 移动语义（遵循 Rule of Five）：</p>\n<figure class=\"highlight c++\"><figcaption><span>数组</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyArray</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span>* data;</span><br><span class=\"line\">    <span class=\"type\">int</span> size;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MyArray</span>(): <span class=\"built_in\">data</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">size</span>(<span class=\"number\">0</span>) &#123;&#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">MyArray</span>()&#123; <span class=\"keyword\">delete</span>[] data; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">MyArray</span>(<span class=\"type\">int</span> sz): <span class=\"built_in\">data</span>(sz ? <span class=\"keyword\">new</span> <span class=\"type\">int</span>[sz] : <span class=\"literal\">nullptr</span>), <span class=\"built_in\">size</span>(sz) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 拷贝构造：深拷贝</span></span><br><span class=\"line\">    <span class=\"built_in\">MyArray</span>(<span class=\"type\">const</span> MyArray&amp; other): <span class=\"built_in\">data</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">size</span>(other.size) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (other.data &amp;&amp; other.size &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[other.size];</span><br><span class=\"line\">            <span class=\"built_in\">copy</span>(other.data, other.data + other.size, data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 移动构造：接管资源</span></span><br><span class=\"line\">    <span class=\"built_in\">MyArray</span>(MyArray&amp;&amp; other) <span class=\"keyword\">noexcept</span>: <span class=\"built_in\">data</span>(other.data), <span class=\"built_in\">size</span>(other.size) &#123;</span><br><span class=\"line\">        other.data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        other.size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 拷贝赋值：先复制再交换（异常安全）</span></span><br><span class=\"line\">    MyArray&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> MyArray&amp; other) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == &amp;other) <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span>* newData = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (other.size &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            newData = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[other.size];</span><br><span class=\"line\">            <span class=\"built_in\">copy</span>(other.data, other.data + other.size, newData);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] data;</span><br><span class=\"line\">        data = newData;</span><br><span class=\"line\">        size = other.size;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 移动赋值：释放当前资源并接管</span></span><br><span class=\"line\">    MyArray&amp; <span class=\"keyword\">operator</span>=(MyArray&amp;&amp; other) <span class=\"keyword\">noexcept</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == &amp;other) <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] data;</span><br><span class=\"line\">        data = other.data;</span><br><span class=\"line\">        size = other.size;</span><br><span class=\"line\">        other.data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        other.size = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getSize</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> size; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span>* <span class=\"title\">getData</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> data; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>要点：</p>\n<ul>\n<li>对于拥有动态资源的类型，建议同时实现析构、拷贝构造、移动构造、拷贝赋值、移动赋值（Rule of Five）。</li>\n<li>拷贝要做深拷贝，移动要尽可能接管资源并置空原对象以避免双重释放。</li>\n<li>拷贝赋值实现中可以先分配新资源，再释放旧资源以提高异常安全性。</li>\n</ul>\n<h1 id=\"智能指针怎么用\"><a class=\"markdownIt-Anchor\" href=\"#智能指针怎么用\">#</a> 智能指针怎么用</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xOTIxNTc5ODE0Mjg1OTc1Njcw\">https://zhuanlan.zhihu.com/p/1921579814285975670</span></p>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用std::make_shared</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> ptr1 = std::<span class=\"built_in\">make_shared</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用std::shared_ptr(new T(args...))</span></span><br><span class=\"line\"><span class=\"function\">std::shared_ptr&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">ptr2</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"type\">int</span>(<span class=\"number\">10</span>))</span></span>;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::shared_ptr&lt;<span class=\"type\">int</span>&gt; shared_ptr1 = std::<span class=\"built_in\">make_shared</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">10</span>); </span><br><span class=\"line\">std::weak_ptr&lt;<span class=\"type\">int</span>&gt; weak_ptr1 = shared_ptr1; </span><br><span class=\"line\"><span class=\"keyword\">auto</span> shared_ptr2 = weak_ptr<span class=\"number\">1.l</span>ock(); </span><br><span class=\"line\"><span class=\"keyword\">if</span> (shared_ptr2) &#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Object is still alive: &quot;</span> &lt;&lt; *shared_ptr2 &lt;&lt; std::endl; </span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Object has been destroyed&quot;</span> &lt;&lt; std::endl; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>多个 shared_ptr 对象可以共享同一个动态分配的对象，并通过一个<mark>共享的控制块</mark>（control block）来维护引用计数，当最后一个 shared_ptr 被销毁或重置时，自动释放所管理的对象。</p>\n<h3 id=\"1-控制块control-block\"><a class=\"markdownIt-Anchor\" href=\"#1-控制块control-block\">#</a> 1. 控制块（Control Block）</h3>\n<p>每个被  <code>shared_ptr</code>  管理的对象都会关联一个 <strong>控制块（control block）</strong>，这个控制块通常包含以下信息：</p>\n<ul>\n<li><strong>强引用计数（strong reference count）</strong>：即有多少个  <code>shared_ptr</code>  正在共享该对象。</li>\n<li><strong>弱引用计数（weak reference count）</strong>：即有多少个  <code>weak_ptr</code>  指向该控制块（用于支持  <code>weak_ptr</code> ）。</li>\n<li><strong>被管理对象的指针</strong>（有时直接内嵌对象，如通过  <code>make_shared</code> ）。</li>\n<li><strong>删除器（deleter）</strong>：可自定义的函数对象，用于释放资源（默认是  <code>delete</code> ）。</li>\n<li><strong>分配器（allocator）</strong>：如果使用了自定义内存分配策略。</li>\n</ul>\n<blockquote>\n<p>注意：控制块本身是堆上分配的（除非使用  <code>make_shared</code> ，此时对象和控制块可能分配在同一块内存中以提高效率）。</p>\n</blockquote>\n<h3 id=\"2-引用计数的增减\"><a class=\"markdownIt-Anchor\" href=\"#2-引用计数的增减\">#</a> 2. 引用计数的增减</h3>\n<ul>\n<li><strong>构造 / 拷贝 / 赋值</strong>：\n<ul>\n<li>当一个新的  <code>shared_ptr</code>  通过拷贝构造、移动构造或赋值操作指向同一对象时，<strong>强引用计数加 1</strong>。</li>\n</ul>\n</li>\n<li><strong>析构 / 重置（reset）</strong>：\n<ul>\n<li>当一个  <code>shared_ptr</code>  被销毁或调用  <code>reset()</code>  时，<strong>强引用计数减 1</strong>。</li>\n<li>如果强引用计数变为 0，则：\n<ul>\n<li>调用删除器（deleter）释放被管理的对象；</li>\n<li><strong>但控制块不会立即释放</strong>，因为可能还有  <code>weak_ptr</code>  存在（需等待弱引用计数也为 0 才释放控制块）。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-线程安全性\"><a class=\"markdownIt-Anchor\" href=\"#3-线程安全性\">#</a> 3. 线程安全性</h3>\n<ul>\n<li><strong>引用计数的操作是原子的</strong>（通常使用  <code>std::atomic</code>  实现），因此多个线程同时拷贝或销毁  <code>shared_ptr</code>  是线程安全的。</li>\n<li>但注意：<strong>对被管理对象本身的访问不是线程安全的</strong>，需要用户自己加锁。</li>\n</ul>\n<h1 id=\"shared_ptr什么时候1什么时候-1\"><a class=\"markdownIt-Anchor\" href=\"#shared_ptr什么时候1什么时候-1\">#</a> shared_ptr 什么时候 + 1 什么时候 - 1</h1>\n<h2 id=\"1\"><a class=\"markdownIt-Anchor\" href=\"#1\">#</a> +1</h2>\n<ol>\n<li>拷贝构造</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::shared_ptr&lt;<span class=\"type\">int</span>&gt; p1 = std::<span class=\"built_in\">make_shared</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">42</span>);</span><br><span class=\"line\"><span class=\"function\">std::shared_ptr&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">p2</span><span class=\"params\">(p1)</span></span>;  <span class=\"comment\">// +1 → 强引用计数变为 2</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>拷贝赋值</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::shared_ptr&lt;<span class=\"type\">int</span>&gt; p3;</span><br><span class=\"line\">p3 = p1;  <span class=\"comment\">// p3 原来为空，现在共享 p1 的对象 → +1</span></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>函数传参</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">foo</span><span class=\"params\">(std::shared_ptr&lt;<span class=\"type\">int</span>&gt; p)</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\"><span class=\"built_in\">foo</span>(p1);  <span class=\"comment\">// 进入函数时拷贝 → +1；函数返回时析构 → -1</span></span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>作为返回值返回</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::shared_ptr&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">getPtr</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p1;  <span class=\"comment\">// 返回时可能触发拷贝或移动（见下文）</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> p4 = <span class=\"built_in\">getPtr</span>();  <span class=\"comment\">// 若发生拷贝 → +1；若被优化为移动 → 不变</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>现代编译器通常会进行 返回值优化（RVO） 或使用 移动语义，避免不必要的 +1/-1</p>\n</blockquote>\n<ol start=\"5\">\n<li>放入容器（如 vector、list）</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::vector&lt;std::shared_ptr&lt;<span class=\"type\">int</span>&gt;&gt; vec;</span><br><span class=\"line\">vec.<span class=\"built_in\">push_back</span>(p1);  <span class=\"comment\">// 拷贝进容器 → +1</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"-1\"><a class=\"markdownIt-Anchor\" href=\"#-1\">#</a> -1</h2>\n<ol>\n<li>析构</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    std::shared_ptr&lt;<span class=\"type\">int</span>&gt; p = p1;  <span class=\"comment\">// +1</span></span><br><span class=\"line\">&#125; <span class=\"comment\">// p 析构 → -1</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>调用 reset</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p<span class=\"number\">1.</span><span class=\"built_in\">reset</span>();        <span class=\"comment\">// 放弃当前对象 → -1</span></span><br><span class=\"line\">p<span class=\"number\">1.</span><span class=\"built_in\">reset</span>(<span class=\"literal\">nullptr</span>); <span class=\"comment\">// 同上</span></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>被赋予新值</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::shared_ptr&lt;<span class=\"type\">int</span>&gt; p2 = std::<span class=\"built_in\">make_shared</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">100</span>);</span><br><span class=\"line\">p1 = p2;  </span><br><span class=\"line\"><span class=\"comment\">// 先对 p1 原来的对象 -1，</span></span><br><span class=\"line\"><span class=\"comment\">// 再对 p2 的对象 +1（因为 p1 现在共享 p2 的对象）</span></span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>被赋予 nullptr 或空</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p1 = <span class=\"literal\">nullptr</span>;  <span class=\"comment\">// 相当于 reset() → -1</span></span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>从容器中移除或 clear</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>智能指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec.<span class=\"built_in\">clear</span>();  <span class=\"comment\">// 容器中每个 shared_ptr 析构 → 各自管理的对象引用计数 -1</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"vector底层\"><a class=\"markdownIt-Anchor\" href=\"#vector底层\">#</a> vector 底层</h1>\n<p>连续内存存储 + 动态扩容</p>\n<h2 id=\"一-基本结构\"><a class=\"markdownIt-Anchor\" href=\"#一-基本结构\">#</a> 一、基本结构</h2>\n<p><code>std::vector&lt;T&gt;</code>  内部通常维护三个关键指针（或等效的成员）：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> Allocator = std::allocator&lt;T&gt;&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> vector &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    T* begin_;     <span class=\"comment\">// 指向首元素</span></span><br><span class=\"line\">    T* end_;       <span class=\"comment\">// 指向最后一个元素的下一个位置（即 size 的边界）</span></span><br><span class=\"line\">    T* capacity_;  <span class=\"comment\">// 指向已分配内存的末尾（即 capacity 的边界）</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong> <code>size()</code> </strong> =  <code>end_ - begin_</code></li>\n<li><strong> <code>capacity()</code> </strong> =  <code>capacity_ - begin_</code></li>\n<li>所有元素在  <code>[begin_, end_)</code>  范围内，内存连续。</li>\n</ul>\n<blockquote>\n<p>实际标准库实现（如 libstdc++、libc++）可能用一个指针 + 两个整数（size/capacity），但逻辑等价。</p>\n</blockquote>\n<h2 id=\"二-内存分配与释放\"><a class=\"markdownIt-Anchor\" href=\"#二-内存分配与释放\">#</a> 二、内存分配与释放</h2>\n<ul>\n<li>使用 <strong>分配器（Allocator）</strong> 管理内存，默认是  <code>std::allocator&lt;T&gt;</code> 。</li>\n<li>初始时  <code>capacity() == 0</code> ，不分配内存（除非显式  <code>reserve</code>  或插入元素）。</li>\n<li>当需要更多空间时，<strong>重新分配一块更大的连续内存</strong>，将旧元素<strong>移动或拷贝</strong>过去，再释放旧内存。</li>\n</ul>\n<h2 id=\"三-动态扩容机制关键\"><a class=\"markdownIt-Anchor\" href=\"#三-动态扩容机制关键\">#</a> 三、动态扩容机制（关键！）</h2>\n<h3 id=\"1-何时扩容\"><a class=\"markdownIt-Anchor\" href=\"#1-何时扩容\">#</a> 1. <strong>何时扩容？</strong></h3>\n<p>当  <code>size() == capacity()</code>  且尝试插入新元素（如  <code>push_back</code> 、 <code>insert</code> ）时，触发扩容。</p>\n<h3 id=\"2-扩容策略\"><a class=\"markdownIt-Anchor\" href=\"#2-扩容策略\">#</a> 2. <strong>扩容策略</strong></h3>\n<ul>\n<li><strong>不是每次只加 1 个元素</strong>（那样效率极低）。</li>\n<li>通常采用 <strong>倍增策略（geometric growth）</strong>：\n<ul>\n<li>GCC (libstdc++)：<strong>容量 × 2</strong></li>\n<li>MSVC：<strong>容量 × 1.5</strong></li>\n<li>目的：保证 <strong>摊还时间复杂度 O (1)</strong> 的  <code>push_back</code></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>例如：初始容量 1 → 2 → 4 → 8 → 16 …</p>\n</blockquote>\n<h3 id=\"3-扩容过程\"><a class=\"markdownIt-Anchor\" href=\"#3-扩容过程\">#</a> 3. <strong>扩容过程</strong></h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_back</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">size</span>() == <span class=\"built_in\">capacity</span>()) &#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> new_cap = (<span class=\"built_in\">capacity</span>() == <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : <span class=\"built_in\">capacity</span>() * <span class=\"number\">2</span>;</span><br><span class=\"line\">        T* new_mem = allocator.<span class=\"built_in\">allocate</span>(new_cap);           <span class=\"comment\">// 分配新内存</span></span><br><span class=\"line\">        <span class=\"built_in\">uninitialized_move</span>(begin_, end_, new_mem);          <span class=\"comment\">// 移动旧元素</span></span><br><span class=\"line\">        allocator.<span class=\"built_in\">deallocate</span>(begin_, <span class=\"built_in\">capacity</span>());           <span class=\"comment\">// 释放旧内存</span></span><br><span class=\"line\">        begin_ = new_mem;</span><br><span class=\"line\">        end_ = new_mem + <span class=\"built_in\">size</span>();</span><br><span class=\"line\">        capacity_ = new_mem + new_cap;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">construct</span>(end_, value);  <span class=\"comment\">// 在 end_ 处构造新元素</span></span><br><span class=\"line\">    ++end_;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：C++11 起优先使用 <strong>移动语义</strong>（move）而非拷贝，提升性能。</p>\n</blockquote>\n<h2 id=\"四-关键操作的时间复杂度\"><a class=\"markdownIt-Anchor\" href=\"#四-关键操作的时间复杂度\">#</a> 四、关键操作的时间复杂度</h2>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>时间复杂度</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>operator[]</code> ,  <code>at()</code></td>\n<td>O(1)</td>\n<td>随机访问</td>\n</tr>\n<tr>\n<td><code>push_back()</code></td>\n<td><strong>O (1) 摊还</strong></td>\n<td>偶尔 O (n) 扩容</td>\n</tr>\n<tr>\n<td><code>pop_back()</code></td>\n<td>O(1)</td>\n<td>仅析构最后一个元素，不释放内存</td>\n</tr>\n<tr>\n<td><code>insert(pos, val)</code></td>\n<td>O(n)</td>\n<td>需移动 pos 后所有元素</td>\n</tr>\n<tr>\n<td><code>erase(pos)</code></td>\n<td>O(n)</td>\n<td>同上</td>\n</tr>\n<tr>\n<td><code>clear()</code></td>\n<td>O(n)</td>\n<td>析构所有元素，但 <strong>不释放内存</strong>（capacity 不变）</td>\n</tr>\n<tr>\n<td><code>shrink_to_fit()</code></td>\n<td>O(n)</td>\n<td>请求释放多余内存（非强制，依赖实现）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"五-内存管理特性\"><a class=\"markdownIt-Anchor\" href=\"#五-内存管理特性\">#</a> 五、内存管理特性</h2>\n<ul>\n<li><strong>内存连续</strong>：支持与 C 数组互操作（如  <code>&amp;vec[0]</code>  或  <code>vec.data()</code> ）。</li>\n<li><strong>不自动缩容</strong>： <code>pop_back</code>  或  <code>erase</code>  后  <code>capacity()</code>  不变，避免频繁 realloc。</li>\n<li><strong>异常安全</strong>：现代实现通常提供 <strong>强异常安全保证</strong>（如 copy-and-swap 技术）。</li>\n</ul>\n",
            "tags": [
                "杂项"
            ]
        },
        {
            "id": "http://example.com/2025/11/23/note/20251123/",
            "url": "http://example.com/2025/11/23/note/20251123/",
            "title": "20251123面经回忆",
            "date_published": "2025-11-22T16:00:00.000Z",
            "content_html": "<ol>\n<li>pdd 二面，手撕开放地址法哈希，实现 Get, Set, Delete 操作</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>Hashing</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> key;</span><br><span class=\"line\">    <span class=\"type\">int</span> value;</span><br><span class=\"line\">    <span class=\"built_in\">Node</span>(): <span class=\"built_in\">key</span>(<span class=\"number\">-1</span>), <span class=\"built_in\">value</span>(<span class=\"number\">-1</span>)&#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">Node</span>(<span class=\"type\">int</span> key, <span class=\"type\">int</span> value) : <span class=\"built_in\">key</span>(key), <span class=\"built_in\">value</span>(value) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">HashTable</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> size;</span><br><span class=\"line\">    vector&lt;Node&gt; table;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> EMPTY = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> DELETED = <span class=\"number\">-2</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span>: </span><br><span class=\"line\">    <span class=\"built_in\">HashTable</span>(<span class=\"type\">int</span> size): <span class=\"built_in\">size</span>(size), <span class=\"built_in\">table</span>(size)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i)&#123;</span><br><span class=\"line\">            table[i].key = EMPTY;</span><br><span class=\"line\">            table[i].value = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Get</span><span class=\"params\">(<span class=\"type\">int</span> key)</span></span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> h = key % size;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h &lt; <span class=\"number\">0</span>) h += size;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> idx = (h + i) % size;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (table[idx].key == EMPTY) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; <span class=\"comment\">// not found</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (table[idx].key == key) <span class=\"keyword\">return</span> table[idx].value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Set</span><span class=\"params\">(<span class=\"type\">int</span> key, <span class=\"type\">int</span> value)</span></span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> h = key % size;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h &lt; <span class=\"number\">0</span>) h += size;</span><br><span class=\"line\">        <span class=\"type\">int</span> firstDeleted = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> idx = (h + i) % size;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (table[idx].key == key)&#123;</span><br><span class=\"line\">                table[idx].value = value; <span class=\"comment\">// update existing</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (firstDeleted == <span class=\"number\">-1</span> &amp;&amp; table[idx].key == DELETED)&#123;</span><br><span class=\"line\">                firstDeleted = idx;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (table[idx].key == EMPTY)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (firstDeleted != <span class=\"number\">-1</span>) idx = firstDeleted;</span><br><span class=\"line\">                table[idx].key = key;</span><br><span class=\"line\">                table[idx].value = value;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (firstDeleted != <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            table[firstDeleted].key = key;</span><br><span class=\"line\">            table[firstDeleted].value = value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; <span class=\"comment\">// table full</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Delete</span><span class=\"params\">(<span class=\"type\">int</span> key)</span></span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> h = key % size;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h &lt; <span class=\"number\">0</span>) h += size;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> idx = (h + i) % size;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (table[idx].key == EMPTY) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; <span class=\"comment\">// not found</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (table[idx].key == key)&#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> value = table[idx].value;</span><br><span class=\"line\">                table[idx].key = DELETED; <span class=\"comment\">// tombstone</span></span><br><span class=\"line\">                table[idx].value = <span class=\"number\">-1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>\n<p>网易<br>\n找到 n 个数里面第 k 大的，除了排序有没有别的方法<br>\n问了一堆基础知识，static/inline 等等</p>\n</li>\n<li>\n<p>华为<br>\n一面双指针，二面贪心</p>\n</li>\n<li>\n<p>忘了</p>\n</li>\n</ol>\n",
            "tags": [
                "面经"
            ]
        },
        {
            "id": "http://example.com/2025/11/20/note/20251130/",
            "url": "http://example.com/2025/11/20/note/20251130/",
            "title": "杂项",
            "date_published": "2025-11-19T16:00:00.000Z",
            "content_html": "<h1 id=\"杂项\"><a class=\"markdownIt-Anchor\" href=\"#杂项\">#</a> 杂项</h1>\n<ol>\n<li>explicit<br>\n 构造函数默认是隐式转换的，如果想要禁止隐式转换，可以使用 explicit 关键字修饰构造函数。<br>\n比如</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>explicit</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">FileSize</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 构造函数：接受字节数</span></span><br><span class=\"line\">    <span class=\"built_in\">FileSize</span>(<span class=\"type\">long</span> <span class=\"type\">long</span> bytes) : <span class=\"built_in\">bytes_</span>(bytes) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">long</span> <span class=\"type\">long</span> <span class=\"title\">getBytes</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> bytes_; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"type\">long</span> bytes_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">deleteFileLargerThan</span><span class=\"params\">(<span class=\"type\">const</span> FileSize&amp; maxSize)</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Deleting files larger than &quot;</span> &lt;&lt; maxSize.<span class=\"built_in\">getBytes</span>() &lt;&lt; <span class=\"string\">&quot; bytes.\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 实际逻辑省略...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">deleteFileLargerThan</span>(<span class=\"string\">&quot;100MB&quot;</span>);  <span class=\"comment\">// 打错了！本想传字符串配置，但函数不接受 string</span></span><br><span class=\"line\">    <span class=\"comment\">// &quot;100MB&quot;  →  const char*  →  bool(true)  →  long long(1)   →  FileSize(1)</span></span><br><span class=\"line\">    <span class=\"comment\">// 变成：Deleting files larger than 1 bytes. 严重错误</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>回调函数<br>\n回调函数是一种函数指针，它允许在运行时指定一个函数，并在某个事件发生时调用该函数。<br>\n人话：一个被作为参数传递给另一个函数，并在 “合适的时候” 被调用的函数。</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>callback</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">std::function&lt;R(Args...)&gt; cb;</span><br><span class=\"line\"><span class=\"comment\">// R: 返回类型</span></span><br><span class=\"line\"><span class=\"comment\">// Args...: 参数列表</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>std::function 能装什么？</p>\n</blockquote>\n<ul>\n<li>普通函数</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>callback</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">greet</span><span class=\"params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"string\">&quot;Hello!\\n&quot;</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">std::function&lt;<span class=\"type\">void</span>()&gt; cb = greet;</span><br><span class=\"line\"><span class=\"built_in\">cb</span>(); <span class=\"comment\">// 输出 Hello!</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>Lambda 表达式</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>callback</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> x = <span class=\"number\">42</span>;</span><br><span class=\"line\">std::function&lt;<span class=\"type\">void</span>()&gt; cb = [x]() &#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Captured x = &quot;</span> &lt;&lt; x &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">cb</span>(); <span class=\"comment\">// 输出 Captured x = 42</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>函数对象</li>\n<li>成员函数</li>\n</ul>\n<ol start=\"3\">\n<li>\n<p><code>mutable std::mutex mtx_;</code> <br>\n <code>mutable</code>  关键字表示变量可以在常量函数中修改。<br>\n如果没有 mutable，mtx_ 是普通成员变量，在 const 函数中，所有成员都被视为 const，调用 mtx_.lock () 会报错</p>\n</li>\n<li>\n<p>std::unique_lock<span class=\"exturl\" data-url=\"c3RkOjptdXRleA==\">std::mutex</span> lock(mtx_)<br>\n 进入时自动调用 mtx_.lock ()（当前线程获得锁），当 lock 变量离开作用域（比如函数返回、出 {}），会自动调用 mtx_.unlock ()</p>\n</li>\n<li>\n<p>lambda<br>\n 有点抽象，有空继续研究<br>\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jLmJpYW5jaGVuZy5uZXQvdmlldy9ibDF5dnd5Lmh0bWw=\"> https://c.biancheng.net/view/bl1yvwy.html</span></p>\n</li>\n</ol>\n<ul>\n<li>作为函数对象（Functor）替代手写类</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>lambda</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">IsEven</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> x % <span class=\"number\">2</span> == <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">std::vector&lt;<span class=\"type\">int</span>&gt; v = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> it = std::<span class=\"built_in\">find_if</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), IsEven&#123;&#125;);</span><br><span class=\"line\"><span class=\"comment\">// lambda写法</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> it = std::<span class=\"built_in\">find_if</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), [](<span class=\"type\">int</span> x) &#123; <span class=\"keyword\">return</span> x % <span class=\"number\">2</span> == <span class=\"number\">0</span>; &#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>STL 算法的自定义谓词（最常用！）</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>lambda</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::vector&lt;Person&gt; people = &#123;...&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 按年龄降序</span></span><br><span class=\"line\">std::<span class=\"built_in\">sort</span>(people.<span class=\"built_in\">begin</span>(), people.<span class=\"built_in\">end</span>(),</span><br><span class=\"line\">          [](<span class=\"type\">const</span> Person&amp; a, <span class=\"type\">const</span> Person&amp; b) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> a.age &gt; b.age;</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除所有空字符串</span></span><br><span class=\"line\">vec.<span class=\"built_in\">erase</span>(</span><br><span class=\"line\">    std::<span class=\"built_in\">remove_if</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">end</span>(),</span><br><span class=\"line\">                   [](<span class=\"type\">const</span> std::string&amp; s) &#123; <span class=\"keyword\">return</span> s.<span class=\"built_in\">empty</span>(); &#125;),</span><br><span class=\"line\">    vec.<span class=\"built_in\">end</span>()</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 找第一个大于 10 的数</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> it = std::<span class=\"built_in\">find_if</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), [](<span class=\"type\">int</span> x) &#123; <span class=\"keyword\">return</span> x &gt; <span class=\"number\">10</span>; &#125;);</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>condition_variable<br>\n 不希望 FSM 的 worker 线程这样:</li>\n</ol>\n<figure class=\"highlight c++\"><figcaption><span>轮询</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (queue 空)</span><br><span class=\"line\">        一直查（忙等）</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>condition_variable 的作用：</p>\n<ul>\n<li>队列空 → 工作线程睡觉</li>\n<li>有事件 → 唤醒工作线程<br>\n写法：</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>condition_variable</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cv.<span class=\"built_in\">wait</span>(lock, []&#123; <span class=\"keyword\">return</span> !queue.<span class=\"built_in\">empty</span>(); &#125;);</span><br></pre></td></tr></table></figure>\n<ol start=\"7\">\n<li>\n<p>atomic 库<br>\n <code>atomic&lt;bool&gt;</code>  原子变量，线程安全的 bool</p>\n</li>\n<li>\n<p>匿名函数</p>\n</li>\n<li>\n<p>workerThread + 队列 + 状态机</p>\n</li>\n</ol>\n",
            "tags": [
                "杂项"
            ]
        },
        {
            "id": "http://example.com/2025/11/20/note/20251201/",
            "url": "http://example.com/2025/11/20/note/20251201/",
            "title": "测试相关",
            "date_published": "2025-11-19T16:00:00.000Z",
            "content_html": "<h1 id=\"gtest\"><a class=\"markdownIt-Anchor\" href=\"#gtest\">#</a> gtest</h1>\n<p>Google 开源的 c++ 单元测试框架<br>\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2dvb2dsZXRlc3Qv\"> https://google.github.io/googletest/</span></p>\n<h1 id=\"查看代码覆盖率\"><a class=\"markdownIt-Anchor\" href=\"#查看代码覆盖率\">#</a> 查看代码覆盖率</h1>\n<ul>\n<li>GCC + gcov (cmake 一般带了) + lcov</li>\n</ul>\n<ol>\n<li>修改 CMakeLists.txt</li>\n</ol>\n<figure class=\"highlight cmake\"><figcaption><span>lcov</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启用调试信息和覆盖率支持（仅在需要时开启）</span></span><br><span class=\"line\"><span class=\"keyword\">option</span>(ENABLE_COVERAGE <span class=\"string\">&quot;Enable coverage build&quot;</span> <span class=\"keyword\">OFF</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(ENABLE_COVERAGE)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(CMAKE_CXX_COMPILER_ID <span class=\"keyword\">MATCHES</span> <span class=\"string\">&quot;GNU|Clang&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">target_compile_options</span>(your_library_or_source_files PRIVATE</span><br><span class=\"line\">            -O0          <span class=\"comment\"># 禁用优化（否则行号可能不准）</span></span><br><span class=\"line\">            -g           <span class=\"comment\"># 调试信息</span></span><br><span class=\"line\">            --coverage   <span class=\"comment\"># 等价于 -fprofile-arcs -ftest-coverage</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">        <span class=\"keyword\">target_link_options</span>(your_library_or_source_files PRIVATE --coverage)</span><br><span class=\"line\">    <span class=\"keyword\">endif</span>()</span><br><span class=\"line\"><span class=\"keyword\">endif</span>()</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>构建并运行测试<br>\n…<br>\ncmake … -DENABLE_COVERAGE=ON<br>\n…</li>\n<li>生成可视化覆盖率报告（HTML）</li>\n</ol>\n<figure class=\"highlight bash\"><figcaption><span>lcov</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 初始化覆盖率数据</span></span><br><span class=\"line\">lcov --capture --initial --directory . --output-file coverage_base.info</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 收集实际运行后的覆盖率</span></span><br><span class=\"line\">lcov --capture --directory . --output-file coverage_test.info</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 合并（可选，但推荐）</span></span><br><span class=\"line\">lcov --add-tracefile coverage_base.info --add-tracefile coverage_test.info --output-file coverage_total.info</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># （可选）过滤掉第三方代码（如 googletest）</span></span><br><span class=\"line\">lcov --remove coverage_total.info <span class=\"string\">&#x27;/usr/*&#x27;</span> <span class=\"string\">&#x27;*/thirdpart/*&#x27;</span> <span class=\"string\">&#x27;*/googletest*&#x27;</span> --output-file coverage_final.info</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生成 HTML 报告</span></span><br><span class=\"line\">genhtml coverage_final.info --output-directory coverage_report</span><br></pre></td></tr></table></figure>\n<p>或者直接</p>\n<figure class=\"highlight bash\"><figcaption><span>lcov</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make coverage</span><br></pre></td></tr></table></figure>\n<p>然后再 build 目录下的 coverage_html 目录下查看 index.html，可以点开具体文件查看哪些行没有覆盖到</p>\n<h1 id=\"如何提高单元测试的覆盖率\"><a class=\"markdownIt-Anchor\" href=\"#如何提高单元测试的覆盖率\">#</a> 如何提高单元测试的覆盖率</h1>\n<p>分析当前覆盖率报告，找出未执行的代码路径，然后编写新的测试用例来触发这些路径。</p>\n",
            "tags": [
                "ctest",
                "gtest",
                "test coverage"
            ]
        },
        {
            "id": "http://example.com/2025/10/15/note/20251015/",
            "url": "http://example.com/2025/10/15/note/20251015/",
            "title": "20251015力扣刷题笔记",
            "date_published": "2025-10-14T16:00:00.000Z",
            "content_html": "<h2 id=\"一-c-常用容器总览\"><a class=\"markdownIt-Anchor\" href=\"#一-c-常用容器总览\">#</a> 一、C++ 常用容器总览</h2>\n<table>\n<thead>\n<tr>\n<th>容器</th>\n<th>类型</th>\n<th>底层结构</th>\n<th>是否有序</th>\n<th>是否去重</th>\n<th>主要用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>vector</code></td>\n<td>序列容器</td>\n<td>动态数组</td>\n<td>否</td>\n<td>否</td>\n<td>动态数组，随机访问</td>\n</tr>\n<tr>\n<td><code>deque</code></td>\n<td>序列容器</td>\n<td>双端队列（分段连续）</td>\n<td>否</td>\n<td>否</td>\n<td>首尾高效插入</td>\n</tr>\n<tr>\n<td><code>list</code></td>\n<td>序列容器</td>\n<td>双向链表</td>\n<td>否</td>\n<td>否</td>\n<td>频繁中间插入 / 删除</td>\n</tr>\n<tr>\n<td><code>forward_list</code></td>\n<td>序列容器</td>\n<td>单向链表</td>\n<td>否</td>\n<td>否</td>\n<td>节省内存的链表</td>\n</tr>\n<tr>\n<td><code>array</code></td>\n<td>序列容器</td>\n<td>静态数组</td>\n<td>否</td>\n<td>否</td>\n<td>固定大小数组</td>\n</tr>\n<tr>\n<td><code>stack</code></td>\n<td>容器适配器</td>\n<td><code>deque</code> （默认）</td>\n<td>否</td>\n<td>否</td>\n<td>栈（LIFO）</td>\n</tr>\n<tr>\n<td><code>queue</code></td>\n<td>容器适配器</td>\n<td><code>deque</code> （默认）</td>\n<td>否</td>\n<td>否</td>\n<td>队列（FIFO）</td>\n</tr>\n<tr>\n<td><code>priority_queue</code></td>\n<td>容器适配器</td>\n<td><code>vector</code> （默认）</td>\n<td>是（堆序）</td>\n<td>否</td>\n<td>优先队列</td>\n</tr>\n<tr>\n<td><code>set</code></td>\n<td>关联容器</td>\n<td>红黑树</td>\n<td>是（升序）</td>\n<td>是</td>\n<td>有序唯一集合</td>\n</tr>\n<tr>\n<td><code>multiset</code></td>\n<td>关联容器</td>\n<td>红黑树</td>\n<td>是</td>\n<td>否</td>\n<td>有序可重复集合</td>\n</tr>\n<tr>\n<td><code>map</code></td>\n<td>关联容器</td>\n<td>红黑树</td>\n<td>是</td>\n<td>是（按键）</td>\n<td>有序键值对</td>\n</tr>\n<tr>\n<td><code>multimap</code></td>\n<td>关联容器</td>\n<td>红黑树</td>\n<td>是</td>\n<td>否</td>\n<td>有序可重复键值对</td>\n</tr>\n<tr>\n<td><code>unordered_set</code></td>\n<td>无序关联容器</td>\n<td>哈希表</td>\n<td>否</td>\n<td>是</td>\n<td>无序唯一集合</td>\n</tr>\n<tr>\n<td><code>unordered_multiset</code></td>\n<td>无序关联容器</td>\n<td>哈希表</td>\n<td>否</td>\n<td>否</td>\n<td>无序可重复集合</td>\n</tr>\n<tr>\n<td><code>unordered_map</code></td>\n<td>无序关联容器</td>\n<td>哈希表</td>\n<td>否</td>\n<td>是（按键）</td>\n<td>无序键值对</td>\n</tr>\n<tr>\n<td><code>unordered_multimap</code></td>\n<td>无序关联容器</td>\n<td>哈希表</td>\n<td>否</td>\n<td>否</td>\n<td>无序可重复键值对</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"二-各容器操作复杂度对比\"><a class=\"markdownIt-Anchor\" href=\"#二-各容器操作复杂度对比\">#</a> 二、各容器操作复杂度对比</h2>\n<h3 id=\"1-vectort\"><a class=\"markdownIt-Anchor\" href=\"#1-vectort\">#</a> 1.  <code>vector&lt;T&gt;</code></h3>\n<ul>\n<li><strong>底层</strong>：动态数组（连续内存）</li>\n<li><strong>特点</strong>：支持随机访问，尾部操作快，中间插入慢。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>复杂度</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>push_back()</code></td>\n<td>平均 O (1)，最坏 O (n)</td>\n<td>扩容时复制</td>\n</tr>\n<tr>\n<td><code>pop_back()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>insert(it, x)</code></td>\n<td>O(n)</td>\n<td>中间插入需移动</td>\n</tr>\n<tr>\n<td><code>erase(it)</code></td>\n<td>O(n)</td>\n<td>删除后需移动</td>\n</tr>\n<tr>\n<td><code>operator[]</code>  /  <code>at()</code></td>\n<td>O(1)</td>\n<td>随机访问</td>\n</tr>\n<tr>\n<td><code>size()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>begin()</code>  /  <code>end()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>适合：频繁随机访问、尾部增删<br>\n不适合：频繁中间插入 / 删除</p>\n</blockquote>\n<hr>\n<h3 id=\"2-dequet双端队列\"><a class=\"markdownIt-Anchor\" href=\"#2-dequet双端队列\">#</a> 2.  <code>deque&lt;T&gt;</code> （双端队列）</h3>\n<ul>\n<li><strong>底层</strong>：分段连续数组（多个小数组）</li>\n<li><strong>特点</strong>：首尾操作都快，支持随机访问。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>复杂度</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>push_front()</code>  /  <code>push_back()</code></td>\n<td>O(1)</td>\n<td>首尾插入都快</td>\n</tr>\n<tr>\n<td><code>pop_front()</code>  /  <code>pop_back()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>insert()</code>  /  <code>erase()</code> （中间）</td>\n<td>O(n)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>operator[]</code>  /  <code>at()</code></td>\n<td>O(1)</td>\n<td>支持随机访问</td>\n</tr>\n<tr>\n<td><code>size()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>适合：需要首尾高效插入的场景（如滑动窗口）<br>\n注意：迭代器失效规则比  <code>vector</code>  复杂</p>\n</blockquote>\n<hr>\n<h3 id=\"3-listt双向链表\"><a class=\"markdownIt-Anchor\" href=\"#3-listt双向链表\">#</a> 3.  <code>list&lt;T&gt;</code> （双向链表）</h3>\n<ul>\n<li><strong>底层</strong>：双向链表</li>\n<li><strong>特点</strong>：任意位置插入 / 删除 O (1)，但不支持随机访问。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>复杂度</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>push_front()</code>  /  <code>push_back()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>insert(it, x)</code></td>\n<td>O(1)</td>\n<td>已知位置</td>\n</tr>\n<tr>\n<td><code>erase(it)</code></td>\n<td>O(1)</td>\n<td>已知位置</td>\n</tr>\n<tr>\n<td><code>operator[]</code></td>\n<td>不支持</td>\n<td></td>\n</tr>\n<tr>\n<td><code>find()</code></td>\n<td>O(n)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>size()</code></td>\n<td>C++11 起 O (1)，之前 O (n)</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>适合：频繁中间插入 / 删除<br>\n不适合：随机访问、缓存不友好</p>\n</blockquote>\n<hr>\n<h3 id=\"4-forward_listt单向链表\"><a class=\"markdownIt-Anchor\" href=\"#4-forward_listt单向链表\">#</a> 4.  <code>forward_list&lt;T&gt;</code> （单向链表）</h3>\n<ul>\n<li><strong>底层</strong>：单向链表</li>\n<li><strong>特点</strong>：比  <code>list</code>  更省内存，但只能单向遍历。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>复杂度</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>push_front()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>insert_after()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>erase_after()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td>不支持  <code>push_back()</code></td>\n<td>—</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>适合：内存敏感、只需前向遍历的场景</p>\n</blockquote>\n<hr>\n<h3 id=\"5-arrayt-n\"><a class=\"markdownIt-Anchor\" href=\"#5-arrayt-n\">#</a> 5.  <code>array&lt;T, N&gt;</code></h3>\n<ul>\n<li><strong>底层</strong>：静态数组（栈上内存）</li>\n<li><strong>特点</strong>：大小固定，性能极高。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>复杂度</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>operator[]</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>at()</code></td>\n<td>O(1)</td>\n<td>带边界检查</td>\n</tr>\n<tr>\n<td><code>size()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td>所有操作</td>\n<td>O(1)</td>\n<td>固定大小</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>适合：小数据、固定大小、高性能场景</p>\n</blockquote>\n<hr>\n<h3 id=\"6-sett-mapkv\"><a class=\"markdownIt-Anchor\" href=\"#6-sett-mapkv\">#</a> 6.  <code>set&lt;T&gt;</code>  /  <code>map&lt;K,V&gt;</code></h3>\n<ul>\n<li><strong>底层</strong>：<strong>红黑树</strong>（自平衡二叉搜索树）</li>\n<li><strong>特点</strong>：自动排序、自动去重（ <code>set</code>  和  <code>map</code>  键唯一）</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>复杂度</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>insert()</code></td>\n<td>O(log n)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>find()</code></td>\n<td>O(log n)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>erase()</code></td>\n<td>O(log n)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>size()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td>遍历</td>\n<td>O(n)</td>\n<td>有序输出</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>适合：需要有序、去重、查找的场景</p>\n</blockquote>\n<hr>\n<h3 id=\"7-unordered_sett-unordered_mapkv\"><a class=\"markdownIt-Anchor\" href=\"#7-unordered_sett-unordered_mapkv\">#</a> 7.  <code>unordered_set&lt;T&gt;</code>  /  <code>unordered_map&lt;K,V&gt;</code></h3>\n<ul>\n<li><strong>底层</strong>：<strong>哈希表</strong>（开链法或开放寻址）</li>\n<li><strong>特点</strong>：平均极快，但无序，最坏 O (n)</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>复杂度</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>insert()</code></td>\n<td>平均 O (1)，最坏 O (n)</td>\n<td>哈希冲突时退化</td>\n</tr>\n<tr>\n<td><code>find()</code></td>\n<td>平均 O (1)，最坏 O (n)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>erase()</code></td>\n<td>平均 O (1)，最坏 O (n)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>size()</code></td>\n<td>O(1)</td>\n<td></td>\n</tr>\n<tr>\n<td>负载因子</td>\n<td>影响性能</td>\n<td>可调  <code>max_load_factor()</code></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>适合：大数据、高频查找、不在乎顺序<br>\n不适合：需要有序输出</p>\n</blockquote>\n<h3 id=\"8-容器适配器stack-queue-priority_queue\"><a class=\"markdownIt-Anchor\" href=\"#8-容器适配器stack-queue-priority_queue\">#</a> 8. 容器适配器（ <code>stack</code> ,  <code>queue</code> ,  <code>priority_queue</code> ）</h3>\n<table>\n<thead>\n<tr>\n<th>容器</th>\n<th>默认底层</th>\n<th>特点</th>\n<th>操作复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>stack&lt;T&gt;</code></td>\n<td><code>deque</code></td>\n<td>后进先出（LIFO）</td>\n<td><code>push</code> / <code>pop</code> / <code>top</code> : O(1)</td>\n</tr>\n<tr>\n<td><code>queue&lt;T&gt;</code></td>\n<td><code>deque</code></td>\n<td>先进先出（FIFO）</td>\n<td><code>push</code> / <code>pop</code> / <code>front</code> : O(1)</td>\n</tr>\n<tr>\n<td><code>priority_queue&lt;T&gt;</code></td>\n<td><code>vector</code>  + 堆</td>\n<td>最大 / 最小元素在顶</td>\n<td><code>push</code> : O(log n),  <code>top</code> : O(1),  <code>pop</code> : O(log n)</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>它们<strong>不是真正容器</strong>，而是基于其他容器的封装，接口受限。</p>\n</blockquote>\n<h2 id=\"选择\"><a class=\"markdownIt-Anchor\" href=\"#选择\">#</a> 选择</h2>\n<table>\n<thead>\n<tr>\n<th>需求</th>\n<th>推荐容器</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>动态数组，随机访问</td>\n<td><code>vector</code></td>\n</tr>\n<tr>\n<td>首尾都能高效插入</td>\n<td><code>deque</code></td>\n</tr>\n<tr>\n<td>频繁中间插入 / 删除</td>\n<td><code>list</code></td>\n</tr>\n<tr>\n<td>固定大小数组</td>\n<td><code>array</code></td>\n</tr>\n<tr>\n<td>快速查找、去重（不在乎顺序）</td>\n<td><code>unordered_set</code>  /  <code>unordered_map</code></td>\n</tr>\n<tr>\n<td>需要有序输出、去重</td>\n<td><code>set</code>  /  <code>map</code></td>\n</tr>\n<tr>\n<td>栈操作</td>\n<td><code>stack</code></td>\n</tr>\n<tr>\n<td>队列操作</td>\n<td><code>queue</code></td>\n</tr>\n<tr>\n<td>找最大 / 最小元素（堆）</td>\n<td><code>priority_queue</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h2>\n<table>\n<thead>\n<tr>\n<th>口诀</th>\n<th>对应容器</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>“要快用 unordered”</strong></td>\n<td><code>unordered_set/map</code> （平均 O (1)）</td>\n</tr>\n<tr>\n<td><strong>“要序用 set/map”</strong></td>\n<td><code>set/map</code> （O (log n)，有序）</td>\n</tr>\n<tr>\n<td><strong>“通用选 vector”</strong></td>\n<td><code>vector</code> （最常用）</td>\n</tr>\n<tr>\n<td><strong>“首尾快用 deque”</strong></td>\n<td><code>deque</code> （双端高效）</td>\n</tr>\n<tr>\n<td><strong>“中间删用 list”</strong></td>\n<td><code>list</code> （任意位置 O (1) 删除）</td>\n</tr>\n<tr>\n<td><strong>“最大最小用堆”</strong></td>\n<td><code>priority_queue</code></td>\n</tr>\n</tbody>\n</table>\n<p>LRU：</p>\n<figure class=\"highlight c++\"><figcaption><span>lru</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 哈希表+双向链表</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">DNode</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">DNode</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> key, value;</span><br><span class=\"line\">    DNode* pre;</span><br><span class=\"line\">    DNode* next;</span><br><span class=\"line\">    <span class=\"built_in\">DNode</span>(): <span class=\"built_in\">key</span>(<span class=\"number\">-1</span>), <span class=\"built_in\">value</span>(<span class=\"number\">-1</span>), <span class=\"built_in\">pre</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">next</span>(<span class=\"literal\">nullptr</span>)&#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">DNode</span>(<span class=\"type\">int</span> key, <span class=\"type\">int</span> val): <span class=\"built_in\">key</span>(key), <span class=\"built_in\">value</span>(val), <span class=\"built_in\">pre</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">next</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LRUCache</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">LRUCache</span>(<span class=\"type\">int</span> capacity) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;capacity = capacity;</span><br><span class=\"line\">        head = <span class=\"keyword\">new</span> <span class=\"built_in\">DNode</span>();</span><br><span class=\"line\">        tail = <span class=\"keyword\">new</span> <span class=\"built_in\">DNode</span>();</span><br><span class=\"line\">        head-&gt;next = tail;</span><br><span class=\"line\">        tail-&gt;pre = head;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mp.<span class=\"built_in\">find</span>(key) != mp.<span class=\"built_in\">end</span>())&#123;</span><br><span class=\"line\">            DNode* pre = mp[key]-&gt;pre;</span><br><span class=\"line\">            pre-&gt;next = mp[key]-&gt;next;</span><br><span class=\"line\">            mp[key]-&gt;next-&gt;pre = pre;</span><br><span class=\"line\">            DNode* next = head-&gt;next;</span><br><span class=\"line\">            head-&gt;next = mp[key];</span><br><span class=\"line\">            mp[key]-&gt;pre = head;</span><br><span class=\"line\">            mp[key]-&gt;next = next;</span><br><span class=\"line\">            next-&gt;pre = mp[key];</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mp[key]-&gt;value;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">put</span><span class=\"params\">(<span class=\"type\">int</span> key, <span class=\"type\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mp.<span class=\"built_in\">find</span>(key) != mp.<span class=\"built_in\">end</span>())&#123;</span><br><span class=\"line\">            mp[key]-&gt;value = value;</span><br><span class=\"line\">            DNode* pre = mp[key]-&gt;pre;</span><br><span class=\"line\">            pre-&gt;next = mp[key]-&gt;next;</span><br><span class=\"line\">            mp[key]-&gt;next-&gt;pre = pre;</span><br><span class=\"line\">            DNode* next = head-&gt;next;</span><br><span class=\"line\">            head-&gt;next = mp[key];</span><br><span class=\"line\">            mp[key]-&gt;pre = head;</span><br><span class=\"line\">            mp[key]-&gt;next = next;</span><br><span class=\"line\">            next-&gt;pre = mp[key];</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>-&gt;size &lt; <span class=\"keyword\">this</span>-&gt;capacity)&#123;</span><br><span class=\"line\">                DNode* p = head-&gt;next;</span><br><span class=\"line\">                DNode* newNode = <span class=\"keyword\">new</span> <span class=\"built_in\">DNode</span>(key, value);</span><br><span class=\"line\">                head-&gt;next = newNode;</span><br><span class=\"line\">                newNode-&gt;pre = head;</span><br><span class=\"line\">                newNode-&gt;next = p;</span><br><span class=\"line\">                p-&gt;pre = newNode;</span><br><span class=\"line\">                mp[key] = newNode;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>-&gt;size++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                DNode* remove = tail-&gt;pre;</span><br><span class=\"line\">                mp.<span class=\"built_in\">erase</span>(remove-&gt;key);</span><br><span class=\"line\">                remove-&gt;pre-&gt;next = tail;</span><br><span class=\"line\">                tail-&gt;pre = remove-&gt;pre;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> remove;</span><br><span class=\"line\">                DNode* newNode = <span class=\"keyword\">new</span> <span class=\"built_in\">DNode</span>(key, value);</span><br><span class=\"line\">                DNode* nxt = head-&gt;next;</span><br><span class=\"line\">                head-&gt;next = newNode;</span><br><span class=\"line\">                newNode-&gt;pre = head;</span><br><span class=\"line\">                newNode-&gt;next = nxt;</span><br><span class=\"line\">                nxt-&gt;pre = newNode;</span><br><span class=\"line\">                mp[key] = newNode;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> capacity;</span><br><span class=\"line\">    <span class=\"type\">int</span> size;</span><br><span class=\"line\">    unordered_map&lt;<span class=\"type\">int</span>, DNode*&gt; mp;</span><br><span class=\"line\">    DNode* head;</span><br><span class=\"line\">    DNode* tail;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>反转链表</p>\n<figure class=\"highlight c++\"><figcaption><span>reverse</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ListNode</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> val;</span><br><span class=\"line\">    ListNode *next;</span><br><span class=\"line\">    <span class=\"built_in\">ListNode</span>() : <span class=\"built_in\">val</span>(<span class=\"number\">0</span>), <span class=\"built_in\">next</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">ListNode</span>(<span class=\"type\">int</span> x) : <span class=\"built_in\">val</span>(x), <span class=\"built_in\">next</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">ListNode</span>(<span class=\"type\">int</span> x, ListNode *next) : <span class=\"built_in\">val</span>(x), <span class=\"built_in\">next</span>(next) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">reverseList</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">    ListNode* prev = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    ListNode* curr = head;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (curr != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        ListNode* next = curr-&gt;next; <span class=\"comment\">// 保存下一个节点</span></span><br><span class=\"line\">        curr-&gt;next = prev;           <span class=\"comment\">// 反转当前节点</span></span><br><span class=\"line\">        prev = curr;                 <span class=\"comment\">// prev 前进</span></span><br><span class=\"line\">        curr = next;                 <span class=\"comment\">// curr 前进</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> prev; <span class=\"comment\">// 新的头节点</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>",
            "tags": [
                "容器"
            ]
        },
        {
            "id": "http://example.com/2025/08/02/note/20250802/",
            "url": "http://example.com/2025/08/02/note/20250802/",
            "title": "20250802阅读论文",
            "date_published": "2025-08-01T16:00:00.000Z",
            "content_html": "<blockquote>\n<p><strong>标题</strong>：Self-supervised representation learning from 12-lead ECG data<br>\n<strong> 作者</strong>：Temesgen Mehari, Nils Strodthoff<br>\n<strong> 期刊</strong>：<em>Computers in Biology and Medicine</em>, 2022<br>\n<strong>DOI</strong>: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2kub3JnLzEwLjEwMTYvai5jb21wYmlvbWVkLjIwMjEuMTA1MTE0\">10.1016/j.compbiomed.2021.105114</span><br>\n<strong> 关键词</strong>：自监督学习、对比学习、心电图（ECG）、时间序列分析、深度学习</p>\n</blockquote>\n<p>12-lead ECG 是常见生物信号，但高质量标注数据稀缺，标注依赖专家，成本高，尤其对罕见病或睡眠相关心血管事件更难获取标签，然而，无标签 ECG 数据海量存在，因此利用自监督学习从大量无标签 ECG 中预训练模型，学习通用特征表示，再用于下游任务微调，提升性能与标签效率。</p>\n<p>本文采用  <code>xresnet1d50</code>  作为主干网络，对比了不同的自监督学习方法。</p>\n<h2 id=\"xresnet1d\"><a class=\"markdownIt-Anchor\" href=\"#xresnet1d\">#</a> xresnet1d</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly90aW1lc2VyaWVzYWkuZ2l0aHViLmlvL3RzYWkvbW9kZWxzLnhyZXNuZXQxZC5odG1s\">https://timeseriesai.github.io/tsai/models.xresnet1d.html</span></p>\n<h2 id=\"instance-discrimination\"><a class=\"markdownIt-Anchor\" href=\"#instance-discrimination\">#</a> Instance Discrimination</h2>\n<h3 id=\"simclr\"><a class=\"markdownIt-Anchor\" href=\"#simclr\">#</a> SimCLR</h3>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzIwMDIuMDU3MDk=\">T. Chen, S. Kornblith, M. Norouzi, G. Hinton, A simple framework for contrastive learning of visual representations, in: International Conference on Machine Learning, 2020.</span></p>\n<h3 id=\"byol\"><a class=\"markdownIt-Anchor\" href=\"#byol\">#</a> BYOL</h3>\n<h3 id=\"swav\"><a class=\"markdownIt-Anchor\" href=\"#swav\">#</a> SwAV</h3>\n<h3 id=\"cpc\"><a class=\"markdownIt-Anchor\" href=\"#cpc\">#</a> CPC</h3>\n<h2 id=\"latent-forecasting\"><a class=\"markdownIt-Anchor\" href=\"#latent-forecasting\">#</a> Latent Forecasting</h2>\n",
            "tags": [
                "自监督学习"
            ]
        }
    ]
}