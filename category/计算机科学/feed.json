{
    "version": "https://jsonfeed.org/version/1",
    "title": " • All posts by \"计算机科学\" category",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2024/05/13/computer-science/computer-organization/ch1/",
            "url": "http://example.com/2024/05/13/computer-science/computer-organization/ch1/",
            "title": "Ch1",
            "date_published": "2024-05-12T16:00:00.000Z",
            "content_html": "<blockquote>\n<p>王道计组考研复习笔记<br>\n怕学完忘了写个笔记保留一下顺便加深印象 x<br>\n 王道书写得好烂、、</p>\n</blockquote>\n<h1 id=\"ch1-计算机系统概述\"><a class=\"markdownIt-Anchor\" href=\"#ch1-计算机系统概述\">#</a> Ch1 计算机系统概述</h1>\n<h2 id=\"11-计算机发展历程\"><a class=\"markdownIt-Anchor\" href=\"#11-计算机发展历程\">#</a> 1.1 计算机发展历程</h2>\n<ul>\n<li>四代计算机：电子管 -&gt; 晶体管 -&gt; 集成电路 -&gt; 超大规模集成电路</li>\n<li>摩尔定律：集成电路上可以容纳的晶体管数目在大约每经过 18 个月到 24 个月便会增加一倍</li>\n</ul>\n<h2 id=\"12-计算机系统层次结构\"><a class=\"markdownIt-Anchor\" href=\"#12-计算机系统层次结构\">#</a> 1.2 计算机系统层次结构</h2>\n<ul>\n<li>计算机系统：硬件 + 软件</li>\n<li>对于某一功能，既能用软件实现又能用硬件实现，称为软、硬件在逻辑功能上是等价的</li>\n</ul>\n<h3 id=\"122-硬件\"><a class=\"markdownIt-Anchor\" href=\"#122-硬件\">#</a> 1.2.2 硬件</h3>\n<ul>\n<li>冯・诺依曼机的特点：\n<ul>\n<li>采用 “存储程序” 的工作方式</li>\n<li>冯・诺依曼计算机由五大部件组成：运算器、控制器、存储器、输入设备和输出设备</li>\n<li>指令和数据以同等地位存储在存储器中</li>\n<li>指令和数据均用二进制代码表示</li>\n<li>指令由操作码和地址码组成</li>\n<li><img data-src=\"img1.png\" alt></li>\n</ul>\n</li>\n<li>计算机的功能部件：\n<ul>\n<li>输入设备</li>\n<li>输出设备</li>\n<li>存储器：主存 + 外存\n<ul>\n<li>CPU 能直接访问的是主存</li>\n<li><img data-src=\"img2.jpg\" alt></li>\n<li>MAR 位 10 位则最多有 $$2^{10}$$ 个存储单元</li>\n<li>在现代计算机中 MAR 和 MDR 存在 CPU 中</li>\n</ul>\n</li>\n<li>运算器：进行算术运算和逻辑运算\n<ul>\n<li>核心是 ALU：通用寄存器有<mark>累加器 (ACC)，乘商寄存器 (MQ)，操作数寄存器 (X)</mark>，变址寄存器 (IX)，基址寄存器 (BR) 等，前三个必备</li>\n<li>程序状态寄存器 (PSW)</li>\n<li><img data-src=\"img3.jpg\" alt></li>\n</ul>\n</li>\n<li>控制器：由 PC, IR 和 control unit 组成\n<ul>\n<li>: RISCV 控制器</li>\n<li><img data-src=\"img4.png\" alt></li>\n</ul>\n</li>\n<li>CPU 由运算器、控制器和 cache 组成</li>\n<li>总线有地址总线、数据总线、控制总线</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"123-软件\"><a class=\"markdownIt-Anchor\" href=\"#123-软件\">#</a> 1.2.3 软件</h3>\n<ul>\n<li>组成：系统软件 (OS, DBMS, 编译器，…)+ 应用软件</li>\n<li>语言：汇编语言、机器语言、高级语言\n<ul>\n<li>汇编器：把汇编语言翻译成机器语言</li>\n<li>编译器：把高级语言翻译成汇编语言或机器语言</li>\n<li>解释器：把高级语言翻译成<mark>机器语言</mark> (比如 python)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"124-计算机系统的层次结构\"><a class=\"markdownIt-Anchor\" href=\"#124-计算机系统的层次结构\">#</a> 1.2.4 计算机系统的层次结构</h3>\n<ul>\n<li>看看就好</li>\n<li><img data-src=\"img5.png\" alt></li>\n</ul>\n<h3 id=\"125-计算机系统的工作原理\"><a class=\"markdownIt-Anchor\" href=\"#125-计算机系统的工作原理\">#</a> 1.2.5 计算机系统的工作原理</h3>\n<ul>\n<li>程序执行前，需要把所含的指令和数据一起放入主存中</li>\n<li>五个阶段：IF-ID-EX-MEM-WB</li>\n<li>c 程序怎么变成可执行文件的：直接看图\n<ul>\n<li><img data-src=\"img6.png\" alt></li>\n<li>汇编器把指令打包成可重定位目标代码文件：使用相对地址和符号引用来表示各个代码段之间的关系（代码段、数据段、符号表、重定位表…）使得代码或数据能在内存中任意位置加载或运行</li>\n</ul>\n</li>\n<li>指令执行过程：后面几章会具体讲</li>\n</ul>\n",
            "tags": [
                "计算机组成"
            ]
        },
        {
            "id": "http://example.com/2024/05/13/computer-science/computer-network/ch1/",
            "url": "http://example.com/2024/05/13/computer-science/computer-network/ch1/",
            "title": "Ch1",
            "date_published": "2024-05-12T16:00:00.000Z",
            "content_html": "",
            "tags": [
                "计算机网络"
            ]
        },
        {
            "id": "http://example.com/2024/03/21/computer-science/compile-principles/ch1/",
            "url": "http://example.com/2024/03/21/computer-science/compile-principles/ch1/",
            "title": "Ch1",
            "date_published": "2024-03-20T16:00:00.000Z",
            "content_html": "<blockquote>\n<p>ZJU 2025 春夏编译原理 学习笔记</p>\n<p>主要基于虎书（<em>Modern Compiler Implementation in C</em>, Andrew W. Appel）</p>\n</blockquote>\n<h1 id=\"ch1-introduction\"><a class=\"markdownIt-Anchor\" href=\"#ch1-introduction\">#</a> CH1 Introduction</h1>\n<ul>\n<li>Two Important Concepts\n<ul>\n<li>Phases（阶段）</li>\n<li>Interfaces（接口）</li>\n</ul>\n</li>\n</ul>\n<p>方框里的是 phase，中间的是 interface<br>\n<img data-src=\"image.png\" alt><br>\n 各个阶段的描述<br>\n<img data-src=\"image-1.png\" alt><img data-src=\"image-2.png\" alt></p>\n",
            "tags": [
                "编译原理"
            ]
        },
        {
            "id": "http://example.com/2024/03/21/computer-science/compile-principles/ch5/",
            "url": "http://example.com/2024/03/21/computer-science/compile-principles/ch5/",
            "title": "Ch2",
            "date_published": "2024-03-20T16:00:00.000Z",
            "content_html": "<h1 id=\"语义分析\"><a class=\"markdownIt-Anchor\" href=\"#语义分析\">#</a> 语义分析</h1>\n<blockquote>\n<p>绑定，类型检查</p>\n</blockquote>\n<h2 id=\"symbol-table\"><a class=\"markdownIt-Anchor\" href=\"#symbol-table\">#</a> symbol table</h2>\n<ul>\n<li>Functional style: 函数式风格\n<ul>\n<li>To keep $$\\sigma_1$$ in pristine condition while creating create $$\\sigma_2$$ and $$\\sigma_3$$</li>\n</ul>\n</li>\n<li>Imperative style: 命令式风格\n<ul>\n<li>Modify $$\\sigma_1$$ until it becomes $$\\sigma_2$$.</li>\n<li>While $$\\sigma_2$$ exists, we cannot look things up in $$\\sigma_1$$.</li>\n<li>When done with $$\\sigma_2$$, can undo the modification to get $$\\sigma_1$$ back again.</li>\n</ul>\n</li>\n</ul>\n<div class=\"note info 方法：\">\n<p>Hashing</p>\n</div>\n",
            "tags": [
                "语义分析"
            ]
        },
        {
            "id": "http://example.com/2024/03/21/computer-science/compile-principles/ch3/",
            "url": "http://example.com/2024/03/21/computer-science/compile-principles/ch3/",
            "title": "Ch2",
            "date_published": "2024-03-20T16:00:00.000Z",
            "content_html": "<h1 id=\"语法分析\"><a class=\"markdownIt-Anchor\" href=\"#语法分析\">#</a> 语法分析</h1>\n<h2 id=\"cfg\"><a class=\"markdownIt-Anchor\" href=\"#cfg\">#</a> CFG</h2>\n<p>见计算理论<br>\n Parse tree</p>\n<h3 id=\"ambiguous-grammars\"><a class=\"markdownIt-Anchor\" href=\"#ambiguous-grammars\">#</a> Ambiguous grammars</h3>\n<h2 id><a class=\"markdownIt-Anchor\" href=\"#\">#</a> </h2>\n",
            "tags": [
                "语法分析"
            ]
        },
        {
            "id": "http://example.com/2024/03/21/computer-science/compile-principles/ch2/",
            "url": "http://example.com/2024/03/21/computer-science/compile-principles/ch2/",
            "title": "Ch2",
            "date_published": "2024-03-20T16:00:00.000Z",
            "content_html": "<h1 id=\"ch2-词法分析\"><a class=\"markdownIt-Anchor\" href=\"#ch2-词法分析\">#</a> Ch2 词法分析</h1>\n<blockquote>\n<p>把 input 分解成一个个 token</p>\n</blockquote>\n<h2 id=\"regular-expression\"><a class=\"markdownIt-Anchor\" href=\"#regular-expression\">#</a> Regular Expression</h2>\n<ul>\n<li>Language: a set of strings</li>\n<li>String: a finite sequence of characters</li>\n</ul>\n<blockquote>\n<p>Regular Experssion Notations:<br>\n<img data-src=\"image-1.png\" alt></p>\n</blockquote>\n<div class=\"note info\">\n<p>DFA, NFA 相关 见计算理论</p>\n</div>\n<h2 id=\"re转nfa\"><a class=\"markdownIt-Anchor\" href=\"#re转nfa\">#</a> RE 转 NFA</h2>\n<div class=\"note info 方法：\">\n<ol>\n<li>画出初始态和终态</li>\n<li>分裂规则：<br>\n<img data-src=\"image-2.jpg\" alt></li>\n</ol>\n</div>\n<h2 id=\"nfa转dfa\"><a class=\"markdownIt-Anchor\" href=\"#nfa转dfa\">#</a> NFA 转 DFA</h2>\n<p>从初始状态的闭包开始，每次根据 \\epsilon 和当前状态的闭包，得到下一个状态的闭包，直到得到终态的闭包。</p>\n<details class=\"info\"><summary>example</summary><div>\n<div class=\"tab\" data-id=\"id3\" data-title=\"题目\">\n<p>🌰<br>\n把这个 NFA 转成等价的 DFA<br>\n<img data-src=\"image-3.png\" alt></p>\n</div>\n<div class=\"tab\" data-id=\"id3\" data-title=\"答案\">\n<p>初态的闭包是 1、2、6，1、2、6 经过 a 可以转移到 3、7，因为有 \\epsilon 转移，所以 3、7 的闭包是 3、4、7、8，同理 3、4、7、8 经过 b 可以到 5、8，由于 8 是终态，把所有包含 8 的圆圈画成终态的环。<br>\n<img data-src=\"image-4.png\" alt></p>\n</div>\n</div></details>\n<h2 id=\"最小化dfa\"><a class=\"markdownIt-Anchor\" href=\"#最小化dfa\">#</a> 最小化 DFA</h2>\n<p>含义：</p>\n<ol>\n<li>没有多余状态：</li>\n</ol>\n<ul>\n<li>从这个状态没有通路到达终态</li>\n<li>从开始状态出发，任何输入串也不能到达的那个状态</li>\n</ul>\n<ol start=\"2\">\n<li>没有两个状态相互等价</li>\n</ol>\n<div class=\"note info 方法：\">\n<ol>\n<li>多余状态直接删除<br>\n<img data-src=\"image-5.png\" alt></li>\n<li>合并等价状态</li>\n</ol>\n<ul>\n<li>将状态分为终态和非终态两个集合</li>\n<li>遍历每个集合，如果经过转换到达的状态都在当前集合里，则不用分，否则划分子集，直到划分不了为止</li>\n<li>🌰 例子</li>\n<li><img data-src=\"image-6.png\" alt></li>\n</ul>\n</div>\n",
            "tags": [
                "词法分析"
            ]
        },
        {
            "id": "http://example.com/2024/03/21/computer-science/compile-principles/ch4/",
            "url": "http://example.com/2024/03/21/computer-science/compile-principles/ch4/",
            "title": "Ch2",
            "date_published": "2024-03-20T16:00:00.000Z",
            "content_html": "",
            "tags": [
                "抽象语法"
            ]
        }
    ]
}