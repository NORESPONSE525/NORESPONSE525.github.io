{
    "version": "https://jsonfeed.org/version/1",
    "title": " • All posts by \"计算机科学\" category",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2024/05/14/computer-science/computer-organization/ch2/",
            "url": "http://example.com/2024/05/14/computer-science/computer-organization/ch2/",
            "title": "Ch2",
            "date_published": "2024-05-13T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch2-数据的表示和运算\"><a href=\"#Ch2-数据的表示和运算\" class=\"headerlink\" title=\"Ch2 数据的表示和运算\"></a>Ch2 数据的表示和运算</h1><h2 id=\"2-1-进位计数制及其相互转换\"><a href=\"#2-1-进位计数制及其相互转换\" class=\"headerlink\" title=\"2.1 进位计数制及其相互转换\"></a>2.1 进位计数制及其相互转换</h2><h3 id=\"2-1-1\"><a href=\"#2-1-1\" class=\"headerlink\" title=\"2.1.1\"></a>2.1.1</h3><ul>\n<li>十进制二进制八进制十六进制转换<ul>\n<li>略</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-1-2-定点数的编码表示\"><a href=\"#2-1-2-定点数的编码表示\" class=\"headerlink\" title=\"2.1.2 定点数的编码表示\"></a>2.1.2 定点数的编码表示</h3><ul>\n<li>定点百世一般表示定点小数和定点整数，小数是符号位.xxx，整数是符号位xxxx.0</li>\n<li><blockquote>\n<p>感觉不是什么重要的东西，浮点数表示比较重要</p>\n</blockquote>\n</li>\n<li>原码，反码，补码<ul>\n<li>正数的原码反码补码相同</li>\n<li>负数的原码是1+绝对值，反码是1+绝对值取反，补码是反码+1</li>\n</ul>\n</li>\n<li>移码：用来表示浮点数的阶码，只能表示整数<br>$$ [x]_移 &#x3D; 2^n + x $$<br>正数前面补0负数前面补1到offset位，前面加上补码的符号位取反</li>\n</ul>\n<h3 id=\"2-1-3-整数表示\"><a href=\"#2-1-3-整数表示\" class=\"headerlink\" title=\"2.1.3 整数表示\"></a>2.1.3 整数表示</h3>",
            "tags": [
                "数据的表示与运算"
            ]
        },
        {
            "id": "http://example.com/2024/05/13/computer-science/computer-network/ch1/",
            "url": "http://example.com/2024/05/13/computer-science/computer-network/ch1/",
            "title": "Ch1",
            "date_published": "2024-05-12T16:00:00.000Z",
            "content_html": "",
            "tags": [
                "计算机网络"
            ]
        },
        {
            "id": "http://example.com/2024/05/13/computer-science/computer-organization/ch1/",
            "url": "http://example.com/2024/05/13/computer-science/computer-organization/ch1/",
            "title": "Ch1",
            "date_published": "2024-05-12T16:00:00.000Z",
            "content_html": "<blockquote>\n<p>王道计组考研复习笔记<br>怕学完忘了写个笔记保留一下顺便加深印象x<br>王道书写得好烂、、</p>\n</blockquote>\n<h1 id=\"Ch1-计算机系统概述\"><a href=\"#Ch1-计算机系统概述\" class=\"headerlink\" title=\"Ch1 计算机系统概述\"></a>Ch1 计算机系统概述</h1><h2 id=\"1-1-计算机发展历程\"><a href=\"#1-1-计算机发展历程\" class=\"headerlink\" title=\"1.1 计算机发展历程\"></a>1.1 计算机发展历程</h2><ul>\n<li>四代计算机：电子管-&gt;晶体管-&gt;集成电路-&gt;超大规模集成电路</li>\n<li>摩尔定律：集成电路上可以容纳的晶体管数目在大约每经过18个月到24个月便会增加一倍</li>\n</ul>\n<h2 id=\"1-2-计算机系统层次结构\"><a href=\"#1-2-计算机系统层次结构\" class=\"headerlink\" title=\"1.2 计算机系统层次结构\"></a>1.2 计算机系统层次结构</h2><ul>\n<li>计算机系统：硬件+软件</li>\n<li>对于某一功能，既能用软件实现又能用硬件实现，称为软、硬件在逻辑功能上是等价的</li>\n</ul>\n<h3 id=\"1-2-2-硬件\"><a href=\"#1-2-2-硬件\" class=\"headerlink\" title=\"1.2.2 硬件\"></a>1.2.2 硬件</h3><ul>\n<li>冯·诺依曼机的特点：<ul>\n<li>采用“存储程序”的工作方式</li>\n<li>冯·诺依曼计算机由五大部件组成：运算器、控制器、存储器、输入设备和输出设备</li>\n<li>指令和数据以同等地位存储在存储器中</li>\n<li>指令和数据均用二进制代码表示</li>\n<li>指令由操作码和地址码组成</li>\n<li><img data-src=\"/img1.png\"></li>\n</ul>\n</li>\n<li>计算机的功能部件：<ul>\n<li>输入设备</li>\n<li>输出设备</li>\n<li>存储器：主存+外存<ul>\n<li>CPU能直接访问的是主存</li>\n<li><img data-src=\"/img2.jpg\"></li>\n<li>MAR位10位则最多有$2^{10}$个存储单元</li>\n<li>在现代计算机中MAR和MDR存在CPU中</li>\n</ul>\n</li>\n<li>运算器：进行算术运算和逻辑运算<ul>\n<li>核心是ALU：通用寄存器有&#x3D;&#x3D;累加器(ACC)，乘商寄存器(MQ)，操作数寄存器(X)&#x3D;&#x3D;，变址寄存器(IX)，基址寄存器(BR)等，前三个必备</li>\n<li>程序状态寄存器(PSW)</li>\n<li><img data-src=\"/img3.jpg\"></li>\n</ul>\n</li>\n<li>控制器：由PC, IR和control unit组成<ul>\n<li>: RISCV控制器</li>\n<li><img data-src=\"/img4.png\"></li>\n</ul>\n</li>\n<li>CPU由运算器、控制器和cache组成</li>\n<li>总线有地址总线、数据总线、控制总线</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-2-3-软件\"><a href=\"#1-2-3-软件\" class=\"headerlink\" title=\"1.2.3 软件\"></a>1.2.3 软件</h3><ul>\n<li>组成：系统软件(OS, DBMS, 编译器, …)+应用软件</li>\n<li>语言：汇编语言、机器语言、高级语言<ul>\n<li>汇编器：把汇编语言翻译成机器语言</li>\n<li>编译器：把高级语言翻译成汇编语言或机器语言</li>\n<li>解释器：把高级语言翻译成&#x3D;&#x3D;机器语言&#x3D;&#x3D;(比如python)<br>  +++info example<br>  ;;;id3 题目<br>  :chestnut:<br>  将高级语言源程序转换为机器级目标代码文件的程序是 []。<br>  A. 汇编程序<br>  B. 链接程序<br>  C. 编译程序<br>  D. 解释程序<br>  ;;;<br>  ;;;id3 答案<br>  C. 编译程序<br>  因为解释程序不生成目标代码，编译器可以把高级语言翻译成汇编语言或者直接翻译成机器语言<br>  ;;;<br>  +++</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-2-4-计算机系统的层次结构\"><a href=\"#1-2-4-计算机系统的层次结构\" class=\"headerlink\" title=\"1.2.4 计算机系统的层次结构\"></a>1.2.4 计算机系统的层次结构</h3><ul>\n<li>看看就好</li>\n<li><img data-src=\"/img5.png\"></li>\n</ul>\n<h3 id=\"1-2-5-计算机系统的工作原理\"><a href=\"#1-2-5-计算机系统的工作原理\" class=\"headerlink\" title=\"1.2.5 计算机系统的工作原理\"></a>1.2.5 计算机系统的工作原理</h3><ul>\n<li>程序执行前，需要把所含的指令和数据一起放入主存中</li>\n<li>五个阶段：IF-ID-EX-MEM-WB</li>\n<li>c程序怎么变成可执行文件的：直接看图<ul>\n<li><img data-src=\"/img6.png\"></li>\n<li>汇编器把指令打包成可重定位目标代码文件：使用相对地址和符号引用来表示各个代码段之间的关系（代码段、数据段、符号表、重定位表…）使得代码或数据能在内存中任意位置加载或运行</li>\n</ul>\n</li>\n<li>指令执行过程：后面几章会具体讲</li>\n</ul>\n<h2 id=\"1-3-计算机的性能指标\"><a href=\"#1-3-计算机的性能指标\" class=\"headerlink\" title=\"1.3 计算机的性能指标\"></a>1.3 计算机的性能指标</h2><h3 id=\"1-3-1-主要性能指标\"><a href=\"#1-3-1-主要性能指标\" class=\"headerlink\" title=\"1.3.1 主要性能指标\"></a>1.3.1 主要性能指标</h3><ul>\n<li>字长：一次整数运算所能处理的二进制数据的位数<br> :::info<br> 机器字长、指令字长和存储字长<br> :::</li>\n<li>带宽<code>bandwidth</code>：总线一次能并行传送信息的位数</li>\n<li>主存容量</li>\n<li>运算速度<ul>\n<li>吞吐量<code>throughput</code>：一次输入数据所对应的输出数据个数</li>\n<li>响应时间<code>Response (Execution) time</code></li>\n<li>主频</li>\n<li>clock cycle time( &#x3D; 1&#x2F;CPU frequency)</li>\n<li>MIPS: million instructions per second</li>\n<li>FLOPS: floating-point operations per second<blockquote>\n<p>CPI: clock cycles per instruction(IPC: CPI的倒数)</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<p>$$ \\begin{aligned}<br>    \\text{CPU execution time} &amp;&#x3D; \\text{CPU clock cycles} \\times \\text{Clock cycle time} \\<br>    &amp;&#x3D; \\frac{\\text{CPU clock cycles}}{\\text{Clock rate}}<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>    \\text{CPU clock cycles} &amp;&#x3D; \\text{Instructions count} \\times \\text{Average cycles per instruction}<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>    \\text{CPU execution time} &amp;&#x3D; \\text{CPU clock cycles} \\times \\text{Clock cycle time} \\<br>    &amp;&#x3D; \\frac{\\text{CPU clock cycles}}{\\text{Clock rate}}<br>\\end{aligned} $$</p>\n<p>$$ \\begin{aligned}<br>     \\text{performance} &amp;&#x3D; \\frac{1}{\\text{CPU execution time}}<br>\\end{aligned}$$</p>\n<p>“Processor X is n times fast than Y” is<br>$$ \\begin{aligned}<br>    \\text{n} &amp;&#x3D; \\frac{\\text{CPU execution time of Y}}{\\text{CPU execution time of X}}<br>\\end{aligned}$$</p>\n<p>IPS: instructions per second<br>$$ \\begin{aligned}<br>    \\text{IPS} &amp;&#x3D; \\frac{\\text{CPU frequency}}{\\text{CPI}}<br>        &amp;&#x3D; \\frac{1}{\\text{CPU clock cycles} \\times \\text{CPU execution time}}<br>\\end{aligned}$$</p>\n<ul>\n<li>其他公式，，，用到再说吧</li>\n<li>兼容：软件或硬件的通用性</li>\n</ul>\n<blockquote>\n<p>在用于科学计算的计算机中，标志系统性能最有用的参数是浮点数运算相关的</p>\n<ul>\n<li>MFLOPS 10^6</li>\n<li>GFLOPS 10^9</li>\n<li>TFLOPS 10^12</li>\n<li>PFLOPS 10^15</li>\n<li>EFLOPS 10^18</li>\n<li>ZFLOPS 10^21</li>\n</ul>\n</blockquote>\n",
            "tags": [
                "计算机组成"
            ]
        },
        {
            "id": "http://example.com/2024/03/29/computer-science/compile-principles/ch4/",
            "url": "http://example.com/2024/03/29/computer-science/compile-principles/ch4/",
            "title": "Ch4",
            "date_published": "2024-03-28T16:00:00.000Z",
            "content_html": "",
            "tags": [
                "抽象语法"
            ]
        },
        {
            "id": "http://example.com/2024/03/23/computer-science/compile-principles/ch3/",
            "url": "http://example.com/2024/03/23/computer-science/compile-principles/ch3/",
            "title": "Ch3",
            "date_published": "2024-03-22T16:00:00.000Z",
            "content_html": "<h1 id=\"语法分析\"><a href=\"#语法分析\" class=\"headerlink\" title=\"语法分析\"></a>语法分析</h1><h2 id=\"CFG\"><a href=\"#CFG\" class=\"headerlink\" title=\"CFG\"></a>CFG</h2><p>见计算理论<br>Parse tree</p>\n<h3 id=\"Ambiguous-grammars\"><a href=\"#Ambiguous-grammars\" class=\"headerlink\" title=\"Ambiguous grammars\"></a>Ambiguous grammars</h3><h2 id><a href=\"#\" class=\"headerlink\" title></a></h2>",
            "tags": [
                "语法分析"
            ]
        },
        {
            "id": "http://example.com/2024/03/22/computer-science/compile-principles/ch2/",
            "url": "http://example.com/2024/03/22/computer-science/compile-principles/ch2/",
            "title": "Ch2",
            "date_published": "2024-03-21T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch2-词法分析\"><a href=\"#Ch2-词法分析\" class=\"headerlink\" title=\"Ch2 词法分析\"></a>Ch2 词法分析</h1><blockquote>\n<p>把input分解成一个个token</p>\n</blockquote>\n<h2 id=\"Regular-Expression\"><a href=\"#Regular-Expression\" class=\"headerlink\" title=\"Regular Expression\"></a>Regular Expression</h2><ul>\n<li>Language: a set of strings</li>\n<li>String: a finite sequence of characters<blockquote>\n<p>Regular Experssion Notations:<br><img data-src=\"/image-1.png\"></p>\n</blockquote>\n</li>\n</ul>\n<p>:::info<br>DFA, NFA相关 见计算理论<br>:::</p>\n<h2 id=\"RE转NFA\"><a href=\"#RE转NFA\" class=\"headerlink\" title=\"RE转NFA\"></a>RE转NFA</h2><p>:::info 方法：</p>\n<ol>\n<li>画出初始态和终态</li>\n<li>分裂规则：<br><img data-src=\"/image-2.jpg\"><br>:::</li>\n</ol>\n<h2 id=\"NFA转DFA\"><a href=\"#NFA转DFA\" class=\"headerlink\" title=\"NFA转DFA\"></a>NFA转DFA</h2><p>从初始状态的闭包开始，每次根据\\epsilon和当前状态的闭包，得到下一个状态的闭包，直到得到终态的闭包。</p>\n<p>+++info example<br>;;;id3 题目<br>:chestnut:<br>把这个NFA转成等价的DFA<br><img data-src=\"/image-3.png\"><br>;;;<br>;;;id3 答案<br>初态的闭包是1、2、6，1、2、6经过a可以转移到3、7，因为有\\epsilon转移，所以3、7的闭包是3、4、7、8，同理3、4、7、8经过b可以到5、8，由于8是终态，把所有包含8的圆圈画成终态的环。<br><img data-src=\"/image-4.png\"><br>;;;<br>+++</p>\n<h2 id=\"最小化DFA\"><a href=\"#最小化DFA\" class=\"headerlink\" title=\"最小化DFA\"></a>最小化DFA</h2><p>含义：</p>\n<ol>\n<li>没有多余状态：</li>\n</ol>\n<ul>\n<li>从这个状态没有通路到达终态</li>\n<li>从开始状态出发，任何输入串也不能到达的那个状态</li>\n</ul>\n<ol start=\"2\">\n<li>没有两个状态相互等价<br>:::info 方法：</li>\n<li>多余状态直接删除<br><img data-src=\"/image-5.png\"></li>\n<li>合并等价状态</li>\n</ol>\n<ul>\n<li>将状态分为终态和非终态两个集合</li>\n<li>遍历每个集合，如果经过转换到达的状态都在当前集合里，则不用分，否则划分子集，直到划分不了为止</li>\n<li>:chestnut: 例子</li>\n<li><img data-src=\"/image-6.png\"><br>:::</li>\n</ul>\n",
            "tags": [
                "词法分析"
            ]
        },
        {
            "id": "http://example.com/2024/03/21/computer-science/compile-principles/ch1/",
            "url": "http://example.com/2024/03/21/computer-science/compile-principles/ch1/",
            "title": "Ch1",
            "date_published": "2024-03-20T16:00:00.000Z",
            "content_html": "<blockquote>\n<p>ZJU 2025春夏编译原理 学习笔记</p>\n<p>主要基于虎书（<em>Modern Compiler Implementation in C</em>, Andrew W. Appel）</p>\n</blockquote>\n<h1 id=\"CH1-Introduction\"><a href=\"#CH1-Introduction\" class=\"headerlink\" title=\"CH1 Introduction\"></a>CH1 Introduction</h1><ul>\n<li>Two Important Concepts<ul>\n<li>Phases（阶段）</li>\n<li>Interfaces（接口）</li>\n</ul>\n</li>\n</ul>\n<p>方框里的是phase，中间的是interface<br><img data-src=\"/image.png\"><br>各个阶段的描述<br><img data-src=\"/image-1.png\"><img data-src=\"/image-2.png\"></p>\n",
            "tags": [
                "编译原理"
            ]
        },
        {
            "id": "http://example.com/2024/03/21/computer-science/compile-principles/ch5/",
            "url": "http://example.com/2024/03/21/computer-science/compile-principles/ch5/",
            "title": "Ch5",
            "date_published": "2024-03-20T16:00:00.000Z",
            "content_html": "<h1 id=\"语义分析\"><a href=\"#语义分析\" class=\"headerlink\" title=\"语义分析\"></a>语义分析</h1><blockquote>\n<p>绑定，类型检查</p>\n</blockquote>\n<h2 id=\"symbol-table\"><a href=\"#symbol-table\" class=\"headerlink\" title=\"symbol table\"></a>symbol table</h2><ul>\n<li>Functional style: 函数式风格<ul>\n<li>To keep $\\sigma_1$ in pristine condition while creating create $\\sigma_2$ and $\\sigma_3$</li>\n</ul>\n</li>\n<li>Imperative style: 命令式风格<ul>\n<li>Modify $\\sigma_1$ until it becomes $\\sigma_2$. </li>\n<li>While $\\sigma_2$ exists, we cannot look things up in $\\sigma_1$. </li>\n<li>When done with $\\sigma_2$, can undo the modification to get $\\sigma_1$ back again.<br>:::info 方法：<br>Hashing<br>:::</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "语义分析"
            ]
        }
    ]
}