{
    "version": "https://jsonfeed.org/version/1",
    "title": "NoResponse's Blog • All posts by \"计算机科学\" category",
    "description": "成分复杂的CSer from ZJU",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2025/09/18/computer-science/OS/ch1/",
            "url": "http://example.com/2025/09/18/computer-science/OS/ch1/",
            "title": "ch1",
            "date_published": "2025-09-17T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch1\"><a href=\"#Ch1\" class=\"headerlink\" title=\"Ch1\"></a>Ch1</h1><p>计算机系统自下而上可以大致分为硬件、操作系统、应用程序、用户<br>OS管理各种硬件，为应用程序提供基础，充当计算机硬件与用户之间的中介，是计算机系统中最基本的系统软件</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h3 id=\"操作系统的功能\"><a href=\"#操作系统的功能\" class=\"headerlink\" title=\"操作系统的功能\"></a>操作系统的功能</h3><ol>\n<li>管理计算机系统资源<br>处理机管理（进程&#x2F;线程管理）、存储器管理、设备管理、文件管理，向用户提供接口</li>\n<li>作为用户与硬件系统之间的接口</li>\n</ol>\n<ul>\n<li>命令接口（联机控制方式和脱机控制方式）<ul>\n<li>联机命令接口也称为交互式命令接口，由一组键盘操作命令组成</li>\n<li>脱机命令接口也称批处理命令接口，由一组作业控制命令组成</li>\n</ul>\n</li>\n<li>程序接口<ul>\n<li>由一组系统调用组成</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li>实现了对计算机资源的补充<br>虚拟机</li>\n</ol>\n<h3 id=\"操作系统的特征\"><a href=\"#操作系统的特征\" class=\"headerlink\" title=\"操作系统的特征\"></a>操作系统的特征</h3><p>最基本的两个：并发与共享</p>\n<ol>\n<li>并发<br>多道程序交替运行（和并行不一样）</li>\n<li>共享</li>\n</ol>\n<ul>\n<li>互斥共享</li>\n<li>同时访问</li>\n</ul>\n<ol start=\"3\">\n<li>虚拟</li>\n<li>异步</li>\n</ol>\n<h2 id=\"发展历程\"><a href=\"#发展历程\" class=\"headerlink\" title=\"发展历程\"></a>发展历程</h2><h3 id=\"手工操作阶段（无操作系统）\"><a href=\"#手工操作阶段（无操作系统）\" class=\"headerlink\" title=\"手工操作阶段（无操作系统）\"></a>手工操作阶段（无操作系统）</h3><h3 id=\"批处理阶段\"><a href=\"#批处理阶段\" class=\"headerlink\" title=\"批处理阶段\"></a>批处理阶段</h3><ol>\n<li>单道批处理<br>单道程序</li>\n</ol>\n<ul>\n<li>自动型：一批作业自动地逐个运行</li>\n<li>顺序性：顺序进入内存、顺序运行</li>\n<li>单道性：内存中仅有一道程序运行，一道程序运行完才换入下一道</li>\n</ul>\n<ol start=\"2\">\n<li>多道批处理<br>多道，宏观上并行，微观上串行</li>\n</ol>\n<ul>\n<li>多道：内存中同时存放多道相互独立的程序</li>\n<li>宏观上并行</li>\n<li>微观上串行：轮流占有CPU，交替执行<br>缺点：用户响应时间长，不提供人机交互能力，用户既不能了解自己的程序的运行情况，又不能控制计算机</li>\n</ul>\n<h3 id=\"分时操作系统\"><a href=\"#分时操作系统\" class=\"headerlink\" title=\"分时操作系统\"></a>分时操作系统</h3><p>将运行时间分成时间片</p>\n",
            "tags": [
                "操作系统"
            ]
        },
        {
            "id": "http://example.com/2025/09/15/computer-science/DS/ch2/",
            "url": "http://example.com/2025/09/15/computer-science/DS/ch2/",
            "title": "ch2",
            "date_published": "2025-09-14T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch2-线性表\"><a href=\"#Ch2-线性表\" class=\"headerlink\" title=\"Ch2 线性表\"></a>Ch2 线性表</h1><p>存储结构：顺序表（数组），链表</p>\n",
            "tags": [
                "线性表"
            ]
        },
        {
            "id": "http://example.com/2025/09/15/computer-science/DS/ch1/",
            "url": "http://example.com/2025/09/15/computer-science/DS/ch1/",
            "title": "ch1",
            "date_published": "2025-09-14T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch1-绪论\"><a href=\"#Ch1-绪论\" class=\"headerlink\" title=\"Ch1 绪论\"></a>Ch1 绪论</h1><p>数据<br>数据元素是数据的基本单位<br>数据对象<br>数据类型：原子类型、结构类型、抽象数据类型<br>数据结构：三要素包括逻辑结构、存储结构和数据的运算</p>\n<ul>\n<li>逻辑结构：集合、线性结构、树形结构、图状或网状</li>\n<li>存储结构：顺序存储、链式存储、索引存储、散列存储</li>\n<li>数据的运算：定义针对逻辑结构，实现针对存储结构</li>\n</ul>\n<p>算法的特性：又穷行、确定性、可行性、输入、输出<br>好的算法还应该考虑：正确性、可读性、健壮性、高效率和低存储量需求</p>\n<p>复杂度：时间复杂度、空间复杂度</p>\n",
            "tags": [
                "数据结构"
            ]
        },
        {
            "id": "http://example.com/2025/08/15/computer-science/computer-organization/ch7/",
            "url": "http://example.com/2025/08/15/computer-science/computer-organization/ch7/",
            "title": "Ch7",
            "date_published": "2025-08-14T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch7-输入-输出系统\"><a href=\"#Ch7-输入-输出系统\" class=\"headerlink\" title=\"Ch7 输入&#x2F;输出系统\"></a>Ch7 输入&#x2F;输出系统</h1><h2 id=\"I-O接口\"><a href=\"#I-O接口\" class=\"headerlink\" title=\"I&#x2F;O接口\"></a>I&#x2F;O接口</h2><p>inerrface，主机与外设之间的交接界面</p>\n<h3 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h3><ol>\n<li>进行地址译码和设备选择</li>\n<li>实现主机和外设的通信联络控制<br>解决时序、工作速度不同的问题</li>\n<li>实现数据缓冲</li>\n<li>信号格式的转换<br>电平转换、并&#x2F;串或串&#x2F;并转换、模&#x2F;数或数&#x2F;模转换</li>\n<li>传送控制命令和状态信息<br>CPU通过接口中的命令寄存器发出启动命令给外设，外设就绪是传回Ready状态信息通过接口中的状态寄存器反馈给CPU</li>\n</ol>\n<h3 id=\"基本结构\"><a href=\"#基本结构\" class=\"headerlink\" title=\"基本结构\"></a>基本结构</h3><p><img data-src=\"/f1.jpg\"><br>主机侧通过I&#x2F;O总线与内存、CPU相连。数据缓冲器用来暂存与CPU或内存之间传送的数据信息。状态寄存器用来记录接口和设备的状态信息，控制寄存器用来保存CPU对外设的控制信息<br>状态寄存器和控制寄存器在传送方向是相反的，访问时间上是错开的，所以可以合二为一<br>数据线传送读&#x2F;写数据、状态信息、控制信息、中断类型号<br>地址线传送访问I&#x2F;O接口中的寄存器的地址<br>控制线传送读写控制信号、中断请求、响应信号、仲裁信号、握手信号<br>I&#x2F;O控制逻辑需要对控制寄存器的命令字进行译码，还有收集外设状态到状态寄存器<br><img data-src=\"/f2.jpg\"></p>\n<blockquote>\n<p>对上面两个寄存器的访问操作通过I&#x2F;O指令来完成，只能在操作系统内核的底层I&#x2F;O软件中使用，是一种特权指令<br><img data-src=\"/f3.jpg\"></p>\n</blockquote>\n<h3 id=\"接口类型\"><a href=\"#接口类型\" class=\"headerlink\" title=\"接口类型\"></a>接口类型</h3><ol>\n<li>按（外设和接口一侧的）数据传送方式：并行接口、串行接口</li>\n<li>按主机访问I&#x2F;O设备的控制方式：程序查询接口、中断接口、DMA接口</li>\n<li>按功能选择的灵活性：可编程接口、不可编程接口</li>\n</ol>\n<h3 id=\"I-O端口及其编址\"><a href=\"#I-O端口及其编址\" class=\"headerlink\" title=\"I&#x2F;O端口及其编址\"></a>I&#x2F;O端口及其编址</h3><p>I&#x2F;O端口是指I&#x2F;O接口电路中<strong>可被CPU直接访问的寄存器</strong>，主要有&#x3D;&#x3D;数据端口、状态端口和控制端口&#x3D;&#x3D;。<br>CPU能对数据端口中的数据进行读&#x2F;写操作，但对状态端口中外设的状态只能读，对控制端口只能写<br>每个端口对应一个端口地址，编址方式有与存储器独立编址和统一编址两种</p>\n<ol>\n<li>独立编址<br>也称I&#x2F;O映射方式，I&#x2F;O端口的地址空间与主存地址空间是两个独立的地址空间<br>需要设置专门的I&#x2F;O指令来表明访问的是I&#x2F;O地址空间，I&#x2F;O指令的地址码给出I&#x2F;O端口号<blockquote>\n<p>x86 架构中的 IN 和 OUT 指令<br>IN AL, 0x64    从 I&#x2F;O 端口 0x64 读取一个字节的数据，存入寄存器 AL<br>优点：I&#x2F;O端口数比主存单元数少得多，秩序少量地址线，使得I&#x2F;O端口译码简单，寻址速度更快。使用专门的I&#x2F;O指令，是程序更加清晰<br>缺点：I&#x2F;O指令少，只提供简单的传输操作，灵活性差。CPU需要提供存储器读&#x2F;写、I&#x2F;O设备读写两组控制信号，增大了控制的复杂性</p>\n</blockquote>\n</li>\n<li>统一编址<br>也称存储器映射方式(Memory-Mapped I&#x2F;O)，无需设置专门的I&#x2F;O指令，用统一的访存指令就可以访问I&#x2F;O端口<blockquote>\n<p>riscv就是用Memory-Mapped I&#x2F;O<br>优点：不需要专门的I&#x2F;O指令，CPU访问I&#x2F;O更灵活方便，端口有较大的编址空间。I&#x2F;O访问的保护机制可由虚拟存储管理系统来实现，无需专门设置（内核态才能访问）<br>缺点：端口地址占用了部分主存地址空间。译码电路复杂</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"I-O方式\"><a href=\"#I-O方式\" class=\"headerlink\" title=\"I&#x2F;O方式\"></a>I&#x2F;O方式</h2><p>程序查询、程序中断、DMA<br><img data-src=\"/f5.jpg\"></p>\n<h3 id=\"程序查询方式-Polling\"><a href=\"#程序查询方式-Polling\" class=\"headerlink\" title=\"程序查询方式(Polling)\"></a>程序查询方式(Polling)</h3><p>轮询法，程序执行到某个 I&#x2F;O 操作指令时，由操作系统或设备驱动程序发起<br><img data-src=\"/f4.jpg\"><br>程序查询方式分为两类：</p>\n<ol>\n<li>独占查询<br>一旦设备启动，CPU就一直持续查询接口状态，CPU话费100%时间用于I&#x2F;O操作，外设和CPU完全串行（忙等待）</li>\n<li>定时查询<br>CPU周期性地查询接口状态，每次总是等到条件满足才进行一个数据的传送，传送完成后返回到用户程序。<br>比如设备每 10ms 产生一个数据，可以设置 5ms 查询一次，这样既能及时读取数据，又不至于过度查询。&#x3D;&#x3D;定时查询的时间间隔与设备的数据传输速率有关。&#x3D;&#x3D;</li>\n</ol>\n<h3 id=\"程序中断方式\"><a href=\"#程序中断方式\" class=\"headerlink\" title=\"程序中断方式\"></a>程序中断方式</h3><p><img data-src=\"/f6.jpg\"><br>工作流程：</p>\n<ol>\n<li>中断请求<br>中断源向CPU发送中断请求信号。中断系统对每个中断源设置中断请求标记触发器<br>可屏蔽中断：通过<code>INTR</code>线发出的，优先级低，关中断下不被响应<br>不可屏蔽中断：通过<code>NMI</code>线发出的，优先级最高</li>\n<li>中断响应<br>响应中断的条件。<br>中断判优：多个中断源同时提出请求时通过中断判优逻辑响应一个中断源。<br>一般来说：不可屏蔽中断&gt;可屏蔽中断；在I&#x2F;O传送类终端中，高速设备&gt;低速设备，输入设备&gt;输出设备，实时设备&gt;普通设备<br>CPU响应中断的条件：</li>\n</ol>\n<ul>\n<li>中断源有中断请求</li>\n<li>允许中断及开中断</li>\n<li>一条指令执行完毕（除非是指令执行异常）</li>\n</ul>\n<ol start=\"3\">\n<li>中断处理</li>\n</ol>\n<ul>\n<li>中断隐指令：<ul>\n<li>关中断（防止在中断处理程序执行期间被其他（同级或低优先级）中断再次打断）</li>\n<li>保护现场（把PC, PSW等压入内核栈）</li>\n<li>引出中断服务程序：硬件向量法和软件查询法</li>\n</ul>\n</li>\n</ul>\n<p>中断向量：硬件提供向量号，中断控制器将该中断对应的向量号放到数据总线上，CPU读取该向量号，CPU使用该向量号作为索引，查找中断向量表（IVT）获取ISR的入口地址</p>\n<p>处理流程：</p>\n<ul>\n<li>关中断</li>\n<li>保存断点</li>\n<li>中断服务程序寻址</li>\n<li>保存现场和屏蔽字</li>\n<li>开中断（允许更高级中断请求得到响应）</li>\n<li>执行ISR</li>\n<li>关中断</li>\n<li>恢复现场和屏蔽字</li>\n<li>开中断，中断返回<br>1-3由硬件自动完成，4-9由ISR完成<blockquote>\n<p>为什么要先关再开？<br>确保这个保护现场的操作不会被其他中断打断</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"多重中断和中断屏蔽技术\"><a href=\"#多重中断和中断屏蔽技术\" class=\"headerlink\" title=\"多重中断和中断屏蔽技术\"></a>多重中断和中断屏蔽技术</h4><p>通过中断屏蔽字寄存器来实现，每个中断源都有一个屏蔽触发器，&#x3D;&#x3D;1表示屏蔽该中断源的请求&#x3D;&#x3D;，0表示可以正常申请<br>&#x3D;&#x3D;屏蔽字中‘1’越多，优先级越高。每个屏蔽字中至少有一个<code>1</code>(至少要能屏蔽自身的中断)&#x3D;&#x3D;<br>方法：要能屏蔽自身所以主对角线全为1，同时优先级比自身低的中断要屏蔽屏蔽字全填1，其他的填0</p>\n<h3 id=\"DMA方式\"><a href=\"#DMA方式\" class=\"headerlink\" title=\"DMA方式\"></a>DMA方式</h3><p>DMA方式是一种完全由硬件进行组信息传送的控制方式<br><img data-src=\"/f7.jpg\"><br><img data-src=\"/f8.jpg\"><br><img data-src=\"/f9.jpg\"></p>\n<p>当I&#x2F;O设备和CPU同时访问主存时，可能发生冲突，DMA与CPU通常采用以下3种方式使用驻村：<br><img data-src=\"/f10.jpg\"><br>周期挪用：<br>一次传一组数据</p>\n<ul>\n<li>CPU不访存时：如果CPU当前并不需要访问主存，那么DMA控制器可以直接使用总线进行数据传输，此时不会对CPU的工作造成任何影响。</li>\n<li>CPU正在访存时：如果CPU正在进行主存访问，DMA控制器会等待CPU的当前访问周期结束，然后立即“借用”接下来的一个或几个总线周期来进行自己的数据传输。这种情况下，CPU的访问会被短暂延迟，但通常这种延迟非常短，以至于CPU几乎感觉不到，因此可以认为CPU的正常工作没有受到显著影响。</li>\n<li>CPU与DMA同时请求访存时：在这种情况下，I&#x2F;O设备的访存请求通常具有更高的优先级，这意味着即使CPU也在请求访问主存，DMA控制器也会被优先考虑，从而保证I&#x2F;O设备的数据传输不受阻。</li>\n</ul>\n<ol>\n<li>停止CPU访存<br>优点：控制简单，适用于数据传输速率很高的I&#x2F;O设备实现成组数据的传送<br>缺点：DMA访问主存时，CPU基本上不工作</li>\n<li>周期挪用<br>优点：既实现了I&#x2F;O传送，又较好地发挥了主存与CPU的效率<br>缺点：每挪用一个主存周期，DMA接口都要申请、建立和归还总线周期</li>\n<li>交替访存<br>优点：不需要总线控制权的申请、建立和归还过程，传送效率高<br>缺点：相应的硬件逻辑变得更复杂</li>\n</ol>\n<h4 id=\"DMA的传送过程\"><a href=\"#DMA的传送过程\" class=\"headerlink\" title=\"DMA的传送过程\"></a>DMA的传送过程</h4><p><img data-src=\"/f9.jpg\"></p>\n<ul>\n<li>预处理：由CPU初始化DMA控制其中的寄存器、设置传送方式、测试并启动设备</li>\n<li>数据传送：DMA以数据块为基本传送单位。数据传送完全由DMA控制</li>\n<li>后处理：DMA控制器向CPU发送中断请求，CPU处理中断做DMA结束处理（包括校验）</li>\n</ul>\n<p>DMA方式和中断方式的区别：</p>\n<ul>\n<li>中断需要save context，DMA不需要，除了预处理和后处理其他时候不占用CPU（我觉得DMA方式的预处理和后处理的中断也是需要save context的，只是因为DMA方式中断次数极少，整个数据块只中断一次，所以不需要保存那么多次，所以比较快）</li>\n<li>对中断请求的相应只能发生在每条指令执行结束时，但对DMA请求的相应可以发生在任意一个机器周期结束时(IF, ID, EX…  DMA请求的是总线控制权，不是CPU的执行权。它不关心 CPU正在执行哪条指令，只关心总线是否空闲。只要当前总线周期结束，DMA就可以插空使用)</li>\n<li>中断传送过程需要CPU的干预，DMA传送不需要，数据传输速率高</li>\n</ul>\n<p>优先级：</p>\n<ul>\n<li>DMA请求的优先级高于中断请求</li>\n<li>中断方式具有处理异常事件的能力，DMA方式局限于大批数据的传送</li>\n<li>中断方式靠程序传送，DMA方式靠硬件传送</li>\n</ul>\n",
            "tags": [
                "I/O"
            ]
        },
        {
            "id": "http://example.com/2025/08/10/computer-science/computer-organization/ch6/",
            "url": "http://example.com/2025/08/10/computer-science/computer-organization/ch6/",
            "title": "Ch6",
            "date_published": "2025-08-09T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch6-总线\"><a href=\"#Ch6-总线\" class=\"headerlink\" title=\"Ch6 总线\"></a>Ch6 总线</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>总线是一组能为多个部件分时和共享的公共信息传送线路。&#x3D;&#x3D;分时&#x3D;&#x3D;和&#x3D;&#x3D;共享&#x3D;&#x3D;是总线的两个特点</p>\n<ul>\n<li>分时：同一时刻只允许有一个部件向总线发送信息</li>\n<li>共享：总线上可以挂接多个部件<br>总线设备：按对总线有无控制权分</li>\n<li>主设备：发出总线请求且获得总线控制权的设备</li>\n<li>从设备：被主设备访问的设备，只能响应从这设备发来的各种总线命令<br>特性：机械特性（尺寸、形状）、电气特性（传输方向、有效的电平范围）、功能特性（没跟传输线的功能）、时间特性（信号和时序的关系）</li>\n</ul>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><ol>\n<li>按功能</li>\n</ol>\n<ul>\n<li>片内总线（CPU内部的，连接各寄存器以及寄存器和ALU）</li>\n<li>系统总线（连接CPU、主存、I&#x2F;O）。按传输内容又分为数据总线（数据、指令、终端类型号，双向传输）、地址总线（主存单元或IO端口地址，单向传输）、控制总线（clk, rst, 总线请求&#x2F;允许, 中断请求&#x2F;回答, r&#x2F;w…）</li>\n<li>I&#x2F;O总线（将低速的IO和告诉总线分离，常见的有USB&#x2F;PCI）</li>\n<li>通信总线（外部总线，计算机系统之间或计算机系统与其他系统）</li>\n</ul>\n<ol start=\"2\">\n<li>按时序控制方式</li>\n</ol>\n<ul>\n<li>同步总线</li>\n<li>异步总线</li>\n</ul>\n<ol start=\"3\">\n<li>按数据传输方式</li>\n</ol>\n<ul>\n<li>串行总线（一条双向或两条单向，数据按bit串行顺序传输，适合长距离通信）</li>\n<li>并行总线（有多条双向，容易出现干扰&#x2F;延迟，适合近距离通信）</li>\n</ul>\n<h3 id=\"系统总线的结构\"><a href=\"#系统总线的结构\" class=\"headerlink\" title=\"系统总线的结构\"></a>系统总线的结构</h3><ol>\n<li>单总线结构<br>CPU，主存，IO，都挂在一组（地址、数据、控制）总线上，允许IO之间、IO与主存直接交换信息<br>结构简单、成本低、易于接入新的设备<br>贷款低、负载中、不支持并发传送<br><img data-src=\"/f13.jpg\"></li>\n<li>双总线结构<br>一条主存总线，一条I&#x2F;O总线<br>主存总线支持突发传送，突发传送（Burst Transfer）是一种数据传输方式，它允许在一次地址发送后，连续传输多个数据块，而不需要为每个数据块单独发送地址和控制信号<br>将低速的I&#x2F;O设备分离开来，实现了存储器总线和I&#x2F;O总线的分离<br>需要增加通道等硬件设备<br><img data-src=\"/f14.jpg\"></li>\n<li>三总线结构<br>主存总线、I&#x2F;O总线、直接内存访问(DMA)总线<br>DMA 允许外部设备（如硬盘、网卡、显卡）直接与主存进行数据交换，无需CPU的直接参与和干预,把CPU从繁琐、低效的数据搬运工作中解放出来，让它可以去做更复杂的计算任务<br>优点是提高了I&#x2F;O设备的性能，使其更快地响应命令，提高系统吞吐量；缺点是任意时刻只能使用一种总线，系统工作效率较低（意思是一个设备不能同时使用多个总线，比如主存总线和DMA总线不能同时对主存进行存取）<br><img data-src=\"/f15.jpg\"></li>\n</ol>\n<h3 id=\"常见的总线标准\"><a href=\"#常见的总线标准\" class=\"headerlink\" title=\"常见的总线标准\"></a>常见的总线标准</h3><p>略</p>\n<h3 id=\"总线的性能指标\"><a href=\"#总线的性能指标\" class=\"headerlink\" title=\"总线的性能指标\"></a>总线的性能指标</h3><ul>\n<li>总线时钟周期</li>\n<li>总线时钟频率</li>\n<li>总线传输周期：申请、寻址、传输、结束</li>\n<li>总线工作频率：1&#x2F;总线（传输）周期</li>\n<li>总线宽度：通常指数据总线的根数</li>\n<li>总线带宽：最大数据传输速率，B&#x2F;s，带宽 &#x3D; 总线工作频率*（总线宽度&#x2F;8）</li>\n<li>总线复用：一种信号现在不同的时间传输不同的信息，比如地址&#x2F;数据线复用（地址通过数据线传送）</li>\n<li>信号线数：地址总线、数据总线、控制总线数量的总和<br>最主要的性能指标：&#x3D;&#x3D;总线宽度、总线工作频率、总线带宽&#x3D;&#x3D;<br>带宽 &#x3D; 总线工作频率*总线宽度 bits&#x2F;s</li>\n</ul>\n<h2 id=\"总线事务和定时\"><a href=\"#总线事务和定时\" class=\"headerlink\" title=\"总线事务和定时\"></a>总线事务和定时</h2><h3 id=\"总线事务\"><a href=\"#总线事务\" class=\"headerlink\" title=\"总线事务\"></a>总线事务</h3><p>从请求总线到完成总线使用的操作序列称为<strong>总线事务</strong>，典型的总线事务包括请求操作、仲裁操作、地址传输、数据传输和总线释放</p>\n<ol>\n<li>请求阶段：主设备（CPU或DMA）发出总线传输请求，获得总线控制权</li>\n<li>仲裁阶段：总选仲裁机构决定将下一个传输周期的总线使用权授予某个申请者</li>\n<li>寻址阶段：传输地址和命令，启动从模块</li>\n<li>传输阶段：主模块和从模块进行数据交换，单向或双向</li>\n<li>释放阶段：主模块有关信息从系统总线上撤除，让出总线使用权、</li>\n</ol>\n<p>数据传送方式：突发方式和非突发方式<br>突发传送：寻址阶段发送的是连续数据单元的首地址，传输阶段传送多个连续单元的数据，每个时钟周期可以传送一个字长的信息（如果总线宽度等于一个字长），一组数据全部传送完毕后再释放总线<br>非突发传送：每个传送周期内都先传送地址，再传送数据，每次只能传输一个字长的数据</p>\n<h3 id=\"总线定时\"><a href=\"#总线定时\" class=\"headerlink\" title=\"总线定时\"></a>总线定时</h3><p>同步、异步、半同步、分离式</p>\n<ol>\n<li>同步定时方式<br>适用于总线较短且部件存取时间比较接近的系统。每个部件或设备发送或接收信息都在固定的总线传送周期中，一个总线的传送周期结束，下一个总线传送周期开始<br>优点：传送速度快，具有较高的传输速率；总线控制逻辑简单。<br>缺点：主从设备属于强制性同步；不能及时进行数据通信的有效性检验，可靠性较差</li>\n<li>异步定时方式<br>依靠传送双方相互制约的“握手”信号来实现定时控制。主设备发出请求，从设备接收到请求后发出回答。<br>优点：总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间的配合。<br>缺点：比同步控制方式稍复杂一些，速度比同步定时方式慢</li>\n</ol>\n<ul>\n<li>根据“请求”和“回答”的撤销是否互锁分为<ul>\n<li>不互锁方式：发出请求不必等回答，一段时间后自动撤销请求信号。收到请求信号后发出回答信号，一段时间后自动撤销回答信号。（速度最快 可靠性最差）</li>\n<li>半互锁方式：发出请求后等待收到回答信号才撤销请求信号。收到请求信号后发出回答信号，一段时间后自动撤销回答信号。</li>\n<li>全互锁方式：发出请求后等待收到回答信号才撤销请求信号，收到请求信号后发出回答，必须获知请求信号撤销之后才撤销回答信号（最可靠 速度最慢）</li>\n</ul>\n</li>\n</ul>\n<p>异步串行通信的方式一步串行通信的第一位是开始位，表示字符传送的开始。铜芯线上没有数据传送时处于逻辑”1”状态，发出逻辑”0”为开始位在从最低位开始传输信号。发送完字符之后可以发送几奇偶校验（若有），之后发送停止位。</p>\n<ol start=\"3\">\n<li><p>半同步定时方式<br><img data-src=\"/f1.jpg\"><br>保留时钟信号的同时增设Wait响应信号线，Wait&#x3D;1的时候才取数据<br>优点：控制方式比异步简单<br>缺点：时钟频率不能太高</p>\n</li>\n<li><p>分离式定时方式<br>将总线事务分解为请求和应答两个子过程。第一个子过程中，主设备发送命令、地址到总线上，发完立即释放总线（第一个字过程很短）。第二个另外以个设备接受命令并发送数据到总线。两个子过程都只有单向信息流，每个设备都变为主设备。<br><img data-src=\"/f2.jpg\"><br><img data-src=\"/f3.jpg\"><br>在空闲阶段释放总线使总线可接受其他设备的请求<br>控制复杂，开销大</p>\n</li>\n</ol>\n",
            "tags": [
                "总线"
            ]
        },
        {
            "id": "http://example.com/2025/08/10/computer-science/computer-organization/ch5/",
            "url": "http://example.com/2025/08/10/computer-science/computer-organization/ch5/",
            "title": "Ch5",
            "date_published": "2025-08-09T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch5-中央处理器\"><a href=\"#Ch5-中央处理器\" class=\"headerlink\" title=\"Ch5 中央处理器\"></a>Ch5 中央处理器</h1><h2 id=\"CPU的功能和基本结构\"><a href=\"#CPU的功能和基本结构\" class=\"headerlink\" title=\"CPU的功能和基本结构\"></a>CPU的功能和基本结构</h2><h3 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h3><p>CPU由运算器和控制器组成，具体功能包括：</p>\n<ul>\n<li>指令控制</li>\n<li>操作控制</li>\n<li>时间控制</li>\n<li>数据加工</li>\n<li>中断处理</li>\n</ul>\n<h3 id=\"基本结构\"><a href=\"#基本结构\" class=\"headerlink\" title=\"基本结构\"></a>基本结构</h3><ol>\n<li>运算器：ALU, 暂存器, ACC, GPRs, PSW, 移位寄存器， 计数器…</li>\n<li>控制器：PC, IR, ID, 时序电路，未操作信号发生器…</li>\n</ol>\n<h3 id=\"CPU的寄存器\"><a href=\"#CPU的寄存器\" class=\"headerlink\" title=\"CPU的寄存器\"></a>CPU的寄存器</h3><p>按汇编程序是否可访问分为用户可见寄存器(GPRs, PSW, PC)和用户不可见寄存器(存储器地址寄存器，存储器数据寄存器，IR, 暂存寄存器，累加寄存器，移位寄存器)<br>各寄存器的作用：</p>\n<ul>\n<li>在运算器中：<ul>\n<li>GPRs</li>\n<li>ACC: 通用寄存器，用于暂时存放ALU运算的结果</li>\n<li>SR（移位寄存器）：存放操作数且可以移位</li>\n<li>暂存寄存器：暂存从数据总线或通用寄存器送来的操作数，对应用程序员透明</li>\n<li>PSW：保留各种状态信息</li>\n</ul>\n</li>\n<li>在控制器中：<ul>\n<li>PC: 存放当前指令的地址</li>\n<li>IR: 存放当前指令</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"指令执行过程\"><a href=\"#指令执行过程\" class=\"headerlink\" title=\"指令执行过程\"></a>指令执行过程</h2><h3 id=\"指令周期\"><a href=\"#指令周期\" class=\"headerlink\" title=\"指令周期\"></a>指令周期</h3><p>&#x3D; 取值周期 + 执行周期<br>间址周期在取址和执行之间<br>如果CPU在每条指令结束前都要发中断查询信号 （轮询法），后面要加上中断周期</p>\n<h3 id=\"指令周期的数据流\"><a href=\"#指令周期的数据流\" class=\"headerlink\" title=\"指令周期的数据流\"></a>指令周期的数据流</h3><ol>\n<li>取址周期</li>\n</ol>\n<ul>\n<li>PC-&gt;MAR-&gt;地址总线-&gt;存储器</li>\n<li>CU发出读命令-&gt;控制总线-&gt;主存</li>\n<li>主存-&gt;数据总线-&gt;IR</li>\n<li>CU发出控制信号-&gt;PC&#x3D;PC+1</li>\n</ul>\n<ol start=\"2\">\n<li>间址周期<br>取指结束后，控制单元CU会检查IR中是否有间接地址（操作数有效地址的地址）。若有，CPU执行如下操作：</li>\n</ol>\n<ul>\n<li>IR(或MDR)的间址-&gt;MAR-&gt;地址总线-&gt;主存</li>\n<li>CU发出读命令-&gt;控制总线-&gt;主存</li>\n<li>主存-&gt;数据总线-&gt;MDR（取出有效地址存入MDR）</li>\n</ul>\n<ol start=\"3\">\n<li><p>执行周期</p>\n</li>\n<li><p>中断周期<br>假设程序断点存入堆栈中，push操作先修改SP再存入（x86采用满递减栈）</p>\n</li>\n</ol>\n<ul>\n<li>CU控制将SP减1，SP-&gt;MAR-&gt;地址总线-&gt;zhucun1</li>\n<li>CU发出写命令-&gt;控制总线-&gt;主存</li>\n<li>PC-&gt;MDR-&gt;数据总线-&gt;主存（把中断时的PC存入栈中）</li>\n<li>CU将中断服务程序入口地址存入PC</li>\n</ul>\n<h3 id=\"指令执行方案\"><a href=\"#指令执行方案\" class=\"headerlink\" title=\"指令执行方案\"></a>指令执行方案</h3><ol>\n<li>单周期处理器<br>CPI &#x3D; 1，指令执行周期取决于执行时间最长的指令的执行时间</li>\n<li>多周期处理器<br>CPI &gt; 1,</li>\n<li>流水线处理器<br>理想状态下CPI &#x3D; 1，流水线并行</li>\n</ol>\n<h2 id=\"数据通路\"><a href=\"#数据通路\" class=\"headerlink\" title=\"数据通路\"></a>数据通路</h2><h3 id=\"功能-1\"><a href=\"#功能-1\" class=\"headerlink\" title=\"功能\"></a>功能</h3><p>。</p>\n<h3 id=\"组成\"><a href=\"#组成\" class=\"headerlink\" title=\"组成\"></a>组成</h3><ol>\n<li>组合逻辑<br>译码器，MUX，三态门…</li>\n<li>时序逻辑<br>包含存储信号的记忆单元</li>\n</ol>\n<h3 id=\"基本结构-1\"><a href=\"#基本结构-1\" class=\"headerlink\" title=\"基本结构\"></a>基本结构</h3><p>2种：</p>\n<ul>\n<li>CPU内部总线（单总线、多总线）</li>\n<li>专用数据通路</li>\n</ul>\n<ol>\n<li>CPU内部单总线方式<br>ALU和寄存器连接到一条总线上，性能低<br>单总线的ALU要配合暂存器使用，比如从内存取出来的数据要放在暂存器中，再从暂存器中取数据给ALU<br><img data-src=\"/f1.jpg\"><br>了解每条指令的datapath</li>\n<li>CPU内部多总线方式<br>允许同时在多个总线上传送不同的数据，提高效率</li>\n<li>专用数据通路方式<br>看图说话，没什么好说的</li>\n</ol>\n<h3 id=\"数据通路的操作举例\"><a href=\"#数据通路的操作举例\" class=\"headerlink\" title=\"数据通路的操作举例\"></a>数据通路的操作举例</h3><p>会画图就会</p>\n<h2 id=\"控制器的功能和工作原理\"><a href=\"#控制器的功能和工作原理\" class=\"headerlink\" title=\"控制器的功能和工作原理\"></a>控制器的功能和工作原理</h2><h3 id=\"结构和功能\"><a href=\"#结构和功能\" class=\"headerlink\" title=\"结构和功能\"></a>结构和功能</h3><ol>\n<li>取指令，指出下一条指令的位置</li>\n<li>译码或测试，产生控制信号</li>\n<li>控制CPU，主存，I&#x2F;O的数据流动方向<br>分为硬布线控制器和微程序控制器</li>\n</ol>\n<h3 id=\"硬布线控制器\"><a href=\"#硬布线控制器\" class=\"headerlink\" title=\"硬布线控制器\"></a>硬布线控制器</h3><p>组合逻辑控制器<br>CU的输入信号来自(1)指令译码器(2)时钟脉冲(3)执行单元的反馈信息<br>比如这种：<br><img data-src=\"/f2.jpg\"></p>\n<h3 id=\"微程序控制器\"><a href=\"#微程序控制器\" class=\"headerlink\" title=\"微程序控制器\"></a>微程序控制器</h3><p>采用存储逻辑实现，将未操作信号代码化，使没调机器指令转化成一段微程序并存入专门的控制存储器中<br>晚点回来学</p>\n<h2 id=\"异常和中断机制\"><a href=\"#异常和中断机制\" class=\"headerlink\" title=\"异常和中断机制\"></a>异常和中断机制</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>内部产生的意外事件叫异常，是同步的；外部产生的事件叫中断，是异步的</p>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><ul>\n<li><p>异常：CPU内部执行指令引起的异常事件，比如整除0，溢出，单步跟踪，非法指令，栈溢出，地址越界，缺页等</p>\n<ul>\n<li><ol>\n<li>Fault故障<br>引起故障的指令启动后、执行结束前检测到的异常事件（所以处理完之后要重新执行该指令或者无法恢复的终止进程）</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>Trap自陷<br>人为设定的特殊中断机制，最常见的是sys call，还有断点、单步，还有一些条件自陷指令（MIPS的teq, teqi, tne, tnei）等<br>&#x3D;&#x3D;以上两种都属于软件中断&#x3D;&#x3D;</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>Abort终止<br>执行过程中发生了硬件故障，比如控制器出错、存储器校验错、总线错误等<br>&#x3D;&#x3D;Abort和外中断属于硬件中断&#x3D;&#x3D;</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>中断：CPU外部比如I&#x2F;O引起的中断，分为可屏蔽中断和不可屏蔽中断</p>\n<ul>\n<li>可屏蔽中断：可屏蔽中断请求线INTR向CPU发出中断请求，CPU可以设置相应的bit屏蔽</li>\n<li>不可屏蔽中断：通过专门的不可屏蔽中断请求线NMI向CPU发出的中断请求，通常是非常紧急的硬件故障<br>&#x3D;&#x3D;所有的异常和终端都是由硬件检测发现的&#x3D;&#x3D;<br>根据识别中断服务程序地址的方式，可以分为向量中断和非向量中断；<br>根据中断处理过程是否允许被打断分为单重中断和多重中断</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"异常和中断的响应过程\"><a href=\"#异常和中断的响应过程\" class=\"headerlink\" title=\"异常和中断的响应过程\"></a>异常和中断的响应过程</h3><ol>\n<li>关中断<br>保存断点和程序状态期间，把IF置0不允许响应中断</li>\n<li>保存断点和程序状态<br>将返回地址和被中断时的PSW送到栈或特定寄存器中（通常是栈，才能支持嵌套中断），处理完之后恢复</li>\n<li>识别异常和中断并转到相应的处理程序<br>异常大多采用软件识别，中断可以采用软件识别或硬件识别<br>软件识别：CPU设置异常状态寄存器，操作系统使用查询程序按优先级顺序查询异常状态寄存器以检测类型并处理<br>硬件识别：向量中断。每个异常或中断被指定一个中断类型号，发生之后查询中断向量表，找到处理程序的入口地址（中断向量），并跳转到处理程序</li>\n</ol>\n<h2 id=\"指令流水线\"><a href=\"#指令流水线\" class=\"headerlink\" title=\"指令流水线\"></a>指令流水线</h2><ul>\n<li>Performance via parallelism</li>\n<li>Performance via pipelining</li>\n<li>Performance via prediction<br>时间并行：流水线<br>空间并行：超标量</li>\n</ul>\n<h3 id=\"基本实现\"><a href=\"#基本实现\" class=\"headerlink\" title=\"基本实现\"></a>基本实现</h3><p>单周期CPU以执行最慢的指令周期作为时钟周期。不能缩短单挑指令的执行时间，但可以提高整个程序的执行速度<br>每个流水段后面都要加一个流水段寄存器锁存数据，保证本段的执行结果能在下个周期给下一流水段使用。</p>\n<h3 id=\"Hazard\"><a href=\"#Hazard\" class=\"headerlink\" title=\"Hazard\"></a>Hazard</h3><ul>\n<li>结构冒险、数据冒险、控制冒险</li>\n</ul>\n<ol>\n<li>structural hazard<br>在流水线执行期间，两条及以上指令同一时间对同一个硬件资源发起使用的请求（Memory conflicts, Register File conflicts, Other units conflicts）<br>解决方法：(1)stall (2)增加更多的硬件支持单元（比如Double Bump，前半周期写后半周期读）</li>\n<li>data hazard<br>RAW, WAR, WAW<br>统考不考乱序执行所以只需要考虑RAW写后读<br>解决方法：(1)stall (2)NOP (3)forwarding</li>\n</ol>\n<ul>\n<li>stall<br>硬件解决方法，流水线阻塞，使数据相关的后续指令延迟执行，也称为插入气泡（bubble）</li>\n<li>NOP<br>软件解决方法，编译时插入空操作（NOP）比如<code>addi x0,x0,0</code>，使数据相关的后续指令延迟执行</li>\n<li>forwarding<br>旁路转发，将数据通路生成的中间数据直接往前传递到ALU的输入端，参与下一条指令的运算<br>必须同时满足两个条件：</li>\n<li>指令确实会写入寄存器（通过检查 RegWrite 信号）。</li>\n<li>目标寄存器编号不是 x0（零寄存器不会变）<br>才需要forwarding<blockquote>\n<p>ALU-&gt;ALU<br>数据可以从 <code>EX/MEM</code> 或 <code>MEM/WB</code> 阶段转发到当前在 EX 阶段的 ALU 输入<br>MEM-&gt;ALU<br>load指令的数据只有在<code>MEM/WB</code>阶段才能被转发到当前在 EX 阶段的 ALU 输入，所以如果load下一条指令要用到load指令的数据，则需要先stall一周期再forwarding</p>\n</blockquote>\n</li>\n</ul>\n<ol start=\"3\">\n<li>control hazard<br>解决方法：</li>\n</ol>\n<ul>\n<li>插入3条<code>NOP</code>直到分支指令的<code>WB</code>阶段才进行下一条指令的<code>IF</code></li>\n<li>分支预测<br><img data-src=\"/f5.jpg\"></li>\n</ul>\n<h3 id=\"流水线的性能指标\"><a href=\"#流水线的性能指标\" class=\"headerlink\" title=\"流水线的性能指标\"></a>流水线的性能指标</h3><ol>\n<li>吞吐率<br>单位时间内流水线所完成的任务数量<br>$$<br>TP &#x3D; \\frac{n}{T_k}<br>$$<br>k是流水线的段数，n是任务数，Tk是处理n个任务所用的总时间。理想状态下一条k段流水线能在<code>k+n-1</code>个时钟周期完成<code>n</code>个任务，吞吐率为$\\frac{n}{(k + n - 1) \\Delta t}$</li>\n<li>流水线的加速比<br>完成同一批任务，不适用流水线和使用流水线所用的时间之比<br>理想状态下流水线加速比为$\\frac{k n}{k+n-1}$</li>\n</ol>\n<h3 id=\"高级流水线技术\"><a href=\"#高级流水线技术\" class=\"headerlink\" title=\"高级流水线技术\"></a>高级流水线技术</h3><ol>\n<li>超标量流水线<br>动态多发射技术，支持乱序执行</li>\n</ol>\n<ul>\n<li>Scoreboard<br><img data-src=\"/f3.jpg\"></li>\n<li>Tomasulo<br><img data-src=\"/f4.jpg\"></li>\n</ul>\n<ol start=\"2\">\n<li>超长指令字技术<br>静态多发射技术，将多条能并行操作的指令组合成一个超长指令字，需要多个处理不见</li>\n<li>超流水线技术<br>流水线功能段划分的越多，时钟周期越短，指令吞吐率越高。<br>超流水线技术通过提高流水线主频来提高性能，但是流水段越多中间寄存器的开销就越大<blockquote>\n<p>超流水线或者理想状态下流水线技术CPI&#x3D;1；多发射流水线的CPI可以小于1</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"多处理器\"><a href=\"#多处理器\" class=\"headerlink\" title=\"多处理器\"></a>多处理器</h2><h3 id=\"SISD-SIMD-MIMD\"><a href=\"#SISD-SIMD-MIMD\" class=\"headerlink\" title=\"SISD SIMD MIMD\"></a>SISD SIMD MIMD</h3><ol>\n<li>SISD: single instruction single data<br>传统串行处理器</li>\n<li>SIMD: single instruction multiple data<br>数据级并行技术(DLP)，一条指令可以同时对多个数据元素执行相同的操作，用到向量寄存器<br>在处理for循环数组时最有效（比如两个数组相加）；在使用case&#x2F;seitch时效率最低</li>\n<li>MISD: multiple instruction single data<br>实际上不存在</li>\n<li>MIMD: multiple instruction multiple data<br>TLP<br>分为多计算机系统和多处理器系统。<br>多计算机系统由多个独立的计算机节点组成，每个节点通常包含自己的存储器、CPU，具有独立的主存地址空间，通过消息传递进行数据传送，也称<code>消息传递MIMD</code><br>多处理器系统是共享存储多处理器<code>SMP</code>系统的简称，共享单一地址空间，也称共享存储MIMD<br>向量处理器是SIMD的变体，实现了直接操作一维数组指令集</li>\n</ol>\n<h3 id=\"硬件多线程\"><a href=\"#硬件多线程\" class=\"headerlink\" title=\"硬件多线程\"></a>硬件多线程</h3><ol>\n<li>细粒度多线程 Fine-grained multithreading<br>多个线程交叉执行指令，线程之间的指令不相关，可以乱序并行执行，需要频繁进行上下文切换，不需要重载流水线。牺牲单个线程执行的性能，来换取整个进程吞吐量的提升</li>\n<li>粗粒度多线程 Coarse-grained multithreading<br>连续几个时钟周期都执行同一线程的指令序列，尽在当前线程出现较大开销的阻塞才切换（比如L2 miss, L2 miss）相比细粒度多线程，上下文切换的频率较低，切换时需要重载流水线</li>\n<li>同时多线程 SMT<br>ILP+TLP，指令级并行的同时实现线程级并行，在同一个时钟周期发射多个不同线程中的多条指令执行<br>Intal的Hyper-threading就是SMT<br><img data-src=\"/f6.jpg\"></li>\n</ol>\n<h3 id=\"多核处理器\"><a href=\"#多核处理器\" class=\"headerlink\" title=\"多核处理器\"></a>多核处理器</h3><p>一个CPU有多个core，也称片上多处理器<br>每个核既可以有自己的Cache，又可以共享同一个Cache，所有核共享主存储器<br>多核处理器必须采用多线程（或多进程）才能发挥性能</p>\n<h3 id=\"共享内存多处理器-SMP\"><a href=\"#共享内存多处理器-SMP\" class=\"headerlink\" title=\"共享内存多处理器 SMP\"></a>共享内存多处理器 SMP</h3><p>处理器通过存储器中的共享变量互相通信，所有存储器都能通过存取指令访问存储器的任何位置，有两种：<br><img data-src=\"/f7.jpg\"></p>\n<ul>\n<li>UMA 统一存储访问多处理器<br>UMA中所有处理器对所有内存模块的访问延迟是相同的，由于访问延迟一致，数据放在哪个内存模块上对性能影响不大。随着系统规模扩大，所有处理器都通过同一个前端总线访问内存，导致互连网络成为瓶颈，延迟增加，带宽受限<br><img data-src=\"/f8.jpg\"></li>\n<li>NUMA 非统一存储访问多处理器<br>内存有本地内存和远程内存，访问本地内存快。CPU可以通过QPI总线访问远程内存<br><img data-src=\"/f9.jpg\"></li>\n<li>需要解决 Cache coherence 问题：Snooping(MSI, MESI, MOESI…), Directory<br>基本思想都是对共享变量加锁，保证互斥访问<ul>\n<li>Snooping:<br><img data-src=\"/f10.jpg\"><br><img data-src=\"/f11.jpg\"></li>\n<li>Directory:<br><img data-src=\"/f12.jpg\"></li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "CPU"
            ]
        },
        {
            "id": "http://example.com/2025/08/01/computer-science/computer-organization/ch4/",
            "url": "http://example.com/2025/08/01/computer-science/computer-organization/ch4/",
            "title": "Ch4",
            "date_published": "2025-07-31T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch4-指令系统\"><a href=\"#Ch4-指令系统\" class=\"headerlink\" title=\"Ch4 指令系统\"></a>Ch4 指令系统</h1><h2 id=\"指令系统\"><a href=\"#指令系统\" class=\"headerlink\" title=\"指令系统\"></a>指令系统</h2><h3 id=\"ISA（王道叫它指令集体系结构）\"><a href=\"#ISA（王道叫它指令集体系结构）\" class=\"headerlink\" title=\"ISA（王道叫它指令集体系结构）\"></a>ISA（王道叫它指令集体系结构）</h3><p>指令系统 vs ISA</p>\n<p>ISA完整地定义了软件和硬件之间的接口，规定了：</p>\n<ul>\n<li>指令格式（指令寻址方式，操作类型，操作数）</li>\n<li>操作数的类型、寻址方式、大端小端存放（大端：高位放在低地址；小端：低位放在低地址）</li>\n<li>程序可访问的寄存器编号、个数和位数，存储空间大小和编址方式</li>\n<li>指令执行过程的控制方式（PC, condition code, …）</li>\n</ul>\n<h3 id=\"指令的基本格式\"><a href=\"#指令的基本格式\" class=\"headerlink\" title=\"指令的基本格式\"></a>指令的基本格式</h3><p>操作码+地址码<br>主存一般是按字节编址，所以指令字长通常为字节的整数倍</p>\n<ol>\n<li><p>零地址指令<br>NOP, HLT<br>不需要操作数。<br>零地址的运算类指令仅用在堆栈计算机中（操作数直接从栈顶弹出）</p>\n</li>\n<li><p>一地址指令<br>OP, A1<br>OP(A1) -&gt; A1<br>加1，减1，取反，求补，移位等<br>可能有一个操作数或者两个操作数</p>\n<blockquote>\n<p>隐含约定目的地址的双操作数指令，地址码指明一个操作数，另一个操作数来自隐含寻址</p>\n</blockquote>\n</li>\n<li><p>二地址指令<br>OP, A1, A2<br>(A1)OP(A2) -&gt; A1</p>\n</li>\n<li><p>三地址指令<br>OP, A1, A2, A3<br>(A1)OP(A2) -&gt; A3</p>\n</li>\n<li><p>四地址指令<br>OP, A1, A2, A3, A4<br>(A1)OP(A2) -&gt; A3, A4 &#x3D; 下一条将要执行指令的地址</p>\n</li>\n</ol>\n<h3 id=\"定长操作码指令格式\"><a href=\"#定长操作码指令格式\" class=\"headerlink\" title=\"定长操作码指令格式\"></a>定长操作码指令格式</h3><p>n位opcode最多能表示2^n条指令<br>指令字长：单字长(PC &#x3D; PC + 1)、双字长(PC &#x3D; PC + 2)…</p>\n<h3 id=\"扩展操作码指令格式\"><a href=\"#扩展操作码指令格式\" class=\"headerlink\" title=\"扩展操作码指令格式\"></a>扩展操作码指令格式</h3><p>才去可变长度操作码，分散地放在指令字的不同位置上<br>要求：</p>\n<ol>\n<li>不允许短码是长码的前缀</li>\n<li>各指令的操作码不能重复<br><img data-src=\"/f1.jpg\"><br>RISC-V指令集</li>\n</ol>\n<h3 id=\"指令的操作类型\"><a href=\"#指令的操作类型\" class=\"headerlink\" title=\"指令的操作类型\"></a>指令的操作类型</h3><ol>\n<li>数据传送</li>\n</ol>\n<ul>\n<li>MOV: 寄存器到寄存器</li>\n<li>LOAD: 从内存读到寄存器</li>\n<li>STORE: 从寄存器写入内存</li>\n<li>PUSH</li>\n<li>POP</li>\n</ul>\n<ol start=\"2\">\n<li><p>算术和逻辑运算<br>ADD, SUB, MUL, DIV, MOD, AND, OR, XOR, NOT, XOR, INC(加一), DEC(减一)</p>\n</li>\n<li><p>移位<br>算术移位，逻辑移位，循环移位</p>\n</li>\n<li><p>转移<br>JMP, BRANCH, CALL, RET, TRAP（中断隐指令是硬件实现的，只有TRAP是软指令）</p>\n</li>\n<li><p>I&#x2F;O操作</p>\n</li>\n</ol>\n<h2 id=\"指令的寻址方式\"><a href=\"#指令的寻址方式\" class=\"headerlink\" title=\"指令的寻址方式\"></a>指令的寻址方式</h2><h3 id=\"指令寻址与数据寻址\"><a href=\"#指令寻址与数据寻址\" class=\"headerlink\" title=\"指令寻址与数据寻址\"></a>指令寻址与数据寻址</h3><ol>\n<li>指令寻址</li>\n</ol>\n<ul>\n<li>顺序： PC &#x3D; PC + 1</li>\n<li>跳转： 绝对转移(PC &#x3D; 跳转地址) ,相对转移(PC &#x3D; PC + offset)</li>\n</ul>\n<ol start=\"2\">\n<li>数据寻址<br>格式：操作码 寻址特征 形式地址A</li>\n</ol>\n<ul>\n<li>立即寻址(addi, …)</li>\n<li>直接寻址（A直接表示地址）</li>\n<li>寄存器寻址(add, …)</li>\n<li>寄存器间接寻址(lw r1 offset(r2), …)</li>\n</ul>\n<h3 id=\"常见的数据寻址方式\"><a href=\"#常见的数据寻址方式\" class=\"headerlink\" title=\"常见的数据寻址方式\"></a>常见的数据寻址方式</h3><ol>\n<li>隐含寻址<br>比如单地址的第二个操作数由ACC提供: Intel 8080的<code>ADD A</code>指令会将寄存器A的内容与指定的操作数（放在ACC内）相加，并将结果存储回累加器中<br>优点是缩短指令字长；缺点是需要增加存储操作数或隐含地址的硬件</li>\n<li>立即（数）寻址<br>比如riscv的<code>addi x5, x6, #1</code><br>优点是不用访存速度快，缺点是立即数位数有限</li>\n<li>直接寻址<br><code>OP #A</code></li>\n</ol>\n<p>比如lc3的<code>LD R1, LABEL1</code>翻译成汇编是<code>LD R1, x3100</code>表示<code>R1 &lt;- MEM[x3100]</code><br>形式地址A就是操作数的真实地址EA<br>优点是简单，缺点是寻址范围受A的位数限制<br>4. 间接寻址<br>EA &#x3D; (A)<br>指令中给出的地址是包含实际地址的内存位置或寄存器<br>比如lc3的<code>LDI R1, LABEL1</code>翻译成汇编是<code>LDI R1, x3100</code>表示<code>R1 &lt;- MEM[MEM[x3100]]</code><br>5. 寄存器寻址<br>EA &#x3D; (Ri)<br><code>ADD R1, R2, R3</code><br>6. 寄存器间接寻址<br>EA &#x3D; (Ri)<br>比如<code>LW R1, offset(R2)</code><br>7. 相对寻址<br>相对PC寻址<br>EA &#x3D; (PC) + A<br>比如branch<br>8. 基址寻址<br>EA &#x3D; (BR) + A<br>面向操作系统，优点是扩大寻址范围，有利于躲到程序设计；缺点是偏移量(A)的位数较短<br>9. 变址寻址<br>EA &#x3D; (IX) + A<br>比如用来访问数组</p>\n<blockquote>\n<p>偏址寻址：相对寻址、基址寻址、变址寻址</p>\n<ol start=\"10\">\n<li>堆栈寻址有一个堆栈指针SP，堆栈分为硬堆栈，软堆栈。寄存器堆栈是硬堆栈，内存是软堆栈。采用无操作数指令<br><img data-src=\"/f2.jpg\"></li>\n</ol>\n</blockquote>\n<h2 id=\"程序的机器级代码表示\"><a href=\"#程序的机器级代码表示\" class=\"headerlink\" title=\"程序的机器级代码表示\"></a>程序的机器级代码表示</h2><p>x86汇编</p>\n<h3 id=\"常用汇编指令介绍\"><a href=\"#常用汇编指令介绍\" class=\"headerlink\" title=\"常用汇编指令介绍\"></a>常用汇编指令介绍</h3><ol>\n<li>相关寄存器<br>x86架构有8个32位的通用寄存器：EAX、EBX、ECX、EDX、ESI、EDI、EBP、ESP<br><img data-src=\"/f3.jpg\"><br><img data-src=\"/f4.jpg\"><br><img data-src=\"/f5.jpg\"></li>\n<li>汇编指令格式<br>x86汇编指令格式有两种：AT&amp;T格式和Intel格式</li>\n</ol>\n<ul>\n<li>AT&amp;T只能小写，Intel大小写都行</li>\n<li>AT&amp;T第一个操作数是源操作数，第二个是目的操作数；Intel第一个操作数是目的操作数，第二个是源操作数</li>\n<li>AT&amp;T寄存器前缀%，立即数前缀$；Intel格式寄存器和立即数不需要加前缀</li>\n<li>内存寻址：AT&amp;T格式为(addr)，Intel格式为[addr]</li>\n<li>处理复杂寻址方式时，AT&amp;T格式为disp(base, index, scale)，表示偏移量，基址寄存器，变址寄存器，比例因子，表示的操作数为M[R[base]+R[index]*scale + disp];</li>\n<li>指定数据长度时，AT&amp;T用b, w, l; Intel用byte ptr, word ptr, dword ptr(一个word是16位，一个dword是32位)<br><img data-src=\"/f6.jpg\"><br><img data-src=\"/f7.jpg\"></li>\n</ul>\n<ol start=\"3\">\n<li>常用指令</li>\n</ol>\n<ul>\n<li><reg>表示任意寄存器，后面跟数字指定其位数</reg></li>\n<li><mem>内存地址</mem></li>\n<li><con>后面跟数字表示几位常数<br>常见的指令：</con></li>\n<li>数据传送指令<ul>\n<li>mov<ul>\n<li>mov <reg>, <reg></reg></reg></li>\n<li>mov <reg>, <mem></mem></reg></li>\n<li>mov <mem>, <reg></reg></mem></li>\n<li>mov <reg>, <con></con></reg></li>\n<li>mov <mem>, <con></con></mem></li>\n</ul>\n</li>\n<li>push(ESP指向栈顶空的位置，push之前ESP &#x3D; ESP - 4)&#x3D;&#x3D;栈中元素固定为32位&#x3D;&#x3D;<ul>\n<li>push &lt;reg32</li>\n<li>push <mem></mem></li>\n<li>push <con32></con32></li>\n</ul>\n</li>\n<li>pop(pop之后ESP &#x3D; ESP + 4)<ul>\n<li>pop <reg32></reg32></li>\n<li>pop <mem></mem></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>算术和逻辑运算<ul>\n<li>add&#x2F;sub(把两个操作数相加&#x2F;减，结果放回目的操作数)<ul>\n<li>add eax, 10    # eax &#x3D; eax + 10</li>\n<li>add byte ptr [var], 10    # 10与var指向的内存地址的一字节值相加，结果放回var指向的内存中</li>\n</ul>\n</li>\n<li>inc&#x2F;dec(把操作数自加1&#x2F;自减1)<ul>\n<li>dec eax    # eax &#x3D; eax - 1</li>\n<li>inc dword ptr [var]    # var指向的32位值自加1，结果放回var指向的32位内存中</li>\n</ul>\n</li>\n<li>imul(有符号数整数乘法, mul是无符号数乘法)目的操作数必须是寄存器，溢出时<code>OF = 1</code><ul>\n<li>imul <reg32>, <reg32></reg32></reg32></li>\n<li>imul <reg32>, <mem></mem></reg32></li>\n<li>imul <reg32>, <reg32>, <con></con></reg32></reg32></li>\n<li>imul <reg32>, <mem>, <con></con></mem></reg32></li>\n</ul>\n</li>\n<li>idiv(有符号数整数除法，&#x3D;&#x3D;只有一个操作数为除数，被除数有64位放在 <code>edx:eax</code> 中，操作结果商放到<code>eax</code>，余数放到<code>edx</code>&#x3D;&#x3D;)<ul>\n<li>idiv <reg32></reg32></li>\n<li>idiv <mem></mem></li>\n</ul>\n</li>\n<li>and&#x2F;or&#x2F;xor<ul>\n<li>and&#x2F;or&#x2F;xor <reg>, <reg></reg></reg></li>\n<li>and&#x2F;or&#x2F;xor <reg>, <mem></mem></reg></li>\n<li>and&#x2F;or&#x2F;xor <mem>, <reg></reg></mem></li>\n<li>and&#x2F;or&#x2F;xor <reg>, <con></con></reg></li>\n<li>and&#x2F;or&#x2F;xor <mem>, <con></con></mem></li>\n</ul>\n</li>\n<li>not(按位取反)<ul>\n<li>not <reg></reg></li>\n<li>not <mem></mem></li>\n</ul>\n</li>\n<li>neg(取负)<ul>\n<li>neg <reg></reg></li>\n<li>neg <mem></mem></li>\n</ul>\n</li>\n<li>shl&#x2F;shr(逻辑左移&#x2F;右移)<ul>\n<li>shl <reg>, <con8></con8></reg></li>\n<li>shl <mem>, <con8></con8></mem></li>\n<li>shr <reg>, <reg8></reg8></reg></li>\n<li>shr <mem>, <reg8></reg8></mem></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>控制流<ul>\n<li>jmp<ul>\n<li>jmp <label></label></li>\n</ul>\n</li>\n<li>jcondition<ul>\n<li>je <label></label></li>\n<li>jz <label></label></li>\n<li>jne <label></label></li>\n<li>jg <label></label></li>\n<li>jge <label></label></li>\n<li>jl <label></label></li>\n<li>jle <label></label></li>\n</ul>\n</li>\n<li>cmp&#x2F;test(cmp相当于相减，test相当于按位与，不保存操作结果仅设置条件码用于跳转指令)<ul>\n<li>cmp&#x2F;test <reg>, <reg></reg></reg></li>\n<li>cmp&#x2F;test <reg>, <mem></mem></reg></li>\n<li>cmp&#x2F;test <mem>, <reg></reg></mem></li>\n<li>cmp&#x2F;test <reg>, <con></con></reg></li>\n</ul>\n</li>\n<li>call&#x2F;ret(call将返回地址入栈然后跳转，ret弹出返回地址并跳转)<ul>\n<li>call <label></label></li>\n<li>ret</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"选择语句的机器级表示\"><a href=\"#选择语句的机器级表示\" class=\"headerlink\" title=\"选择语句的机器级表示\"></a>选择语句的机器级表示</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(test_exp)</span><br><span class=\"line\">    then_stmt</span><br><span class=\"line\">else</span><br><span class=\"line\">    else_stmt</span><br></pre></td></tr></table></figure>\n<p>翻译成</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(!t)</span><br><span class=\"line\">    goto false;</span><br><span class=\"line\">then_stmt;   </span><br><span class=\"line\">goto done;</span><br><span class=\"line\">false:  else_stmt;</span><br><span class=\"line\">done:</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"循环语句的机器级表示\"><a href=\"#循环语句的机器级表示\" class=\"headerlink\" title=\"循环语句的机器级表示\"></a>循环语句的机器级表示</h3><ol>\n<li>do-while</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">do</span><br><span class=\"line\">  body_stmt</span><br><span class=\"line\">  while(test_exp);</span><br></pre></td></tr></table></figure>\n<p>翻译成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loop:   body_stmt;</span><br><span class=\"line\">  t = test_exp;</span><br><span class=\"line\">  if(t)</span><br><span class=\"line\">    goto loop;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>while</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while(test_exp)</span><br><span class=\"line\">  body_stmt;</span><br></pre></td></tr></table></figure>\n<p>翻译成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t = test_exp;</span><br><span class=\"line\">if(!t)</span><br><span class=\"line\">  goto done;</span><br><span class=\"line\">loop:</span><br><span class=\"line\">  body_stmt;</span><br><span class=\"line\">  t = test_exp;</span><br><span class=\"line\">  if(t)</span><br><span class=\"line\">    goto loop;</span><br><span class=\"line\">done:</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>for</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(init_exp; test_exp; update_exp)</span><br><span class=\"line\">  body_stmt;</span><br></pre></td></tr></table></figure>\n<p>翻译成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init_exp;</span><br><span class=\"line\">t = test_exp;</span><br><span class=\"line\">if(!t)</span><br><span class=\"line\">  goto done;</span><br><span class=\"line\">loop:</span><br><span class=\"line\">  body_stmt;</span><br><span class=\"line\">  update_exp;</span><br><span class=\"line\">  t = test_exp;</span><br><span class=\"line\">  if(t)</span><br><span class=\"line\">    goto loop;</span><br><span class=\"line\">done:</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"过程调用的机器级表示\"><a href=\"#过程调用的机器级表示\" class=\"headerlink\" title=\"过程调用的机器级表示\"></a>过程调用的机器级表示</h3><ol>\n<li>caller将实参放到callee能访问的地方（寄存器放不下放栈里）</li>\n<li>caller保存返回地址（通过call指令实现）</li>\n<li>callee保存caller通用寄存器的内容，并为自己的非静态局部变量分配空间</li>\n<li>执行callee</li>\n<li>恢复caller的寄存器内容，将返回值放到caller能访问的地方（寄存器、栈），释放局部变量</li>\n<li>callee取出返回地址，恢复PC（ret实现）<blockquote>\n<p>EAX, ECX, EDX是caller saved register<br>通常用于传递参数、存储临时变量或返回值，所以call的时候内容可能会变，要先保存再调用。比如返回值一般保存在EAX<br>EBX, ESI, EDI是callee saved register<br>这些寄存器的值在函数调用后应保持不变，所以由callee保存，ret的时候要恢复</p>\n</blockquote>\n</li>\n</ol>\n<p>每个过程有自己的栈帧，<code>EBP</code>保存栈帧的基址，<code>ESP</code>指向栈顶位置，<code>EBP</code>的值不变，当前栈帧的范围在<code>EBP</code>和<code>ESP</code>之间（详见编译原理<code>activated record</code>）<br><img data-src=\"/f8.jpg\"><br>前三行的意思是新开一个栈帧，分配了24字节的栈帧空间。<code>push epb</code>实际上就是把static link压栈。<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ub3Jlc3BvbnNlNTI1LmdpdGh1Yi5pby8yMDI1LzA2LzE1L2NvbXB1dGVyLXNjaWVuY2UvY29tcGlsZS1wcmluY2lwbGVzL2NoNi8jJUU1JTg3JUJEJUU2JTk1JUIwJUU4JUIwJTgzJUU3JTk0JUE4JUU2JUI1JTgxJUU3JUE4JThC\">详见编译原理笔记</span><br>执行<code>call</code>之后，<code>call</code>会先将返回地址压栈，然后跳转到<code>add</code>的起始地址，为<code>add</code>创建栈帧。<code>add</code>的返回值存放在<code>EAX</code>中。<br>执行<code>ret</code>之前需要释放当前栈帧，恢复caller的栈帧。因此<code>leave</code>相当于<code>mov esp, ebp</code> <code>pop ebp</code></p>\n<h2 id=\"CISC和RISC的基本概念\"><a href=\"#CISC和RISC的基本概念\" class=\"headerlink\" title=\"CISC和RISC的基本概念\"></a>CISC和RISC的基本概念</h2><p>复杂指令系统计算机(CISC)：比如x86<br>精简指令系统计算机(RISC)：ARM, MIPS…</p>\n<h3 id=\"CISC\"><a href=\"#CISC\" class=\"headerlink\" title=\"CISC\"></a>CISC</h3><ul>\n<li>指令系统复杂庞大，指令数目多</li>\n<li>指令长度不固定，格式多，寻址方式多</li>\n<li>可以访存的指令不受限制（比如x86的add可以直接把reg和mem相加，但是riscv的只能reg和reg或者reg和imm）</li>\n<li>各种指令使用频度相差很大</li>\n<li>各种指令执行时间相差很大，大多指令需要多个时钟周期</li>\n<li>控制器大多采用微程序控制，无法采用硬连线控制</li>\n<li>难以用优化编译生成高效的目标代码程序</li>\n</ul>\n<h3 id=\"RISC\"><a href=\"#RISC\" class=\"headerlink\" title=\"RISC\"></a>RISC</h3><ul>\n<li>选取使用频率最高的一些简单指令，复杂指令的功能由简单指令的组合来实现</li>\n<li>指令长度固定，指令格式种类少，寻址方式种类少</li>\n<li>只有LOAD&#x2F;STORE访存，其余指令的操作只能访问寄存器&#x2F;imm</li>\n<li>CPU中通用寄存器数量相当多</li>\n<li>采用流水线技术，大部分指令在一个时钟周期内完成</li>\n<li>硬布线控制为主，不用或少用微程序控制</li>\n<li>重视编译优化<br>CISC兼容性好，大多RISC不能和老机器兼容，但具有更强的实用性。CISC可以提供更多的功能</li>\n</ul>\n<h3 id=\"CISC和RISC的比较\"><a href=\"#CISC和RISC的比较\" class=\"headerlink\" title=\"CISC和RISC的比较\"></a>CISC和RISC的比较</h3><p>和CISC相比，RISC的优点：</p>\n<ul>\n<li>RISC更能充分利用VLSI（超大规模集成电路）芯片的面积（减少了控制逻辑）</li>\n<li>RISC更能提高运算速度</li>\n<li>RISC便于设计，可以降低成本，提高可靠性</li>\n<li>有利于编译优化<br><img data-src=\"/f9.jpg\"></li>\n</ul>\n",
            "tags": [
                "指令系统"
            ]
        },
        {
            "id": "http://example.com/2025/07/01/computer-science/computer-organization/ch3/",
            "url": "http://example.com/2025/07/01/computer-science/computer-organization/ch3/",
            "title": "Ch3",
            "date_published": "2025-06-30T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch3-存储系统\"><a href=\"#Ch3-存储系统\" class=\"headerlink\" title=\"Ch3 存储系统\"></a>Ch3 存储系统</h1><h2 id=\"存储器概述\"><a href=\"#存储器概述\" class=\"headerlink\" title=\"存储器概述\"></a>存储器概述</h2><h3 id=\"存储器的分类\"><a href=\"#存储器的分类\" class=\"headerlink\" title=\"存储器的分类\"></a>存储器的分类</h3><ol>\n<li>按层次分</li>\n</ol>\n<ul>\n<li>主存（小、快、成本高）</li>\n<li>辅存（大、慢、成本低）</li>\n<li>Cache</li>\n</ul>\n<ol start=\"2\">\n<li>按存储介质分</li>\n</ol>\n<ul>\n<li>磁表面存储器（磁盘、磁带）</li>\n<li>磁芯存储器</li>\n<li>半导体存储器（MOS型、双极型）</li>\n<li>光存储器（光盘）</li>\n</ul>\n<ol start=\"3\">\n<li>按存储方式分</li>\n</ol>\n<ul>\n<li>RAM （随机存储器）:随机读取存储单元，存取时间与存储单元的物理位置无关。读写方便，主要用作主存和cache，分静态RAM和动态RAM。</li>\n<li>ROM （只读存储器）：只能读不能写，非易失性，随机读取。广义的ROM也可以通过电擦除进行写入(EEPROM)</li>\n<li>SAM （顺序存储器）：按顺序存储，存取时间与存储单元的物理位置有关</li>\n<li>DAM （直接存储器）：先选取信息所在区域，然后顺序存取。结合了RAM和SAM的特性（磁盘）</li>\n<li>Associated memory: 不根据地址而是根据存储内容来进行存取的存储器，可以实现快速地查找快表。既可以按照&#x3D;&#x3D;地址&#x3D;&#x3D;寻址也可以按照&#x3D;&#x3D;内容&#x3D;&#x3D;寻址（通常是某些字段）</li>\n<li>串行访问存储器：SAM和DAM都是，所以读写时间和物理位置有关</li>\n</ul>\n<ol start=\"4\">\n<li>按信息的可保存性分类</li>\n</ol>\n<ul>\n<li>易失性存储器：断电后丢失数据，如RAM</li>\n<li>非易失性存储器：断电后数据还在，如ROM，磁盘光盘</li>\n<li>破坏性读出：读出数据后数据被破坏</li>\n<li>非破坏性读出：读出数据后数据不改变</li>\n</ul>\n<h3 id=\"存储器的性能指标\"><a href=\"#存储器的性能指标\" class=\"headerlink\" title=\"存储器的性能指标\"></a>存储器的性能指标</h3><p>三个主要性能指标：存储容量、单位成本、存储速度</p>\n<ol>\n<li>容量 &#x3D; 存储字数 * 字长</li>\n<li>单位成本 &#x3D; 总成本&#x2F;总容量</li>\n<li>存储速度：<br>存取时间$T_a$: 启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入事件<br>存取周期$T_m$: 进行连续读&#x2F;写操作所允许的最短时间间隔<br>主存带宽$B_m$: b&#x2F;s, B&#x2F;s, word&#x2F;s<blockquote>\n<p>存取时间仅为完成一次操作的时间，而存取周期不仅包含操作时间，还包括操作后线路的恢复时间</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"多级层次的存储系统\"><a href=\"#多级层次的存储系统\" class=\"headerlink\" title=\"多级层次的存储系统\"></a>多级层次的存储系统</h3><p><img data-src=\"/f1.jpg\"><br>从上到下价格越来越低，速度越来越慢，容量越来越大，CPU访问频度越来越低<br><img data-src=\"/f2.jpg\"><br>存储时间与存储周期的关系</p>\n<ul>\n<li>透明（transparent）指的是某种机制或技术的存在对使用者来说是不可见或无感知的<br>主存-Cache之间的数据调用由硬件自动完成，对所有程序员均是透明的<br>主存-辅存的数据调用由硬件和操作系统共同完成，对应用程序员是透明的</li>\n</ul>\n<h2 id=\"主存储器\"><a href=\"#主存储器\" class=\"headerlink\" title=\"主存储器\"></a>主存储器</h2><p>存储元件：MOS管</p>\n<h3 id=\"SRAM-DRAM\"><a href=\"#SRAM-DRAM\" class=\"headerlink\" title=\"SRAM &amp; DRAM\"></a>SRAM &amp; DRAM</h3><p>RAM: SRAM静态随机存储器和DRAM动态随机存储器<br>&#x3D;&#x3D;主存主要是DRAM，Cache主要是SRAM&#x3D;&#x3D;，都易失</p>\n<p>DRAM芯片：使用栅极电容存储信息，只要一个晶体管，读写&#x3D;&#x3D;更慢&#x3D;&#x3D;，是&#x3D;&#x3D;破坏性读出&#x3D;&#x3D;，需要重写，&#x3D;&#x3D;成本低，集成度高，功耗低&#x3D;&#x3D;</p>\n<p>SRAM芯片：使用双稳态触发器存储信息（六晶体管MOS，RS, JK, D）。读写&#x3D;&#x3D;更快&#x3D;&#x3D;，是非破坏性读出，&#x3D;&#x3D;成本高，集成度低，功耗大&#x3D;&#x3D;<br><img data-src=\"/f4.jpg\"><br>栅极电容需要一直刷新给电容充电，触发器不需要刷新，只要不断电状态不会改变</p>\n<h4 id=\"DRAM的刷新\"><a href=\"#DRAM的刷新\" class=\"headerlink\" title=\"DRAM的刷新\"></a>DRAM的刷新</h4><ol>\n<li>多久需要刷新一次？ 刷新周期：一般为2ms</li>\n<li>每次刷新多少存储单元？以行为单位，每次刷新一行存储单元<br>——为什么要用行列地址？减少选通线的数量</li>\n<li>在什么时刻刷新？<br>有硬件支持，读出一行的信息后重新写入，占用1个读&#x2F;写周期<br>假设DRAM内部结构排列成128×128的形式，读&#x2F;写周期0.5us<br>2ms共 2ms&#x2F;0.5us &#x3D; 4000 个周期<br>三种刷新方式：<br><img data-src=\"/f5.jpg\"><br>刷新以行为单位，再生（重写）只需要恢复被读出来的存储单元<br>刷新由存储器独立完成，不需要CPU控制</li>\n</ol>\n<h5 id=\"DRAM的地址引脚复用技术\"><a href=\"#DRAM的地址引脚复用技术\" class=\"headerlink\" title=\"DRAM的地址引脚复用技术\"></a>DRAM的地址引脚复用技术</h5><p><img data-src=\"/f6.jpg\"><br>行列地址分成两次送，节省了一半的地址线<br>行列数优化原则：尽量使行、列数相同，且行数较少（因为按行刷新）<br>目前常用SDRAM（同步DRAM），数据交换同步于CPU的时钟信号，使得CPU不需要等待</p>\n<h3 id=\"ROM\"><a href=\"#ROM\" class=\"headerlink\" title=\"ROM\"></a>ROM</h3><p>结构简单、非易失性<br>类型：</p>\n<ol>\n<li>MROM 掩模式ROM<br>在芯片生产过程中写入，无法改变，可靠性高，急程度高，价格便宜，灵活性差</li>\n<li>PROM 一次可编程ROM<br>可以用专门的设备写入一次，一旦写入无法改变</li>\n<li>EPROM 可擦除可编程ROM<br>可以写入并多次改写，但是编程次数有限且时间长</li>\n<li>Flash<br>兼有RAM和ROM的优点，可以不加电长期保存信息，又能在线快速擦除和重写，价格便宜，急程度高，电可擦除重写且速度快<br>SSD 固态硬盘基于Flash，由控制单元和Flash组成，长期保存、快速擦除和重写，对比传统硬盘读写速度快。低功耗。但是价格高</li>\n</ol>\n<h3 id=\"主存储器的基本组成\"><a href=\"#主存储器的基本组成\" class=\"headerlink\" title=\"主存储器的基本组成\"></a>主存储器的基本组成</h3><p>核心部件：一个个存储0或1的存储单元构成的存储矩阵<br>访问主存时，CPU把地址送到MAR，MAR通过地址总线把地址送到主存中的地址寄存器，地址译码器进行译码，选中相应的内存单元，然后通过控制电路决定读&#x2F;写操作：</p>\n<ul>\n<li>读操作：将选中的内存单元的内容通过数据总线送到MDR中</li>\n<li>写操作：将MDR中的内容通过数据总线送到选中的内存单元中<br>MDR的位数和数据总线位数相同，通常等于存储字长；MAR的位数和地址总线位数相同</li>\n</ul>\n<h3 id=\"多模块存储器\"><a href=\"#多模块存储器\" class=\"headerlink\" title=\"多模块存储器\"></a>多模块存储器</h3><p>DRAM芯片的恢复时间比较长，有可能是存取时间的几倍（SRAM的恢复时间较短）。CPU的读写速度比主存快很多，主存恢复时间太长<br> —— 利用多个完全相同的存储模块并行工作来提高吞吐率：单体多字存储器，多体低位交叉存储器</p>\n<ul>\n<li>双端口RAM（408不考，了解即可）<br><img data-src=\"/f7.jpg\"></li>\n</ul>\n<ol>\n<li><p>单体多字存储器<br>一般一个存储单元只存储一个word，但是单体多字存储器一个存储单元存储多个word，然后读的时候一次性读取这多个字。好处是快，缺点是只有指令和数据连续存放时才能提高存取速度，否则造成不必要的读取。</p>\n</li>\n<li><p>&#x3D;&#x3D;多体并行存储器（重点）&#x3D;&#x3D;<br>分为高位交叉编址和低位交叉编址两种<br><img data-src=\"/f8.jpg\"><br>高位交叉编址每一块存储体的高位是一样的，实际上还是顺序存储。因此访问连续内存实际上访问的还是同一块存储体，并不能通过并行加快访问速度<br>低位交叉编址的每一块存储体低位相同，因此可以在恢复时间并行存取下一块内存的数据<br>存取周期为<code>T</code>, 存取时间为<code>r</code>, T &#x3D; r + 恢复时间<br>对于n个存储器并行访问的存储器：<br>采用高位交叉编址的时间为<code>n*T</code><br>低位交叉编址为<code>T + (n-1)*r</code></p>\n</li>\n</ol>\n<p><img data-src=\"/f9.png\"></p>\n<ul>\n<li>轮流启动：每个bank的存储位数等于数据总线的位数，此时采用轮流启动<ul>\n<li>对于低位交叉编址，要保证<code>m&gt;=T/r</code>，以保证流水线不间断</li>\n<li>理想情况下，m个bank的交叉存储器每隔<code>T/m</code>个周期可以读&#x2F;写一个数据，若相邻m次访问的当存地址出现在同一个模块内，则会发生访存冲突，此时需要延迟发生冲突的访问请求。</li>\n</ul>\n</li>\n<li>同时启动：如果m个bank的总位数加起来刚好等于数据总线的位数，则m个同时存&#x2F;取</li>\n</ul>\n<h2 id=\"主存储器与CPU的连接\"><a href=\"#主存储器与CPU的连接\" class=\"headerlink\" title=\"主存储器与CPU的连接\"></a>主存储器与CPU的连接</h2><h3 id=\"连接原理\"><a href=\"#连接原理\" class=\"headerlink\" title=\"连接原理\"></a>连接原理</h3><p>通过总线连接（控制、地址、数据）<br>传输速率 &#x3D; 总线宽度&#x2F;传输时间<br>地址总线的位数决定了可寻址的最大内存空间<br>控制总线指出总线周期的类型和本次输入输出完成的时刻<br>将多个芯片集成在内存条上，由多个内存条和主板上的ROM芯片组成计算机所需的主存空间，通过总线与CPU连接</p>\n<h3 id=\"主存容量的扩展\"><a href=\"#主存容量的扩展\" class=\"headerlink\" title=\"主存容量的扩展\"></a>主存容量的扩展</h3><p>数据总线宽度&gt;存储字长 —— 位扩展<br>地址总线宽度&gt;存储字数量所需的宽度<br><img data-src=\"/f10.jpg\"></p>\n<ol>\n<li><p>位扩展法：增加存储字长<br>由于数据总线宽度大于存储字长，存在浪费情况，必须进行位扩展使数据位数与数据总线位数相等<br>如图：<br><img data-src=\"/f11.jpg\"></p>\n</li>\n<li><p>字扩展法<br>地址总线存在浪费情况，对存储字的数量进行扩展<br>用多出来的地址线提供CS片选信号，决定输出的是哪个芯片的数据</p>\n</li>\n</ol>\n<ul>\n<li>线选法：n条多余的地址线，对应n个选片信号，地址空间不连续造成地址空间浪费（只能有一个1有效），电路简单<br><img data-src=\"/f13.jpg\"></li>\n<li>译码器选法：n条多余的线对应$2^n$个选片信号，地址空间可以连续<br><img data-src=\"/f12.jpg\"></li>\n</ul>\n<ol start=\"3\">\n<li>字、位同时扩展<br>既增加存储字的数量，又增加存储字长<br><img data-src=\"/f14.jpg\"></li>\n</ol>\n<h3 id=\"存储芯片的地址分配和片选\"><a href=\"#存储芯片的地址分配和片选\" class=\"headerlink\" title=\"存储芯片的地址分配和片选\"></a>存储芯片的地址分配和片选</h3><p>见上方线选法译码器选法</p>\n<h3 id=\"存储器与CPU的连接\"><a href=\"#存储器与CPU的连接\" class=\"headerlink\" title=\"存储器与CPU的连接\"></a>存储器与CPU的连接</h3><p>……<br>片选信号还与CPU的方寸控制信号$\\overline{MREQ}$有关（低电平有效），若CPU访问IO则此信号为高电平<br>MAR位数要看主存地址空间大小，而不能看实际上用了多少位</p>\n<h2 id=\"外部存储器\"><a href=\"#外部存储器\" class=\"headerlink\" title=\"外部存储器\"></a>外部存储器</h2><p>磁盘存储器是以磁盘为存储介质的存储器，优点：容量大，价格低；记录介质可重复使用；可以长期保存；非破坏性读出。缺点：存取速度慢；机械结构复杂；对工作环境要求高</p>\n<h3 id=\"磁盘存储器\"><a href=\"#磁盘存储器\" class=\"headerlink\" title=\"磁盘存储器\"></a>磁盘存储器</h3><ol>\n<li>磁盘存储器</li>\n</ol>\n<ul>\n<li>组成：磁盘驱动器，磁盘控制器，盘片<br><img data-src=\"/f15.jpg\"></li>\n<li>存储区域：&#x3D;&#x3D;扇区（也称块）是磁盘读写的最小单位&#x3D;&#x3D;，按块存取<ul>\n<li>磁头数(Heads)：一个记录面对应一个磁头</li>\n<li>柱面数(Cylinders)：表示每面盘片上的磁道数，不同记录面的相同位置的磁道构成一个柱面</li>\n<li>扇区数(Sectors)：每条磁道上有多少扇区</li>\n</ul>\n</li>\n<li>Disk Cache<ul>\n<li>在内存上的一片区域，用来缓冲被送到磁盘上的数据。优点：写磁盘时按簇进行，可以避免频繁地用小块数据写；中间结果数据写回之前可以被快速再次使用</li>\n</ul>\n</li>\n<li>磁记录原理<ul>\n<li>原理：当磁头和磁性记录介质有相对运动时，通过电磁转换完成读&#x2F;写操作。</li>\n<li>编码方法：按某种方案（规律），把一连串的二进制信息变换成存储介质磁层中一个磁化翻转状态的序列，并使读&#x2F;写控制电路容易、可靠地实现转换。</li>\n<li>磁记录方式：通常采用调频制（FM）和改进型调频制（MFM）的记录方式。</li>\n</ul>\n</li>\n<li>性能指标<ul>\n<li><p>磁盘的容量：一个磁盘所能存储的字节总数称为磁盘容量。磁盘容量有非格式化容量和格式化容量之分。<br>非格式化容量是指磁记录表面可以利用的磁化单元总数，非格式化容量 &#x3D; 记录面数 * 柱面数 * 每条磁道的磁化单元数<br>格式化容量是指按照某种特定的记录格式所能存储信息的总量，格式化容量 &#x3D; 记录面数 * 柱面数 * 每道扇区数 * 每个扇区的容量<br>&#x3D;&#x3D;格式化容量 &lt; 非格式化容量&#x3D;&#x3D;</p>\n</li>\n<li><p>记录密度:记录密度是指盘片单位面积上记录的二进制的信息量，通常以<code>道密度</code>、<code>位密度</code>和<code>面密度</code>表示。道密度是&#x3D;&#x3D;沿磁盘半径方向单位长度上的磁道数&#x3D;&#x3D;；位密度是&#x3D;&#x3D;磁道单位长度上能记录的二进制代码位数&#x3D;&#x3D;；面密度是位密度和道密度的乘积。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>&#x3D;&#x3D;磁盘所有磁道记录的信息量一定是相等的，并不是圆越大信息越多，故每个磁道的位密度都不同，越靠近圆心位密度越大&#x3D;&#x3D;</p>\n<ul>\n<li><p>平均存取时间：<br>&#x3D;&#x3D;平均存取时间 &#x3D; 寻道时间（磁头移动到目的磁道）+ 旋转延迟时间（磁头定位到所在扇区）+ 传输时间（传输数据所花费的时间）&#x3D;&#x3D;<br>&#x3D;&#x3D;寻道时间通常取从最外道到最内道时间的一半，旋转延迟时间通常取旋转半周的时间&#x3D;&#x3D;</p>\n</li>\n<li><p>数据传输率：磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输率<br>假设磁盘转速为r（转&#x2F;秒），每条磁道容量为N个字节，则数据传输率为$D_r&#x3D;rN$</p>\n</li>\n<li><p>磁盘地址<br><img data-src=\"/f16.jpg\"></p>\n</li>\n<li><p>磁盘的工作原理<br>硬盘的主要操作是寻址、读盘、写盘。每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字。<br>硬盘属于机械式部件，其读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据。</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>RAID<br>将多个独立的物理磁盘组成一个独立的逻辑磁盘，数据分割交叉存储，并行访问。</li>\n</ol>\n<ul>\n<li>RAID0：无冗余和无校验的磁盘阵列。</li>\n<li>RAID1：镜像磁盘阵列。每份数据存两遍，成本太高</li>\n<li>RAID2：采用纠错的海明码的磁盘阵列。<br>逻辑上连续的几个bit物理上分散存储在各个盘中4bit信息位+3bit海明校验位——可纠正1bit错误<br>每个码字有 <code>m</code> 个信息位和 <code>r</code> 个冗余位，$ (m+r+1)≤2^r$<br>参考xyx学长的计网笔记：<br><img data-src=\"/f17.jpg\"></li>\n<li>RAID3：位交叉奇偶校验的磁盘阵列。前三个盘的奇偶校验位写在第四个盘上</li>\n<li>RAID4：块交叉奇偶校验的磁盘阵列。</li>\n<li>RAID5：无独立校验的奇偶校验磁盘阵列。在所有磁盘之间分条，并且每个数据块的奇偶校验块 (P) 写入到同一条带上<br>RAID1-RAID5数据不会损坏</li>\n</ul>\n<h3 id=\"固态硬盘-SSD\"><a href=\"#固态硬盘-SSD\" class=\"headerlink\" title=\"固态硬盘(SSD)\"></a>固态硬盘(SSD)</h3><ol>\n<li>特性<br>属于Flash memory, EEPROM<br>组成：闪存翻译层，存储介质<br><img data-src=\"/f18.jpg\"><br>&#x3D;&#x3D;数据以页为单位读写，以块为单位擦除&#x3D;&#x3D;只有整个块被擦除之后才能写这一页，若视图修改包含已有数据的页$P_i$，则这个快中所有含有有用数据的页必须被复制到新的空白的块中，才能对$P_i$进行写操作<br>SSD的优点：&#x3D;&#x3D;随机写很慢，随机读比机械磁盘块&#x3D;&#x3D;，没噪声，能耗低，抗震性好，安全性高</li>\n<li>Wear Leveling 磨损均衡<br>重复擦写块就会磨损坏，一般是几百次到几千次<br>(1) 动态磨损均衡：&#x3D;&#x3D;写入时&#x3D;&#x3D;优先选择擦除次数少的新闪存块，只在写入时触发，仅考虑可用空间（对于冷数据不包括在空间池中，减少了可以用的block数量）<br>(2) 静态磨损均衡：就算没有写入，SSD也会监测并自动进行数据分配，让老的闪存快以读为主，让新的块腾出空间，以写为主：将数据从写入&#x2F;擦除次数较低的block移动到其他block中，这样可以将低擦写次数的block释放出来，添加到可用可用空间池中，以便后续使用。仅覆盖单个闪存芯片单元</li>\n</ol>\n<h2 id=\"Cache\"><a href=\"#Cache\" class=\"headerlink\" title=\"Cache\"></a>Cache</h2><p>解决CPU和主存速度不一致问题，由SRAM组成，通常集成在CPU中</p>\n<h3 id=\"程序访问的局部性原理\"><a href=\"#程序访问的局部性原理\" class=\"headerlink\" title=\"程序访问的局部性原理\"></a>程序访问的局部性原理</h3><ul>\n<li>时间局部性：比如循环、数组（每次循环访问一次数组能体现时间局部性）</li>\n<li>空间局部性：最近的未来用到的信息很可能和正在使用的信息在存储空间上是临近的（顺序访问数组能体现空间局部性）<br>Cache利用局部性原理，将最近或频繁访问的数据复制到更快但容量较小的存储中，以便提高访问速度和系统性能。</li>\n</ul>\n<p>:::primary<br><strong>hit&#x2F;miss计算</strong><br>设$t_c$为访问一次Cache所需时间，$t_m$为访问一次内存所需时间，则Cache和主存同时被访问总时间为$t &#x3D; Ht_c + (1 - H)t_m$<br>若先访问Cache再访问主存则时间为：$t &#x3D; t_c + (1 - H)t_m$<br>:::</p>\n<h3 id=\"Cache工作原理\"><a href=\"#Cache工作原理\" class=\"headerlink\" title=\"Cache工作原理\"></a>Cache工作原理</h3><p>主存和Cache之间以&#x3D;&#x3D;块(Block)&#x3D;&#x3D;为单位进行数据交换</p>\n<h3 id=\"映射方式\"><a href=\"#映射方式\" class=\"headerlink\" title=\"映射方式\"></a>映射方式</h3><ol>\n<li><p>直接映射 Directed mapped<br><img data-src=\"/f20.jpg\"><br><img data-src=\"/f27.jpg\"><br>cache 行号 &#x3D; 主存块号 mod cache行数<br>物理地址结构：<br>| tag | index（行号） | byte offset |<br><img data-src=\"/f19.jpg\"><br>$$ index的位数 &#x3D; log_2(cache的block数) $$<br>$$ byte\\ offset的位数 &#x3D; log_2(cache的block的字节数) $$<br>$$ tag的位数 &#x3D; 32 - index的位数 - byte\\ offset的位数 $$<br>在32位系统中，一个word是4B；64位系统中，一个word是8B<br>Cache的一行构成：<br>| valid bit | dirty bit | tag | data |<br>+++primary example<br><img data-src=\"/f21.jpg\"><br><img data-src=\"/f22.jpg\"><br><img data-src=\"/f23.jpg\"><br><img data-src=\"/f24.jpg\"><br><img data-src=\"/f25.jpg\"><br><img data-src=\"/f26.jpg\"><br>+++</p>\n</li>\n<li><p>全相连 Full Associative<br>block can go anywhere in cache<br>主存地址：<br>| tag | byte offset |<br>好处是能降低冲突率，每次需要和所有block比较是否hit开销大，不适合大容量Cache</p>\n</li>\n<li><p>组相连 Set Associative<br><img data-src=\"/f28.jpg\"><br>物理地址构成：<br>| tag | set index | 块内偏移 |<br>set index的位数表示有多少组，<br>$$ setNum &#x3D;  \\frac{Cache大小}{blockSize * 路数} $$</p>\n</li>\n</ol>\n<p>+++primary<br>一个四路相联cache，CPU字长为4字节，内存和cache都是以字节编址，cache和内存交换单位为块，每个块大小为512字节，cache能够容纳1024个块。如果物理内存为32位地址:<br>set数 &#x3D; 1024&#x2F;4 &#x3D; 256<br>index位数 &#x3D; log2(256) &#x3D; 8<br>blockOffset位数 &#x3D; log2(512) &#x3D; 9<br>tag位数 &#x3D; 32 - 8 - 9 &#x3D; 17</p>\n<ul>\n<li>物理地址构成：| tag 17位 | set index 8位 | block offset 9 位 |</li>\n<li>计算内存地址FAB12389（16进制）在cache中可能的位置块号:<br>1111 1010 1011 0001 0010 0011 1000 1001<br>set index是10010001也就是145，所以可能的block号是145*4 &#x3D; 580, 581, 582, 583<br>+++<br><img data-src=\"/f29.jpg\"><br>&#x3D;&#x3D;n路组相连需要n个比较器，位数&#x3D;tag位数&#x3D;&#x3D;</li>\n</ul>\n<h3 id=\"替换算法\"><a href=\"#替换算法\" class=\"headerlink\" title=\"替换算法\"></a>替换算法</h3><ol>\n<li><p>Random Replacement<br>随机找一块替换，实现简单，命中率低</p>\n</li>\n<li><p>FIFO<br>选择最早进入的Cache行的进行替换</p>\n</li>\n<li><p>LRU<br>选择近期用得最少的Cache行进行替换，对每个Cache行维护一个计数器表示访问的次数，每次替换掉数值最小的。<br>2-way Cache要用1 bit来记录，4-way Cache要用2 bit来记录<br>+++primary<br>4-way Cache，有五个块映射到Cache同一组，访问顺序是{1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5}<br><img data-src=\"/f30.jpg\"><br>+++</p>\n</li>\n</ol>\n<h3 id=\"Cache一致性问题\"><a href=\"#Cache一致性问题\" class=\"headerlink\" title=\"Cache一致性问题\"></a>Cache一致性问题</h3><p>当write hit时：</p>\n<ol>\n<li>Write through 直写&#x2F;全写法<br>Cache hit的时候，CPU不仅写入Cache，而且写入主存<br>为了减少写入主存的时间小号，增加一个write buffer，CPU同时写入Cache和write buffer，write buffer采用FIFO，当write buffer满时，将write buffer中的数据写入主存</li>\n<li>Write back 写回法<br>write hit时，只把数据写入Cache，只有此块被replace的时候才写入主存。减少了方寸次数，所以给cache行设置一个dirty bit，CPU写数据时将dirty bit置为1表示此块被修改过，repalce时需要写入主存</li>\n</ol>\n<p>write miss时：</p>\n<ol>\n<li>Write Allocate 写分配法<br>如果发生write miss，会从内存中加载对应的数据块到 cache 中，然后进行写操作。和 write-back搭配使用，把后续对该块的修改都缓存在 cache 中</li>\n<li>Not-Write-Allocate 非写分配法<br>只更新主存不把主存写入Cache，适用于 write-through，因为即使写入 cache，也会马上写回内存，没必要占用 cache 空间。</li>\n</ol>\n<p>&#x3D;&#x3D;write through通常和not-write-allocate一起用，write back 通常和write allocate一起用&#x3D;&#x3D;</p>\n<h4 id=\"使用分离的指令Cache和数据Cache\"><a href=\"#使用分离的指令Cache和数据Cache\" class=\"headerlink\" title=\"使用分离的指令Cache和数据Cache\"></a>使用分离的指令Cache和数据Cache</h4><p>+++primary<br><img data-src=\"/f31.jpg\"><br><img data-src=\"/f32.jpg\"><br>+++</p>\n<h2 id=\"虚拟存储器\"><a href=\"#虚拟存储器\" class=\"headerlink\" title=\"虚拟存储器\"></a>虚拟存储器</h2><h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>主存和辅存共同构成了虚拟存储器，对于应用程序员而言，虚拟存储器是透明的。（对OS开系统程序员不透明，他们必须管理TLB）<br>虚拟存储器具有主存的速度和辅存的容量</p>\n<ul>\n<li>允许多个程序之间高效、安全地共享内存</li>\n<li>允许单个程序使用超过内存容量的内存</li>\n</ul>\n<p>+++primary<br>实地址&#x3D;主存页号+页内字地址<br>虚地址&#x3D;虚存页号+页内字地址<br>辅存地址&#x3D;磁盘号+盘面号+磁道号+扇区号<br>+++</p>\n<p>虚拟存储器缺页访问辅存的代价很大，当程序访问某个virtual page时，如果该页当前不在主存中，就会发生page fault，操作系统需要从辅存加载该页到主存，访问很慢所以访问代价大。因此采用<code>full associative</code>允许virtual page可以加载到主存的任何一个空闲物理页框中，提高命中率。<br>写操作中处理一致性问题时采用 <code>write back</code>。主存中的页面状态维护一个dirty标志位。当操作系统需要将该页替换出主存时，会检查该页的脏页标志：如果dirty，说明主存页面数据修改过，必须写回辅存；如果dirty为0，说明主存数据和辅存一致，直接丢弃主存页面，无需写回</p>\n<h3 id=\"页式虚拟存储器\"><a href=\"#页式虚拟存储器\" class=\"headerlink\" title=\"页式虚拟存储器\"></a>页式虚拟存储器</h3><ul>\n<li>基本单位：页<br>主存和虚拟地址空间被划分为相同大小的页，主存中的成为物理页（实页、页框、frame），虚拟地址空间中的页称为虚拟页（虚页）<br>页表(page table)记录了程序的虚页调入贮存时被安排在主存中的位置<br>一般的page大小从4KiB ~ 64KiB不等</li>\n</ul>\n<ol>\n<li>页表(page table)<br>页表放在主存中。<br><img data-src=\"/f33.jpg\"><br>有效位（Valid Bit）：用于指示一个页面是否已经被加载到主存中。如果有效位被设置为1，这意味着对应的页面已经在物理内存中，可以立即被访问。如果有效位为0，则表示该页面当前不在内存中，可能需要从磁盘或其他存储设备中调入。当一个程序尝试访问一个页面时，操作系统会检查页表中的有效位，如果发现页面不在内存中，就会触发一个page fault，然后将页面从磁盘加载到内存中。<br>引用位（Reference Bit）：引用位主要用于页面置换算法中，它记录了页面最近是否被访问过。每当一个页面被访问时，操作系统会将该页面的引用位置为1。随着时间的推移，如果一个页面长时间没有被访问，它的引用位可能会被清零。当操作系统需要选择一个页面进行置换时，它可能会优先选择那些引用位为0的页面。</li>\n</ol>\n<p>转换过程：当一个程序尝试访问内存时，它会生成一个虚拟地址。虚拟地址包含两部分信息：页号（Page Number）和页内偏移（Offset）。用VPN作为索引查询page table，检查valid bit是否为1，从页表条目中获取PPN，PPN和page offset组合成物理地址。</p>\n<blockquote>\n<p>页式虚拟存储器的优点：页面长度固定，页表简单，调入方便<br>缺点：产生内碎片</p>\n</blockquote>\n<ol start=\"2\">\n<li><p>地址转换<br><img data-src=\"/f34.png\"><br>每个进程都有一个页表基址寄存器，存放该进程的页表首地址。然后通过VPN作为索引在页表中查找对应的页表项。物理地址&#x3D;物理页号 + 页内地址。</p>\n</li>\n<li><p>TLB（快表）<br>为了减少访问主存的此书，TLB相当于page table的cache。<br>TLB用<code>SRAM</code>实现，不在主存中，工作原理类似于Cache，通常采用full associative或者set associative。<br><img data-src=\"/f35.jpg\"><br>通过VPN查找TLB和Cache的查找一样，如果是全相连则直接比较tag，如果是组相连则通过低位查找set，然后用高位和tag比较。</p>\n</li>\n<li><p>具有TLB和Cache的多级存储系统<br><img data-src=\"/f36.jpg\"><br>查找时，TLB和page table可以同步进行，如果在TLB中找到了，page table的查找就作废。</p>\n</li>\n</ol>\n<p><img data-src=\"/f37.jpg\"></p>\n<h3 id=\"段式虚拟存储器\"><a href=\"#段式虚拟存储器\" class=\"headerlink\" title=\"段式虚拟存储器\"></a>段式虚拟存储器</h3><p><img data-src=\"/f38.jpg\"><br>按程序的逻辑结构划分，段的长度因程序而异。虚拟地址分为段号和段内地址。虚地址和实地址的转换依靠段表。<br>段表每行记录某个段的&#x3D;&#x3D;段号、有效位、段长度、段起始地址&#x3D;&#x3D;。<br>段表本身也是段，一般驻留在主存中<br>&#x3D;&#x3D;分页对程序员是透明的，分段对程序员是不透明的&#x3D;&#x3D;</p>\n<blockquote>\n<p>段式虚拟存储器的优点：具有逻辑独立性，易于编译、管理、修改和保护，便于多道程序的共享<br>缺点：产生外碎片</p>\n</blockquote>\n<h3 id=\"段页式虚拟存储器\"><a href=\"#段页式虚拟存储器\" class=\"headerlink\" title=\"段页式虚拟存储器\"></a>段页式虚拟存储器</h3><p>把程序按逻辑结构分段，再在每段划分固定大小的页。因此段的长度必须是页长度的整数倍，段的起点必须是某一页的起点。<br>虚地址分为&#x3D;&#x3D;段号，段内页号，页内地址&#x3D;&#x3D;</p>\n<ul>\n<li>访问流程：从段表基址寄存器（STBR） 中读取段表的起始地址，用段号（s）作为索引，在段表中查找第 s 个表项，从该表项中取出该段对应的页表起始地址（即页表基址），与段内页号合成得到页表地址（页表项地址 &#x3D; PTBR + p × 页表项大小），读取第 p 个页表项得到物理页号（PPN），和页内地址合成得到物理地址</li>\n</ul>\n",
            "tags": [
                "存储系统"
            ]
        },
        {
            "id": "http://example.com/2025/07/01/computer-science/computer-organization/%E9%94%99%E9%A2%98%E9%9B%86%E5%90%88/",
            "url": "http://example.com/2025/07/01/computer-science/computer-organization/%E9%94%99%E9%A2%98%E9%9B%86%E5%90%88/",
            "title": "错题集合",
            "date_published": "2025-06-30T16:00:00.000Z",
            "content_html": "<h1 id=\"错题集合\"><a href=\"#错题集合\" class=\"headerlink\" title=\"错题集合\"></a>错题集合</h1><h2 id=\"Ch2\"><a href=\"#Ch2\" class=\"headerlink\" title=\"Ch2\"></a>Ch2</h2><ol>\n<li>某计算机字长为8位，CPU中有一个8位加法器，已知无符号数x&#x3D;69, y&#x3D;38，若在该加法器中计算x-y，则加法器的两个输入短信息和输入的低位进位信息分别为（）</li>\n</ol>\n<ul>\n<li>0100 0101, 1101 1001, 1 <blockquote>\n<p>无符号数减法，在加法器中输入x的原码，y的取反和1</p>\n</blockquote>\n</li>\n</ul>\n<ol start=\"2\">\n<li>减法指令 “sub R1, R2, R3” 的功能为 “(R1) - (R2) -&gt; R3”, 该指令执行后将生成进位&#x2F;借位标志CF和溢出标志OF，若(R1) &#x3D; FFFF FFFFH, R2 &#x3D; FFFF FFF0H, 则该减法指令执行后，CF和OF分别为：</li>\n</ol>\n<ul>\n<li>CF &#x3D; 0, OF &#x3D; 0</li>\n</ul>\n<ol start=\"3\">\n<li>已知x, y为int类型，当x &#x3D; 100, y &#x3D; 200时，执行 “x - y”指令得到的溢出标志OF和结尾标志CF分别为0，1，那么当x &#x3D; 1-, y &#x3D; -20时，执行该指令得到的OF和CF分别为：</li>\n</ol>\n<ul>\n<li>OF &#x3D; 0, CF &#x3D; 1<blockquote>\n<p>ALU生成标志位时只负责计算，不管运算对象是有符号数还是无符号数。CF&#x3D;1表示当做无符号数运算时溢出，OF&#x3D;1表示当做有符号数运算时溢出。当做有符号数，10-(-20)没问题，所以OF&#x3D;0；把它俩当做无符号数的时候，x &#x3D; 10 &#x3D; 0000 0000 0000 0000 0000 0000 0000 1010，y &#x3D; -20 &#x3D; 1111 1111 1111 1111 1111 1111 1110 1100，此时x &lt; y，所以CF&#x3D;1。</p>\n</blockquote>\n</li>\n</ul>\n<ol start=\"4\">\n<li>下列关于整数乘法运算的叙述中，错误的是：D</li>\n</ol>\n<ul>\n<li>A. 用阵列乘法器实现的乘运算可以在一个时钟周期内完成 –正确，因为是组合逻辑理论上可以在一个clc里完成</li>\n<li>B. 用ALU和移位器实现的乘运算无法在一个时钟周期内完成</li>\n<li>C. 变量与常数的乘运算可编译优化为若干移位及家&#x2F;减运算指令</li>\n<li>D. 两个变量的乘运算无法编译转换为移位及加法等指令的循环实现</li>\n</ul>\n<h2 id=\"Ch4\"><a href=\"#Ch4\" class=\"headerlink\" title=\"Ch4\"></a>Ch4</h2><ol>\n<li>简化地址结构的方式是尽量采用： 隐含寻址</li>\n</ol>\n",
            "tags": [
                "错题"
            ]
        },
        {
            "id": "http://example.com/2025/06/18/computer-science/compile-principles/ch11/",
            "url": "http://example.com/2025/06/18/computer-science/compile-principles/ch11/",
            "title": "Register Allocation",
            "date_published": "2025-06-17T16:00:00.000Z",
            "content_html": "<h1 id=\"Register-Allocation\"><a href=\"#Register-Allocation\" class=\"headerlink\" title=\"Register Allocation\"></a>Register Allocation</h1><p>目标：</p>\n<ul>\n<li>Map temporaries to registers</li>\n<li>Preserve program semantics</li>\n<li>Optimize performance</li>\n</ul>\n<h2 id=\"图着色算法\"><a href=\"#图着色算法\" class=\"headerlink\" title=\"图着色算法\"></a>图着色算法</h2><p>冲突图是一个无向图，冲突图中，每个节点是一个变量（寄存器分配的候选对象）。<br>如果两个变量在同一时刻是活跃的（live），它们就有冲突边（interference edge），表示它们不能被分配到同一个寄存器<br>冲突信息可以用矩阵或者图来表示</p>\n<h3 id=\"冲突图构建\"><a href=\"#冲突图构建\" class=\"headerlink\" title=\"冲突图构建\"></a>冲突图构建</h3><p>我们从一个中间代码的指令出发，根据live-out（就是out集合）添加冲突边：</p>\n<ol>\n<li>非 move 指令（不是a :&#x3D; b这种）<br>比如a :&#x3D; b1 + b2<br>对于每个bn和a之间都添加冲突边<br>比如下面这个例子：<br><img data-src=\"/f1.jpg\"><br>可以看到有ab ac同时live了，所以为a和b，a和c添加冲突边</li>\n<li>move指令<br>对于move指令，不添加冲突边：<br>比如对于第 2 条指令 d ← a，out[2] &#x3D; {a, e}，那么只对d和e添加冲突边，对d和a不添加<br>但如果move之后又对d重新赋值了，那么还是要添加上d和a之间的冲突边</li>\n</ol>\n<h3 id=\"冲突图着色\"><a href=\"#冲突图着色\" class=\"headerlink\" title=\"冲突图着色\"></a>冲突图着色</h3><p>Vertex Coloring: 给图中的顶点着色，使得图中没有边连接相同颜色的顶点<br>K-Coloring: 颜色数小于K</p>\n<h4 id=\"Kempe-简化\"><a href=\"#Kempe-简化\" class=\"headerlink\" title=\"Kempe 简化\"></a>Kempe 简化</h4><p>如果图中有一个节点 n 的度数 &lt; K（也就是它的冲突数少于寄存器数），那我们可以“临时删掉”这个节点，并递归给剩下的图上色。之后再把这个节点加回来，它一定可以找到一个合法颜色。</p>\n<p>如果图中所有节点的度数都 ≥ K，那就可能要进入溢出（spill）处理<br>算法步骤：</p>\n<ol>\n<li>build: 画冲突图</li>\n<li>simplify the nodes with insignificant degree: 选取degree &lt; k的节点，压栈</li>\n<li>select (or color) while rebuilding the graph: 出栈，分配颜色<br>A vertex such that its degree &lt; k is always k-colorable<br>Remove such vertices and push them to a stack until the graph becomes empty<br>移除顶点的同时移除相关边</li>\n</ol>\n<h4 id=\"Coalescing\"><a href=\"#Coalescing\" class=\"headerlink\" title=\"Coalescing\"></a>Coalescing</h4><p>遵循两种策略：</p>\n<ul>\n<li><strong>Briggs Criteria</strong>: 如果将节点 <code>a</code> 和 <code>b</code> 合并后得到的新节点 <code>ab</code>，其相邻节点中degree &gt;&#x3D; K 的节点（significant-degree neighbors）的数量 小于 K，则可以合并</li>\n<li><strong>George Criteria</strong>: 如果对节点 <code>a</code> 和 <code>b</code>，对于 <code>a</code> 的每一个邻居 <code>t</code>， 满足二者其中之一，就能合并：<ul>\n<li><code>t</code> 本来就和 <code>b</code> 有冲突</li>\n<li><code>t</code>的degree &lt; K</li>\n</ul>\n</li>\n</ul>\n<p>整体流程：<br><img data-src=\"/f2.jpg\"></p>\n<ul>\n<li>为什么要simplify non-move-related node: 保留move-related的后续可以合并</li>\n<li>freeze: 当我们遇到两个变量 a ← b 有 move 指令，但现在还不能安全合并，我们又不想立刻 spill，于是我们“冻结”这条 move 指令：不再试图合并 a 和 b，而是让其中一个变成非 move 相关（non-move-related），进入 Simplify 阶段继续处理</li>\n<li>spill规则：优先移除不被经常使用、degree大的节点<ul>\n<li>实际溢出的priority计算，对于节点a：<br>$$<br>priority(t) &#x3D; \\frac{(use + def outside loop) + loop_num * (use + def inside loop)}{D}<br>$$</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "Register Allocation"
            ]
        },
        {
            "id": "http://example.com/2025/06/18/computer-science/compile-principles/ch10/",
            "url": "http://example.com/2025/06/18/computer-science/compile-principles/ch10/",
            "title": "Liveness Analysis",
            "date_published": "2025-06-17T16:00:00.000Z",
            "content_html": "<h1 id=\"Liveness-Analysis-活跃变量分析\"><a href=\"#Liveness-Analysis-活跃变量分析\" class=\"headerlink\" title=\"Liveness Analysis 活跃变量分析\"></a>Liveness Analysis 活跃变量分析</h1><p>判断在程序执行的某个点上，一个变量的值是否可能在未来被使用，是寄存器分配、死代码消除的基础</p>\n<h2 id=\"Compiler-Optimizations\"><a href=\"#Compiler-Optimizations\" class=\"headerlink\" title=\"Compiler Optimizations\"></a>Compiler Optimizations</h2><ul>\n<li>Local: 基于basic blocks</li>\n<li>Intraprocedural (or “global’): 基本块的控制流转移</li>\n<li>Interprocedural (or “whole-program”): Operate on &gt; 1 procedure, up to whole program; Sometimes, at link time (LTO, link time optimization)</li>\n</ul>\n<p>两步：</p>\n<ul>\n<li>Analyze program to gather “facts”</li>\n<li>Apply transformation (e.g., optimizations)</li>\n</ul>\n<h2 id=\"Dataflow-Analysis\"><a href=\"#Dataflow-Analysis\" class=\"headerlink\" title=\"Dataflow Analysis\"></a>Dataflow Analysis</h2><p>Control Flow Graph: A directed graph 数据流图<br>– Nodes represent statements<br>– Edges represent control flow</p>\n<p>CFG的简化：基本块<br><img data-src=\"/f1.jpg\"></p>\n<h3 id=\"变量的活跃性：\"><a href=\"#变量的活跃性：\" class=\"headerlink\" title=\"变量的活跃性：\"></a>变量的活跃性：</h3><p>变量x在语句s处（执行s之前）处于活动状态，当且仅当满足以下三个条件：</p>\n<ol>\n<li>存在一个使用x的语句s’；</li>\n<li>存在从s到s’的路径；</li>\n<li>这条路径上没有对x进行任何赋值操作</li>\n</ol>\n<p>通过分析liveness，我们可以实现：</p>\n<ol>\n<li>Register Allocation</li>\n<li>Code Optimizations：Remove unused assignments</li>\n<li>IR Construction： Optimize the construction of SSA</li>\n<li>Security&#x2F;Reliability: Detect the use of uninitialized variables</li>\n</ol>\n<h2 id=\"Dataflow-Equations-for-Liveness-构建数据流方程\"><a href=\"#Dataflow-Equations-for-Liveness-构建数据流方程\" class=\"headerlink\" title=\"Dataflow Equations for Liveness 构建数据流方程\"></a>Dataflow Equations for Liveness 构建数据流方程</h2><p>A CFG node has</p>\n<ul>\n<li>out-edges: lead to successor nodes</li>\n<li>in-edges: come from predecessor nodes</li>\n<li>pred[n]: the predecessors of node n       前驱</li>\n<li>succ[n]: the successors of node n     后继</li>\n</ul>\n<p>几个定义：</p>\n<ul>\n<li>use[n]: 在节点n被读取或使用(x &#x3D; a + b的a和b, if(a &lt; b)的a和b, return c的c)</li>\n<li>def[n]: 在节点n被定义(x &#x3D; a + b的x)</li>\n<li>in[n]: 在节点n之前，所有活跃变量的集合</li>\n<li>out[n]: 在节点n之后，所有活跃变量的集合<br>三条活跃性规则：</li>\n</ul>\n<ol>\n<li>if $a \\in in[n]$ then for $\\all m \\in pred[n]$ we have $a \\in out[m]$</li>\n<li>if $a \\in use[n]$ then $a \\in in[n]$</li>\n<li>if $a \\in out[n]$ and $a \\notin def[n]$ then $a \\in in[n]$</li>\n</ol>\n<p>得到以下两个数据流方程：<br>$$<br>out[n] &#x3D; \\cup_{s \\in succ[n]} in[s]<br>$$<br> 一个节点在n的出口处活跃当且仅当在它后继的入口处是活跃的（活跃性的反向传播）<br>$$<br>in[n] &#x3D; use[n] \\cup (out[n] - def[n])<br>$$</p>\n<h2 id=\"求解数据流方程\"><a href=\"#求解数据流方程\" class=\"headerlink\" title=\"求解数据流方程\"></a>求解数据流方程</h2><p>有了上面的两个数据流方程，就可以求解数据流方程了<br>算法：</p>\n<figure class=\"highlight plaintext\"><figcaption><span>pseudo</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for each n</span><br><span class=\"line\">    in[n] ←&#123;&#125;; out[n] ←&#123;&#125;</span><br><span class=\"line\">repeat</span><br><span class=\"line\">    for each n</span><br><span class=\"line\">        in′[n] ← in[n]; out′[n] ← out[n]</span><br><span class=\"line\">        in[n] ← use[n] ∪ (out[n] − def[n])</span><br><span class=\"line\">        out[n] ← ⋃( ∈()**[+] in[s]</span><br><span class=\"line\">until in′[n] = in[n] and out′[n] = out[n] for all n</span><br></pre></td></tr></table></figure>\n<ol>\n<li>将所有节点的 <code>in</code> 和 <code>out</code> 集合初始化为空集。</li>\n<li>写出<code>use[n]</code>和<code>def[n]</code></li>\n<li>用数据流方程更新<code>in</code>和<code>out</code>集合</li>\n<li>直到<code>in</code>和<code>out</code>集合不再改变为止<br>例：<br><img data-src=\"/f2.jpg\"><br>对于这个CFG<br>每一次迭代如图：<br><img data-src=\"/f3.jpg\"></li>\n</ol>\n<h2 id=\"Improvements\"><a href=\"#Improvements\" class=\"headerlink\" title=\"Improvements\"></a>Improvements</h2><h3 id=\"Use-Basic-Block\"><a href=\"#Use-Basic-Block\" class=\"headerlink\" title=\"Use Basic Block\"></a>Use Basic Block</h3><p>后面有点懒得看，先放着</p>\n<h2 id=\"集合的表示方法\"><a href=\"#集合的表示方法\" class=\"headerlink\" title=\"集合的表示方法\"></a>集合的表示方法</h2><p>对于in, out, use, def集合的表示和操作对性能有很大影响</p>\n<h3 id=\"Bit-Arrays\"><a href=\"#Bit-Arrays\" class=\"headerlink\" title=\"Bit Arrays\"></a>Bit Arrays</h3><p>有点像bit map，适用于稠密集合（1比较多的，如果0太多就浪费了）</p>\n<h3 id=\"Sorted-Lists\"><a href=\"#Sorted-Lists\" class=\"headerlink\" title=\"Sorted Lists\"></a>Sorted Lists</h3><p>适合稀疏集合（用一个链表存集合中的变量, Sorted by variable name&#x2F;ID）</p>\n",
            "tags": [
                "Liveness Analysis"
            ]
        },
        {
            "id": "http://example.com/2025/06/17/computer-science/compile-principles/ch9/",
            "url": "http://example.com/2025/06/17/computer-science/compile-principles/ch9/",
            "title": "指令选择",
            "date_published": "2025-06-16T16:00:00.000Z",
            "content_html": "<h1 id=\"指令选择\"><a href=\"#指令选择\" class=\"headerlink\" title=\"指令选择\"></a>指令选择</h1><p>找出实现一个给定的IR Tree的恰当机器指令序列。Mapping IR into abstract assembly code</p>\n<ul>\n<li>Abstract assembly &#x3D; assembly with infinite registers<ul>\n<li>Invent new temporaries for intermediate results</li>\n<li>Map to actual registers later<br>Tree pattern, 也叫tile<br>本质上是pattern matching, 我们使用tree covering 来实现</li>\n</ul>\n</li>\n</ul>\n<p>我们<code>Jouette</code>体系将树模式映射为指令:</p>\n<ul>\n<li>寄存器中可以存储数据或地址，每条指令可以访问任意寄存器</li>\n<li>寄存器r0的值永远是0</li>\n<li>每条指令的latency都是一周期（除了MOVEM的周期是m）</li>\n<li>每个周期执行一条指令</li>\n</ul>\n<p><img data-src=\"/f2.jpg\"><br><img data-src=\"/f1.jpg\"><br>将IR与后端的机器指令都转换为树结构。这样就把指令选择问题转换为机器指令树覆盖全IR Tree的问题。<br>一棵树可以有多种tiling方式</p>\n<h2 id=\"Optimal-Tiling-Optimum-Tiling\"><a href=\"#Optimal-Tiling-Optimum-Tiling\" class=\"headerlink\" title=\"Optimal Tiling &amp; Optimum Tiling\"></a>Optimal Tiling &amp; Optimum Tiling</h2><ul>\n<li>Optimum Tiling：使得tiling数最少，是&#x3D;&#x3D;全局最优&#x3D;&#x3D;</li>\n<li>Optimal Tiling：No two adjacent tiles can be combined into a single tile of lower cost，是&#x3D;&#x3D;局部最优&#x3D;&#x3D;<br>一个optimum tiling必定是optimal tiling<br><img data-src=\"/f3.jpg\"></li>\n</ul>\n<h2 id=\"Algorithms-for-Instruction-Selection\"><a href=\"#Algorithms-for-Instruction-Selection\" class=\"headerlink\" title=\"Algorithms for Instruction Selection\"></a>Algorithms for Instruction Selection</h2><h3 id=\"Maximal-Munch-Find-an-optimal-tiling\"><a href=\"#Maximal-Munch-Find-an-optimal-tiling\" class=\"headerlink\" title=\"Maximal Munch: Find an optimal tiling\"></a>Maximal Munch: Find an optimal tiling</h3><p>最大匹配：贪心算法、自顶向下<br>方法：从IR树的根节点开始，用&#x3D;&#x3D;最大的&#x3D;&#x3D;tile覆盖当前节点（包含最多节点的），然后在子树中重复此过程</p>\n<h3 id=\"DP\"><a href=\"#DP\" class=\"headerlink\" title=\"DP\"></a>DP</h3><p>动态规划：自底向上<br>方法：</p>\n<ol>\n<li>递归计算每个子树的最优平铺成本</li>\n<li>对于每个节点，考虑所有可能的匹配平铺</li>\n<li>对于每个匹配平铺，计算其成本如下：cost &#x3D; tile_cost + sum（costs_of_children）</li>\n<li>选择成本最低的平铺</li>\n</ol>\n<ul>\n<li>对于$CONST i$，它的代价为1( ADD r1, r0, i)</li>\n<li>对于这棵树，有三种匹配方法<br><img data-src=\"/f4.jpg\"><br><img data-src=\"/f5.jpg\"><br>因为2&lt;3，所以我们从cost&#x3D;2的两个任选一个<br>接下来对于MEM，用的都是LOAD，代价都是1，2&lt;3所以选cost&#x3D;2的</li>\n</ul>\n<figure class=\"highlight c\"><figcaption><span>指令发射</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function <span class=\"title function_\">Emission</span><span class=\"params\">(node n)</span>:</span><br><span class=\"line\">    For each leaf l_i of the tile selected at node n:</span><br><span class=\"line\">        <span class=\"title function_\">Emission</span><span class=\"params\">(l_i)</span> </span><br><span class=\"line\">    Emit the instruction matched at node n</span><br></pre></td></tr></table></figure>\n<h3 id=\"最大匹配-vs-动态规划\"><a href=\"#最大匹配-vs-动态规划\" class=\"headerlink\" title=\"最大匹配 vs 动态规划\"></a>最大匹配 vs 动态规划</h3><ul>\n<li><strong>T</strong> - tile的总种类数  </li>\n<li><strong>K</strong> - 一个matching tile平均覆盖的节点数  </li>\n<li><strong>K’</strong> - 需要检查的最大tile尺寸（即最大的瓦片包含的节点数）  </li>\n<li><strong>T’</strong> - 每个树节点平均能匹配上的tile数量  </li>\n<li><strong>N</strong> - 输入的中间表示IR Tree中的总节点数</li>\n</ul>\n<p>两种算法的运行时间复杂度：</p>\n<ul>\n<li><p><strong>最大匹配（Maximal Munch）</strong> - 其时间复杂度与<br>$$<br>\\frac{(K’ + T’) * K}{K} * N &#x3D; (K’ + T’) * N<br>$$<br>成正比</p>\n</li>\n<li><p><strong>动态规划（Dynamic Programming）</strong> - 其时间复杂度与<br>$$<br>(K’ + T’) * N<br>$$<br>成正比</p>\n</li>\n</ul>\n<h2 id=\"Tree-Grammar-树文法\"><a href=\"#Tree-Grammar-树文法\" class=\"headerlink\" title=\"Tree Grammar 树文法\"></a>Tree Grammar 树文法</h2><p>问题：对于具有复杂指令集和多种寄存器类型及寻址模式的机器，难以使用简单的tree pattern和tiling算法。<br>用一种文法来描述tiles，代替手写过程式匹配代码，支持自动化的指令选择，增强了可移植性<br>图没看懂，后面再回来研究</p>\n",
            "tags": [
                "指令选择"
            ]
        },
        {
            "id": "http://example.com/2025/06/17/computer-science/compile-principles/ch8/",
            "url": "http://example.com/2025/06/17/computer-science/compile-principles/ch8/",
            "title": "Basic Blocks & Traces",
            "date_published": "2025-06-16T16:00:00.000Z",
            "content_html": "<h1 id=\"Basic-Blocks-and-Traces\"><a href=\"#Basic-Blocks-and-Traces\" class=\"headerlink\" title=\"Basic Blocks and Traces\"></a>Basic Blocks and Traces</h1><h2 id=\"Canonical-Form\"><a href=\"#Canonical-Form\" class=\"headerlink\" title=\"Canonical Form\"></a>Canonical Form</h2><p>IR存在一些与机器语言不能完全对应的情况，和与编译优化分析相冲突的情况。</p>\n<ul>\n<li>CJUMP能够转移到t或者f，但是真正的机器语言在条件为假的时候直接下降至下一条指令（条件为真才跳转）</li>\n<li>在表达式中使用ESEQ不太方便，会使子树不同的计算顺序产生不同的计算结果</li>\n<li>CALL调用CALL作为参数的时候会有寄存器冲突、语句副作用（修改全局变量、改变堆内存, etc.）等问题</li>\n</ul>\n<p>三种方法：</p>\n<ol>\n<li>Linearize: Transform trees into a list of canonical<br>trees without SEQ or ESEQ nodes</li>\n<li>Basic blocks: Group statements into sequences with<br>no internal jumps&#x2F;labels</li>\n<li>Trace schedule: Order basic blocks so every CJUMP is followed by its false label</li>\n</ol>\n<h3 id=\"线性化\"><a href=\"#线性化\" class=\"headerlink\" title=\"线性化\"></a>线性化</h3><p>&#x3D;&#x3D;规范树（Canonical Tree）定义：&#x3D;&#x3D;</p>\n<ol>\n<li>无SEQ或ESEQ</li>\n<li>每一个CALL的父亲不是EXP(…)就是MOVE(TEMP t, …)</li>\n</ol>\n<h4 id=\"消除ESEQ\"><a href=\"#消除ESEQ\" class=\"headerlink\" title=\"消除ESEQ\"></a>消除ESEQ</h4><h5 id=\"规则\"><a href=\"#规则\" class=\"headerlink\" title=\"规则\"></a>规则</h5><p>合并副作用，提升ESEQ：</p>\n<ul>\n<li>ESEQ(s1, ESEQ(s2,e)) &#x3D;&gt; ESEQ(SEQ(s1,s2),e)</li>\n<li>BINOP(op, ESEQ(s, e1), e2) ⇒ ESEQ(s, BINOP(op, e1, e2))</li>\n<li>MEM(ESEQ(s, e1)) ⇒ ESEQ(s, MEM(e1))</li>\n<li>JUMP(ESEQ(s, e1)) ⇒ SEQ(s, JUMP(e1))</li>\n<li>CJUMP(op, ESEQ(s, e1), e2, l1, l2) ⇒ SEQ(s, CJUMP(op, e1, e2, l1, l2))</li>\n</ul>\n<h5 id=\"Commutativity（重点）\"><a href=\"#Commutativity（重点）\" class=\"headerlink\" title=\"Commutativity（重点）\"></a>Commutativity（重点）</h5><p>当<code>ESEQ</code>出现在<code>BINOP</code>的右操作数，即$BINOP(op, e1, ESEQ(s, e2))$时，我们不能再像之前那样简单地把<code>s</code>提升到整个<code>BINOP</code>之前，因为<code>e1</code>的求值在<code>e2</code>之前，否则可能影响<code>e1</code>的计算结果</p>\n<p>Commutativity：交换性</p>\n<ul>\n<li>Commuting: s不影响e1的结果<ul>\n<li>rule: $BINOP(op, e1, ESEQ(s, e2)) &#x3D; ESEQ(s, BINOP(op, e1, e2))$</li>\n</ul>\n</li>\n<li>Non-commuting: s会影响e1的结果，把e1的结果显算出来放到临时变量t里，再提升s<ul>\n<li>rule: $BINOP(op, ESEQ(s, e1), e2) &#x3D; ESEQ(MOVE(TEMP t, e1), ESEQ(s, BINOP(op, TEMP t, e2)))$</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"将CALL移到顶层\"><a href=\"#将CALL移到顶层\" class=\"headerlink\" title=\"将CALL移到顶层\"></a>将CALL移到顶层</h4><p>方法：立即将每一个返回值赋给一个新的临时寄存器<br>$$<br>CALL(fun, args) ⇒ ESEQ(MOVE(TEMP t, CALL(fun, args)), TEMP t)<br>$$</p>\n<h4 id=\"消除SEQ\"><a href=\"#消除SEQ\" class=\"headerlink\" title=\"消除SEQ\"></a>消除SEQ</h4><p>$$<br>SEQ(SEQ(a, b), c) &#x3D; SEQ(a, SEQ(b, c))<br>$$<br>把SEQ变成一个线性语句表：$SEQ(s_1, SEQ(s_2, …, SEQ(s_{n-1}, s_n) …))$<br>就可以认为是由语句组成的简单列表$s_1, s_2, …, s_n$</p>\n<h3 id=\"处理CJUMP\"><a href=\"#处理CJUMP\" class=\"headerlink\" title=\"处理CJUMP\"></a>处理CJUMP</h3><p>重排CJUMP，使得每个$CJUMP(op, e_1, e_2, l_t, l_f)后面都紧跟着$LABEL(l_f)$<br>分两步：1. 取一列canonical tree由它们形成basic block 2. 对basic block进行排序形成trace</p>\n<h4 id=\"Basic-Block\"><a href=\"#Basic-Block\" class=\"headerlink\" title=\"Basic Block\"></a>Basic Block</h4><p>一个基本块是一段连续的指令序列，即:</p>\n<ul>\n<li>第一个语句是一个<code>LABEL</code></li>\n<li>最后一个语句是<code>JUMP</code>或<code>CJUMP</code></li>\n<li>没有其他的<code>LABEL</code>, <code>JUMP</code>或<code>CJUMP</code><br>划分方法：</li>\n</ul>\n<ol>\n<li>每一个<code>LABEL</code>都对应一个基本块的开始</li>\n<li>每一个<code>JUMP</code>或<code>CJUMP</code>都对应一个基本块的结束</li>\n<li>如果遇到<code>LABEL1</code> -&gt; <code>LABEL2</code>,就在<code>LABEL2</code>前面加一个<code>JUMP</code>到<code>LABEL2</code></li>\n<li>如果遇到开头没有<code>LABEL</code>的，则加一个<code>LABEL</code>（比如程序的开头）</li>\n<li>出口处理：添加一个LABEL <code>done</code>表示出口处理的开始，并把$JUMP done$放最后一个block末尾</li>\n</ol>\n<h4 id=\"Trace\"><a href=\"#Trace\" class=\"headerlink\" title=\"Trace\"></a>Trace</h4><p>现在我们可以按任意顺序来安排这些基本块，并且程序执行的结果仍是相同的——因为无论怎么排序，每个基本块的末尾都能转移到一个正确的位置。我们可以利用这一点来选择适当的基本块排列顺序，以满足每个<code>CJUMP</code>之后都跟随它的false标号这一条件。<br>与此同时，我们也可以安排基本块使得无条件转移<code>JUMP</code>之后直接跟随的是它们的目标标号。这样便可以删除这些无条件转移，从而使编译生成的程序的执行速度更快。</p>\n<p>把basic block排成trace的方法也很简单：&#x3D;&#x3D;从每个基本块开始，追踪JUMP链，标记遇到的每一个未标记的基本快并添加到当前trace中，最终到达一个其后继都标记过的块，就是结束块。之后再选则一个未标记的基本块开始，重复上述过程。&#x3D;&#x3D;</p>\n<p>因为轨迹调度不可能覆盖所有情况，所以：</p>\n<ol>\n<li>如果CJUMP 后跟 true label: 条件取反，交换 true&#x2F;false，改成：<br>$$<br>CJUMP(!cond, lf, lt)<br>$$</li>\n<li>CJUMP 后跟的不是 true 也不是 false: 创建中间 label，插入 JUMP<br>$$<br>CJUMP(cond, lt, lf) &#x3D;&gt; CJUMP(cond, lt, l’f) LABEL l’f   JUMP NAME(lf)<br>$$</li>\n</ol>\n<h4 id=\"最优轨迹-Optimal-Trace\"><a href=\"#最优轨迹-Optimal-Trace\" class=\"headerlink\" title=\"最优轨迹(Optimal Trace)\"></a>最优轨迹(Optimal Trace)</h4><p>对于basic block可能有不同的trace划分方法</p>\n<ul>\n<li>Hot Path Prioritization（优先热路径）: 优先将**运行频率高的基本块（hot blocks）**合并在同一条轨迹（trace）里，减少跳转，提高局部性。<br>+++info example<br>假设 if-else 中 if 分支占 90% 执行概率，else 只有 10%：</li>\n</ul>\n<figure class=\"highlight c\"><figcaption><span>tiger</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> x &gt; <span class=\"number\">0</span> then</span><br><span class=\"line\">    a := a + <span class=\"number\">1</span>   -- 热路径</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    a := a - <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>生成时应把 x &gt; 0 为真的路径（包括 CJUMP 的 false 分支）安排成 fall-through，避免跳转开销出现在热路径上。<br>+++</p>\n<ul>\n<li>Locality Enhancement（增强局部性）: 把逻辑上相关联的代码块放得更近一些，让它们在内存中“邻近”。<ul>\n<li>原因：<ul>\n<li>更好地利用 CPU cache、预取机制。</li>\n<li>避免指令 cache miss 导致性能下降。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>比如：将循环体和循环条件代码块排在一起（而不是让条件跳到远处），从而保持指令流顺序性。</p>\n<ul>\n<li>Jump Minimization（最小化跳转）: 尽量减少无条件跳转（JUMP）和不必要的条件跳转（CJUMP），尤其在常走路径上，\t减少分支预测失败。</li>\n</ul>\n<p><img data-src=\"/f1.jpg\"><br>哪个划分比较好？<br>根据3，c比a好；</p>\n",
            "tags": [
                "Basic Blocks and Traces"
            ]
        },
        {
            "id": "http://example.com/2025/06/16/computer-science/compile-principles/ch7/",
            "url": "http://example.com/2025/06/16/computer-science/compile-principles/ch7/",
            "title": "IR",
            "date_published": "2025-06-15T16:00:00.000Z",
            "content_html": "<h1 id=\"IR\"><a href=\"#IR\" class=\"headerlink\" title=\"IR\"></a>IR</h1><p>Intermediate Representation<br>解决高级语言和目标机器汇编语言之间的转化<br>为什么需要IR:</p>\n<ul>\n<li>更模块化、可迁移</li>\n<li>分层分析和优化<br>IR可以有好多层：IR1-&gt;IR2-&gt;…-&gt;IRn<br>+++info 编译流程划分<br>前端：源代码-&gt;词法分析-&gt;语法分析-&gt;语义分析（IR之前的都是）<br>中端：基于IR的分析与变换（可能生成新IR，可以做一些机器无关优化比如循环展开等）<br>后端：指令选择-&gt;寄存器分配-&gt;指令调度-&gt;机器码（IR之后的）<br>+++</li>\n</ul>\n<h2 id=\"Three-Address-Code\"><a href=\"#Three-Address-Code\" class=\"headerlink\" title=\"Three-Address Code\"></a>Three-Address Code</h2><p>最多有三个操作数<br>x &#x3D; y op z<br>“地址”可以具有如下形式</p>\n<ul>\n<li>源程序中的名字(name)</li>\n<li>常量 (constant)</li>\n<li>临时变量(temporary)<br><img data-src=\"/f1.jpg\"><br>最常见的实现方法是将三地址代码作为四元组实现<br>+++info example<br>t1&#x3D;x&gt;0                  (gt, x, 0, t1)<br>if_false t1 goto L1     (if_f, t1, L1, _)<br>fact&#x3D;1                  (asn, 1, fact, _)<br>label L2                (lab, L2, _, _)<br>+++</li>\n</ul>\n<h2 id=\"IR-Tree\"><a href=\"#IR-Tree\" class=\"headerlink\" title=\"IR Tree\"></a>IR Tree</h2><p>两大类节点：</p>\n<ol>\n<li>表达式Exp</li>\n<li>语句Stmt<br>文法：<br><img data-src=\"/f2.jpg\"><br>表达式：<table>\n<thead>\n<tr>\n<th>Node</th>\n<th>Description</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CONST(i)</td>\n<td>整数常量i</td>\n<td>CONST(42) → the value 42</td>\n</tr>\n<tr>\n<td>NAME(n)</td>\n<td>符号常量n，通常是一个label，值是label的地址</td>\n<td>NAME(L1) → address of label L1</td>\n</tr>\n<tr>\n<td>TEMP(t)</td>\n<td>临时变量t (like register)</td>\n<td>TEMP(t123) → contents of temporary t123</td>\n</tr>\n<tr>\n<td>BINOP(o,e1,e2)</td>\n<td>对e1和e2执行二元操作o</td>\n<td>BINOP(PLUS,TEMP(t1),CONST(1)) → t1+1</td>\n</tr>\n<tr>\n<td>MEM(e)</td>\n<td>Memory access</td>\n<td>MEM(CONST(100)) → contents at address 100</td>\n</tr>\n<tr>\n<td>CALL(f,l)</td>\n<td>Function call, l是参数列表</td>\n<td>CALL(NAME(print),[TEMP(t1)]) → call print(t1)</td>\n</tr>\n<tr>\n<td>ESEQ(s,e)</td>\n<td>先执行语句s，再求值表达式e并返回e的结果</td>\n<td>ESEQ(MOVE(TEMP(t),CONST(1)),TEMP(t)) → (t&#x3D;1; t)</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<p>语句：</p>\n<table>\n<thead>\n<tr>\n<th>Node</th>\n<th>Description</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>MOVE(TEMP t, e)</td>\n<td>将表达式e的值赋给临时变量t</td>\n<td>MOVE(TEMP(t1), CONST(42)) → t1 &#x3D; 42</td>\n</tr>\n<tr>\n<td>MOVE(MEM(e1), e2)</td>\n<td>将表达式e2的值存储到由e1指定的内存地址中</td>\n<td>MOVE(MEM(TEMP(t1)), CONST(42)) → *t1 &#x3D; 42</td>\n</tr>\n<tr>\n<td>EXP(e)</td>\n<td>计算表达式e的值但不返回结果，通常用于有副作用的操作（如函数调用）</td>\n<td>EXP(CALL(NAME(print), …)) → 调用print()函数以产生效果</td>\n</tr>\n<tr>\n<td>JUMP(e, labs)</td>\n<td>无条件跳转到由e指定的地址</td>\n<td>JUMP(NAME(L1), [L1]) → goto L1</td>\n</tr>\n<tr>\n<td>CJUMP(o,e1,e2,t,f)</td>\n<td>条件跳转，根据操作o对e1和e2的结果决定跳转到t或f</td>\n<td>CJUMP(LT, TEMP(t1), CONST(0), L1, L2) → 如果t1 &lt; 0则跳转到L1，否则跳转到L2</td>\n</tr>\n<tr>\n<td>SEQ(s1, s2)</td>\n<td>语句序列，先执行s1再执行s2</td>\n<td>SEQ(MOVE(…), JUMP(…)) → 先赋值再跳转</td>\n</tr>\n<tr>\n<td>LABEL(n)</td>\n<td>定义一个标签</td>\n<td>LABEL(L1) → L1:</td>\n</tr>\n</tbody></table>\n<p>例子：<br><img data-src=\"/f3.jpg\"><br>ADD那个地方写成BINOP的写法也可以</p>\n<h2 id=\"翻译AST成IR-Tree\"><a href=\"#翻译AST成IR-Tree\" class=\"headerlink\" title=\"翻译AST成IR Tree\"></a>翻译AST成IR Tree</h2><p>把AST表达式分为三类：</p>\n<ul>\n<li>Ex: 有结果的AST表达式比如a+b</li>\n<li>Nx：无结果的语句的比如print</li>\n<li>Cx：条件语句，值为bool的AST表达式</li>\n</ul>\n<h3 id=\"translate-Exp\"><a href=\"#translate-Exp\" class=\"headerlink\" title=\"translate Exp\"></a>translate Exp</h3><ol>\n<li>翻译简单变量：<br>在函数中访问一个局部变量实际上是访问它在当前栈帧中的位置，所以访问一个距离fp的offset为k的局部变量v，其IR Tree表示为:<br>$$<br>MEM(BINOP(PLUS, TEMP fp, CONST k))<br>$$<br><img data-src=\"/f4.jpg\"><br>如果通过static link访问一个变量，就要嵌套好几层MEM和BINOP<br>比如这个访问嵌套两层外面的x<br>最内层使用 CONST(8)：是因为需要从 inner 函数的帧指针 FP 开始，偏移 8 字节来访问静态链，该静态链指向 middle 函数的帧。<br>中间层和最外层使用 CONST(0)：是因为它们分别通过静态链直接访问 outer 函数的帧和变量 x，不需要额外的偏移<br><img data-src=\"/f5.jpg\"><br>:::danger<br>这个地方为什么内层是8中层是0存疑<br>:::</li>\n</ol>\n<p>左值和右值：&#x3D;左右的<br>MEM(addr)可以是左值也可以是右值</p>\n<ul>\n<li>Scalar L-value(Tiger): 一个地址</li>\n<li>Structured L-value(Pascal&#x2F;C): 一块内存</li>\n</ul>\n<ol start=\"2\">\n<li>翻译算术运算</li>\n</ol>\n<ul>\n<li>二元: BINOP(op, e1, e2)</li>\n<li>一元: <ul>\n<li>-x &#x3D;&#x3D;&gt; BINOP(MINUS, CONST(0), e_x)</li>\n<li>~x &#x3D;&#x3D;&gt; BINOP(XOR, e_x, CONST(-1))</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li>数组访问<br>$$<br>MEM(BINOP(PLUS, MEM(e_a), BINOP(MUL, e_i, CONST(W))))<br>$$</li>\n</ol>\n<ul>\n<li><code>e_a</code> 是表示变量 <code>a</code> 的表达式，通常是&#x3D;&#x3D; <code>MEM(+(TEMP(fp), CONST(k_a)))</code>&#x3D;&#x3D;</li>\n<li><code>MEM(e_a)</code>：&#x3D;&#x3D;获取存储在变量 <code>a</code> 中的值，即数组基地址&#x3D;&#x3D;</li>\n<li><code>e_i</code> 是计算索引 <code>i</code> 的表达式</li>\n<li><code>BINOP(MUL, e_i, CONST(W))</code>：计算偏移<br><img data-src=\"/f6.jpg\"></li>\n</ul>\n<p>记录字段r.f访问:<br>$$<br>MEM(BINOP(PLUS, MEM(e_r), BINOP(MUL, n, CONST(W))))<br>$$</p>\n<ol start=\"4\">\n<li>翻译控制流<br>对于if e1 op e2 then stmt1 else stmt2翻译成</li>\n</ol>\n<figure class=\"highlight c\"><figcaption><span>IR</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 6个SEQ</span></span><br><span class=\"line\">SEQ(</span><br><span class=\"line\">    CJUMP(op, e1, e2, t, f),</span><br><span class=\"line\">    SEQ(</span><br><span class=\"line\">        LABEL(t),</span><br><span class=\"line\">        SEQ(</span><br><span class=\"line\">            stm1,</span><br><span class=\"line\">            SEQ(</span><br><span class=\"line\">                JUMP(NAME(end)),</span><br><span class=\"line\">                SEQ(</span><br><span class=\"line\">                    LABEL(f),</span><br><span class=\"line\">                    SEQ(stm2, LABEL(end))</span><br><span class=\"line\">                )</span><br><span class=\"line\">            )</span><br><span class=\"line\">        )</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>Tiger的逻辑运算符&amp;(and)和|(or)需要实现短路求值：只计算必要的操作数<br>每个Cx是一个Label</p>\n<ul>\n<li>逻辑与 (a &amp; b)的短路规则：<ul>\n<li>计算a<br>  -若a为假，直接得到假结果（不计算b）<br>  -若a为真，继续计算b，最终结果即为b的值</li>\n</ul>\n</li>\n<li>逻辑或 (a | b)的短路规则：<br>  -计算a<br>  -若a为真，直接得到真结果（不计算b）<ul>\n<li>若a为假，继续计算b，最终结果即为b的值</li>\n</ul>\n</li>\n</ul>\n<ol start=\"5\">\n<li>循环语句</li>\n</ol>\n<figure class=\"highlight c\"><figcaption><span>tiger</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> a &gt; <span class=\"number\">0</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">a := a - <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>翻译成</p>\n<figure class=\"highlight c\"><figcaption><span>IR</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SEQ(LABEL test, </span><br><span class=\"line\">    SEQ(CJUMP(GT, TEMP a, CONST <span class=\"number\">0</span>, body, done), </span><br><span class=\"line\">        SEQ(LABEL body, </span><br><span class=\"line\">            SEQ(MOVE(TEMP a, BINOP(MINUS, TEMP a, CONST <span class=\"number\">1</span>)), </span><br><span class=\"line\">                SEQ(JUMP(NAME(test), [test]), </span><br><span class=\"line\">                    LABEL done)))))</span><br></pre></td></tr></table></figure>\n<p>break翻译为直接跳转到done<br>for循环我懒得写了，也是一个道理<br>和汇编差不多意思</p>\n<ol start=\"6\">\n<li>翻译函数<br>$$<br>CALL(NAME(l_f), [sl, a_1, …, a_n])<br>$$<br>sl是static link。</li>\n</ol>\n<h3 id=\"translate-Declaration\"><a href=\"#translate-Declaration\" class=\"headerlink\" title=\"translate Declaration\"></a>translate Declaration</h3><ul>\n<li>Variable declaration</li>\n<li>Type declaration</li>\n<li>Function declaration</li>\n</ul>\n<ol>\n<li>翻译变量声明</li>\n</ol>\n<figure class=\"highlight c\"><figcaption><span>tiger</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let</span><br><span class=\"line\">    var x := <span class=\"number\">10</span></span><br><span class=\"line\">    var y := x + <span class=\"number\">5</span></span><br><span class=\"line\">in </span><br><span class=\"line\">    x + y</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><figcaption><span>IR</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ESEQ( </span><br><span class=\"line\">    SEQ( </span><br><span class=\"line\">        MOVE(MEM(+(FP, CONST(x_offset))), CONST(<span class=\"number\">10</span>)), </span><br><span class=\"line\">        MOVE(MEM(+(FP, CONST(y_offset))), </span><br><span class=\"line\">        BINOP(PLUS, </span><br><span class=\"line\">        MEM(+(FP, CONST(x_offset))), </span><br><span class=\"line\">        CONST(<span class=\"number\">5</span>))) </span><br><span class=\"line\">    ), </span><br><span class=\"line\">    BINOP(PLUS, </span><br><span class=\"line\">    MEM(+(FP, CONST(x_offset))), </span><br><span class=\"line\">    MEM(+(FP, CONST(y_offset)))) </span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>let body in e end翻译成ESEQ(body, e)<br>变量定义翻译成 MEM(+(FP, CONST(offset)))<br>初始化翻译成 MOVE(MEM(+(FP, CONST(offset))), CONST(value))</p>\n<ol start=\"2\">\n<li><p>类型声明<br>No need to generate any IR tree code</p>\n</li>\n<li><p>函数声明<br> – Prologue（序言）<br> – Body（函数体）<br> – Epilogue（尾声）</p>\n</li>\n</ol>\n<ul>\n<li>Prologue<ul>\n<li>pseudo-instructions to announce the beginning of a function</li>\n<li>定义函数标签用于跳转&#x2F;调用</li>\n<li>修改栈指针（SP），为新栈帧分配空间，一般是$SP :&#x3D; SP - frame_size$</li>\n<li>保存被调用者需要保存的寄存器（callee-save），如 $s0-$s7；保存返回地址（RA）</li>\n<li>保存函数参数到栈中（尤其是传值调用时）；保存静态链（static link）</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "中间代码"
            ]
        },
        {
            "id": "http://example.com/2025/06/15/computer-science/compile-principles/ch6/",
            "url": "http://example.com/2025/06/15/computer-science/compile-principles/ch6/",
            "title": "活动记录",
            "date_published": "2025-06-14T16:00:00.000Z",
            "content_html": "<h1 id=\"Activation-Record-Stack-Frame\"><a href=\"#Activation-Record-Stack-Frame\" class=\"headerlink\" title=\"Activation Record&#x2F;Stack Frame\"></a>Activation Record&#x2F;Stack Frame</h1><p>函数的栈帧是栈上用来放函数的局部变量、参数、返回地址以及其他临时变量的区域<br>stack一般从高地址向低地址，heap从低地址向高地址<br>layout:<br><img data-src=\"/f1.jpg\"></p>\n<ul>\n<li>incoming arguments: 存储caller传递给callee的参数</li>\n<li>frame pointer: 帧指针，用来访问incoming arguments，从低向高是argument 1, argument 2, …</li>\n<li>local variables: 存储函数的局部变量（还有一些保存在寄存器里）</li>\n<li>return address: 存储需要返回caller的哪里；non-leaf过程会把return address写入栈帧里面</li>\n<li>temporaries: 存储临时变量，复杂表达式拆出来的中间变量放的地方</li>\n<li>saved registers</li>\n<li>outgoing arguments: 存储当前函数要传递给别的函数的参数</li>\n<li>stack pointer: 栈指针，从低向高</li>\n</ul>\n<h2 id=\"函数调用流程：\"><a href=\"#函数调用流程：\" class=\"headerlink\" title=\"函数调用流程：\"></a>函数调用流程：</h2><ul>\n<li>g调用f的时候</li>\n</ul>\n<ol>\n<li>进入f的时候，保存旧的FP(g的FP)</li>\n<li>把FP设置为原来的SP，把SP &#x3D; SP - frame size<br><img data-src=\"/f2.jpg\"></li>\n</ol>\n<ul>\n<li>f返回的时候</li>\n</ul>\n<ol>\n<li>让SP &#x3D; FP(恢复g的SP)</li>\n<li>从内存中读出g的FP恢复回去</li>\n</ol>\n<p>如果栈帧大小固定就只需要FP不需要SP了，因为FP &#x3D; SP + frame size</p>\n<h2 id=\"saved-register\"><a href=\"#saved-register\" class=\"headerlink\" title=\"saved register\"></a>saved register</h2><p>函数g调用f的时候，用到了寄存器r，调用f的时候要把r保存在saved register中，等调用结束再恢复回去</p>\n<ul>\n<li>caller-saved register: 函数调用的时候用到的寄存器，调用结束后可以恢复</li>\n<li>callee-saved register: 函数调用的时候用不到的寄存器，调用结束后不能恢复<br>&#x3D;&#x3D;FP是由callee保存和恢复的&#x3D;&#x3D;</li>\n</ul>\n<h2 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h2><p>一般约定把前k(4 or 6)个参数放在寄存器传递，剩下的参数放在栈中传递<br>四种传参方法：</p>\n<ol>\n<li>不给叶过程 (leaf procedure) 分配栈帧<br>叶过程是指不调用其他过程的过程。在这种情况下，可以不为叶过程分配栈帧</li>\n<li>过程间寄存器分配 (interprocedural register allocation)<br>这种方法需要先分析代码中全部的函数，然后再根据分析结果来分配寄存器。<br>假设有一个程序包含多个函数，通过全局分析发现某些变量在多个函数之间频繁使用，可以为其分配固定的寄存器，避免频繁的内存读写</li>\n<li>若变量 x 不再被使用，可以直接写其寄存器，不需要再保存 x 到栈帧中<br>当一个变量在当前作用域内不再被使用时，可以直接将其值写入寄存器，而无需保存到栈帧中</li>\n</ol>\n<figure class=\"highlight c\"><figcaption><span>example</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">exampleFunction</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> y = x * <span class=\"number\">2</span>;  <span class=\"comment\">// 使用x后，x不再被使用</span></span><br><span class=\"line\">    <span class=\"comment\">// 直接将y的值写入寄存器，无需保存x到栈帧中</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Result: %d\\n&quot;</span>, y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>寄存器窗口技术 (register windows)<br>在每次函数调用时，系统会自动切换到一组新的寄存器，称为寄存器窗口。这样，每个函数都可以独立地使用自己的寄存器，而不会影响其他函数的寄存器状态。</li>\n</ol>\n<figure class=\"highlight c\"><figcaption><span>example</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">functionA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用寄存器窗口A</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">functionB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用寄存器窗口B</span></span><br><span class=\"line\">    functionA();  <span class=\"comment\">// 调用functionA时，自动切换到寄存器窗口A</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Frame-Resident-Variables\"><a href=\"#Frame-Resident-Variables\" class=\"headerlink\" title=\"Frame-Resident Variables\"></a>Frame-Resident Variables</h2><p>什么情况下要把变量写入栈帧里面？、</p>\n<ol>\n<li>the varibles will be passed by reference 变量传地址&#x2F;引用</li>\n<li>变量被嵌套在函数内部的函数访问（不绝对）</li>\n<li>变量太大了没法直接放寄存器</li>\n<li>变量是一个数组</li>\n<li>传递参数</li>\n<li>有太多局部变量和临时变量放不下了</li>\n</ol>\n<ul>\n<li>escape 逃逸：如果一个变量需要传地址&#x2F;取地址&#x2F;被过程内部嵌套的函数访问，那么这个变量就会逃逸。</li>\n</ul>\n<h2 id=\"static-links\"><a href=\"#static-links\" class=\"headerlink\" title=\"static links\"></a>static links</h2><p>在嵌套的函数声明中，内层函数是有可能用到外层函数的局部变量的。</p>\n<ul>\n<li>static links是指向上一层嵌套层级的栈帧的指针。内层嵌套函数调用外层定义的变量的时候需要用到static links，否则无法寻址。<br><img data-src=\"/f3.jpg\"><br><img data-src=\"/f4.jpg\"><br>只有调用自身的时候才传递自己的static link作为static link，其他的都是把外层函数的fp作为static link<br>如果要访问外层变量，就顺着static一层一层查上去直到找到了为止。<br>其他访问方法：</li>\n<li>嵌套层次显示表(display)<br>建立一个全局数组，位置i包含一个指针，指向最近一次进入的，其静态嵌套深度是i的过程的栈帧<br><img data-src=\"/f5.jpg\"><br>先给它们标上嵌套深度<br>直接把链表变成数组了，需要用到一个变量，就查看当前变量的嵌套深度i然后直接找那个数组i位置的座位fp地址来找</li>\n<li>lambda lifting<br>g调用f时，g中每一个实际（或被嵌套在f内的任意函数）访问了的变量，都将作为额外的参数传递给f<br>把内部的函数，从内往外进行改写，改写函数的参数实现lambda lifting<br><img data-src=\"/f6.jpg\"></li>\n</ul>\n<h2 id=\"tiger编译器的栈帧\"><a href=\"#tiger编译器的栈帧\" class=\"headerlink\" title=\"tiger编译器的栈帧\"></a>tiger编译器的栈帧</h2><p>tiger不支持高阶函数<br>看不完了。。再说吧</p>\n",
            "tags": [
                "活动记录"
            ]
        },
        {
            "id": "http://example.com/2025/05/14/computer-science/computer-organization/ch2/",
            "url": "http://example.com/2025/05/14/computer-science/computer-organization/ch2/",
            "title": "Ch2",
            "date_published": "2025-05-13T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch2-数据的表示和运算\"><a href=\"#Ch2-数据的表示和运算\" class=\"headerlink\" title=\"Ch2 数据的表示和运算\"></a>Ch2 数据的表示和运算</h1><h2 id=\"2-1-进位计数制及其相互转换\"><a href=\"#2-1-进位计数制及其相互转换\" class=\"headerlink\" title=\"2.1 进位计数制及其相互转换\"></a>2.1 进位计数制及其相互转换</h2><h3 id=\"2-1-1\"><a href=\"#2-1-1\" class=\"headerlink\" title=\"2.1.1\"></a>2.1.1</h3><ul>\n<li>十进制二进制八进制十六进制转换<ul>\n<li>略</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-1-2-定点数的编码表示\"><a href=\"#2-1-2-定点数的编码表示\" class=\"headerlink\" title=\"2.1.2 定点数的编码表示\"></a>2.1.2 定点数的编码表示</h3><ul>\n<li>定点数一般表示定点小数和定点整数，小数是符号位.xxx，整数是符号位xxxx.0</li>\n<li><blockquote>\n<p>感觉不是什么重要的东西，浮点数表示比较重要</p>\n</blockquote>\n</li>\n<li>原码，反码，补码<ul>\n<li>正数的原码反码补码相同</li>\n<li>原码表示的范围为 $-2^n+1 ~ 2^n-1$</li>\n<li>补码表示的范围为 $-2^n ~ 2^n-1$</li>\n<li>负数的原码是1+绝对值，反码是1+绝对值取反，补码是反码+1</li>\n</ul>\n</li>\n<li>移码：用来表示浮点数的阶码，只能表示整数<ul>\n<li>一般用移码表示浮点数的阶码，用补码表示定点整数<br>$$ [x]_移 &#x3D; 2^n + x $$<br>移码就是在真值x前面加一个offset，比如取offset为2^7，就在补码的第8位加上1</li>\n<li>比如正数10101，移码是10010101，负数-10101的补码是11101011，所以移码是01101011</li>\n<li>移码的作用是&#x3D;&#x3D;保持数据原有的大小顺序&#x3D;&#x3D;，移码大真值大，移码小真值小，所以可以直观地进行比较<br>:::warning<br>相同位数的补码和移码表示具有相同的数据表示范围，区别只是表示方法不同<br>补码与移码只差一个符号位。同一个数的补码和移码表示，其数值部分相同，而符号位相反。<br>:::</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-1-3-整数表示\"><a href=\"#2-1-3-整数表示\" class=\"headerlink\" title=\"2.1.3 整数表示\"></a>2.1.3 整数表示</h3><p>略</p>\n<h3 id=\"2-1-4\"><a href=\"#2-1-4\" class=\"headerlink\" title=\"2.1.4\"></a>2.1.4</h3><p>c中的强制转换<br>short转成unsigned short直接把二进制看成unsigned short，比如-1变成65535<br>int变成short直接截断<br>小字长转大字长不会改变值，如果是unsigned就会在前面补0，如果是有符号数就在前面补符号位<br>short转unsigned int，先对short进行符号扩展到int，再把它当做unsigned int，如果是unsigned short转int，就进行零扩展再看成int……</p>\n<p>一些题目<br>+++info example<br>;;;id3 t1<br>若$[x]_补 &#x3D; 1,x_1x_2x_3x_4x_5x_6$,其中$x_i$取0或1，若要x&gt;-32，应当满足：<br>C. $x_1$为1，$x_2…x_6$中至少有一位为1<br>1100000是-32，要比-32大所以绝对值要小，所以数值部分要大，所以$x_1$必须是1,后面随便有个1就行<br>;;;<br>;;;id3 t2<br>设x为正数，$[x]_补 &#x3D; 1,x_1x_2x_3x_4x_5$,若要x&lt;-16，应当满足：<br>C. $x_1$必须为0，其它任意<br>110000是-16，要小于-16所以数值部分绝对值要小，所以只要$x_1$为0就比-16小<br>;;;<br>;;;id3 t3<br>一个8位的二进制整数由2个“0”和6个“1”组成，采用补码或者移码表示，则<br>若采用移码表示，偏置值为127，则此整数最小为-64（偏置为127需要在补码加上1111111，&#x3D;&#x3D;要让数值最小，应该把1放低位&#x3D;&#x3D;，所以移码是00111111，补码是10111111是-64）</p>\n<blockquote>\n<p>：前面说过，移码大真值大，移码小真值小，所以要让数值最小把1放低位就行了</p>\n</blockquote>\n<p>若采用补码表示，则此整数最小为-97（10011111&#x3D;-97）<br>;;;<br>;;;id3 比较大小的方法<br>对于无符号数，数值大的数就大<br>对于有符号数的原码和反码比较大小：先看正负然后看数值，反码数值转成原码再比<br>对于补码比较大小，正数正常比较，负数数值部分越小，绝对值越大（前面1更多的数的绝对值越小，所以11111111是-1）<br>;;;<br>+++</p>\n<h2 id=\"2-2-运算方法和运算电路\"><a href=\"#2-2-运算方法和运算电路\" class=\"headerlink\" title=\"2.2 运算方法和运算电路\"></a>2.2 运算方法和运算电路</h2><h3 id=\"2-2-1-基本运算部件\"><a href=\"#2-2-1-基本运算部件\" class=\"headerlink\" title=\"2.2.1 基本运算部件\"></a>2.2.1 基本运算部件</h3><h4 id=\"一位全加器\"><a href=\"#一位全加器\" class=\"headerlink\" title=\"一位全加器\"></a>一位全加器</h4><ul>\n<li>用真值表实现的：进位C，和S<table>\n<thead>\n<tr>\n<th align=\"center\">A</th>\n<th align=\"center\">B</th>\n<th align=\"center\">Cin</th>\n<th align=\"center\">Cout</th>\n<th align=\"center\">S</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n</tr>\n</tbody></table>\n<ul>\n<li>可以用卡诺图或者直接理解<br><img data-src=\"/img2.jpg\"><br>$$<br>\\begin{aligned}<br>S &amp;&#x3D; \\overline{A} , \\overline{B} , C_i + \\overline{A} , B , \\overline{C_i} + A , \\overline{B} , \\overline{C_i} + A , B , C_i \\<br>&amp;&#x3D; A \\oplus B \\oplus C_i<br>\\end{aligned}<br>$$<br>$$<br>\\begin{aligned}<br>Co &amp;&#x3D; AB + A \\overline{B} C_i + \\overline{A} B C_i \\<br>&amp;&#x3D; AB + (A \\oplus B) \\cdot C_i<br>\\end{aligned}<br>$$</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"串行进位加法器\"><a href=\"#串行进位加法器\" class=\"headerlink\" title=\"串行进位加法器\"></a>串行进位加法器</h4><ul>\n<li>把n个一位全加器连起来<br><img data-src=\"/img3.png\"><br>Carry Propagation &amp; Delay</li>\n</ul>\n<h4 id=\"并行进位加法器\"><a href=\"#并行进位加法器\" class=\"headerlink\" title=\"并行进位加法器\"></a>并行进位加法器</h4><p>对Cin进行look ahead</p>\n<p><img data-src=\"/img4.png\"></p>\n<p>前面提到：<br>$$<br>\\begin{aligned}<br>Co &amp;&#x3D; AB + A \\overline{B} C_i + \\overline{A} B C_i \\<br>   &amp;&#x3D; AB + (A \\oplus B) \\cdot C_i<br>\\end{aligned}<br>$$<br>下一位的Cin等于上一位的Cout，所以可以进行look ahead，这里让<br>$$<br>\\begin{aligned}<br>G_i &amp;&#x3D; A_iB_i<br>\\end{aligned}<br>$$<br>$$<br>\\begin{aligned}<br>P_i &amp;&#x3D; A_i \\oplus B_i<br>\\end{aligned}<br>$$<br>所以<br>$$<br>\\begin{aligned}<br>C_{i+1} &amp;&#x3D; G_i + P_iC_i<br>\\end{aligned}<br>$$<br>$$<br>\\begin{aligned}<br>S_i &amp;&#x3D; P_i \\oplus C_i<br>\\end{aligned}<br>$$<br>就能得到超前进位的效果</p>\n<h4 id=\"带标志加法器\"><a href=\"#带标志加法器\" class=\"headerlink\" title=\"带标志加法器\"></a>带标志加法器</h4><p><img data-src=\"/img5.jpg\"></p>\n<ul>\n<li>溢出标志 $OF &#x3D; C_n  \\oplus C_{n-1}$，只能判断有符号数是否溢出<br>-两个正数加起来变成负数或者两个负数加起来变成正数，就会溢出<table>\n<thead>\n<tr>\n<th align=\"center\">A</th>\n<th align=\"center\">B</th>\n<th align=\"center\">$C_{n-1}$</th>\n<th align=\"center\">F</th>\n<th align=\"center\">$C_n$</th>\n<th align=\"center\">OF</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<blockquote>\n<p>第二行A&#x3D;0, B&#x3D;0, F&#x3D;1，正+正&#x3D;负<br>  第七行A&#x3D;0, B&#x3D;1, F&#x3D;0，负+负&#x3D;正<br>  所以OF&#x3D;1，表示有溢出<br>  观察发现$OF &#x3D; C_{n-1}  \\oplus C_n$</p>\n</blockquote>\n<ul>\n<li>符号标志 $SF &#x3D; F_{n-1}$，输出的最高位决定有符号数的正负</li>\n<li><code>CF</code>进位&#x2F;借位标志：用于判断无符号数的加减运算是否溢出<ul>\n<li>$CF &#x3D; Cin \\oplus Cout$</li>\n<li>此处的Cin和Cout表示最开始的输入和最后的输出，还没理解</li>\n</ul>\n</li>\n<li><code>ZF</code>零标志 当且仅当所有F&#x3D;0时为1，否则为0（把所有F作或非）</li>\n<li><code>SF</code>符号标志位,结果为负，即符号位为1时SF&#x3D;1，否则为0<br>具体可以看这篇：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhYmJ5X19fXy9hcnRpY2xlL2RldGFpbHMvODA4MjU1NDk=\">https://blog.csdn.net/gabby____/article/details/80825549</span></li>\n</ul>\n<h4 id=\"ALU\"><a href=\"#ALU\" class=\"headerlink\" title=\"ALU\"></a>ALU</h4><p>略</p>\n<h3 id=\"2-2-2-定点数的移位运算\"><a href=\"#2-2-2-定点数的移位运算\" class=\"headerlink\" title=\"2.2.2 定点数的移位运算\"></a>2.2.2 定点数的移位运算</h3><ul>\n<li>左移一位*2，右移一位&#x2F;2</li>\n<li>逻辑移位：移完直接补0<ul>\n<li>无符号数若高位的1移出，则发生溢出</li>\n</ul>\n</li>\n<li>算数移位：有符号数右移时，补符号位，左移直接移，如果高位和符号位不同，则发生溢出</li>\n</ul>\n<h3 id=\"定点数的加减运算\"><a href=\"#定点数的加减运算\" class=\"headerlink\" title=\"定点数的加减运算\"></a>定点数的加减运算</h3><p>补码相加减，略<br>主要是溢出判断：符号相同的数相加或者符号相异的数相减会发生溢出</p>\n<ul>\n<li>一位符号位（参考前面OF）</li>\n<li>双符号位（模4补码）<ul>\n<li>符号位左边那一位表示正确的符号，0为正，1为负；右边那一位如果和左边的相同，如 “00”表示正且无溢出，”11”表示负且无溢出。如果右边那一位与左边那一位不一样，则表示有溢出</li>\n<li>溢出逻辑判断：若V为0则无溢出，V为1则溢出</li>\n<li>&#x3D;&#x3D;存储的时候，模4补码只需要一位符号位&#x3D;&#x3D;，因为任何一个正确的数值它的两个符号位是相同的。它只是把两个模4补码的数送往ALU进行运算的时候，把符号位同时送入ALU的双符号位中，即&#x3D;&#x3D;只在ALU中采用双符号位&#x3D;&#x3D;<br>$$<br>V &#x3D; S_{s1} \\oplus S_{s2}<br>$$<br>例子看这篇写的挺清楚：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1bl9ib3lfYm95X3N1bi9hcnRpY2xlL2RldGFpbHMvODc5MTcwMjA=\">https://blog.csdn.net/sun_boy_boy_sun/article/details/87917020</span><br>总之两位不同则有溢出</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"定点数的乘除运算\"><a href=\"#定点数的乘除运算\" class=\"headerlink\" title=\"定点数的乘除运算\"></a>定点数的乘除运算</h3><p>略，列竖式即可</p>\n<h3 id=\"浮点数的表示与运算\"><a href=\"#浮点数的表示与运算\" class=\"headerlink\" title=\"浮点数的表示与运算\"></a>浮点数的表示与运算</h3><ol>\n<li>浮点数的表示格式<br>$$<br>N &#x3D; (-1)^s \\cdot M \\cdot R^E<br>$$<br>s符号，M尾数，E阶码，R基数</li>\n<li>浮点数的表示范围<br>范围关于原点对称，运算结果大于最大正数时成为正上溢，小遇绝对值最大负数是成为负上溢，统称上溢。运算结果在0-最小整数之间成为正下溢，负数同理，统称下溢（原因是精度不够）</li>\n<li>浮点数的规格化<br>化成$1.xxxxx… \\cdot 2^n$的形式</li>\n<li>IEEE754<br>符号，阶码，尾数<br>32位单精度：1 8 23，偏置为$2^7-1&#x3D;127$，真值为$(-1)^s \\cdot 2^{e-127} \\cdot (1.M)$<br>单精度表示的最小值为$1 \\cdot 2^{1-127} \\cdot (1.000…) &#x3D; 2^{-126}$，最大值为$1 \\cdot 2^{254-127} \\cdot (1.111…) &#x3D; (2 - 2^{-23}) \\cdot 2^{127}$}<br>64位双精度：1 11 52，偏置为$2^{10}-1&#x3D;1023$，真值为$(-1)^s \\cdot 2^{e-1023} \\cdot (1.M)$，最大值为$1 \\cdot 2^{2046-1023} \\cdot (1.111…) &#x3D; (2 - 2^{-52}) \\cdot 2^{1023}$<br>阶码全为0或者全为1有特殊意义<br><img data-src=\"/f1.jpg\"><br>阶码全1尾数不全0表示无穷大<br>阶码全1尾数全0表示NaN<br>阶码全0尾数不全0表示非规格化数，隐藏位为0（精度不够表示，需要特殊处理）</li>\n</ol>\n<h3 id=\"浮点数的加减运算\"><a href=\"#浮点数的加减运算\" class=\"headerlink\" title=\"浮点数的加减运算\"></a>浮点数的加减运算</h3><ol>\n<li>对阶</li>\n<li>尾数相加减</li>\n<li>尾数规格化，修改阶数</li>\n<li>舍入</li>\n</ol>\n<ul>\n<li>就近舍入：舍入为最近的可表示数，当结果是两个可表示数的中间时，选择结果为偶数</li>\n<li>正向舍入：朝数轴正无穷方向舍入，取右边最近的可表示数</li>\n<li>负向舍入：和正向相反</li>\n<li>截断法：直接截取所需位数，是一种趋向原点的舍入</li>\n</ul>\n<ol start=\"5\">\n<li>溢出判断<br>对阶码加减时要判断是否溢出</li>\n</ol>\n",
            "tags": [
                "数据的表示与运算"
            ]
        },
        {
            "id": "http://example.com/2025/05/13/computer-science/computer-organization/ch1/",
            "url": "http://example.com/2025/05/13/computer-science/computer-organization/ch1/",
            "title": "Ch1",
            "date_published": "2025-05-12T16:00:00.000Z",
            "content_html": "<blockquote>\n<p>计组考研复习笔记，参考资料：王道，zju数逻&#x2F;计组&#x2F;体系课程ppt<br>怕学完忘了写个笔记保留一下顺便加深印象x<br>王道书写得好烂、、</p>\n</blockquote>\n<h1 id=\"Ch1-计算机系统概述\"><a href=\"#Ch1-计算机系统概述\" class=\"headerlink\" title=\"Ch1 计算机系统概述\"></a>Ch1 计算机系统概述</h1><h2 id=\"1-1-计算机发展历程\"><a href=\"#1-1-计算机发展历程\" class=\"headerlink\" title=\"1.1 计算机发展历程\"></a>1.1 计算机发展历程</h2><ul>\n<li>四代计算机：电子管-&gt;晶体管-&gt;集成电路-&gt;超大规模集成电路</li>\n<li>摩尔定律：集成电路上可以容纳的晶体管数目在大约每经过18个月到24个月便会增加一倍</li>\n</ul>\n<h2 id=\"1-2-计算机系统层次结构\"><a href=\"#1-2-计算机系统层次结构\" class=\"headerlink\" title=\"1.2 计算机系统层次结构\"></a>1.2 计算机系统层次结构</h2><ul>\n<li>计算机系统：硬件+软件</li>\n<li>对于某一功能，既能用软件实现又能用硬件实现，称为软、硬件在逻辑功能上是等价的</li>\n</ul>\n<h3 id=\"1-2-2-硬件\"><a href=\"#1-2-2-硬件\" class=\"headerlink\" title=\"1.2.2 硬件\"></a>1.2.2 硬件</h3><ul>\n<li>冯·诺依曼机的特点：<ul>\n<li>采用“存储程序”的工作方式</li>\n<li>冯·诺依曼计算机由五大部件组成：运算器、控制器、存储器、输入设备和输出设备</li>\n<li>指令和数据以同等地位存储在存储器中</li>\n<li>指令和数据均用二进制代码表示</li>\n<li>指令由操作码和地址码组成</li>\n<li><img data-src=\"/img1.png\"></li>\n</ul>\n</li>\n<li>计算机的功能部件：<ul>\n<li>输入设备</li>\n<li>输出设备</li>\n<li>存储器：主存+外存<ul>\n<li>CPU能直接访问的是主存</li>\n<li><img data-src=\"/img2.jpg\"></li>\n<li>MAR位10位则最多有$2^{10}$个存储单元</li>\n<li>在现代计算机中MAR和MDR存在CPU中</li>\n</ul>\n</li>\n<li>运算器：进行算术运算和逻辑运算<ul>\n<li>核心是ALU：通用寄存器有&#x3D;&#x3D;累加器(ACC)，乘商寄存器(MQ)，操作数寄存器(X)&#x3D;&#x3D;，变址寄存器(IX)，基址寄存器(BR)等，前三个必备</li>\n<li>程序状态寄存器(PSW)</li>\n<li><img data-src=\"/img3.jpg\"></li>\n</ul>\n</li>\n<li>控制器：由PC, IR和control unit组成<ul>\n<li>: RISCV控制器</li>\n<li><img data-src=\"/img4.png\"></li>\n</ul>\n</li>\n<li>CPU由运算器、控制器和cache组成</li>\n<li>总线有地址总线、数据总线、控制总线</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-2-3-软件\"><a href=\"#1-2-3-软件\" class=\"headerlink\" title=\"1.2.3 软件\"></a>1.2.3 软件</h3><ul>\n<li>组成：系统软件(OS, DBMS, 编译器, …)+应用软件</li>\n<li>语言：汇编语言、机器语言、高级语言<ul>\n<li>汇编器：把汇编语言翻译成机器语言</li>\n<li>编译器：把高级语言翻译成汇编语言或机器语言</li>\n<li>解释器：把高级语言翻译成&#x3D;&#x3D;机器语言&#x3D;&#x3D;(比如python)<br>  +++info example<br>  ;;;id3 题目<br>  :chestnut:<br>  将高级语言源程序转换为机器级目标代码文件的程序是 []。<br>  A. 汇编程序<br>  B. 链接程序<br>  C. 编译程序<br>  D. 解释程序<br>  ;;;<br>  ;;;id3 答案<br>  C. 编译程序<br>  因为解释程序不生成目标代码，编译器可以把高级语言翻译成汇编语言或者直接翻译成机器语言<br>  ;;;<br>  +++</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-2-4-计算机系统的层次结构\"><a href=\"#1-2-4-计算机系统的层次结构\" class=\"headerlink\" title=\"1.2.4 计算机系统的层次结构\"></a>1.2.4 计算机系统的层次结构</h3><ul>\n<li>看看就好</li>\n<li><img data-src=\"/img5.png\"></li>\n</ul>\n<h3 id=\"1-2-5-计算机系统的工作原理\"><a href=\"#1-2-5-计算机系统的工作原理\" class=\"headerlink\" title=\"1.2.5 计算机系统的工作原理\"></a>1.2.5 计算机系统的工作原理</h3><ul>\n<li>程序执行前，需要把所含的指令和数据一起放入主存中</li>\n<li>五个阶段：IF-ID-EX-MEM-WB</li>\n<li>c程序怎么变成可执行文件的：直接看图<ul>\n<li><img data-src=\"/img6.png\"></li>\n<li>汇编器把指令打包成可重定位目标代码文件：使用相对地址和符号引用来表示各个代码段之间的关系（代码段、数据段、符号表、重定位表…）使得代码或数据能在内存中任意位置加载或运行</li>\n</ul>\n</li>\n<li>指令执行过程：后面几章会具体讲</li>\n</ul>\n<h2 id=\"1-3-计算机的性能指标\"><a href=\"#1-3-计算机的性能指标\" class=\"headerlink\" title=\"1.3 计算机的性能指标\"></a>1.3 计算机的性能指标</h2><h3 id=\"1-3-1-主要性能指标\"><a href=\"#1-3-1-主要性能指标\" class=\"headerlink\" title=\"1.3.1 主要性能指标\"></a>1.3.1 主要性能指标</h3><ul>\n<li>字长：一次整数运算所能处理的二进制数据的位数<br> :::info<br> 机器字长、指令字长和存储字长<br> :::</li>\n<li>带宽<code>bandwidth</code>：总线一次能并行传送信息的位数</li>\n<li>主存容量</li>\n<li>运算速度<ul>\n<li>吞吐量<code>throughput</code>：一次输入数据所对应的输出数据个数</li>\n<li>响应时间<code>Response (Execution) time</code></li>\n<li>主频</li>\n<li>clock cycle time( &#x3D; 1&#x2F;CPU frequency)</li>\n<li>MIPS: million instructions per second</li>\n<li>FLOPS: floating-point operations per second<blockquote>\n<p>CPI: clock cycles per instruction(IPC: CPI的倒数)</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<p>$$ \\begin{aligned}<br>    \\text{CPU execution time} &amp;&#x3D; \\text{CPU clock cycles} \\times \\text{Clock cycle time} \\<br>    &amp;&#x3D; \\frac{\\text{CPU clock cycles}}{\\text{Clock rate}}<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>    \\text{CPU clock cycles} &amp;&#x3D; \\text{Instructions count} \\times \\text{Average cycles per instruction}<br>\\end{aligned}$$</p>\n<p>$$\\begin{aligned}<br>    \\text{CPU execution time} &amp;&#x3D; \\text{CPU clock cycles} \\times \\text{Clock cycle time} \\<br>    &amp;&#x3D; \\frac{\\text{CPU clock cycles}}{\\text{Clock rate}}<br>\\end{aligned} $$</p>\n<p>$$ \\begin{aligned}<br>     \\text{performance} &amp;&#x3D; \\frac{1}{\\text{CPU execution time}}<br>\\end{aligned}$$</p>\n<p>“Processor X is n times fast than Y” is<br>$$ \\begin{aligned}<br>    \\text{n} &amp;&#x3D; \\frac{\\text{CPU execution time of Y}}{\\text{CPU execution time of X}}<br>\\end{aligned}$$</p>\n<p>IPS: instructions per second<br>$$ \\begin{aligned}<br>    \\text{IPS} &amp;&#x3D; \\frac{\\text{CPU frequency}}{\\text{CPI}}<br>        &amp;&#x3D; \\frac{1}{\\text{CPU clock cycles} \\times \\text{CPU execution time}}<br>\\end{aligned}$$</p>\n<ul>\n<li>其他公式，，，用到再说吧</li>\n<li>兼容：软件或硬件的通用性</li>\n</ul>\n<blockquote>\n<p>在用于科学计算的计算机中，标志系统性能最有用的参数是浮点数运算相关的</p>\n<ul>\n<li>MFLOPS 10^6</li>\n<li>GFLOPS 10^9</li>\n<li>TFLOPS 10^12</li>\n<li>PFLOPS 10^15</li>\n<li>EFLOPS 10^18</li>\n<li>ZFLOPS 10^21</li>\n</ul>\n</blockquote>\n",
            "tags": [
                "计算机组成"
            ]
        },
        {
            "id": "http://example.com/2025/05/13/computer-science/computer-network/ch1/",
            "url": "http://example.com/2025/05/13/computer-science/computer-network/ch1/",
            "title": "Ch1",
            "date_published": "2025-05-12T16:00:00.000Z",
            "content_html": "",
            "tags": [
                "计算机网络"
            ]
        },
        {
            "id": "http://example.com/2025/03/30/computer-science/compile-principles/ch5/",
            "url": "http://example.com/2025/03/30/computer-science/compile-principles/ch5/",
            "title": "语义分析",
            "date_published": "2025-03-29T16:00:00.000Z",
            "content_html": "<h1 id=\"语义分析\"><a href=\"#语义分析\" class=\"headerlink\" title=\"语义分析\"></a>语义分析</h1><blockquote>\n<p>绑定，类型检查</p>\n</blockquote>\n<h2 id=\"symbol-table\"><a href=\"#symbol-table\" class=\"headerlink\" title=\"symbol table\"></a>symbol table</h2><ul>\n<li><p>Imperative style: 命令式风格</p>\n<ul>\n<li>Modify $\\sigma_1$ until it becomes $\\sigma_2$. </li>\n<li>While $\\sigma_2$ exists, we cannot look things up in $\\sigma_1$. </li>\n<li>When done with $\\sigma_2$, can undo the modification to get $\\sigma_1$ back again.<br>+++info 方法：<br>Hashing<br>插入：找到哈希值然后插入链表的表头<br>查找：找到哈希值然后遍历链表<br>pop: 找到哈希值然后把链表表头删掉  table[hash(key)] &#x3D; table[hash(key)].next<br>+++</li>\n</ul>\n</li>\n<li><p>Functional style: 函数式风格</p>\n<ul>\n<li>To keep $\\sigma_1$ in pristine condition while creating create $\\sigma_2$ and $\\sigma_3$<br>+++info 方法：<br>如果依旧用哈希，每次要复制一遍哈希表，开销太大了，不现实<br><img data-src=\"/f2.jpg\"><br>所以用persistent BST<br><img data-src=\"/f1.jpg\"><br>先遍历二叉搜索树找到要插入的位置，然后对于插入节点把它从根节点到它全都复制一遍然后插入<br>+++</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Tiger编译器中的符号\"><a href=\"#Tiger编译器中的符号\" class=\"headerlink\" title=\"Tiger编译器中的符号\"></a>Tiger编译器中的符号</h2><p>对链表进行lookup的时候每一次都要进行string compare，开销是很大的。所以使用新的数据结构将符号对象关联到一个整数上，因此对于任意给定字符串的所有不同出现，都会被转换成同一个符号对象。<br>Symbol的实现：通过hash函数将字符串映射到一个symbol对象上<br>SymbolTable的实现：beginScope()和endScope()的实现</p>\n<ul>\n<li>beginScope()：添加一个marksym</li>\n<li>endScope()：从符号表中不断pop直到marksym</li>\n<li>引入一个 辅助栈(Auxiliary stack) 来维护<ul>\n<li>符号入栈时，会将binding联动地插入对应bucket的链表头</li>\n<li>弹出栈顶符号时，对应bucket的链表头也会联动地被移除</li>\n<li>beginScope: 压入一个特殊标记到辅助栈中</li>\n<li>endScope: 一直弹出符号直到弹出了一个特殊标记</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"类型检查\"><a href=\"#类型检查\" class=\"headerlink\" title=\"类型检查\"></a>类型检查</h2><h3 id=\"哪些类型表达式是合法-非法的\"><a href=\"#哪些类型表达式是合法-非法的\" class=\"headerlink\" title=\"哪些类型表达式是合法&#x2F;非法的\"></a>哪些类型表达式是合法&#x2F;非法的</h3><p>Tiger的类型系统：</p>\n<ul>\n<li>两种primitive type: int, string</li>\n<li>两种constructed type: records, arrays</li>\n</ul>\n<p>文法</p>\n<ol>\n<li>typec → type type-id &#x3D; ty<ul>\n<li>这表示定义一个类型。<code>typec</code> 是一个类型定义的开始，它由关键字 <code>type</code>、一个类型标识符 <code>type-id</code> 和一个等号 <code>=</code> 后跟类型定义 <code>ty</code> 组成。</li>\n</ul>\n</li>\n<li>ty → type-id<ul>\n<li>这表示类型 <code>ty</code> 可以直接是一个已定义的类型标识符 <code>type-id</code>。</li>\n</ul>\n</li>\n<li>ty → ‘{’ tyfields ‘}’<ul>\n<li>这表示类型 <code>ty</code> 可以是一个记录（record），由花括号 <code>&#123;&#125;</code> 包围的一系列字段 <code>tyfields</code> 定义。</li>\n</ul>\n</li>\n<li>ty → array of type-id<ul>\n<li>这表示类型 <code>ty</code> 可以是一个数组，由关键字 <code>array of</code> 后跟一个类型标识符 <code>type-id</code> 定义。</li>\n</ul>\n</li>\n<li>tyfields → ε<ul>\n<li>这表示字段列表 <code>tyfields</code> 可以为空（ε 表示空串）。</li>\n</ul>\n</li>\n<li>tyfields → id: type-id {, id:type-id}<ul>\n<li>这表示字段列表 <code>tyfields</code> 由一个或多个字段组成，每个字段由一个标识符 <code>id</code> 和冒号 <code>:</code> 后跟一个类型标识符 <code>type-id</code> 定义，多个字段之间用逗号 <code>,</code> 分隔。</li>\n</ul>\n</li>\n</ol>\n<p>示例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let type a = &#123;x: int; y: int&#125;</span><br><span class=\"line\">    type b = a</span><br><span class=\"line\">    var i : a := ...</span><br><span class=\"line\">    var j : b := ...</span><br><span class=\"line\">in i := j</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"类型等价\"><a href=\"#类型等价\" class=\"headerlink\" title=\"类型等价\"></a>类型等价</h3><ul>\n<li>Name equivalence (NE): 必须声明是同一个类型才是同一类型</li>\n<li>Structure equivalence (SE): 如果两个类型的结构完全相同（即它们由相同的构造器以相同的顺序组成），那么它们就被认为是等价的，即使它们的名字不同</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type A = &#123;x: int; y: int&#125;</span><br><span class=\"line\">type B = &#123;x: int; y: int&#125; </span><br></pre></td></tr></table></figure>\n<p>Tiger用的是NE<br>在Tiger编程语言中，存在两个独立的命名空间：一个用于类型（Types），另一个用于函数和变量（Functions and Variables）。所以类型和函数&#x2F;变量可以存在相同的名字，但是函数和变量不能存在相同的名字。<br>所以需要两个env</p>\n<ul>\n<li>Type env<ul>\n<li>symbol -&gt; Ty_ty</li>\n</ul>\n</li>\n<li>Value env<ul>\n<li>对于变量，symbol -&gt; Ty_ty</li>\n<li>对于函数，symbol -&gt; struct{Ty_tyList formals, Ty_ty results}</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"类型检查的rule\"><a href=\"#类型检查的rule\" class=\"headerlink\" title=\"类型检查的rule\"></a>类型检查的rule</h3><p>类型检查分为两部分:</p>\n<ul>\n<li>Type-checking expressions: 对于每个表达式，根据当前的Type和Value环境来确定其类型，并检查是否符合语言的类型规则</li>\n<li>Type-checking declarations: 在Tiger语言中声明只可能在let语句中出现<br>好像就是讲了transExp, transDec, transVar，AST递归检查每个节点的类型然后一层一层往上传再检查</li>\n</ul>\n",
            "tags": [
                "语义分析"
            ]
        },
        {
            "id": "http://example.com/2025/03/29/computer-science/compile-principles/ch4/",
            "url": "http://example.com/2025/03/29/computer-science/compile-principles/ch4/",
            "title": "抽象语法",
            "date_published": "2025-03-28T16:00:00.000Z",
            "content_html": "",
            "tags": [
                "抽象语法"
            ]
        },
        {
            "id": "http://example.com/2025/03/23/computer-science/compile-principles/ch3/",
            "url": "http://example.com/2025/03/23/computer-science/compile-principles/ch3/",
            "title": "语法分析",
            "date_published": "2025-03-22T16:00:00.000Z",
            "content_html": "<h1 id=\"语法分析\"><a href=\"#语法分析\" class=\"headerlink\" title=\"语法分析\"></a>语法分析</h1><h2 id=\"CFG\"><a href=\"#CFG\" class=\"headerlink\" title=\"CFG\"></a>CFG</h2><p>见计算理论<br>Parse tree</p>\n<h3 id=\"Ambiguous-grammars\"><a href=\"#Ambiguous-grammars\" class=\"headerlink\" title=\"Ambiguous grammars\"></a>Ambiguous grammars</h3><h2 id><a href=\"#\" class=\"headerlink\" title></a></h2>",
            "tags": [
                "语法分析"
            ]
        },
        {
            "id": "http://example.com/2025/03/22/computer-science/compile-principles/ch2/",
            "url": "http://example.com/2025/03/22/computer-science/compile-principles/ch2/",
            "title": "词法分析",
            "date_published": "2025-03-21T16:00:00.000Z",
            "content_html": "<h1 id=\"Ch2-词法分析\"><a href=\"#Ch2-词法分析\" class=\"headerlink\" title=\"Ch2 词法分析\"></a>Ch2 词法分析</h1><blockquote>\n<p>把input分解成一个个token</p>\n</blockquote>\n<h2 id=\"Regular-Expression\"><a href=\"#Regular-Expression\" class=\"headerlink\" title=\"Regular Expression\"></a>Regular Expression</h2><ul>\n<li>Language: a set of strings</li>\n<li>String: a finite sequence of characters<blockquote>\n<p>Regular Experssion Notations:<br><img data-src=\"/image-1.png\"></p>\n</blockquote>\n</li>\n</ul>\n<p>:::info<br>DFA, NFA相关 见计算理论<br>:::</p>\n<h2 id=\"RE转NFA\"><a href=\"#RE转NFA\" class=\"headerlink\" title=\"RE转NFA\"></a>RE转NFA</h2><p>:::info 方法：</p>\n<ol>\n<li>画出初始态和终态</li>\n<li>分裂规则：<br><img data-src=\"/image-2.jpg\"><br>:::</li>\n</ol>\n<h2 id=\"NFA转DFA\"><a href=\"#NFA转DFA\" class=\"headerlink\" title=\"NFA转DFA\"></a>NFA转DFA</h2><p>从初始状态的闭包开始，每次根据\\epsilon和当前状态的闭包，得到下一个状态的闭包，直到得到终态的闭包。</p>\n<p>+++info example<br>;;;id3 题目<br>:chestnut:<br>把这个NFA转成等价的DFA<br><img data-src=\"/image-3.png\"><br>;;;<br>;;;id3 答案<br>初态的闭包是1、2、6，1、2、6经过a可以转移到3、7，因为有\\epsilon转移，所以3、7的闭包是3、4、7、8，同理3、4、7、8经过b可以到5、8，由于8是终态，把所有包含8的圆圈画成终态的环。<br><img data-src=\"/image-4.png\"><br>;;;<br>+++</p>\n<h2 id=\"最小化DFA\"><a href=\"#最小化DFA\" class=\"headerlink\" title=\"最小化DFA\"></a>最小化DFA</h2><p>含义：</p>\n<ol>\n<li>没有多余状态：</li>\n</ol>\n<ul>\n<li>从这个状态没有通路到达终态</li>\n<li>从开始状态出发，任何输入串也不能到达的那个状态</li>\n</ul>\n<ol start=\"2\">\n<li>没有两个状态相互等价<br>:::info 方法：</li>\n<li>多余状态直接删除<br><img data-src=\"/image-5.png\"></li>\n<li>合并等价状态</li>\n</ol>\n<ul>\n<li>将状态分为终态和非终态两个集合</li>\n<li>遍历每个集合，如果经过转换到达的状态都在当前集合里，则不用分，否则划分子集，直到划分不了为止</li>\n<li>:chestnut: 例子</li>\n<li><img data-src=\"/image-6.png\"><br>:::</li>\n</ul>\n",
            "tags": [
                "词法分析"
            ]
        },
        {
            "id": "http://example.com/2025/03/21/computer-science/compile-principles/ch1/",
            "url": "http://example.com/2025/03/21/computer-science/compile-principles/ch1/",
            "title": "Introduction",
            "date_published": "2025-03-20T16:00:00.000Z",
            "content_html": "<blockquote>\n<p>ZJU 2025春夏编译原理 学习笔记</p>\n<p>主要基于虎书（<em>Modern Compiler Implementation in C</em>, Andrew W. Appel）和好多老师的ppt（ldm, yps），还有lzx的智云</p>\n</blockquote>\n<h1 id=\"CH1-Introduction\"><a href=\"#CH1-Introduction\" class=\"headerlink\" title=\"CH1 Introduction\"></a>CH1 Introduction</h1><ul>\n<li>Two Important Concepts<ul>\n<li>Phases（阶段）</li>\n<li>Interfaces（接口）</li>\n</ul>\n</li>\n</ul>\n<p>方框里的是phase，中间的是interface<br><img data-src=\"/image.png\"><br>各个阶段的描述<br><img data-src=\"/image-1.png\"><img data-src=\"/image-2.png\"></p>\n",
            "tags": [
                "编译原理"
            ]
        }
    ]
}