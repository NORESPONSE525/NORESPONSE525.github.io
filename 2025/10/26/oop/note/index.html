



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="NoResponse's Blog" href="http://example.com/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="NoResponse's Blog" href="http://example.com/atom.xml" />
<link rel="alternate" type="application/json" title="NoResponse's Blog" href="http://example.com/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="C++" />


<link rel="canonical" href="http://example.com/2025/10/26/oop/note/">



  <title>
C++八股 - C++ |
NoResponse's Blog = NoResponse's Blog</title>
<meta name="generator" content="Hexo 7.3.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">C++八股
  </h1>
  
<div class="meta">
  <span class="item" title="Created: 2025-10-26 00:00:00">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">Posted on</span>
    <time itemprop="dateCreated datePublished" datetime="2025-10-26T00:00:00+08:00">2025-10-26</time>
  </span>
  <span class="item" title="Symbols count in article">
    <span class="icon">
      <i class="ic i-pen"></i>
    </span>
    <span class="text">Symbols count in article</span>
    <span>9.8k</span>
    <span class="text">words</span>
  </span>
  <span class="item" title="Reading time">
    <span class="icon">
      <i class="ic i-clock"></i>
    </span>
    <span class="text">Reading time</span>
    <span>9 mins.</span>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">NoResponse's Blog</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
          <img src="/images/bg11.jpg">
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">Home</a></span><i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/oop/" itemprop="item" rel="index" title="In C++"><span itemprop="name">C++</span></a>
<meta itemprop="position" content="1" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/26/oop/note/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/asuka.jpg">
    <meta itemprop="name" content="NoResponse">
    <meta itemprop="description" content=", 成分复杂的CSer from ZJU">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="NoResponse's Blog">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <ol>
<li>
<p>面向对象 vs 面向过程<br>
面向对象三大特性：封装、继承、多态<br>
 c++ 不是完全面向对象的语言<br>
封装：把数据和方法打包成一个类，隐藏实现细节，只提供接口<br>
继承：子类继承父类的属性和方法，子类可以扩展父类的功能，实现代码复用<br>
多态：在运行时，根据对象的实际类型，调用对应的函数。主要通过虚函数和继承实现</p>
</li>
<li>
<p>C++ 编译过程<br>
预处理 -&gt; 编译 -&gt; 汇编 -&gt; 链接<br>
预处理：预处理指令、宏定义、包含文件 (处理 #include, #define, 条件编译等)<br>
 编译：把源代码编译成汇编代码 (将 .cpp 转为 .s)<br>
 汇编：把汇编代码编译成机器码<br>
链接：把多个对象文件链接成可执行文件 (将多个目标文件和库合并成可执行文件)<br>
<mark> 第三方库就是在第 4 步 —— 链接（Linking）阶段加入的</mark><br>
在 链接阶段，通过 -lxxx（如 -lcurl）告诉链接器：“我要用这个库”，然后链接器去找到对应的 静态库（.a 或 .lib）或动态库（.so 或 .dll）<br>
静态库在在编译过程中（链接阶段）被载入可执行程序，生成的可执行文件体积较大<br>
动态库是在运行时才载入内存，但更新库后需要重新编译。<mark>动态库是运行时库</mark></p>
</li>
<li>
<p>静态链接和动态链接<br>
静态链接：把所有用到的库文件都链接到可执行文件中，编译速度慢，但运行速度快<br>
动态链接：把所有用到的库文件都放到一个单独的文件中，运行时再加载，编译速度快，但运行速度慢</p>
</li>
<li>
<p>静态多态（编译时多态） 和 动态多态（运行时多态）</p>
</li>
</ol>
<ul>
<li>动态多态（Dynamic Polymorphism）—— 运行时多态<br>
这是通过 继承 + 虚函数（virtual function） 实现的。动态多态是通过虚函数重写实现的，是在运行期间确定的多态，是一种<mark>晚绑定</mark>机制（或<mark>动态绑定</mark>），在运行期间才能确定调用哪一个函数</li>
</ul>
<blockquote>
<p>基类中的虚函数：使用 virtual 关键字声明。<br>
派生类重写（override）虚函数。<br>
通过基类指针或引用调用虚函数。<br>
必须通过 基类指针或引用 调用虚函数，涉及虚函数表（ <code>vtable</code> ）和虚指针（ <code>vptr</code> ）</p>
</blockquote>
<div class="note info">
<p>虚函数如何实现晚绑定？<br>
每个有虚函数的类有一个 虚函数表（vtable），存函数指针。<br>
每个对象有一个 虚指针（vptr），指向自己的 vtable。<br>
调用虚函数时：<br>
通过对象的 vptr 找到 vtable<br>
 在 vtable 中查找对应函数地址<br>
调用该函数<br>
这个过程在运行时完成，所以是晚绑定。</p>
</div>
<ul>
<li>静态多态（Static Polymorphism）—— 编译时多态<br>
在编译期就确定了调用哪个函数，不涉及运行时开销，属于 “<mark>早绑定</mark>（Early Binding）”</li>
</ul>
<blockquote>
<p>函数重载（Function Overloading）<br>
运算符重载（Operator Overloading）<br>
函数模板（Function Templates）</p>
</blockquote>
<figure class="highlight c++"><figcaption><span>例子</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 函数重载</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Integer: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Double: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;String: &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 函数模板（泛型）</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printGeneric</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Generic: &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 运算符重载</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="type">const</span> Point&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(x + other.x, y + other.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">42</span>);           <span class="comment">// 调用 print(int)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3.14</span>);         <span class="comment">// 调用 print(double)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>);      <span class="comment">// 调用 print(string)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printGeneric</span>(<span class="number">100</span>);   <span class="comment">// 编译时生成 printGeneric&lt;int&gt;</span></span><br><span class="line">    <span class="built_in">printGeneric</span>(<span class="number">2.5</span>);   <span class="comment">// 生成 printGeneric&lt;double&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>, <span class="title">p2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    Point p3 = p1 + p2;  <span class="comment">// 使用重载的 +</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Point: (&quot;</span> &lt;&lt; p<span class="number">3.</span>x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p<span class="number">3.</span>y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>必须通过指针或引用调用 才能触发多态。如果直接用对象调用，会是静态绑定。<br>
想用多态，必须用基类指针或基类引用去操作派生类对象</li>
</ol>
<figure class="highlight c++"><figcaption><span>例子</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal speaks&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Dog barks: 汪汪！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过指针调用 → 触发多态（动态绑定）</li>
</ul>
<figure class="highlight c++"><figcaption><span>1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog dog;</span><br><span class="line">    Animal* ptr = &amp;dog;  <span class="comment">// 基类指针指向派生类对象</span></span><br><span class="line"></span><br><span class="line">    ptr-&gt;<span class="built_in">speak</span>();  <span class="comment">// 输出 Dog barks: 汪汪！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过引用调用 → 也触发多态</li>
</ul>
<figure class="highlight c++"><figcaption><span>2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeAnimalSpeak</span><span class="params">(Animal&amp; animal)</span> </span>&#123;</span><br><span class="line">    animal.<span class="built_in">speak</span>();  <span class="comment">// 动态绑定</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog dog;</span><br><span class="line">    <span class="built_in">makeAnimalSpeak</span>(dog);  <span class="comment">// 输出：Dog barks: 汪汪！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>直接对对象调用，静态绑定</li>
</ul>
<figure class="highlight c++"><figcaption><span>3</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog dog;</span><br><span class="line">    Animal a = dog;  <span class="comment">// 把 Dog 对象赋值给 Animal 对象（会发生“对象切片”）</span></span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">speak</span>();  <span class="comment">// 输出 Animal speaks</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>指针 vs 引用<br>
引用是别名，指针是表示地址的变量<br>
引用的特性：</li>
</ol>
<blockquote>
<p>必须初始化，引用定义时必须绑定到一个变量<br>
不能重新绑定，一旦绑定，就不能再指向其他变量<br>
操作即原变量，对引用的所有操作都作用于原变量</p>
</blockquote>
<figure class="highlight c++"><figcaption><span>引用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp; ref;     <span class="comment">// 错误！未初始化</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;</span><br><span class="line">ref = b;      <span class="comment">// 注意：这是赋值！不是重新绑定！a 变成 10，ref 仍绑定 a，此时a 和 ref 都是 10</span></span><br></pre></td></tr></table></figure>
<p>引用的常见用法：</p>
<blockquote>
<p>函数参数传递：传递大对象（如 string、vector）<br>
函数返回值（返回对象本身，支持链式调用）</p>
</blockquote>
<figure class="highlight c++"><figcaption><span>引用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInt</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyInt</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回引用，支持链式赋值</span></span><br><span class="line">    MyInt&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyInt&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;  <span class="comment">// 自赋值检查</span></span><br><span class="line">            value = other.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 返回当前对象的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">MyInt <span class="title">a</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">2</span>)</span>, <span class="title">c</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">a = b = c;  <span class="comment">// 链式赋值：b=c 返回 b 的引用，再赋给 a</span></span><br></pre></td></tr></table></figure>
<div class="note danger">
<p>不能返回局部变量的引用</p>
</div>
<figure class="highlight c++"><figcaption><span>错误</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">getRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> x;  <span class="comment">// 错误！x 是局部变量，函数结束后销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>遍历容器（避免拷贝元素）</p>
</blockquote>
<figure class="highlight c++"><figcaption><span>遍历容器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; names = &#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用引用遍历，避免拷贝字符串</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> string&amp; name : names) &#123;</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或使用 auto&amp;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; name : names) &#123;</span><br><span class="line">    name += <span class="string">&quot; (modified)&quot;</span>;  <span class="comment">// 如果想修改原元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>作为输出参数（替代指针）</p>
</blockquote>
<ol start="7">
<li>const 引用<br>
引用是别名，const 引用是常量别名，不能修改别名指向的变量</li>
</ol>
<figure class="highlight c++"><figcaption><span>const引用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; cref = x;  <span class="comment">// cref 是 x 的常引用</span></span><br><span class="line">cref = <span class="number">20</span>;            <span class="comment">// 错误！不能通过 cref 修改 x</span></span><br></pre></td></tr></table></figure>
<p>可以用来绑定临时对象（延长生命周期）</p>
<figure class="highlight c++"><figcaption><span>常引用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3.14</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span>&amp; r = <span class="built_in">getValue</span>();  <span class="comment">// 合法！临时对象生命周期延长到 r 结束</span></span><br><span class="line">cout &lt;&lt; r;  <span class="comment">// 输出 3.14</span></span><br></pre></td></tr></table></figure>
<p>getValue () 的值在表达式结束就应该销毁了，但是当一个 const 引用绑定到临时对象时，这个临时对象的生命周期会被 “延长”，直到引用 r 结束为止。<br>
用法：</p>
<blockquote>
<p>避免不必要的拷贝</p>
</blockquote>
<figure class="highlight c++"><figcaption><span>引用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> string&amp; s = <span class="string">&quot;hello&quot;</span>;  <span class="comment">// 不拷贝字符串</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>支持函数链式调用</p>
</blockquote>
<figure class="highlight c++"><figcaption><span>引用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> string&amp; result = <span class="built_in">getPrefix</span>() + <span class="built_in">getName</span>() + <span class="built_in">getSuffix</span>();</span><br><span class="line"><span class="comment">// 临时 string 对象被 const 引用延长生命周期</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>STL 中使用</p>
</blockquote>
<figure class="highlight c++"><figcaption><span>STL</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : vec) &#123; ... &#125;  <span class="comment">// 避免拷贝，安全高效</span></span><br></pre></td></tr></table></figure>
<ol start="8">
<li>左值引用 vs 右值引用<br>
左值：有名字、能取地址的变量，可以放在赋值号左边，生命周期较长<br>
右值：临时变量，不能取地址，生命周期较短，通常在表达式中 “用完就扔”</li>
</ol>
<figure class="highlight c++"><figcaption><span>右值</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>;                <span class="comment">// 字面量，右值</span></span><br><span class="line">x + <span class="number">1</span>;             <span class="comment">// 表达式结果，右值</span></span><br><span class="line"><span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>);   <span class="comment">// 临时 string 对象，右值</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>右值引用（T&amp;&amp;）就是一种可以绑定到右值（临时对象）的引用。</p>
</blockquote>
<figure class="highlight c++"><figcaption><span>右值引用</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型&amp;&amp; 右值引用名 = 右值;</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; rref = <span class="number">10</span>;           <span class="comment">// 10 是右值，rref 是它的右值引用</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; rref2 = <span class="number">5</span> + <span class="number">3</span>;       <span class="comment">// 表达式结果是右值</span></span><br><span class="line">string&amp;&amp; sref = <span class="built_in">string</span>(<span class="string">&quot;临时字符串&quot;</span>);  <span class="comment">// 绑定临时 string 对象</span></span><br></pre></td></tr></table></figure>
<p>用法：对临时变量移动构造，避免深拷贝</p>
<figure class="highlight c++"><figcaption><span>移动构造</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std:move(x) 将左值转换为右值引用，触发移动语义</span></span><br><span class="line"><span class="function">MyString <span class="title">s1</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">MyString s2 = std::<span class="built_in">move</span>(s1);  <span class="comment">// 告诉编译器：“s1 可以被移动了”</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; s<span class="number">1.</span>data;  <span class="comment">// 可能是 nullptr！s1 处于“有效但不可用”状态</span></span><br></pre></td></tr></table></figure>
<ol start="9">
<li>继承</li>
</ol>
<figure class="highlight c++"><figcaption><span>继承</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(string n) : <span class="built_in">name</span>(n) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123; cout &lt;&lt; name &lt;&lt; <span class="string">&quot; 在吃东西&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dog 继承 Animal，继承方式为 public</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(string n) : <span class="built_in">Animal</span>(n) &#123;&#125;  <span class="comment">// 调用基类构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123; cout &lt;&lt; name &lt;&lt; <span class="string">&quot; 汪汪叫！&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Dog <span class="title">d</span><span class="params">(<span class="string">&quot;小黄&quot;</span>)</span></span>;</span><br><span class="line">    d.<span class="built_in">eat</span>();   <span class="comment">// 继承自 Animal</span></span><br><span class="line">    d.<span class="built_in">bark</span>();  <span class="comment">// Dog 自己的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>| — | — | — | — |<br>
| 继承方式 | 基类 public 成员 | 基类 protected 成员 | 基类 private 成员 |<br>
|public | 在派生类中仍是 public | 在派生类中是 protected | 不可访问 |<br>
|protected | 在派生类中是 protected | 在派生类中是 protected | 不可访问 |<br>
|private | 在派生类中是 private | 在派生类中是 private | 不可访问 |</p>
<p>继承中的构造与析构顺序</p>
<blockquote>
<p>构造顺序：<br>
基类构造函数<br>
成员对象构造函数（按声明顺序）<br>
派生类构造函数<br>
析构顺序：与构造相反<br>
派生类析构函数<br>
成员对象析构函数（按声明逆序）<br>
基类析构函数</p>
</blockquote>
<figure class="highlight c++"><figcaption><span>继承中的构造与析构顺序</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123; cout &lt;&lt; <span class="string">&quot;Base 构造\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123; cout &lt;&lt; <span class="string">&quot;Base 析构\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Member</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Member</span>() &#123; cout &lt;&lt; <span class="string">&quot;Member 构造\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">Member</span>() &#123; cout &lt;&lt; <span class="string">&quot;Member 析构\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    Member m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123; cout &lt;&lt; <span class="string">&quot;Derived 构造\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; cout &lt;&lt; <span class="string">&quot;Derived 析构\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br>
Base 构造<br>
 Member 构造<br>
 Derived 构造<br>
 Derived 析构<br>
 Member 析构<br>
 Base 析构</p>
<p>继承是实现  <code>动态多态</code>  的基础。<br>
条件：</p>
<ul>
<li>基类有  <code>virtual</code>  函数</li>
<li>派生类  <code>override</code>  它</li>
<li>通过  <code>基类指针或引用</code>  调用</li>
</ul>
<blockquote>
<p>继承类不能访问基类的私有成员<br>
构造函数不能继承，C++11 起支持  <code>using Base::Base;</code>  继承构造函数<br>
析构函数应为虚函数：如果类可能被继承，析构函数必须是  <code>virtual</code> ，否则  <code>delete基类指针</code> 会只调用基类析构，导致派生类资源泄漏</p>
</blockquote>
<div class="note info">
<p>多重继承</p>
</div>
<p><mark>如果一个类可能被继承（作为基类），那么它的析构函数就应该声明为  <code>virtual</code> </mark><br>
 否则，当用基类指针（或引用）删除派生类对象时，派生类的析构函数不会被调用，造成资源泄漏<br>
原因：virtual 让析构函数变成动态绑定，delete 时，程序会通过虚函数表（vtable）找到实际对象的类型</p>
<ol start="10">
<li>为什么构造函数不能是虚函数？<br>
虚函数依赖对象的 vptr<br>
 构造函数执行时，对象还没完全构造，vptr 还没初始化<br>
每个有虚函数的类，编译器会生成一个 虚函数表（vtable），里面存着虚函数的地址。<br>
每个对象内部有一个虚指针（vptr），指向自己的 vtable。<br>
调用虚函数时：<br>
对象 -&gt; vptr -&gt; vtable -&gt; 找到函数地址 -&gt; 调用</li>
</ol>
<ul>
<li>构造函数执行时：</li>
</ul>
<figure class="highlight c++"><figcaption><span>例子</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Animal sound\n&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">Animal</span>() &#123;  <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="comment">// 在这里，vptr 被设置为指向 Animal 的 vtable</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;汪汪！\n&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">Dog</span>() &#123;  <span class="comment">// Dog 的构造函数</span></span><br><span class="line">        <span class="comment">// 在这里，vptr 被更新为指向 Dog 的 vtable</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调用 Dog dog;<br>
 先调用 Animal 的构造函数<br>
此时，dog 对象的 vptr 被初始化为指向 Animal 的 vtable<br>
 再调用 Dog 的构造函数<br>
 vptr 被更新为指向 Dog 的 vtable</p>
<div class="note danger">
<p>虚拟构造函数（后面在学）</p>
</div>
<ol start="11">
<li>重载（Overload）、重写（Override）、隐藏（Hiding）<br>
Overload: 同一个作用域（通常是同一个类），函数名相同，参数列表不同（类型、个数、顺序），返回类型可以不同（但不能仅靠返回类型区分）<br>
Override: 发生在继承关系中，基类函数必须是 virtual，函数名、参数列表、返回类型（或协变）完全相同，派生类中使用 override<br>
Hiding: 两种情况① 函数名相同，参数不同；② 函数名相同，但基类函数不是 virtual</li>
</ol>
<figure class="highlight c++"><figcaption><span>隐藏</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal speak&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">(string msg)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal says: &quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;  <span class="comment">// ✅ 重写 speak()</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Dog barks&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意：speak(string) 被隐藏了！</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Dog d;</span><br><span class="line">d.<span class="built_in">speak</span>();           <span class="comment">// 输出：Dog barks</span></span><br><span class="line"><span class="comment">// d.speak(&quot;hello&quot;); // 编译错误！speak(string) 被隐藏</span></span><br></pre></td></tr></table></figure>
<p>解除隐藏：添加  <code>using Base::speak;</code></p>
<ol start="12">
<li>深拷贝浅拷贝<br>
深拷贝复制相同大小的内容到堆区，浅拷贝把源对象的指针赋给目标对象，多个对象的指针会指向同一块内存，容易导致双重释放</li>
</ol>
<p>类里面有动态分配的资源比如 <code>int*</code> ,  <code>char*</code>  必须进行深拷贝：</p>
<ul>
<li>析构函数</li>
<li>构造函数和拷贝构造需要手动实现深拷贝（比如 strcpy）</li>
<li><mark>重载赋值运算符</mark></li>
</ul>
<figure class="highlight c++"><figcaption><span>深拷贝</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* data;  <span class="comment">// 指向堆上的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 1️⃣ 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">nullptr</span> || str[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            data = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">            data[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(data, str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2️⃣ 析构函数：释放资源</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;  <span class="comment">// 释放堆内存</span></span><br><span class="line">        data = <span class="literal">nullptr</span>; <span class="comment">// 防止悬空（可选）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3️⃣ 拷贝构造函数：深拷贝</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> MyString&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (other.data == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            data = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.data) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(data, other.data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4️⃣ 拷贝赋值运算符：深拷贝赋值</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyString&amp; other) &#123;</span><br><span class="line">        <span class="comment">// 自我赋值检查</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先释放旧资源</span></span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分配新内存，深拷贝</span></span><br><span class="line">        <span class="keyword">if</span> (other.data == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            data = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.data) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(data, other.data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助函数：打印</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; (data ? data : <span class="string">&quot;null&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="13">
<li>
<p>拷贝构造参数不是引用行吗？<br>
拷贝构造的参数不是引用会导致无限递归，加 const 是为了避免通过形参修改实参</p>
</li>
<li>
<p>堆和栈的区别？<br>
堆是由程序员手动申请和释放的，可以使用 new 和 malloc 申请，释放使用 delete 和 free。内存空间较大，从低地址到高地址，访问速度较慢，有碎片问题，适合用于大对象、动态数组等<br>
栈由编译器自动分配和释放，内存空间较小，从高地址到低地址，访问速度快，无碎片问题，适合用于局部变量、函数参数、返回地址</p>
</li>
</ol>
<ul>
<li>为什么栈快，堆慢？<br>
栈：内存分配只是移动栈指针（esp），是 CPU 指令级操作，极快。<br>
堆：需要调用操作系统 API，查找合适的内存块，维护空闲链表，效率较低。</li>
</ul>
<ol start="15">
<li>内联函数<br>
请求编译器将函数体直接插入到调用处的机制，避免函数调用的开销<br>
但是只是对编译器的建议，编译器不一定会实现<br>
一般来说递归函数不适合内联，因为递归调用会生成临时变量，这些变量在函数退出时会被销毁，内联函数的临时变量会一直存在，导致内存泄漏；虚函数也不适合内联，内联函数在编译的时候确定代码，但虚函数是运行时多态</li>
</ol>
<ul>
<li>使用 <code>inline</code>  关键字</li>
<li>类内定义函数自动内联<br>
内联函数比宏定义安全：</li>
</ul>
<figure class="highlight c++"><figcaption><span>宏定义vs内联函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a,b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="type">int</span> x = <span class="built_in">MAX</span>(i++, j++);  <span class="comment">// i 和 j 可能被 ++ 两次！</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a &gt; b ? a : b; &#125;</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">max</span>(i++, j++);  <span class="comment">// 安全，参数只计算一次</span></span><br></pre></td></tr></table></figure>
<p>定义写在类内不需要显式写 inline 关键字，定义在类外需要</p>
<ol start="16">
<li>
<p>友元</p>
</li>
<li>
<p>智能指针<br>
允许某个函数或类 “突破封装”，访问另一个类的私有（private）和保护（protected）成员。</p>
</li>
</ol>

      <div class="tags">
          <a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C++</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2025-10-28 11:11:11" itemprop="dateModified" datetime="2025-10-28T11:11:11+08:00">2025-10-28</time>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> Donate</button>
  <p>Give me a cup of [coffee]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/images/wechatpay.jpg" alt="NoResponse WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div>
        <img data-src="/images/alipay.jpg" alt="NoResponse Alipay">
        <p>Alipay</p>
      </div>
      
      <div>
        <img data-src="/images/paypal.jpg" alt="NoResponse PayPal">
        <p>PayPal</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>Post author:  </strong>NoResponse <i class="ic i-at"><em>@</em></i>NoResponse's Blog
  </li>
  <li class="link">
    <strong>Post link: </strong>
    <a href="http://example.com/2025/10/26/oop/note/" title="C++八股">http://example.com/2025/10/26/oop/note/</a>
  </li>
  <li class="license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2025/10/15/note/20251015/" itemprop="url" rel="prev" data-background-image="&#x2F;images&#x2F;bg5.jpg" title="20251015力扣刷题笔记">
  <span class="type">Previous Post</span>
  <span class="category"><i class="ic i-flag"></i> 七七八八</span>
  <h3>20251015力扣刷题笔记</h3>
  </a>

    </div>
    <div class="item right">
    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
      </div>
      <div class="related panel pjax" data-title="Related">
        <ul>
          <li class="active"><a href="/2025/10/26/oop/note/" rel="bookmark" title="C++八股">C++八股</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="NoResponse"
      data-src="/images/asuka.jpg">
  <p class="name" itemprop="name">NoResponse</p>
  <div class="description" itemprop="description">成分复杂的CSer from ZJU</div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">44</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">10</span>
        <span class="name">categories</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">35</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL25vcmVzcG9uc2U1MjU=" title="https:&#x2F;&#x2F;github.com&#x2F;noresponse525"><i class="ic i-github"></i></span>
      <span class="exturl item cloudmusic" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTE5OTc3MTA2MzY=" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;1997710636"><i class="ic i-cloud-music"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>About</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a>
  </li>

    
  <li class="item">
    <a href="/links/" rel="section"><i class="ic i-magic"></i>links</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>Random Posts</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="In 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/compiler-principles/" title="In 编译原理">编译原理</a>
</div>

    <span><a href="/2025/06/17/computer-science/compile-principles/ch9/" title="指令选择">指令选择</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="In 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/DS/" title="In 数据结构">数据结构</a>
</div>

    <span><a href="/2025/09/15/computer-science/DS/ch1/" title="ch1">ch1</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="In 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/computer-organization/" title="In 计算机组成">计算机组成</a>
</div>

    <span><a href="/2025/05/14/computer-science/computer-organization/ch2/" title="Ch2">Ch2</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="In 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/DS/" title="In 数据结构">数据结构</a>
</div>

    <span><a href="/2025/10/13/computer-science/DS/ch7/" title="ch7">ch7</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="In 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/OS/" title="In 操作系统">操作系统</a>
</div>

    <span><a href="/2025/10/09/computer-science/OS/ch2/" title="ch2">ch2</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="In 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/DS/" title="In 数据结构">数据结构</a>
</div>

    <span><a href="/2025/10/10/computer-science/DS/ch5/" title="ch5">ch5</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="In 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/compiler-principles/" title="In 编译原理">编译原理</a>
</div>

    <span><a href="/2025/03/21/computer-science/compile-principles/ch1/" title="Introduction">Introduction</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="In 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/computer-organization/" title="In 计算机组成">计算机组成</a>
</div>

    <span><a href="/2025/08/01/computer-science/computer-organization/ch4/" title="Ch4">Ch4</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/AI/" title="In 人工智能">人工智能</a>
</div>

    <span><a href="/2025/05/20/AI/week1/" title="Week1">Week1</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="In 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/DS/" title="In 数据结构">数据结构</a>
</div>

    <span><a href="/2025/10/13/computer-science/DS/ch8/" title="ch8">ch8</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>Recent Comments</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2024 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">NoResponse @ NoResponse's Blog</span>
  </div>
  <div class="count">
    <span class="post-meta-item-icon">
      <i class="ic i-chart-area"></i>
    </span>
    <span title="Symbols count total">164k words</span>

    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="ic i-coffee"></i>
    </span>
    <span title="Reading time total">2:29</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2025/10/26/oop/note/',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,
    copyright: 'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
