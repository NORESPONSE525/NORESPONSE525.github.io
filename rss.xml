<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>NoResponse&#39;s Blog</title>
        <link>http://example.com</link>
        <description>成分复杂的CSer from ZJU</description>
        <language>en</language>
        <pubDate>Fri, 15 Aug 2025 00:00:00 +0800</pubDate>
        <lastBuildDate>Fri, 15 Aug 2025 00:00:00 +0800</lastBuildDate>
        <category>软件工程</category>
        <category>人工智能</category>
        <category>计算机网络</category>
        <category>计算机组成</category>
        <category>数据的表示与运算</category>
        <category>存储系统</category>
        <category>总线</category>
        <category>CPU</category>
        <category>指令系统</category>
        <category>错题</category>
        <category>Liveness Analysis</category>
        <category>编译原理</category>
        <category>I/O</category>
        <category>词法分析</category>
        <category>Register Allocation</category>
        <category>抽象语法</category>
        <category>语法分析</category>
        <category>语义分析</category>
        <category>活动记录</category>
        <category>Basic Blocks and Traces</category>
        <category>中间代码</category>
        <category>指令选择</category>
        <item>
            <guid isPermalink="true">http://example.com/2025/08/15/computer-science/computer-organization/ch7/</guid>
            <title>Ch7</title>
            <link>http://example.com/2025/08/15/computer-science/computer-organization/ch7/</link>
            <category>I/O</category>
            <pubDate>Fri, 15 Aug 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Ch7-输入-输出系统&#34;&gt;&lt;a href=&#34;#Ch7-输入-输出系统&#34; class=&#34;headerlink&#34; title=&#34;Ch7 输入&amp;#x2F;输出系统&#34;&gt;&lt;/a&gt;Ch7 输入&amp;#x2F;输出系统&lt;/h1&gt;&lt;h2 id=&#34;I-O接口&#34;&gt;&lt;a href=&#34;#I-O接口&#34; class=&#34;headerlink&#34; title=&#34;I&amp;#x2F;O接口&#34;&gt;&lt;/a&gt;I&amp;#x2F;O接口&lt;/h2&gt;&lt;p&gt;inerrface，主机与外设之间的交接界面&lt;/p&gt;
&lt;h3 id=&#34;功能&#34;&gt;&lt;a href=&#34;#功能&#34; class=&#34;headerlink&#34; title=&#34;功能&#34;&gt;&lt;/a&gt;功能&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;进行地址译码和设备选择&lt;/li&gt;
&lt;li&gt;实现主机和外设的通信联络控制&lt;br&gt;解决时序、工作速度不同的问题&lt;/li&gt;
&lt;li&gt;实现数据缓冲&lt;/li&gt;
&lt;li&gt;信号格式的转换&lt;br&gt;电平转换、并&amp;#x2F;串或串&amp;#x2F;并转换、模&amp;#x2F;数或数&amp;#x2F;模转换&lt;/li&gt;
&lt;li&gt;传送控制命令和状态信息&lt;br&gt;CPU通过接口中的命令寄存器发出启动命令给外设，外设就绪是传回Ready状态信息通过接口中的状态寄存器反馈给CPU&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;基本结构&#34;&gt;&lt;a href=&#34;#基本结构&#34; class=&#34;headerlink&#34; title=&#34;基本结构&#34;&gt;&lt;/a&gt;基本结构&lt;/h3&gt;&lt;p&gt;&lt;img data-src=&#34;/f1.jpg&#34;&gt;&lt;br&gt;主机侧通过I&amp;#x2F;O总线与内存、CPU相连。数据缓冲器用来暂存与CPU或内存之间传送的数据信息。状态寄存器用来记录接口和设备的状态信息，控制寄存器用来保存CPU对外设的控制信息&lt;br&gt;状态寄存器和控制寄存器在传送方向是相反的，访问时间上是错开的，所以可以合二为一&lt;br&gt;数据线传送读&amp;#x2F;写数据、状态信息、控制信息、中断类型号&lt;br&gt;地址线传送访问I&amp;#x2F;O接口中的寄存器的地址&lt;br&gt;控制线传送读写控制信号、中断请求、响应信号、仲裁信号、握手信号&lt;br&gt;I&amp;#x2F;O控制逻辑需要对控制寄存器的命令字进行译码，还有收集外设状态到状态寄存器&lt;br&gt;&lt;img data-src=&#34;/f2.jpg&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对上面两个寄存器的访问操作通过I&amp;#x2F;O指令来完成，只能在操作系统内核的底层I&amp;#x2F;O软件中使用，是一种特权指令&lt;br&gt;&lt;img data-src=&#34;/f3.jpg&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;接口类型&#34;&gt;&lt;a href=&#34;#接口类型&#34; class=&#34;headerlink&#34; title=&#34;接口类型&#34;&gt;&lt;/a&gt;接口类型&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;按（外设和接口一侧的）数据传送方式：并行接口、串行接口&lt;/li&gt;
&lt;li&gt;按主机访问I&amp;#x2F;O设备的控制方式：程序查询接口、中断接口、DMA接口&lt;/li&gt;
&lt;li&gt;按功能选择的灵活性：可编程接口、不可编程接口&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;I-O端口及其编址&#34;&gt;&lt;a href=&#34;#I-O端口及其编址&#34; class=&#34;headerlink&#34; title=&#34;I&amp;#x2F;O端口及其编址&#34;&gt;&lt;/a&gt;I&amp;#x2F;O端口及其编址&lt;/h3&gt;&lt;p&gt;I&amp;#x2F;O端口是指I&amp;#x2F;O接口电路中&lt;strong&gt;可被CPU直接访问的寄存器&lt;/strong&gt;，主要有&amp;#x3D;&amp;#x3D;数据端口、状态端口和控制端口&amp;#x3D;&amp;#x3D;。&lt;br&gt;CPU能对数据端口中的数据进行读&amp;#x2F;写操作，但对状态端口中外设的状态只能读，对控制端口只能写&lt;br&gt;每个端口对应一个端口地址，编址方式有与存储器独立编址和统一编址两种&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;独立编址&lt;br&gt;也称I&amp;#x2F;O映射方式，I&amp;#x2F;O端口的地址空间与主存地址空间是两个独立的地址空间&lt;br&gt;需要设置专门的I&amp;#x2F;O指令来表明访问的是I&amp;#x2F;O地址空间，I&amp;#x2F;O指令的地址码给出I&amp;#x2F;O端口号&lt;blockquote&gt;
&lt;p&gt;x86 架构中的 IN 和 OUT 指令&lt;br&gt;IN AL, 0x64    从 I&amp;#x2F;O 端口 0x64 读取一个字节的数据，存入寄存器 AL&lt;br&gt;优点：I&amp;#x2F;O端口数比主存单元数少得多，秩序少量地址线，使得I&amp;#x2F;O端口译码简单，寻址速度更快。使用专门的I&amp;#x2F;O指令，是程序更加清晰&lt;br&gt;缺点：I&amp;#x2F;O指令少，只提供简单的传输操作，灵活性差。CPU需要提供存储器读&amp;#x2F;写、I&amp;#x2F;O设备读写两组控制信号，增大了控制的复杂性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;统一编址&lt;br&gt;也称存储器映射方式(Memory-Mapped I&amp;#x2F;O)，无需设置专门的I&amp;#x2F;O指令，用统一的访存指令就可以访问I&amp;#x2F;O端口&lt;blockquote&gt;
&lt;p&gt;riscv就是用Memory-Mapped I&amp;#x2F;O&lt;br&gt;优点：不需要专门的I&amp;#x2F;O指令，CPU访问I&amp;#x2F;O更灵活方便，端口有较大的编址空间。I&amp;#x2F;O访问的保护机制可由虚拟存储管理系统来实现，无需专门设置（内核态才能访问）&lt;br&gt;缺点：端口地址占用了部分主存地址空间。译码电路复杂&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;I-O方式&#34;&gt;&lt;a href=&#34;#I-O方式&#34; class=&#34;headerlink&#34; title=&#34;I&amp;#x2F;O方式&#34;&gt;&lt;/a&gt;I&amp;#x2F;O方式&lt;/h2&gt;&lt;p&gt;程序查询、程序中断、DMA&lt;br&gt;&lt;img data-src=&#34;/f5.jpg&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;程序查询方式-Polling&#34;&gt;&lt;a href=&#34;#程序查询方式-Polling&#34; class=&#34;headerlink&#34; title=&#34;程序查询方式(Polling)&#34;&gt;&lt;/a&gt;程序查询方式(Polling)&lt;/h3&gt;&lt;p&gt;轮询法，程序执行到某个 I&amp;#x2F;O 操作指令时，由操作系统或设备驱动程序发起&lt;br&gt;&lt;img data-src=&#34;/f4.jpg&#34;&gt;&lt;br&gt;程序查询方式分为两类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;独占查询&lt;br&gt;一旦设备启动，CPU就一直持续查询接口状态，CPU话费100%时间用于I&amp;#x2F;O操作，外设和CPU完全串行（忙等待）&lt;/li&gt;
&lt;li&gt;定时查询&lt;br&gt;CPU周期性地查询接口状态，每次总是等到条件满足才进行一个数据的传送，传送完成后返回到用户程序。&lt;br&gt;比如设备每 10ms 产生一个数据，可以设置 5ms 查询一次，这样既能及时读取数据，又不至于过度查询。&amp;#x3D;&amp;#x3D;定时查询的时间间隔与设备的数据传输速率有关。&amp;#x3D;&amp;#x3D;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;程序中断方式&#34;&gt;&lt;a href=&#34;#程序中断方式&#34; class=&#34;headerlink&#34; title=&#34;程序中断方式&#34;&gt;&lt;/a&gt;程序中断方式&lt;/h3&gt;&lt;p&gt;&lt;img data-src=&#34;/f6.jpg&#34;&gt;&lt;br&gt;工作流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;中断请求&lt;br&gt;中断源向CPU发送中断请求信号。中断系统对每个中断源设置中断请求标记触发器&lt;br&gt;可屏蔽中断：通过&lt;code&gt;INTR&lt;/code&gt;线发出的，优先级低，关中断下不被响应&lt;br&gt;不可屏蔽中断：通过&lt;code&gt;NMI&lt;/code&gt;线发出的，优先级最高&lt;/li&gt;
&lt;li&gt;中断响应&lt;br&gt;响应中断的条件。&lt;br&gt;中断判优：多个中断源同时提出请求时通过中断判优逻辑响应一个中断源。&lt;br&gt;一般来说：不可屏蔽中断&amp;gt;可屏蔽中断；在I&amp;#x2F;O传送类终端中，高速设备&amp;gt;低速设备，输入设备&amp;gt;输出设备，实时设备&amp;gt;普通设备&lt;br&gt;CPU响应中断的条件：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;中断源有中断请求&lt;/li&gt;
&lt;li&gt;允许中断及开中断&lt;/li&gt;
&lt;li&gt;一条指令执行完毕（除非是指令执行异常）&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;中断处理&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;中断隐指令：&lt;ul&gt;
&lt;li&gt;关中断（防止在中断处理程序执行期间被其他（同级或低优先级）中断再次打断）&lt;/li&gt;
&lt;li&gt;保护现场（把PC, PSW等压入内核栈）&lt;/li&gt;
&lt;li&gt;引出中断服务程序：硬件向量法和软件查询法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中断向量：硬件提供向量号，中断控制器将该中断对应的向量号放到数据总线上，CPU读取该向量号，CPU使用该向量号作为索引，查找中断向量表（IVT）获取ISR的入口地址&lt;/p&gt;
&lt;p&gt;处理流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关中断&lt;/li&gt;
&lt;li&gt;保存断点&lt;/li&gt;
&lt;li&gt;中断服务程序寻址&lt;/li&gt;
&lt;li&gt;保存现场和屏蔽字&lt;/li&gt;
&lt;li&gt;开中断（允许更高级中断请求得到响应）&lt;/li&gt;
&lt;li&gt;执行ISR&lt;/li&gt;
&lt;li&gt;关中断&lt;/li&gt;
&lt;li&gt;恢复现场和屏蔽字&lt;/li&gt;
&lt;li&gt;开中断，中断返回&lt;br&gt;1-3由硬件自动完成，4-9由ISR完成&lt;blockquote&gt;
&lt;p&gt;为什么要先关再开？&lt;br&gt;确保这个保护现场的操作不会被其他中断打断&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;多重中断和中断屏蔽技术&#34;&gt;&lt;a href=&#34;#多重中断和中断屏蔽技术&#34; class=&#34;headerlink&#34; title=&#34;多重中断和中断屏蔽技术&#34;&gt;&lt;/a&gt;多重中断和中断屏蔽技术&lt;/h4&gt;&lt;p&gt;通过中断屏蔽字寄存器来实现，每个中断源都有一个屏蔽触发器，&amp;#x3D;&amp;#x3D;1表示屏蔽该中断源的请求&amp;#x3D;&amp;#x3D;，0表示可以正常申请&lt;br&gt;&amp;#x3D;&amp;#x3D;屏蔽字中‘1’越多，优先级越高。每个屏蔽字中至少有一个&lt;code&gt;1&lt;/code&gt;(至少要能屏蔽自身的中断)&amp;#x3D;&amp;#x3D;&lt;br&gt;方法：要能屏蔽自身所以主对角线全为1，同时优先级比自身低的中断要屏蔽屏蔽字全填1，其他的填0&lt;/p&gt;
&lt;h3 id=&#34;DMA方式&#34;&gt;&lt;a href=&#34;#DMA方式&#34; class=&#34;headerlink&#34; title=&#34;DMA方式&#34;&gt;&lt;/a&gt;DMA方式&lt;/h3&gt;&lt;p&gt;DMA方式是一种完全由硬件进行组信息传送的控制方式&lt;br&gt;&lt;img data-src=&#34;/f7.jpg&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/f8.jpg&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/f9.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;当I&amp;#x2F;O设备和CPU同时访问主存时，可能发生冲突，DMA与CPU通常采用以下3种方式使用驻村：&lt;br&gt;&lt;img data-src=&#34;/f10.jpg&#34;&gt;&lt;br&gt;周期挪用：&lt;br&gt;一次传一组数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU不访存时：如果CPU当前并不需要访问主存，那么DMA控制器可以直接使用总线进行数据传输，此时不会对CPU的工作造成任何影响。&lt;/li&gt;
&lt;li&gt;CPU正在访存时：如果CPU正在进行主存访问，DMA控制器会等待CPU的当前访问周期结束，然后立即“借用”接下来的一个或几个总线周期来进行自己的数据传输。这种情况下，CPU的访问会被短暂延迟，但通常这种延迟非常短，以至于CPU几乎感觉不到，因此可以认为CPU的正常工作没有受到显著影响。&lt;/li&gt;
&lt;li&gt;CPU与DMA同时请求访存时：在这种情况下，I&amp;#x2F;O设备的访存请求通常具有更高的优先级，这意味着即使CPU也在请求访问主存，DMA控制器也会被优先考虑，从而保证I&amp;#x2F;O设备的数据传输不受阻。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;停止CPU访存&lt;br&gt;优点：控制简单，适用于数据传输速率很高的I&amp;#x2F;O设备实现成组数据的传送&lt;br&gt;缺点：DMA访问主存时，CPU基本上不工作&lt;/li&gt;
&lt;li&gt;周期挪用&lt;br&gt;优点：既实现了I&amp;#x2F;O传送，又较好地发挥了主存与CPU的效率&lt;br&gt;缺点：每挪用一个主存周期，DMA接口都要申请、建立和归还总线周期&lt;/li&gt;
&lt;li&gt;交替访存&lt;br&gt;优点：不需要总线控制权的申请、建立和归还过程，传送效率高&lt;br&gt;缺点：相应的硬件逻辑变得更复杂&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;DMA的传送过程&#34;&gt;&lt;a href=&#34;#DMA的传送过程&#34; class=&#34;headerlink&#34; title=&#34;DMA的传送过程&#34;&gt;&lt;/a&gt;DMA的传送过程&lt;/h4&gt;&lt;p&gt;&lt;img data-src=&#34;/f9.jpg&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;预处理：由CPU初始化DMA控制其中的寄存器、设置传送方式、测试并启动设备&lt;/li&gt;
&lt;li&gt;数据传送：DMA以数据块为基本传送单位。数据传送完全由DMA控制&lt;/li&gt;
&lt;li&gt;后处理：DMA控制器向CPU发送中断请求，CPU处理中断做DMA结束处理（包括校验）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DMA方式和中断方式的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中断需要save context，DMA不需要，除了预处理和后处理其他时候不占用CPU（我觉得DMA方式的预处理和后处理的中断也是需要save context的，只是因为DMA方式中断次数极少，整个数据块只中断一次，所以不需要保存那么多次，所以比较快）&lt;/li&gt;
&lt;li&gt;对中断请求的相应只能发生在每条指令执行结束时，但对DMA请求的相应可以发生在任意一个机器周期结束时(IF, ID, EX…  DMA请求的是总线控制权，不是CPU的执行权。它不关心 CPU正在执行哪条指令，只关心总线是否空闲。只要当前总线周期结束，DMA就可以插空使用)&lt;/li&gt;
&lt;li&gt;中断传送过程需要CPU的干预，DMA传送不需要，数据传输速率高&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优先级：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DMA请求的优先级高于中断请求&lt;/li&gt;
&lt;li&gt;中断方式具有处理异常事件的能力，DMA方式局限于大批数据的传送&lt;/li&gt;
&lt;li&gt;中断方式靠程序传送，DMA方式靠硬件传送&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/08/10/computer-science/computer-organization/ch6/</guid>
            <title>Ch6</title>
            <link>http://example.com/2025/08/10/computer-science/computer-organization/ch6/</link>
            <category>总线</category>
            <pubDate>Sun, 10 Aug 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Ch6-总线&#34;&gt;&lt;a href=&#34;#Ch6-总线&#34; class=&#34;headerlink&#34; title=&#34;Ch6 总线&#34;&gt;&lt;/a&gt;Ch6 总线&lt;/h1&gt;&lt;h2 id=&#34;概述&#34;&gt;&lt;a href=&#34;#概述&#34; class=&#34;headerlink&#34; title=&#34;概述&#34;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;h3 id=&#34;概念&#34;&gt;&lt;a href=&#34;#概念&#34; class=&#34;headerlink&#34; title=&#34;概念&#34;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;总线是一组能为多个部件分时和共享的公共信息传送线路。&amp;#x3D;&amp;#x3D;分时&amp;#x3D;&amp;#x3D;和&amp;#x3D;&amp;#x3D;共享&amp;#x3D;&amp;#x3D;是总线的两个特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分时：同一时刻只允许有一个部件向总线发送信息&lt;/li&gt;
&lt;li&gt;共享：总线上可以挂接多个部件&lt;br&gt;总线设备：按对总线有无控制权分&lt;/li&gt;
&lt;li&gt;主设备：发出总线请求且获得总线控制权的设备&lt;/li&gt;
&lt;li&gt;从设备：被主设备访问的设备，只能响应从这设备发来的各种总线命令&lt;br&gt;特性：机械特性（尺寸、形状）、电气特性（传输方向、有效的电平范围）、功能特性（没跟传输线的功能）、时间特性（信号和时序的关系）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分类&#34;&gt;&lt;a href=&#34;#分类&#34; class=&#34;headerlink&#34; title=&#34;分类&#34;&gt;&lt;/a&gt;分类&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;按功能&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;片内总线（CPU内部的，连接各寄存器以及寄存器和ALU）&lt;/li&gt;
&lt;li&gt;系统总线（连接CPU、主存、I&amp;#x2F;O）。按传输内容又分为数据总线（数据、指令、终端类型号，双向传输）、地址总线（主存单元或IO端口地址，单向传输）、控制总线（clk, rst, 总线请求&amp;#x2F;允许, 中断请求&amp;#x2F;回答, r&amp;#x2F;w…）&lt;/li&gt;
&lt;li&gt;I&amp;#x2F;O总线（将低速的IO和告诉总线分离，常见的有USB&amp;#x2F;PCI）&lt;/li&gt;
&lt;li&gt;通信总线（外部总线，计算机系统之间或计算机系统与其他系统）&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;按时序控制方式&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;同步总线&lt;/li&gt;
&lt;li&gt;异步总线&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;按数据传输方式&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;串行总线（一条双向或两条单向，数据按bit串行顺序传输，适合长距离通信）&lt;/li&gt;
&lt;li&gt;并行总线（有多条双向，容易出现干扰&amp;#x2F;延迟，适合近距离通信）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;系统总线的结构&#34;&gt;&lt;a href=&#34;#系统总线的结构&#34; class=&#34;headerlink&#34; title=&#34;系统总线的结构&#34;&gt;&lt;/a&gt;系统总线的结构&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;单总线结构&lt;br&gt;CPU，主存，IO，都挂在一组（地址、数据、控制）总线上，允许IO之间、IO与主存直接交换信息&lt;br&gt;结构简单、成本低、易于接入新的设备&lt;br&gt;贷款低、负载中、不支持并发传送&lt;br&gt;&lt;img data-src=&#34;/f13.jpg&#34;&gt;&lt;/li&gt;
&lt;li&gt;双总线结构&lt;br&gt;一条主存总线，一条I&amp;#x2F;O总线&lt;br&gt;主存总线支持突发传送，突发传送（Burst Transfer）是一种数据传输方式，它允许在一次地址发送后，连续传输多个数据块，而不需要为每个数据块单独发送地址和控制信号&lt;br&gt;将低速的I&amp;#x2F;O设备分离开来，实现了存储器总线和I&amp;#x2F;O总线的分离&lt;br&gt;需要增加通道等硬件设备&lt;br&gt;&lt;img data-src=&#34;/f14.jpg&#34;&gt;&lt;/li&gt;
&lt;li&gt;三总线结构&lt;br&gt;主存总线、I&amp;#x2F;O总线、直接内存访问(DMA)总线&lt;br&gt;DMA 允许外部设备（如硬盘、网卡、显卡）直接与主存进行数据交换，无需CPU的直接参与和干预,把CPU从繁琐、低效的数据搬运工作中解放出来，让它可以去做更复杂的计算任务&lt;br&gt;优点是提高了I&amp;#x2F;O设备的性能，使其更快地响应命令，提高系统吞吐量；缺点是任意时刻只能使用一种总线，系统工作效率较低（意思是一个设备不能同时使用多个总线，比如主存总线和DMA总线不能同时对主存进行存取）&lt;br&gt;&lt;img data-src=&#34;/f15.jpg&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;常见的总线标准&#34;&gt;&lt;a href=&#34;#常见的总线标准&#34; class=&#34;headerlink&#34; title=&#34;常见的总线标准&#34;&gt;&lt;/a&gt;常见的总线标准&lt;/h3&gt;&lt;p&gt;略&lt;/p&gt;
&lt;h3 id=&#34;总线的性能指标&#34;&gt;&lt;a href=&#34;#总线的性能指标&#34; class=&#34;headerlink&#34; title=&#34;总线的性能指标&#34;&gt;&lt;/a&gt;总线的性能指标&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;总线时钟周期&lt;/li&gt;
&lt;li&gt;总线时钟频率&lt;/li&gt;
&lt;li&gt;总线传输周期：申请、寻址、传输、结束&lt;/li&gt;
&lt;li&gt;总线工作频率：1&amp;#x2F;总线（传输）周期&lt;/li&gt;
&lt;li&gt;总线宽度：通常指数据总线的根数&lt;/li&gt;
&lt;li&gt;总线带宽：最大数据传输速率，B&amp;#x2F;s，带宽 &amp;#x3D; 总线工作频率*（总线宽度&amp;#x2F;8）&lt;/li&gt;
&lt;li&gt;总线复用：一种信号现在不同的时间传输不同的信息，比如地址&amp;#x2F;数据线复用（地址通过数据线传送）&lt;/li&gt;
&lt;li&gt;信号线数：地址总线、数据总线、控制总线数量的总和&lt;br&gt;最主要的性能指标：&amp;#x3D;&amp;#x3D;总线宽度、总线工作频率、总线带宽&amp;#x3D;&amp;#x3D;&lt;br&gt;带宽 &amp;#x3D; 总线工作频率*总线宽度 bits&amp;#x2F;s&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;总线事务和定时&#34;&gt;&lt;a href=&#34;#总线事务和定时&#34; class=&#34;headerlink&#34; title=&#34;总线事务和定时&#34;&gt;&lt;/a&gt;总线事务和定时&lt;/h2&gt;&lt;h3 id=&#34;总线事务&#34;&gt;&lt;a href=&#34;#总线事务&#34; class=&#34;headerlink&#34; title=&#34;总线事务&#34;&gt;&lt;/a&gt;总线事务&lt;/h3&gt;&lt;p&gt;从请求总线到完成总线使用的操作序列称为&lt;strong&gt;总线事务&lt;/strong&gt;，典型的总线事务包括请求操作、仲裁操作、地址传输、数据传输和总线释放&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;请求阶段：主设备（CPU或DMA）发出总线传输请求，获得总线控制权&lt;/li&gt;
&lt;li&gt;仲裁阶段：总选仲裁机构决定将下一个传输周期的总线使用权授予某个申请者&lt;/li&gt;
&lt;li&gt;寻址阶段：传输地址和命令，启动从模块&lt;/li&gt;
&lt;li&gt;传输阶段：主模块和从模块进行数据交换，单向或双向&lt;/li&gt;
&lt;li&gt;释放阶段：主模块有关信息从系统总线上撤除，让出总线使用权、&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数据传送方式：突发方式和非突发方式&lt;br&gt;突发传送：寻址阶段发送的是连续数据单元的首地址，传输阶段传送多个连续单元的数据，每个时钟周期可以传送一个字长的信息（如果总线宽度等于一个字长），一组数据全部传送完毕后再释放总线&lt;br&gt;非突发传送：每个传送周期内都先传送地址，再传送数据，每次只能传输一个字长的数据&lt;/p&gt;
&lt;h3 id=&#34;总线定时&#34;&gt;&lt;a href=&#34;#总线定时&#34; class=&#34;headerlink&#34; title=&#34;总线定时&#34;&gt;&lt;/a&gt;总线定时&lt;/h3&gt;&lt;p&gt;同步、异步、半同步、分离式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;同步定时方式&lt;br&gt;适用于总线较短且部件存取时间比较接近的系统。每个部件或设备发送或接收信息都在固定的总线传送周期中，一个总线的传送周期结束，下一个总线传送周期开始&lt;br&gt;优点：传送速度快，具有较高的传输速率；总线控制逻辑简单。&lt;br&gt;缺点：主从设备属于强制性同步；不能及时进行数据通信的有效性检验，可靠性较差&lt;/li&gt;
&lt;li&gt;异步定时方式&lt;br&gt;依靠传送双方相互制约的“握手”信号来实现定时控制。主设备发出请求，从设备接收到请求后发出回答。&lt;br&gt;优点：总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间的配合。&lt;br&gt;缺点：比同步控制方式稍复杂一些，速度比同步定时方式慢&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;根据“请求”和“回答”的撤销是否互锁分为&lt;ul&gt;
&lt;li&gt;不互锁方式：发出请求不必等回答，一段时间后自动撤销请求信号。收到请求信号后发出回答信号，一段时间后自动撤销回答信号。（速度最快 可靠性最差）&lt;/li&gt;
&lt;li&gt;半互锁方式：发出请求后等待收到回答信号才撤销请求信号。收到请求信号后发出回答信号，一段时间后自动撤销回答信号。&lt;/li&gt;
&lt;li&gt;全互锁方式：发出请求后等待收到回答信号才撤销请求信号，收到请求信号后发出回答，必须获知请求信号撤销之后才撤销回答信号（最可靠 速度最慢）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;异步串行通信的方式一步串行通信的第一位是开始位，表示字符传送的开始。铜芯线上没有数据传送时处于逻辑”1”状态，发出逻辑”0”为开始位在从最低位开始传输信号。发送完字符之后可以发送几奇偶校验（若有），之后发送停止位。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;p&gt;半同步定时方式&lt;br&gt;&lt;img data-src=&#34;/f1.jpg&#34;&gt;&lt;br&gt;保留时钟信号的同时增设Wait响应信号线，Wait&amp;#x3D;1的时候才取数据&lt;br&gt;优点：控制方式比异步简单&lt;br&gt;缺点：时钟频率不能太高&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分离式定时方式&lt;br&gt;将总线事务分解为请求和应答两个子过程。第一个子过程中，主设备发送命令、地址到总线上，发完立即释放总线（第一个字过程很短）。第二个另外以个设备接受命令并发送数据到总线。两个子过程都只有单向信息流，每个设备都变为主设备。&lt;br&gt;&lt;img data-src=&#34;/f2.jpg&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/f3.jpg&#34;&gt;&lt;br&gt;在空闲阶段释放总线使总线可接受其他设备的请求&lt;br&gt;控制复杂，开销大&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/08/10/computer-science/computer-organization/ch5/</guid>
            <title>Ch5</title>
            <link>http://example.com/2025/08/10/computer-science/computer-organization/ch5/</link>
            <category>CPU</category>
            <pubDate>Sun, 10 Aug 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Ch5-中央处理器&#34;&gt;&lt;a href=&#34;#Ch5-中央处理器&#34; class=&#34;headerlink&#34; title=&#34;Ch5 中央处理器&#34;&gt;&lt;/a&gt;Ch5 中央处理器&lt;/h1&gt;&lt;h2 id=&#34;CPU的功能和基本结构&#34;&gt;&lt;a href=&#34;#CPU的功能和基本结构&#34; class=&#34;headerlink&#34; title=&#34;CPU的功能和基本结构&#34;&gt;&lt;/a&gt;CPU的功能和基本结构&lt;/h2&gt;&lt;h3 id=&#34;功能&#34;&gt;&lt;a href=&#34;#功能&#34; class=&#34;headerlink&#34; title=&#34;功能&#34;&gt;&lt;/a&gt;功能&lt;/h3&gt;&lt;p&gt;CPU由运算器和控制器组成，具体功能包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指令控制&lt;/li&gt;
&lt;li&gt;操作控制&lt;/li&gt;
&lt;li&gt;时间控制&lt;/li&gt;
&lt;li&gt;数据加工&lt;/li&gt;
&lt;li&gt;中断处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;基本结构&#34;&gt;&lt;a href=&#34;#基本结构&#34; class=&#34;headerlink&#34; title=&#34;基本结构&#34;&gt;&lt;/a&gt;基本结构&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;运算器：ALU, 暂存器, ACC, GPRs, PSW, 移位寄存器， 计数器…&lt;/li&gt;
&lt;li&gt;控制器：PC, IR, ID, 时序电路，未操作信号发生器…&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;CPU的寄存器&#34;&gt;&lt;a href=&#34;#CPU的寄存器&#34; class=&#34;headerlink&#34; title=&#34;CPU的寄存器&#34;&gt;&lt;/a&gt;CPU的寄存器&lt;/h3&gt;&lt;p&gt;按汇编程序是否可访问分为用户可见寄存器(GPRs, PSW, PC)和用户不可见寄存器(存储器地址寄存器，存储器数据寄存器，IR, 暂存寄存器，累加寄存器，移位寄存器)&lt;br&gt;各寄存器的作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在运算器中：&lt;ul&gt;
&lt;li&gt;GPRs&lt;/li&gt;
&lt;li&gt;ACC: 通用寄存器，用于暂时存放ALU运算的结果&lt;/li&gt;
&lt;li&gt;SR（移位寄存器）：存放操作数且可以移位&lt;/li&gt;
&lt;li&gt;暂存寄存器：暂存从数据总线或通用寄存器送来的操作数，对应用程序员透明&lt;/li&gt;
&lt;li&gt;PSW：保留各种状态信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在控制器中：&lt;ul&gt;
&lt;li&gt;PC: 存放当前指令的地址&lt;/li&gt;
&lt;li&gt;IR: 存放当前指令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;指令执行过程&#34;&gt;&lt;a href=&#34;#指令执行过程&#34; class=&#34;headerlink&#34; title=&#34;指令执行过程&#34;&gt;&lt;/a&gt;指令执行过程&lt;/h2&gt;&lt;h3 id=&#34;指令周期&#34;&gt;&lt;a href=&#34;#指令周期&#34; class=&#34;headerlink&#34; title=&#34;指令周期&#34;&gt;&lt;/a&gt;指令周期&lt;/h3&gt;&lt;p&gt;&amp;#x3D; 取值周期 + 执行周期&lt;br&gt;间址周期在取址和执行之间&lt;br&gt;如果CPU在每条指令结束前都要发中断查询信号 （轮询法），后面要加上中断周期&lt;/p&gt;
&lt;h3 id=&#34;指令周期的数据流&#34;&gt;&lt;a href=&#34;#指令周期的数据流&#34; class=&#34;headerlink&#34; title=&#34;指令周期的数据流&#34;&gt;&lt;/a&gt;指令周期的数据流&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;取址周期&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;PC-&amp;gt;MAR-&amp;gt;地址总线-&amp;gt;存储器&lt;/li&gt;
&lt;li&gt;CU发出读命令-&amp;gt;控制总线-&amp;gt;主存&lt;/li&gt;
&lt;li&gt;主存-&amp;gt;数据总线-&amp;gt;IR&lt;/li&gt;
&lt;li&gt;CU发出控制信号-&amp;gt;PC&amp;#x3D;PC+1&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;间址周期&lt;br&gt;取指结束后，控制单元CU会检查IR中是否有间接地址（操作数有效地址的地址）。若有，CPU执行如下操作：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;IR(或MDR)的间址-&amp;gt;MAR-&amp;gt;地址总线-&amp;gt;主存&lt;/li&gt;
&lt;li&gt;CU发出读命令-&amp;gt;控制总线-&amp;gt;主存&lt;/li&gt;
&lt;li&gt;主存-&amp;gt;数据总线-&amp;gt;MDR（取出有效地址存入MDR）&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;p&gt;执行周期&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;中断周期&lt;br&gt;假设程序断点存入堆栈中，push操作先修改SP再存入（x86采用满递减栈）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;CU控制将SP减1，SP-&amp;gt;MAR-&amp;gt;地址总线-&amp;gt;zhucun1&lt;/li&gt;
&lt;li&gt;CU发出写命令-&amp;gt;控制总线-&amp;gt;主存&lt;/li&gt;
&lt;li&gt;PC-&amp;gt;MDR-&amp;gt;数据总线-&amp;gt;主存（把中断时的PC存入栈中）&lt;/li&gt;
&lt;li&gt;CU将中断服务程序入口地址存入PC&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;指令执行方案&#34;&gt;&lt;a href=&#34;#指令执行方案&#34; class=&#34;headerlink&#34; title=&#34;指令执行方案&#34;&gt;&lt;/a&gt;指令执行方案&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;单周期处理器&lt;br&gt;CPI &amp;#x3D; 1，指令执行周期取决于执行时间最长的指令的执行时间&lt;/li&gt;
&lt;li&gt;多周期处理器&lt;br&gt;CPI &amp;gt; 1,&lt;/li&gt;
&lt;li&gt;流水线处理器&lt;br&gt;理想状态下CPI &amp;#x3D; 1，流水线并行&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数据通路&#34;&gt;&lt;a href=&#34;#数据通路&#34; class=&#34;headerlink&#34; title=&#34;数据通路&#34;&gt;&lt;/a&gt;数据通路&lt;/h2&gt;&lt;h3 id=&#34;功能-1&#34;&gt;&lt;a href=&#34;#功能-1&#34; class=&#34;headerlink&#34; title=&#34;功能&#34;&gt;&lt;/a&gt;功能&lt;/h3&gt;&lt;p&gt;。&lt;/p&gt;
&lt;h3 id=&#34;组成&#34;&gt;&lt;a href=&#34;#组成&#34; class=&#34;headerlink&#34; title=&#34;组成&#34;&gt;&lt;/a&gt;组成&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;组合逻辑&lt;br&gt;译码器，MUX，三态门…&lt;/li&gt;
&lt;li&gt;时序逻辑&lt;br&gt;包含存储信号的记忆单元&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;基本结构-1&#34;&gt;&lt;a href=&#34;#基本结构-1&#34; class=&#34;headerlink&#34; title=&#34;基本结构&#34;&gt;&lt;/a&gt;基本结构&lt;/h3&gt;&lt;p&gt;2种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU内部总线（单总线、多总线）&lt;/li&gt;
&lt;li&gt;专用数据通路&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;CPU内部单总线方式&lt;br&gt;ALU和寄存器连接到一条总线上，性能低&lt;br&gt;单总线的ALU要配合暂存器使用，比如从内存取出来的数据要放在暂存器中，再从暂存器中取数据给ALU&lt;br&gt;&lt;img data-src=&#34;/f1.jpg&#34;&gt;&lt;br&gt;了解每条指令的datapath&lt;/li&gt;
&lt;li&gt;CPU内部多总线方式&lt;br&gt;允许同时在多个总线上传送不同的数据，提高效率&lt;/li&gt;
&lt;li&gt;专用数据通路方式&lt;br&gt;看图说话，没什么好说的&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;数据通路的操作举例&#34;&gt;&lt;a href=&#34;#数据通路的操作举例&#34; class=&#34;headerlink&#34; title=&#34;数据通路的操作举例&#34;&gt;&lt;/a&gt;数据通路的操作举例&lt;/h3&gt;&lt;p&gt;会画图就会&lt;/p&gt;
&lt;h2 id=&#34;控制器的功能和工作原理&#34;&gt;&lt;a href=&#34;#控制器的功能和工作原理&#34; class=&#34;headerlink&#34; title=&#34;控制器的功能和工作原理&#34;&gt;&lt;/a&gt;控制器的功能和工作原理&lt;/h2&gt;&lt;h3 id=&#34;结构和功能&#34;&gt;&lt;a href=&#34;#结构和功能&#34; class=&#34;headerlink&#34; title=&#34;结构和功能&#34;&gt;&lt;/a&gt;结构和功能&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;取指令，指出下一条指令的位置&lt;/li&gt;
&lt;li&gt;译码或测试，产生控制信号&lt;/li&gt;
&lt;li&gt;控制CPU，主存，I&amp;#x2F;O的数据流动方向&lt;br&gt;分为硬布线控制器和微程序控制器&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;硬布线控制器&#34;&gt;&lt;a href=&#34;#硬布线控制器&#34; class=&#34;headerlink&#34; title=&#34;硬布线控制器&#34;&gt;&lt;/a&gt;硬布线控制器&lt;/h3&gt;&lt;p&gt;组合逻辑控制器&lt;br&gt;CU的输入信号来自(1)指令译码器(2)时钟脉冲(3)执行单元的反馈信息&lt;br&gt;比如这种：&lt;br&gt;&lt;img data-src=&#34;/f2.jpg&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;微程序控制器&#34;&gt;&lt;a href=&#34;#微程序控制器&#34; class=&#34;headerlink&#34; title=&#34;微程序控制器&#34;&gt;&lt;/a&gt;微程序控制器&lt;/h3&gt;&lt;p&gt;采用存储逻辑实现，将未操作信号代码化，使没调机器指令转化成一段微程序并存入专门的控制存储器中&lt;br&gt;晚点回来学&lt;/p&gt;
&lt;h2 id=&#34;异常和中断机制&#34;&gt;&lt;a href=&#34;#异常和中断机制&#34; class=&#34;headerlink&#34; title=&#34;异常和中断机制&#34;&gt;&lt;/a&gt;异常和中断机制&lt;/h2&gt;&lt;h3 id=&#34;概念&#34;&gt;&lt;a href=&#34;#概念&#34; class=&#34;headerlink&#34; title=&#34;概念&#34;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;内部产生的意外事件叫异常，是同步的；外部产生的事件叫中断，是异步的&lt;/p&gt;
&lt;h3 id=&#34;分类&#34;&gt;&lt;a href=&#34;#分类&#34; class=&#34;headerlink&#34; title=&#34;分类&#34;&gt;&lt;/a&gt;分类&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;异常：CPU内部执行指令引起的异常事件，比如整除0，溢出，单步跟踪，非法指令，栈溢出，地址越界，缺页等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;Fault故障&lt;br&gt;引起故障的指令启动后、执行结束前检测到的异常事件（所以处理完之后要重新执行该指令或者无法恢复的终止进程）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Trap自陷&lt;br&gt;人为设定的特殊中断机制，最常见的是sys call，还有断点、单步，还有一些条件自陷指令（MIPS的teq, teqi, tne, tnei）等&lt;br&gt;&amp;#x3D;&amp;#x3D;以上两种都属于软件中断&amp;#x3D;&amp;#x3D;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Abort终止&lt;br&gt;执行过程中发生了硬件故障，比如控制器出错、存储器校验错、总线错误等&lt;br&gt;&amp;#x3D;&amp;#x3D;Abort和外中断属于硬件中断&amp;#x3D;&amp;#x3D;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;中断：CPU外部比如I&amp;#x2F;O引起的中断，分为可屏蔽中断和不可屏蔽中断&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可屏蔽中断：可屏蔽中断请求线INTR向CPU发出中断请求，CPU可以设置相应的bit屏蔽&lt;/li&gt;
&lt;li&gt;不可屏蔽中断：通过专门的不可屏蔽中断请求线NMI向CPU发出的中断请求，通常是非常紧急的硬件故障&lt;br&gt;&amp;#x3D;&amp;#x3D;所有的异常和终端都是由硬件检测发现的&amp;#x3D;&amp;#x3D;&lt;br&gt;根据识别中断服务程序地址的方式，可以分为向量中断和非向量中断；&lt;br&gt;根据中断处理过程是否允许被打断分为单重中断和多重中断&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;异常和中断的响应过程&#34;&gt;&lt;a href=&#34;#异常和中断的响应过程&#34; class=&#34;headerlink&#34; title=&#34;异常和中断的响应过程&#34;&gt;&lt;/a&gt;异常和中断的响应过程&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;关中断&lt;br&gt;保存断点和程序状态期间，把IF置0不允许响应中断&lt;/li&gt;
&lt;li&gt;保存断点和程序状态&lt;br&gt;将返回地址和被中断时的PSW送到栈或特定寄存器中（通常是栈，才能支持嵌套中断），处理完之后恢复&lt;/li&gt;
&lt;li&gt;识别异常和中断并转到相应的处理程序&lt;br&gt;异常大多采用软件识别，中断可以采用软件识别或硬件识别&lt;br&gt;软件识别：CPU设置异常状态寄存器，操作系统使用查询程序按优先级顺序查询异常状态寄存器以检测类型并处理&lt;br&gt;硬件识别：向量中断。每个异常或中断被指定一个中断类型号，发生之后查询中断向量表，找到处理程序的入口地址（中断向量），并跳转到处理程序&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;指令流水线&#34;&gt;&lt;a href=&#34;#指令流水线&#34; class=&#34;headerlink&#34; title=&#34;指令流水线&#34;&gt;&lt;/a&gt;指令流水线&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Performance via parallelism&lt;/li&gt;
&lt;li&gt;Performance via pipelining&lt;/li&gt;
&lt;li&gt;Performance via prediction&lt;br&gt;时间并行：流水线&lt;br&gt;空间并行：超标量&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;基本实现&#34;&gt;&lt;a href=&#34;#基本实现&#34; class=&#34;headerlink&#34; title=&#34;基本实现&#34;&gt;&lt;/a&gt;基本实现&lt;/h3&gt;&lt;p&gt;单周期CPU以执行最慢的指令周期作为时钟周期。不能缩短单挑指令的执行时间，但可以提高整个程序的执行速度&lt;br&gt;每个流水段后面都要加一个流水段寄存器锁存数据，保证本段的执行结果能在下个周期给下一流水段使用。&lt;/p&gt;
&lt;h3 id=&#34;Hazard&#34;&gt;&lt;a href=&#34;#Hazard&#34; class=&#34;headerlink&#34; title=&#34;Hazard&#34;&gt;&lt;/a&gt;Hazard&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;结构冒险、数据冒险、控制冒险&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;structural hazard&lt;br&gt;在流水线执行期间，两条及以上指令同一时间对同一个硬件资源发起使用的请求（Memory conflicts, Register File conflicts, Other units conflicts）&lt;br&gt;解决方法：(1)stall (2)增加更多的硬件支持单元（比如Double Bump，前半周期写后半周期读）&lt;/li&gt;
&lt;li&gt;data hazard&lt;br&gt;RAW, WAR, WAW&lt;br&gt;统考不考乱序执行所以只需要考虑RAW写后读&lt;br&gt;解决方法：(1)stall (2)NOP (3)forwarding&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;stall&lt;br&gt;硬件解决方法，流水线阻塞，使数据相关的后续指令延迟执行，也称为插入气泡（bubble）&lt;/li&gt;
&lt;li&gt;NOP&lt;br&gt;软件解决方法，编译时插入空操作（NOP）比如&lt;code&gt;addi x0,x0,0&lt;/code&gt;，使数据相关的后续指令延迟执行&lt;/li&gt;
&lt;li&gt;forwarding&lt;br&gt;旁路转发，将数据通路生成的中间数据直接往前传递到ALU的输入端，参与下一条指令的运算&lt;br&gt;必须同时满足两个条件：&lt;/li&gt;
&lt;li&gt;指令确实会写入寄存器（通过检查 RegWrite 信号）。&lt;/li&gt;
&lt;li&gt;目标寄存器编号不是 x0（零寄存器不会变）&lt;br&gt;才需要forwarding&lt;blockquote&gt;
&lt;p&gt;ALU-&amp;gt;ALU&lt;br&gt;数据可以从 &lt;code&gt;EX/MEM&lt;/code&gt; 或 &lt;code&gt;MEM/WB&lt;/code&gt; 阶段转发到当前在 EX 阶段的 ALU 输入&lt;br&gt;MEM-&amp;gt;ALU&lt;br&gt;load指令的数据只有在&lt;code&gt;MEM/WB&lt;/code&gt;阶段才能被转发到当前在 EX 阶段的 ALU 输入，所以如果load下一条指令要用到load指令的数据，则需要先stall一周期再forwarding&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;control hazard&lt;br&gt;解决方法：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;插入3条&lt;code&gt;NOP&lt;/code&gt;直到分支指令的&lt;code&gt;WB&lt;/code&gt;阶段才进行下一条指令的&lt;code&gt;IF&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;分支预测&lt;br&gt;&lt;img data-src=&#34;/f5.jpg&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;流水线的性能指标&#34;&gt;&lt;a href=&#34;#流水线的性能指标&#34; class=&#34;headerlink&#34; title=&#34;流水线的性能指标&#34;&gt;&lt;/a&gt;流水线的性能指标&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;吞吐率&lt;br&gt;单位时间内流水线所完成的任务数量&lt;br&gt;$$&lt;br&gt;TP &amp;#x3D; \frac{n}{T_k}&lt;br&gt;$$&lt;br&gt;k是流水线的段数，n是任务数，Tk是处理n个任务所用的总时间。理想状态下一条k段流水线能在&lt;code&gt;k+n-1&lt;/code&gt;个时钟周期完成&lt;code&gt;n&lt;/code&gt;个任务，吞吐率为$\frac{n}{(k + n - 1) \Delta t}$&lt;/li&gt;
&lt;li&gt;流水线的加速比&lt;br&gt;完成同一批任务，不适用流水线和使用流水线所用的时间之比&lt;br&gt;理想状态下流水线加速比为$\frac{k n}{k+n-1}$&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;高级流水线技术&#34;&gt;&lt;a href=&#34;#高级流水线技术&#34; class=&#34;headerlink&#34; title=&#34;高级流水线技术&#34;&gt;&lt;/a&gt;高级流水线技术&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;超标量流水线&lt;br&gt;动态多发射技术，支持乱序执行&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Scoreboard&lt;br&gt;&lt;img data-src=&#34;/f3.jpg&#34;&gt;&lt;/li&gt;
&lt;li&gt;Tomasulo&lt;br&gt;&lt;img data-src=&#34;/f4.jpg&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;超长指令字技术&lt;br&gt;静态多发射技术，将多条能并行操作的指令组合成一个超长指令字，需要多个处理不见&lt;/li&gt;
&lt;li&gt;超流水线技术&lt;br&gt;流水线功能段划分的越多，时钟周期越短，指令吞吐率越高。&lt;br&gt;超流水线技术通过提高流水线主频来提高性能，但是流水段越多中间寄存器的开销就越大&lt;blockquote&gt;
&lt;p&gt;超流水线或者理想状态下流水线技术CPI&amp;#x3D;1；多发射流水线的CPI可以小于1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;多处理器&#34;&gt;&lt;a href=&#34;#多处理器&#34; class=&#34;headerlink&#34; title=&#34;多处理器&#34;&gt;&lt;/a&gt;多处理器&lt;/h2&gt;&lt;h3 id=&#34;SISD-SIMD-MIMD&#34;&gt;&lt;a href=&#34;#SISD-SIMD-MIMD&#34; class=&#34;headerlink&#34; title=&#34;SISD SIMD MIMD&#34;&gt;&lt;/a&gt;SISD SIMD MIMD&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;SISD: single instruction single data&lt;br&gt;传统串行处理器&lt;/li&gt;
&lt;li&gt;SIMD: single instruction multiple data&lt;br&gt;数据级并行技术(DLP)，一条指令可以同时对多个数据元素执行相同的操作，用到向量寄存器&lt;br&gt;在处理for循环数组时最有效（比如两个数组相加）；在使用case&amp;#x2F;seitch时效率最低&lt;/li&gt;
&lt;li&gt;MISD: multiple instruction single data&lt;br&gt;实际上不存在&lt;/li&gt;
&lt;li&gt;MIMD: multiple instruction multiple data&lt;br&gt;TLP&lt;br&gt;分为多计算机系统和多处理器系统。&lt;br&gt;多计算机系统由多个独立的计算机节点组成，每个节点通常包含自己的存储器、CPU，具有独立的主存地址空间，通过消息传递进行数据传送，也称&lt;code&gt;消息传递MIMD&lt;/code&gt;&lt;br&gt;多处理器系统是共享存储多处理器&lt;code&gt;SMP&lt;/code&gt;系统的简称，共享单一地址空间，也称共享存储MIMD&lt;br&gt;向量处理器是SIMD的变体，实现了直接操作一维数组指令集&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;硬件多线程&#34;&gt;&lt;a href=&#34;#硬件多线程&#34; class=&#34;headerlink&#34; title=&#34;硬件多线程&#34;&gt;&lt;/a&gt;硬件多线程&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;细粒度多线程 Fine-grained multithreading&lt;br&gt;多个线程交叉执行指令，线程之间的指令不相关，可以乱序并行执行，需要频繁进行上下文切换，不需要重载流水线。牺牲单个线程执行的性能，来换取整个进程吞吐量的提升&lt;/li&gt;
&lt;li&gt;粗粒度多线程 Coarse-grained multithreading&lt;br&gt;连续几个时钟周期都执行同一线程的指令序列，尽在当前线程出现较大开销的阻塞才切换（比如L2 miss, L2 miss）相比细粒度多线程，上下文切换的频率较低，切换时需要重载流水线&lt;/li&gt;
&lt;li&gt;同时多线程 SMT&lt;br&gt;ILP+TLP，指令级并行的同时实现线程级并行，在同一个时钟周期发射多个不同线程中的多条指令执行&lt;br&gt;Intal的Hyper-threading就是SMT&lt;br&gt;&lt;img data-src=&#34;/f6.jpg&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;多核处理器&#34;&gt;&lt;a href=&#34;#多核处理器&#34; class=&#34;headerlink&#34; title=&#34;多核处理器&#34;&gt;&lt;/a&gt;多核处理器&lt;/h3&gt;&lt;p&gt;一个CPU有多个core，也称片上多处理器&lt;br&gt;每个核既可以有自己的Cache，又可以共享同一个Cache，所有核共享主存储器&lt;br&gt;多核处理器必须采用多线程（或多进程）才能发挥性能&lt;/p&gt;
&lt;h3 id=&#34;共享内存多处理器-SMP&#34;&gt;&lt;a href=&#34;#共享内存多处理器-SMP&#34; class=&#34;headerlink&#34; title=&#34;共享内存多处理器 SMP&#34;&gt;&lt;/a&gt;共享内存多处理器 SMP&lt;/h3&gt;&lt;p&gt;处理器通过存储器中的共享变量互相通信，所有存储器都能通过存取指令访问存储器的任何位置，有两种：&lt;br&gt;&lt;img data-src=&#34;/f7.jpg&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UMA 统一存储访问多处理器&lt;br&gt;UMA中所有处理器对所有内存模块的访问延迟是相同的，由于访问延迟一致，数据放在哪个内存模块上对性能影响不大。随着系统规模扩大，所有处理器都通过同一个前端总线访问内存，导致互连网络成为瓶颈，延迟增加，带宽受限&lt;br&gt;&lt;img data-src=&#34;/f8.jpg&#34;&gt;&lt;/li&gt;
&lt;li&gt;NUMA 非统一存储访问多处理器&lt;br&gt;内存有本地内存和远程内存，访问本地内存快。CPU可以通过QPI总线访问远程内存&lt;br&gt;&lt;img data-src=&#34;/f9.jpg&#34;&gt;&lt;/li&gt;
&lt;li&gt;需要解决 Cache coherence 问题：Snooping(MSI, MESI, MOESI…), Directory&lt;br&gt;基本思想都是对共享变量加锁，保证互斥访问&lt;ul&gt;
&lt;li&gt;Snooping:&lt;br&gt;&lt;img data-src=&#34;/f10.jpg&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/f11.jpg&#34;&gt;&lt;/li&gt;
&lt;li&gt;Directory:&lt;br&gt;&lt;img data-src=&#34;/f12.jpg&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/08/01/computer-science/computer-organization/ch4/</guid>
            <title>Ch4</title>
            <link>http://example.com/2025/08/01/computer-science/computer-organization/ch4/</link>
            <category>指令系统</category>
            <pubDate>Fri, 01 Aug 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Ch4-指令系统&#34;&gt;&lt;a href=&#34;#Ch4-指令系统&#34; class=&#34;headerlink&#34; title=&#34;Ch4 指令系统&#34;&gt;&lt;/a&gt;Ch4 指令系统&lt;/h1&gt;&lt;h2 id=&#34;指令系统&#34;&gt;&lt;a href=&#34;#指令系统&#34; class=&#34;headerlink&#34; title=&#34;指令系统&#34;&gt;&lt;/a&gt;指令系统&lt;/h2&gt;&lt;h3 id=&#34;ISA（王道叫它指令集体系结构）&#34;&gt;&lt;a href=&#34;#ISA（王道叫它指令集体系结构）&#34; class=&#34;headerlink&#34; title=&#34;ISA（王道叫它指令集体系结构）&#34;&gt;&lt;/a&gt;ISA（王道叫它指令集体系结构）&lt;/h3&gt;&lt;p&gt;指令系统 vs ISA&lt;/p&gt;
&lt;p&gt;ISA完整地定义了软件和硬件之间的接口，规定了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指令格式（指令寻址方式，操作类型，操作数）&lt;/li&gt;
&lt;li&gt;操作数的类型、寻址方式、大端小端存放（大端：高位放在低地址；小端：低位放在低地址）&lt;/li&gt;
&lt;li&gt;程序可访问的寄存器编号、个数和位数，存储空间大小和编址方式&lt;/li&gt;
&lt;li&gt;指令执行过程的控制方式（PC, condition code, …）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;指令的基本格式&#34;&gt;&lt;a href=&#34;#指令的基本格式&#34; class=&#34;headerlink&#34; title=&#34;指令的基本格式&#34;&gt;&lt;/a&gt;指令的基本格式&lt;/h3&gt;&lt;p&gt;操作码+地址码&lt;br&gt;主存一般是按字节编址，所以指令字长通常为字节的整数倍&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;零地址指令&lt;br&gt;NOP, HLT&lt;br&gt;不需要操作数。&lt;br&gt;零地址的运算类指令仅用在堆栈计算机中（操作数直接从栈顶弹出）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一地址指令&lt;br&gt;OP, A1&lt;br&gt;OP(A1) -&amp;gt; A1&lt;br&gt;加1，减1，取反，求补，移位等&lt;br&gt;可能有一个操作数或者两个操作数&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;隐含约定目的地址的双操作数指令，地址码指明一个操作数，另一个操作数来自隐含寻址&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;二地址指令&lt;br&gt;OP, A1, A2&lt;br&gt;(A1)OP(A2) -&amp;gt; A1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;三地址指令&lt;br&gt;OP, A1, A2, A3&lt;br&gt;(A1)OP(A2) -&amp;gt; A3&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;四地址指令&lt;br&gt;OP, A1, A2, A3, A4&lt;br&gt;(A1)OP(A2) -&amp;gt; A3, A4 &amp;#x3D; 下一条将要执行指令的地址&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;定长操作码指令格式&#34;&gt;&lt;a href=&#34;#定长操作码指令格式&#34; class=&#34;headerlink&#34; title=&#34;定长操作码指令格式&#34;&gt;&lt;/a&gt;定长操作码指令格式&lt;/h3&gt;&lt;p&gt;n位opcode最多能表示2^n条指令&lt;br&gt;指令字长：单字长(PC &amp;#x3D; PC + 1)、双字长(PC &amp;#x3D; PC + 2)…&lt;/p&gt;
&lt;h3 id=&#34;扩展操作码指令格式&#34;&gt;&lt;a href=&#34;#扩展操作码指令格式&#34; class=&#34;headerlink&#34; title=&#34;扩展操作码指令格式&#34;&gt;&lt;/a&gt;扩展操作码指令格式&lt;/h3&gt;&lt;p&gt;才去可变长度操作码，分散地放在指令字的不同位置上&lt;br&gt;要求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不允许短码是长码的前缀&lt;/li&gt;
&lt;li&gt;各指令的操作码不能重复&lt;br&gt;&lt;img data-src=&#34;/f1.jpg&#34;&gt;&lt;br&gt;RISC-V指令集&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;指令的操作类型&#34;&gt;&lt;a href=&#34;#指令的操作类型&#34; class=&#34;headerlink&#34; title=&#34;指令的操作类型&#34;&gt;&lt;/a&gt;指令的操作类型&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;数据传送&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;MOV: 寄存器到寄存器&lt;/li&gt;
&lt;li&gt;LOAD: 从内存读到寄存器&lt;/li&gt;
&lt;li&gt;STORE: 从寄存器写入内存&lt;/li&gt;
&lt;li&gt;PUSH&lt;/li&gt;
&lt;li&gt;POP&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;p&gt;算术和逻辑运算&lt;br&gt;ADD, SUB, MUL, DIV, MOD, AND, OR, XOR, NOT, XOR, INC(加一), DEC(减一)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;移位&lt;br&gt;算术移位，逻辑移位，循环移位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;转移&lt;br&gt;JMP, BRANCH, CALL, RET, TRAP（中断隐指令是硬件实现的，只有TRAP是软指令）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I&amp;#x2F;O操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;指令的寻址方式&#34;&gt;&lt;a href=&#34;#指令的寻址方式&#34; class=&#34;headerlink&#34; title=&#34;指令的寻址方式&#34;&gt;&lt;/a&gt;指令的寻址方式&lt;/h2&gt;&lt;h3 id=&#34;指令寻址与数据寻址&#34;&gt;&lt;a href=&#34;#指令寻址与数据寻址&#34; class=&#34;headerlink&#34; title=&#34;指令寻址与数据寻址&#34;&gt;&lt;/a&gt;指令寻址与数据寻址&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;指令寻址&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;顺序： PC &amp;#x3D; PC + 1&lt;/li&gt;
&lt;li&gt;跳转： 绝对转移(PC &amp;#x3D; 跳转地址) ,相对转移(PC &amp;#x3D; PC + offset)&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;数据寻址&lt;br&gt;格式：操作码 寻址特征 形式地址A&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;立即寻址(addi, …)&lt;/li&gt;
&lt;li&gt;直接寻址（A直接表示地址）&lt;/li&gt;
&lt;li&gt;寄存器寻址(add, …)&lt;/li&gt;
&lt;li&gt;寄存器间接寻址(lw r1 offset(r2), …)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;常见的数据寻址方式&#34;&gt;&lt;a href=&#34;#常见的数据寻址方式&#34; class=&#34;headerlink&#34; title=&#34;常见的数据寻址方式&#34;&gt;&lt;/a&gt;常见的数据寻址方式&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;隐含寻址&lt;br&gt;比如单地址的第二个操作数由ACC提供: Intel 8080的&lt;code&gt;ADD A&lt;/code&gt;指令会将寄存器A的内容与指定的操作数（放在ACC内）相加，并将结果存储回累加器中&lt;br&gt;优点是缩短指令字长；缺点是需要增加存储操作数或隐含地址的硬件&lt;/li&gt;
&lt;li&gt;立即（数）寻址&lt;br&gt;比如riscv的&lt;code&gt;addi x5, x6, #1&lt;/code&gt;&lt;br&gt;优点是不用访存速度快，缺点是立即数位数有限&lt;/li&gt;
&lt;li&gt;直接寻址&lt;br&gt;&lt;code&gt;OP #A&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比如lc3的&lt;code&gt;LD R1, LABEL1&lt;/code&gt;翻译成汇编是&lt;code&gt;LD R1, x3100&lt;/code&gt;表示&lt;code&gt;R1 &amp;lt;- MEM[x3100]&lt;/code&gt;&lt;br&gt;形式地址A就是操作数的真实地址EA&lt;br&gt;优点是简单，缺点是寻址范围受A的位数限制&lt;br&gt;4. 间接寻址&lt;br&gt;EA &amp;#x3D; (A)&lt;br&gt;指令中给出的地址是包含实际地址的内存位置或寄存器&lt;br&gt;比如lc3的&lt;code&gt;LDI R1, LABEL1&lt;/code&gt;翻译成汇编是&lt;code&gt;LDI R1, x3100&lt;/code&gt;表示&lt;code&gt;R1 &amp;lt;- MEM[MEM[x3100]]&lt;/code&gt;&lt;br&gt;5. 寄存器寻址&lt;br&gt;EA &amp;#x3D; (Ri)&lt;br&gt;&lt;code&gt;ADD R1, R2, R3&lt;/code&gt;&lt;br&gt;6. 寄存器间接寻址&lt;br&gt;EA &amp;#x3D; (Ri)&lt;br&gt;比如&lt;code&gt;LW R1, offset(R2)&lt;/code&gt;&lt;br&gt;7. 相对寻址&lt;br&gt;相对PC寻址&lt;br&gt;EA &amp;#x3D; (PC) + A&lt;br&gt;比如branch&lt;br&gt;8. 基址寻址&lt;br&gt;EA &amp;#x3D; (BR) + A&lt;br&gt;面向操作系统，优点是扩大寻址范围，有利于躲到程序设计；缺点是偏移量(A)的位数较短&lt;br&gt;9. 变址寻址&lt;br&gt;EA &amp;#x3D; (IX) + A&lt;br&gt;比如用来访问数组&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;偏址寻址：相对寻址、基址寻址、变址寻址&lt;/p&gt;
&lt;ol start=&#34;10&#34;&gt;
&lt;li&gt;堆栈寻址有一个堆栈指针SP，堆栈分为硬堆栈，软堆栈。寄存器堆栈是硬堆栈，内存是软堆栈。采用无操作数指令&lt;br&gt;&lt;img data-src=&#34;/f2.jpg&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;程序的机器级代码表示&#34;&gt;&lt;a href=&#34;#程序的机器级代码表示&#34; class=&#34;headerlink&#34; title=&#34;程序的机器级代码表示&#34;&gt;&lt;/a&gt;程序的机器级代码表示&lt;/h2&gt;&lt;p&gt;x86汇编&lt;/p&gt;
&lt;h3 id=&#34;常用汇编指令介绍&#34;&gt;&lt;a href=&#34;#常用汇编指令介绍&#34; class=&#34;headerlink&#34; title=&#34;常用汇编指令介绍&#34;&gt;&lt;/a&gt;常用汇编指令介绍&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;相关寄存器&lt;br&gt;x86架构有8个32位的通用寄存器：EAX、EBX、ECX、EDX、ESI、EDI、EBP、ESP&lt;br&gt;&lt;img data-src=&#34;/f3.jpg&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/f4.jpg&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/f5.jpg&#34;&gt;&lt;/li&gt;
&lt;li&gt;汇编指令格式&lt;br&gt;x86汇编指令格式有两种：AT&amp;amp;T格式和Intel格式&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;AT&amp;amp;T只能小写，Intel大小写都行&lt;/li&gt;
&lt;li&gt;AT&amp;amp;T第一个操作数是源操作数，第二个是目的操作数；Intel第一个操作数是目的操作数，第二个是源操作数&lt;/li&gt;
&lt;li&gt;AT&amp;amp;T寄存器前缀%，立即数前缀$；Intel格式寄存器和立即数不需要加前缀&lt;/li&gt;
&lt;li&gt;内存寻址：AT&amp;amp;T格式为(addr)，Intel格式为[addr]&lt;/li&gt;
&lt;li&gt;处理复杂寻址方式时，AT&amp;amp;T格式为disp(base, index, scale)，表示偏移量，基址寄存器，变址寄存器，比例因子，表示的操作数为M[R[base]+R[index]*scale + disp];&lt;/li&gt;
&lt;li&gt;指定数据长度时，AT&amp;amp;T用b, w, l; Intel用byte ptr, word ptr, dword ptr(一个word是16位，一个dword是32位)&lt;br&gt;&lt;img data-src=&#34;/f6.jpg&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/f7.jpg&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;常用指令&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;reg&gt;表示任意寄存器，后面跟数字指定其位数&lt;/reg&gt;&lt;/li&gt;
&lt;li&gt;&lt;mem&gt;内存地址&lt;/mem&gt;&lt;/li&gt;
&lt;li&gt;&lt;con&gt;后面跟数字表示几位常数&lt;br&gt;常见的指令：&lt;/con&gt;&lt;/li&gt;
&lt;li&gt;数据传送指令&lt;ul&gt;
&lt;li&gt;mov&lt;ul&gt;
&lt;li&gt;mov &lt;reg&gt;, &lt;reg&gt;&lt;/reg&gt;&lt;/reg&gt;&lt;/li&gt;
&lt;li&gt;mov &lt;reg&gt;, &lt;mem&gt;&lt;/mem&gt;&lt;/reg&gt;&lt;/li&gt;
&lt;li&gt;mov &lt;mem&gt;, &lt;reg&gt;&lt;/reg&gt;&lt;/mem&gt;&lt;/li&gt;
&lt;li&gt;mov &lt;reg&gt;, &lt;con&gt;&lt;/con&gt;&lt;/reg&gt;&lt;/li&gt;
&lt;li&gt;mov &lt;mem&gt;, &lt;con&gt;&lt;/con&gt;&lt;/mem&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;push(ESP指向栈顶空的位置，push之前ESP &amp;#x3D; ESP - 4)&amp;#x3D;&amp;#x3D;栈中元素固定为32位&amp;#x3D;&amp;#x3D;&lt;ul&gt;
&lt;li&gt;push &amp;lt;reg32&lt;/li&gt;
&lt;li&gt;push &lt;mem&gt;&lt;/mem&gt;&lt;/li&gt;
&lt;li&gt;push &lt;con32&gt;&lt;/con32&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;pop(pop之后ESP &amp;#x3D; ESP + 4)&lt;ul&gt;
&lt;li&gt;pop &lt;reg32&gt;&lt;/reg32&gt;&lt;/li&gt;
&lt;li&gt;pop &lt;mem&gt;&lt;/mem&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;算术和逻辑运算&lt;ul&gt;
&lt;li&gt;add&amp;#x2F;sub(把两个操作数相加&amp;#x2F;减，结果放回目的操作数)&lt;ul&gt;
&lt;li&gt;add eax, 10    # eax &amp;#x3D; eax + 10&lt;/li&gt;
&lt;li&gt;add byte ptr [var], 10    # 10与var指向的内存地址的一字节值相加，结果放回var指向的内存中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;inc&amp;#x2F;dec(把操作数自加1&amp;#x2F;自减1)&lt;ul&gt;
&lt;li&gt;dec eax    # eax &amp;#x3D; eax - 1&lt;/li&gt;
&lt;li&gt;inc dword ptr [var]    # var指向的32位值自加1，结果放回var指向的32位内存中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;imul(有符号数整数乘法, mul是无符号数乘法)目的操作数必须是寄存器，溢出时&lt;code&gt;OF = 1&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;imul &lt;reg32&gt;, &lt;reg32&gt;&lt;/reg32&gt;&lt;/reg32&gt;&lt;/li&gt;
&lt;li&gt;imul &lt;reg32&gt;, &lt;mem&gt;&lt;/mem&gt;&lt;/reg32&gt;&lt;/li&gt;
&lt;li&gt;imul &lt;reg32&gt;, &lt;reg32&gt;, &lt;con&gt;&lt;/con&gt;&lt;/reg32&gt;&lt;/reg32&gt;&lt;/li&gt;
&lt;li&gt;imul &lt;reg32&gt;, &lt;mem&gt;, &lt;con&gt;&lt;/con&gt;&lt;/mem&gt;&lt;/reg32&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;idiv(有符号数整数除法，&amp;#x3D;&amp;#x3D;只有一个操作数为除数，被除数有64位放在 &lt;code&gt;edx:eax&lt;/code&gt; 中，操作结果商放到&lt;code&gt;eax&lt;/code&gt;，余数放到&lt;code&gt;edx&lt;/code&gt;&amp;#x3D;&amp;#x3D;)&lt;ul&gt;
&lt;li&gt;idiv &lt;reg32&gt;&lt;/reg32&gt;&lt;/li&gt;
&lt;li&gt;idiv &lt;mem&gt;&lt;/mem&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;and&amp;#x2F;or&amp;#x2F;xor&lt;ul&gt;
&lt;li&gt;and&amp;#x2F;or&amp;#x2F;xor &lt;reg&gt;, &lt;reg&gt;&lt;/reg&gt;&lt;/reg&gt;&lt;/li&gt;
&lt;li&gt;and&amp;#x2F;or&amp;#x2F;xor &lt;reg&gt;, &lt;mem&gt;&lt;/mem&gt;&lt;/reg&gt;&lt;/li&gt;
&lt;li&gt;and&amp;#x2F;or&amp;#x2F;xor &lt;mem&gt;, &lt;reg&gt;&lt;/reg&gt;&lt;/mem&gt;&lt;/li&gt;
&lt;li&gt;and&amp;#x2F;or&amp;#x2F;xor &lt;reg&gt;, &lt;con&gt;&lt;/con&gt;&lt;/reg&gt;&lt;/li&gt;
&lt;li&gt;and&amp;#x2F;or&amp;#x2F;xor &lt;mem&gt;, &lt;con&gt;&lt;/con&gt;&lt;/mem&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;not(按位取反)&lt;ul&gt;
&lt;li&gt;not &lt;reg&gt;&lt;/reg&gt;&lt;/li&gt;
&lt;li&gt;not &lt;mem&gt;&lt;/mem&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;neg(取负)&lt;ul&gt;
&lt;li&gt;neg &lt;reg&gt;&lt;/reg&gt;&lt;/li&gt;
&lt;li&gt;neg &lt;mem&gt;&lt;/mem&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;shl&amp;#x2F;shr(逻辑左移&amp;#x2F;右移)&lt;ul&gt;
&lt;li&gt;shl &lt;reg&gt;, &lt;con8&gt;&lt;/con8&gt;&lt;/reg&gt;&lt;/li&gt;
&lt;li&gt;shl &lt;mem&gt;, &lt;con8&gt;&lt;/con8&gt;&lt;/mem&gt;&lt;/li&gt;
&lt;li&gt;shr &lt;reg&gt;, &lt;reg8&gt;&lt;/reg8&gt;&lt;/reg&gt;&lt;/li&gt;
&lt;li&gt;shr &lt;mem&gt;, &lt;reg8&gt;&lt;/reg8&gt;&lt;/mem&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;控制流&lt;ul&gt;
&lt;li&gt;jmp&lt;ul&gt;
&lt;li&gt;jmp &lt;label&gt;&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;jcondition&lt;ul&gt;
&lt;li&gt;je &lt;label&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;jz &lt;label&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;jne &lt;label&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;jg &lt;label&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;jge &lt;label&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;jl &lt;label&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;jle &lt;label&gt;&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;cmp&amp;#x2F;test(cmp相当于相减，test相当于按位与，不保存操作结果仅设置条件码用于跳转指令)&lt;ul&gt;
&lt;li&gt;cmp&amp;#x2F;test &lt;reg&gt;, &lt;reg&gt;&lt;/reg&gt;&lt;/reg&gt;&lt;/li&gt;
&lt;li&gt;cmp&amp;#x2F;test &lt;reg&gt;, &lt;mem&gt;&lt;/mem&gt;&lt;/reg&gt;&lt;/li&gt;
&lt;li&gt;cmp&amp;#x2F;test &lt;mem&gt;, &lt;reg&gt;&lt;/reg&gt;&lt;/mem&gt;&lt;/li&gt;
&lt;li&gt;cmp&amp;#x2F;test &lt;reg&gt;, &lt;con&gt;&lt;/con&gt;&lt;/reg&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;call&amp;#x2F;ret(call将返回地址入栈然后跳转，ret弹出返回地址并跳转)&lt;ul&gt;
&lt;li&gt;call &lt;label&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;ret&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;选择语句的机器级表示&#34;&gt;&lt;a href=&#34;#选择语句的机器级表示&#34; class=&#34;headerlink&#34; title=&#34;选择语句的机器级表示&#34;&gt;&lt;/a&gt;选择语句的机器级表示&lt;/h3&gt;&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;if(test_exp)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    then_stmt&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;else&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    else_stmt&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;翻译成&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;if(!t)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    goto false;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;then_stmt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;goto done;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;false:  else_stmt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;done:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;循环语句的机器级表示&#34;&gt;&lt;a href=&#34;#循环语句的机器级表示&#34; class=&#34;headerlink&#34; title=&#34;循环语句的机器级表示&#34;&gt;&lt;/a&gt;循环语句的机器级表示&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;do-while&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;do&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  body_stmt&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  while(test_exp);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;翻译成：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;loop:   body_stmt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  t = test_exp;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  if(t)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    goto loop;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;while&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;while(test_exp)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  body_stmt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;翻译成：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;t = test_exp;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;if(!t)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  goto done;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;loop:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  body_stmt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  t = test_exp;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  if(t)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    goto loop;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;done:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;for&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;for(init_exp; test_exp; update_exp)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  body_stmt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;翻译成：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;init_exp;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;t = test_exp;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;if(!t)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  goto done;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;loop:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  body_stmt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  update_exp;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  t = test_exp;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  if(t)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    goto loop;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;done:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;过程调用的机器级表示&#34;&gt;&lt;a href=&#34;#过程调用的机器级表示&#34; class=&#34;headerlink&#34; title=&#34;过程调用的机器级表示&#34;&gt;&lt;/a&gt;过程调用的机器级表示&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;caller将实参放到callee能访问的地方（寄存器放不下放栈里）&lt;/li&gt;
&lt;li&gt;caller保存返回地址（通过call指令实现）&lt;/li&gt;
&lt;li&gt;callee保存caller通用寄存器的内容，并为自己的非静态局部变量分配空间&lt;/li&gt;
&lt;li&gt;执行callee&lt;/li&gt;
&lt;li&gt;恢复caller的寄存器内容，将返回值放到caller能访问的地方（寄存器、栈），释放局部变量&lt;/li&gt;
&lt;li&gt;callee取出返回地址，恢复PC（ret实现）&lt;blockquote&gt;
&lt;p&gt;EAX, ECX, EDX是caller saved register&lt;br&gt;通常用于传递参数、存储临时变量或返回值，所以call的时候内容可能会变，要先保存再调用。比如返回值一般保存在EAX&lt;br&gt;EBX, ESI, EDI是callee saved register&lt;br&gt;这些寄存器的值在函数调用后应保持不变，所以由callee保存，ret的时候要恢复&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每个过程有自己的栈帧，&lt;code&gt;EBP&lt;/code&gt;保存栈帧的基址，&lt;code&gt;ESP&lt;/code&gt;指向栈顶位置，&lt;code&gt;EBP&lt;/code&gt;的值不变，当前栈帧的范围在&lt;code&gt;EBP&lt;/code&gt;和&lt;code&gt;ESP&lt;/code&gt;之间（详见编译原理&lt;code&gt;activated record&lt;/code&gt;）&lt;br&gt;&lt;img data-src=&#34;/f8.jpg&#34;&gt;&lt;br&gt;前三行的意思是新开一个栈帧，分配了24字节的栈帧空间。&lt;code&gt;push epb&lt;/code&gt;实际上就是把static link压栈。&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ub3Jlc3BvbnNlNTI1LmdpdGh1Yi5pby8yMDI1LzA2LzE1L2NvbXB1dGVyLXNjaWVuY2UvY29tcGlsZS1wcmluY2lwbGVzL2NoNi8jJUU1JTg3JUJEJUU2JTk1JUIwJUU4JUIwJTgzJUU3JTk0JUE4JUU2JUI1JTgxJUU3JUE4JThC&#34;&gt;详见编译原理笔记&lt;/span&gt;&lt;br&gt;执行&lt;code&gt;call&lt;/code&gt;之后，&lt;code&gt;call&lt;/code&gt;会先将返回地址压栈，然后跳转到&lt;code&gt;add&lt;/code&gt;的起始地址，为&lt;code&gt;add&lt;/code&gt;创建栈帧。&lt;code&gt;add&lt;/code&gt;的返回值存放在&lt;code&gt;EAX&lt;/code&gt;中。&lt;br&gt;执行&lt;code&gt;ret&lt;/code&gt;之前需要释放当前栈帧，恢复caller的栈帧。因此&lt;code&gt;leave&lt;/code&gt;相当于&lt;code&gt;mov esp, ebp&lt;/code&gt; &lt;code&gt;pop ebp&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;CISC和RISC的基本概念&#34;&gt;&lt;a href=&#34;#CISC和RISC的基本概念&#34; class=&#34;headerlink&#34; title=&#34;CISC和RISC的基本概念&#34;&gt;&lt;/a&gt;CISC和RISC的基本概念&lt;/h2&gt;&lt;p&gt;复杂指令系统计算机(CISC)：比如x86&lt;br&gt;精简指令系统计算机(RISC)：ARM, MIPS…&lt;/p&gt;
&lt;h3 id=&#34;CISC&#34;&gt;&lt;a href=&#34;#CISC&#34; class=&#34;headerlink&#34; title=&#34;CISC&#34;&gt;&lt;/a&gt;CISC&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;指令系统复杂庞大，指令数目多&lt;/li&gt;
&lt;li&gt;指令长度不固定，格式多，寻址方式多&lt;/li&gt;
&lt;li&gt;可以访存的指令不受限制（比如x86的add可以直接把reg和mem相加，但是riscv的只能reg和reg或者reg和imm）&lt;/li&gt;
&lt;li&gt;各种指令使用频度相差很大&lt;/li&gt;
&lt;li&gt;各种指令执行时间相差很大，大多指令需要多个时钟周期&lt;/li&gt;
&lt;li&gt;控制器大多采用微程序控制，无法采用硬连线控制&lt;/li&gt;
&lt;li&gt;难以用优化编译生成高效的目标代码程序&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;RISC&#34;&gt;&lt;a href=&#34;#RISC&#34; class=&#34;headerlink&#34; title=&#34;RISC&#34;&gt;&lt;/a&gt;RISC&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;选取使用频率最高的一些简单指令，复杂指令的功能由简单指令的组合来实现&lt;/li&gt;
&lt;li&gt;指令长度固定，指令格式种类少，寻址方式种类少&lt;/li&gt;
&lt;li&gt;只有LOAD&amp;#x2F;STORE访存，其余指令的操作只能访问寄存器&amp;#x2F;imm&lt;/li&gt;
&lt;li&gt;CPU中通用寄存器数量相当多&lt;/li&gt;
&lt;li&gt;采用流水线技术，大部分指令在一个时钟周期内完成&lt;/li&gt;
&lt;li&gt;硬布线控制为主，不用或少用微程序控制&lt;/li&gt;
&lt;li&gt;重视编译优化&lt;br&gt;CISC兼容性好，大多RISC不能和老机器兼容，但具有更强的实用性。CISC可以提供更多的功能&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;CISC和RISC的比较&#34;&gt;&lt;a href=&#34;#CISC和RISC的比较&#34; class=&#34;headerlink&#34; title=&#34;CISC和RISC的比较&#34;&gt;&lt;/a&gt;CISC和RISC的比较&lt;/h3&gt;&lt;p&gt;和CISC相比，RISC的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RISC更能充分利用VLSI（超大规模集成电路）芯片的面积（减少了控制逻辑）&lt;/li&gt;
&lt;li&gt;RISC更能提高运算速度&lt;/li&gt;
&lt;li&gt;RISC便于设计，可以降低成本，提高可靠性&lt;/li&gt;
&lt;li&gt;有利于编译优化&lt;br&gt;&lt;img data-src=&#34;/f9.jpg&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/07/01/computer-science/computer-organization/ch3/</guid>
            <title>Ch3</title>
            <link>http://example.com/2025/07/01/computer-science/computer-organization/ch3/</link>
            <category>存储系统</category>
            <pubDate>Tue, 01 Jul 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Ch3-存储系统&#34;&gt;&lt;a href=&#34;#Ch3-存储系统&#34; class=&#34;headerlink&#34; title=&#34;Ch3 存储系统&#34;&gt;&lt;/a&gt;Ch3 存储系统&lt;/h1&gt;&lt;h2 id=&#34;存储器概述&#34;&gt;&lt;a href=&#34;#存储器概述&#34; class=&#34;headerlink&#34; title=&#34;存储器概述&#34;&gt;&lt;/a&gt;存储器概述&lt;/h2&gt;&lt;h3 id=&#34;存储器的分类&#34;&gt;&lt;a href=&#34;#存储器的分类&#34; class=&#34;headerlink&#34; title=&#34;存储器的分类&#34;&gt;&lt;/a&gt;存储器的分类&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;按层次分&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;主存（小、快、成本高）&lt;/li&gt;
&lt;li&gt;辅存（大、慢、成本低）&lt;/li&gt;
&lt;li&gt;Cache&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;按存储介质分&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;磁表面存储器（磁盘、磁带）&lt;/li&gt;
&lt;li&gt;磁芯存储器&lt;/li&gt;
&lt;li&gt;半导体存储器（MOS型、双极型）&lt;/li&gt;
&lt;li&gt;光存储器（光盘）&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;按存储方式分&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;RAM （随机存储器）:随机读取存储单元，存取时间与存储单元的物理位置无关。读写方便，主要用作主存和cache，分静态RAM和动态RAM。&lt;/li&gt;
&lt;li&gt;ROM （只读存储器）：只能读不能写，非易失性，随机读取。广义的ROM也可以通过电擦除进行写入(EEPROM)&lt;/li&gt;
&lt;li&gt;SAM （顺序存储器）：按顺序存储，存取时间与存储单元的物理位置有关&lt;/li&gt;
&lt;li&gt;DAM （直接存储器）：先选取信息所在区域，然后顺序存取。结合了RAM和SAM的特性（磁盘）&lt;/li&gt;
&lt;li&gt;Associated memory: 不根据地址而是根据存储内容来进行存取的存储器，可以实现快速地查找快表。既可以按照&amp;#x3D;&amp;#x3D;地址&amp;#x3D;&amp;#x3D;寻址也可以按照&amp;#x3D;&amp;#x3D;内容&amp;#x3D;&amp;#x3D;寻址（通常是某些字段）&lt;/li&gt;
&lt;li&gt;串行访问存储器：SAM和DAM都是，所以读写时间和物理位置有关&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;按信息的可保存性分类&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;易失性存储器：断电后丢失数据，如RAM&lt;/li&gt;
&lt;li&gt;非易失性存储器：断电后数据还在，如ROM，磁盘光盘&lt;/li&gt;
&lt;li&gt;破坏性读出：读出数据后数据被破坏&lt;/li&gt;
&lt;li&gt;非破坏性读出：读出数据后数据不改变&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;存储器的性能指标&#34;&gt;&lt;a href=&#34;#存储器的性能指标&#34; class=&#34;headerlink&#34; title=&#34;存储器的性能指标&#34;&gt;&lt;/a&gt;存储器的性能指标&lt;/h3&gt;&lt;p&gt;三个主要性能指标：存储容量、单位成本、存储速度&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;容量 &amp;#x3D; 存储字数 * 字长&lt;/li&gt;
&lt;li&gt;单位成本 &amp;#x3D; 总成本&amp;#x2F;总容量&lt;/li&gt;
&lt;li&gt;存储速度：&lt;br&gt;存取时间$T_a$: 启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入事件&lt;br&gt;存取周期$T_m$: 进行连续读&amp;#x2F;写操作所允许的最短时间间隔&lt;br&gt;主存带宽$B_m$: b&amp;#x2F;s, B&amp;#x2F;s, word&amp;#x2F;s&lt;blockquote&gt;
&lt;p&gt;存取时间仅为完成一次操作的时间，而存取周期不仅包含操作时间，还包括操作后线路的恢复时间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;多级层次的存储系统&#34;&gt;&lt;a href=&#34;#多级层次的存储系统&#34; class=&#34;headerlink&#34; title=&#34;多级层次的存储系统&#34;&gt;&lt;/a&gt;多级层次的存储系统&lt;/h3&gt;&lt;p&gt;&lt;img data-src=&#34;/f1.jpg&#34;&gt;&lt;br&gt;从上到下价格越来越低，速度越来越慢，容量越来越大，CPU访问频度越来越低&lt;br&gt;&lt;img data-src=&#34;/f2.jpg&#34;&gt;&lt;br&gt;存储时间与存储周期的关系&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;透明（transparent）指的是某种机制或技术的存在对使用者来说是不可见或无感知的&lt;br&gt;主存-Cache之间的数据调用由硬件自动完成，对所有程序员均是透明的&lt;br&gt;主存-辅存的数据调用由硬件和操作系统共同完成，对应用程序员是透明的&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;主存储器&#34;&gt;&lt;a href=&#34;#主存储器&#34; class=&#34;headerlink&#34; title=&#34;主存储器&#34;&gt;&lt;/a&gt;主存储器&lt;/h2&gt;&lt;p&gt;存储元件：MOS管&lt;/p&gt;
&lt;h3 id=&#34;SRAM-DRAM&#34;&gt;&lt;a href=&#34;#SRAM-DRAM&#34; class=&#34;headerlink&#34; title=&#34;SRAM &amp;amp; DRAM&#34;&gt;&lt;/a&gt;SRAM &amp;amp; DRAM&lt;/h3&gt;&lt;p&gt;RAM: SRAM静态随机存储器和DRAM动态随机存储器&lt;br&gt;&amp;#x3D;&amp;#x3D;主存主要是DRAM，Cache主要是SRAM&amp;#x3D;&amp;#x3D;，都易失&lt;/p&gt;
&lt;p&gt;DRAM芯片：使用栅极电容存储信息，只要一个晶体管，读写&amp;#x3D;&amp;#x3D;更慢&amp;#x3D;&amp;#x3D;，是&amp;#x3D;&amp;#x3D;破坏性读出&amp;#x3D;&amp;#x3D;，需要重写，&amp;#x3D;&amp;#x3D;成本低，集成度高，功耗低&amp;#x3D;&amp;#x3D;&lt;/p&gt;
&lt;p&gt;SRAM芯片：使用双稳态触发器存储信息（六晶体管MOS，RS, JK, D）。读写&amp;#x3D;&amp;#x3D;更快&amp;#x3D;&amp;#x3D;，是非破坏性读出，&amp;#x3D;&amp;#x3D;成本高，集成度低，功耗大&amp;#x3D;&amp;#x3D;&lt;br&gt;&lt;img data-src=&#34;/f4.jpg&#34;&gt;&lt;br&gt;栅极电容需要一直刷新给电容充电，触发器不需要刷新，只要不断电状态不会改变&lt;/p&gt;
&lt;h4 id=&#34;DRAM的刷新&#34;&gt;&lt;a href=&#34;#DRAM的刷新&#34; class=&#34;headerlink&#34; title=&#34;DRAM的刷新&#34;&gt;&lt;/a&gt;DRAM的刷新&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;多久需要刷新一次？ 刷新周期：一般为2ms&lt;/li&gt;
&lt;li&gt;每次刷新多少存储单元？以行为单位，每次刷新一行存储单元&lt;br&gt;——为什么要用行列地址？减少选通线的数量&lt;/li&gt;
&lt;li&gt;在什么时刻刷新？&lt;br&gt;有硬件支持，读出一行的信息后重新写入，占用1个读&amp;#x2F;写周期&lt;br&gt;假设DRAM内部结构排列成128×128的形式，读&amp;#x2F;写周期0.5us&lt;br&gt;2ms共 2ms&amp;#x2F;0.5us &amp;#x3D; 4000 个周期&lt;br&gt;三种刷新方式：&lt;br&gt;&lt;img data-src=&#34;/f5.jpg&#34;&gt;&lt;br&gt;刷新以行为单位，再生（重写）只需要恢复被读出来的存储单元&lt;br&gt;刷新由存储器独立完成，不需要CPU控制&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;DRAM的地址引脚复用技术&#34;&gt;&lt;a href=&#34;#DRAM的地址引脚复用技术&#34; class=&#34;headerlink&#34; title=&#34;DRAM的地址引脚复用技术&#34;&gt;&lt;/a&gt;DRAM的地址引脚复用技术&lt;/h5&gt;&lt;p&gt;&lt;img data-src=&#34;/f6.jpg&#34;&gt;&lt;br&gt;行列地址分成两次送，节省了一半的地址线&lt;br&gt;行列数优化原则：尽量使行、列数相同，且行数较少（因为按行刷新）&lt;br&gt;目前常用SDRAM（同步DRAM），数据交换同步于CPU的时钟信号，使得CPU不需要等待&lt;/p&gt;
&lt;h3 id=&#34;ROM&#34;&gt;&lt;a href=&#34;#ROM&#34; class=&#34;headerlink&#34; title=&#34;ROM&#34;&gt;&lt;/a&gt;ROM&lt;/h3&gt;&lt;p&gt;结构简单、非易失性&lt;br&gt;类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MROM 掩模式ROM&lt;br&gt;在芯片生产过程中写入，无法改变，可靠性高，急程度高，价格便宜，灵活性差&lt;/li&gt;
&lt;li&gt;PROM 一次可编程ROM&lt;br&gt;可以用专门的设备写入一次，一旦写入无法改变&lt;/li&gt;
&lt;li&gt;EPROM 可擦除可编程ROM&lt;br&gt;可以写入并多次改写，但是编程次数有限且时间长&lt;/li&gt;
&lt;li&gt;Flash&lt;br&gt;兼有RAM和ROM的优点，可以不加电长期保存信息，又能在线快速擦除和重写，价格便宜，急程度高，电可擦除重写且速度快&lt;br&gt;SSD 固态硬盘基于Flash，由控制单元和Flash组成，长期保存、快速擦除和重写，对比传统硬盘读写速度快。低功耗。但是价格高&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;主存储器的基本组成&#34;&gt;&lt;a href=&#34;#主存储器的基本组成&#34; class=&#34;headerlink&#34; title=&#34;主存储器的基本组成&#34;&gt;&lt;/a&gt;主存储器的基本组成&lt;/h3&gt;&lt;p&gt;核心部件：一个个存储0或1的存储单元构成的存储矩阵&lt;br&gt;访问主存时，CPU把地址送到MAR，MAR通过地址总线把地址送到主存中的地址寄存器，地址译码器进行译码，选中相应的内存单元，然后通过控制电路决定读&amp;#x2F;写操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读操作：将选中的内存单元的内容通过数据总线送到MDR中&lt;/li&gt;
&lt;li&gt;写操作：将MDR中的内容通过数据总线送到选中的内存单元中&lt;br&gt;MDR的位数和数据总线位数相同，通常等于存储字长；MAR的位数和地址总线位数相同&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;多模块存储器&#34;&gt;&lt;a href=&#34;#多模块存储器&#34; class=&#34;headerlink&#34; title=&#34;多模块存储器&#34;&gt;&lt;/a&gt;多模块存储器&lt;/h3&gt;&lt;p&gt;DRAM芯片的恢复时间比较长，有可能是存取时间的几倍（SRAM的恢复时间较短）。CPU的读写速度比主存快很多，主存恢复时间太长&lt;br&gt; —— 利用多个完全相同的存储模块并行工作来提高吞吐率：单体多字存储器，多体低位交叉存储器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双端口RAM（408不考，了解即可）&lt;br&gt;&lt;img data-src=&#34;/f7.jpg&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;单体多字存储器&lt;br&gt;一般一个存储单元只存储一个word，但是单体多字存储器一个存储单元存储多个word，然后读的时候一次性读取这多个字。好处是快，缺点是只有指令和数据连续存放时才能提高存取速度，否则造成不必要的读取。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&amp;#x3D;&amp;#x3D;多体并行存储器（重点）&amp;#x3D;&amp;#x3D;&lt;br&gt;分为高位交叉编址和低位交叉编址两种&lt;br&gt;&lt;img data-src=&#34;/f8.jpg&#34;&gt;&lt;br&gt;高位交叉编址每一块存储体的高位是一样的，实际上还是顺序存储。因此访问连续内存实际上访问的还是同一块存储体，并不能通过并行加快访问速度&lt;br&gt;低位交叉编址的每一块存储体低位相同，因此可以在恢复时间并行存取下一块内存的数据&lt;br&gt;存取周期为&lt;code&gt;T&lt;/code&gt;, 存取时间为&lt;code&gt;r&lt;/code&gt;, T &amp;#x3D; r + 恢复时间&lt;br&gt;对于n个存储器并行访问的存储器：&lt;br&gt;采用高位交叉编址的时间为&lt;code&gt;n*T&lt;/code&gt;&lt;br&gt;低位交叉编址为&lt;code&gt;T + (n-1)*r&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;/f9.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;轮流启动：每个bank的存储位数等于数据总线的位数，此时采用轮流启动&lt;ul&gt;
&lt;li&gt;对于低位交叉编址，要保证&lt;code&gt;m&amp;gt;=T/r&lt;/code&gt;，以保证流水线不间断&lt;/li&gt;
&lt;li&gt;理想情况下，m个bank的交叉存储器每隔&lt;code&gt;T/m&lt;/code&gt;个周期可以读&amp;#x2F;写一个数据，若相邻m次访问的当存地址出现在同一个模块内，则会发生访存冲突，此时需要延迟发生冲突的访问请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;同时启动：如果m个bank的总位数加起来刚好等于数据总线的位数，则m个同时存&amp;#x2F;取&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;主存储器与CPU的连接&#34;&gt;&lt;a href=&#34;#主存储器与CPU的连接&#34; class=&#34;headerlink&#34; title=&#34;主存储器与CPU的连接&#34;&gt;&lt;/a&gt;主存储器与CPU的连接&lt;/h2&gt;&lt;h3 id=&#34;连接原理&#34;&gt;&lt;a href=&#34;#连接原理&#34; class=&#34;headerlink&#34; title=&#34;连接原理&#34;&gt;&lt;/a&gt;连接原理&lt;/h3&gt;&lt;p&gt;通过总线连接（控制、地址、数据）&lt;br&gt;传输速率 &amp;#x3D; 总线宽度&amp;#x2F;传输时间&lt;br&gt;地址总线的位数决定了可寻址的最大内存空间&lt;br&gt;控制总线指出总线周期的类型和本次输入输出完成的时刻&lt;br&gt;将多个芯片集成在内存条上，由多个内存条和主板上的ROM芯片组成计算机所需的主存空间，通过总线与CPU连接&lt;/p&gt;
&lt;h3 id=&#34;主存容量的扩展&#34;&gt;&lt;a href=&#34;#主存容量的扩展&#34; class=&#34;headerlink&#34; title=&#34;主存容量的扩展&#34;&gt;&lt;/a&gt;主存容量的扩展&lt;/h3&gt;&lt;p&gt;数据总线宽度&amp;gt;存储字长 —— 位扩展&lt;br&gt;地址总线宽度&amp;gt;存储字数量所需的宽度&lt;br&gt;&lt;img data-src=&#34;/f10.jpg&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;位扩展法：增加存储字长&lt;br&gt;由于数据总线宽度大于存储字长，存在浪费情况，必须进行位扩展使数据位数与数据总线位数相等&lt;br&gt;如图：&lt;br&gt;&lt;img data-src=&#34;/f11.jpg&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;字扩展法&lt;br&gt;地址总线存在浪费情况，对存储字的数量进行扩展&lt;br&gt;用多出来的地址线提供CS片选信号，决定输出的是哪个芯片的数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;线选法：n条多余的地址线，对应n个选片信号，地址空间不连续造成地址空间浪费（只能有一个1有效），电路简单&lt;br&gt;&lt;img data-src=&#34;/f13.jpg&#34;&gt;&lt;/li&gt;
&lt;li&gt;译码器选法：n条多余的线对应$2^n$个选片信号，地址空间可以连续&lt;br&gt;&lt;img data-src=&#34;/f12.jpg&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;字、位同时扩展&lt;br&gt;既增加存储字的数量，又增加存储字长&lt;br&gt;&lt;img data-src=&#34;/f14.jpg&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;存储芯片的地址分配和片选&#34;&gt;&lt;a href=&#34;#存储芯片的地址分配和片选&#34; class=&#34;headerlink&#34; title=&#34;存储芯片的地址分配和片选&#34;&gt;&lt;/a&gt;存储芯片的地址分配和片选&lt;/h3&gt;&lt;p&gt;见上方线选法译码器选法&lt;/p&gt;
&lt;h3 id=&#34;存储器与CPU的连接&#34;&gt;&lt;a href=&#34;#存储器与CPU的连接&#34; class=&#34;headerlink&#34; title=&#34;存储器与CPU的连接&#34;&gt;&lt;/a&gt;存储器与CPU的连接&lt;/h3&gt;&lt;p&gt;……&lt;br&gt;片选信号还与CPU的方寸控制信号$\overline{MREQ}$有关（低电平有效），若CPU访问IO则此信号为高电平&lt;br&gt;MAR位数要看主存地址空间大小，而不能看实际上用了多少位&lt;/p&gt;
&lt;h2 id=&#34;外部存储器&#34;&gt;&lt;a href=&#34;#外部存储器&#34; class=&#34;headerlink&#34; title=&#34;外部存储器&#34;&gt;&lt;/a&gt;外部存储器&lt;/h2&gt;&lt;p&gt;磁盘存储器是以磁盘为存储介质的存储器，优点：容量大，价格低；记录介质可重复使用；可以长期保存；非破坏性读出。缺点：存取速度慢；机械结构复杂；对工作环境要求高&lt;/p&gt;
&lt;h3 id=&#34;磁盘存储器&#34;&gt;&lt;a href=&#34;#磁盘存储器&#34; class=&#34;headerlink&#34; title=&#34;磁盘存储器&#34;&gt;&lt;/a&gt;磁盘存储器&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;磁盘存储器&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;组成：磁盘驱动器，磁盘控制器，盘片&lt;br&gt;&lt;img data-src=&#34;/f15.jpg&#34;&gt;&lt;/li&gt;
&lt;li&gt;存储区域：&amp;#x3D;&amp;#x3D;扇区（也称块）是磁盘读写的最小单位&amp;#x3D;&amp;#x3D;，按块存取&lt;ul&gt;
&lt;li&gt;磁头数(Heads)：一个记录面对应一个磁头&lt;/li&gt;
&lt;li&gt;柱面数(Cylinders)：表示每面盘片上的磁道数，不同记录面的相同位置的磁道构成一个柱面&lt;/li&gt;
&lt;li&gt;扇区数(Sectors)：每条磁道上有多少扇区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Disk Cache&lt;ul&gt;
&lt;li&gt;在内存上的一片区域，用来缓冲被送到磁盘上的数据。优点：写磁盘时按簇进行，可以避免频繁地用小块数据写；中间结果数据写回之前可以被快速再次使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;磁记录原理&lt;ul&gt;
&lt;li&gt;原理：当磁头和磁性记录介质有相对运动时，通过电磁转换完成读&amp;#x2F;写操作。&lt;/li&gt;
&lt;li&gt;编码方法：按某种方案（规律），把一连串的二进制信息变换成存储介质磁层中一个磁化翻转状态的序列，并使读&amp;#x2F;写控制电路容易、可靠地实现转换。&lt;/li&gt;
&lt;li&gt;磁记录方式：通常采用调频制（FM）和改进型调频制（MFM）的记录方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;性能指标&lt;ul&gt;
&lt;li&gt;&lt;p&gt;磁盘的容量：一个磁盘所能存储的字节总数称为磁盘容量。磁盘容量有非格式化容量和格式化容量之分。&lt;br&gt;非格式化容量是指磁记录表面可以利用的磁化单元总数，非格式化容量 &amp;#x3D; 记录面数 * 柱面数 * 每条磁道的磁化单元数&lt;br&gt;格式化容量是指按照某种特定的记录格式所能存储信息的总量，格式化容量 &amp;#x3D; 记录面数 * 柱面数 * 每道扇区数 * 每个扇区的容量&lt;br&gt;&amp;#x3D;&amp;#x3D;格式化容量 &amp;lt; 非格式化容量&amp;#x3D;&amp;#x3D;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;记录密度:记录密度是指盘片单位面积上记录的二进制的信息量，通常以&lt;code&gt;道密度&lt;/code&gt;、&lt;code&gt;位密度&lt;/code&gt;和&lt;code&gt;面密度&lt;/code&gt;表示。道密度是&amp;#x3D;&amp;#x3D;沿磁盘半径方向单位长度上的磁道数&amp;#x3D;&amp;#x3D;；位密度是&amp;#x3D;&amp;#x3D;磁道单位长度上能记录的二进制代码位数&amp;#x3D;&amp;#x3D;；面密度是位密度和道密度的乘积。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;#x3D;&amp;#x3D;磁盘所有磁道记录的信息量一定是相等的，并不是圆越大信息越多，故每个磁道的位密度都不同，越靠近圆心位密度越大&amp;#x3D;&amp;#x3D;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;平均存取时间：&lt;br&gt;&amp;#x3D;&amp;#x3D;平均存取时间 &amp;#x3D; 寻道时间（磁头移动到目的磁道）+ 旋转延迟时间（磁头定位到所在扇区）+ 传输时间（传输数据所花费的时间）&amp;#x3D;&amp;#x3D;&lt;br&gt;&amp;#x3D;&amp;#x3D;寻道时间通常取从最外道到最内道时间的一半，旋转延迟时间通常取旋转半周的时间&amp;#x3D;&amp;#x3D;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据传输率：磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输率&lt;br&gt;假设磁盘转速为r（转&amp;#x2F;秒），每条磁道容量为N个字节，则数据传输率为$D_r&amp;#x3D;rN$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;磁盘地址&lt;br&gt;&lt;img data-src=&#34;/f16.jpg&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;磁盘的工作原理&lt;br&gt;硬盘的主要操作是寻址、读盘、写盘。每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字。&lt;br&gt;硬盘属于机械式部件，其读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;RAID&lt;br&gt;将多个独立的物理磁盘组成一个独立的逻辑磁盘，数据分割交叉存储，并行访问。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;RAID0：无冗余和无校验的磁盘阵列。&lt;/li&gt;
&lt;li&gt;RAID1：镜像磁盘阵列。每份数据存两遍，成本太高&lt;/li&gt;
&lt;li&gt;RAID2：采用纠错的海明码的磁盘阵列。&lt;br&gt;逻辑上连续的几个bit物理上分散存储在各个盘中4bit信息位+3bit海明校验位——可纠正1bit错误&lt;br&gt;每个码字有 &lt;code&gt;m&lt;/code&gt; 个信息位和 &lt;code&gt;r&lt;/code&gt; 个冗余位，$ (m+r+1)≤2^r$&lt;br&gt;参考xyx学长的计网笔记：&lt;br&gt;&lt;img data-src=&#34;/f17.jpg&#34;&gt;&lt;/li&gt;
&lt;li&gt;RAID3：位交叉奇偶校验的磁盘阵列。前三个盘的奇偶校验位写在第四个盘上&lt;/li&gt;
&lt;li&gt;RAID4：块交叉奇偶校验的磁盘阵列。&lt;/li&gt;
&lt;li&gt;RAID5：无独立校验的奇偶校验磁盘阵列。在所有磁盘之间分条，并且每个数据块的奇偶校验块 (P) 写入到同一条带上&lt;br&gt;RAID1-RAID5数据不会损坏&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;固态硬盘-SSD&#34;&gt;&lt;a href=&#34;#固态硬盘-SSD&#34; class=&#34;headerlink&#34; title=&#34;固态硬盘(SSD)&#34;&gt;&lt;/a&gt;固态硬盘(SSD)&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;特性&lt;br&gt;属于Flash memory, EEPROM&lt;br&gt;组成：闪存翻译层，存储介质&lt;br&gt;&lt;img data-src=&#34;/f18.jpg&#34;&gt;&lt;br&gt;&amp;#x3D;&amp;#x3D;数据以页为单位读写，以块为单位擦除&amp;#x3D;&amp;#x3D;只有整个块被擦除之后才能写这一页，若视图修改包含已有数据的页$P_i$，则这个快中所有含有有用数据的页必须被复制到新的空白的块中，才能对$P_i$进行写操作&lt;br&gt;SSD的优点：&amp;#x3D;&amp;#x3D;随机写很慢，随机读比机械磁盘块&amp;#x3D;&amp;#x3D;，没噪声，能耗低，抗震性好，安全性高&lt;/li&gt;
&lt;li&gt;Wear Leveling 磨损均衡&lt;br&gt;重复擦写块就会磨损坏，一般是几百次到几千次&lt;br&gt;(1) 动态磨损均衡：&amp;#x3D;&amp;#x3D;写入时&amp;#x3D;&amp;#x3D;优先选择擦除次数少的新闪存块，只在写入时触发，仅考虑可用空间（对于冷数据不包括在空间池中，减少了可以用的block数量）&lt;br&gt;(2) 静态磨损均衡：就算没有写入，SSD也会监测并自动进行数据分配，让老的闪存快以读为主，让新的块腾出空间，以写为主：将数据从写入&amp;#x2F;擦除次数较低的block移动到其他block中，这样可以将低擦写次数的block释放出来，添加到可用可用空间池中，以便后续使用。仅覆盖单个闪存芯片单元&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;Cache&#34;&gt;&lt;a href=&#34;#Cache&#34; class=&#34;headerlink&#34; title=&#34;Cache&#34;&gt;&lt;/a&gt;Cache&lt;/h2&gt;&lt;p&gt;解决CPU和主存速度不一致问题，由SRAM组成，通常集成在CPU中&lt;/p&gt;
&lt;h3 id=&#34;程序访问的局部性原理&#34;&gt;&lt;a href=&#34;#程序访问的局部性原理&#34; class=&#34;headerlink&#34; title=&#34;程序访问的局部性原理&#34;&gt;&lt;/a&gt;程序访问的局部性原理&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;时间局部性：比如循环、数组（每次循环访问一次数组能体现时间局部性）&lt;/li&gt;
&lt;li&gt;空间局部性：最近的未来用到的信息很可能和正在使用的信息在存储空间上是临近的（顺序访问数组能体现空间局部性）&lt;br&gt;Cache利用局部性原理，将最近或频繁访问的数据复制到更快但容量较小的存储中，以便提高访问速度和系统性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;:::primary&lt;br&gt;&lt;strong&gt;hit&amp;#x2F;miss计算&lt;/strong&gt;&lt;br&gt;设$t_c$为访问一次Cache所需时间，$t_m$为访问一次内存所需时间，则Cache和主存同时被访问总时间为$t &amp;#x3D; Ht_c + (1 - H)t_m$&lt;br&gt;若先访问Cache再访问主存则时间为：$t &amp;#x3D; t_c + (1 - H)t_m$&lt;br&gt;:::&lt;/p&gt;
&lt;h3 id=&#34;Cache工作原理&#34;&gt;&lt;a href=&#34;#Cache工作原理&#34; class=&#34;headerlink&#34; title=&#34;Cache工作原理&#34;&gt;&lt;/a&gt;Cache工作原理&lt;/h3&gt;&lt;p&gt;主存和Cache之间以&amp;#x3D;&amp;#x3D;块(Block)&amp;#x3D;&amp;#x3D;为单位进行数据交换&lt;/p&gt;
&lt;h3 id=&#34;映射方式&#34;&gt;&lt;a href=&#34;#映射方式&#34; class=&#34;headerlink&#34; title=&#34;映射方式&#34;&gt;&lt;/a&gt;映射方式&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;直接映射 Directed mapped&lt;br&gt;&lt;img data-src=&#34;/f20.jpg&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/f27.jpg&#34;&gt;&lt;br&gt;cache 行号 &amp;#x3D; 主存块号 mod cache行数&lt;br&gt;物理地址结构：&lt;br&gt;| tag | index（行号） | byte offset |&lt;br&gt;&lt;img data-src=&#34;/f19.jpg&#34;&gt;&lt;br&gt;$$ index的位数 &amp;#x3D; log_2(cache的block数) $$&lt;br&gt;$$ byte\ offset的位数 &amp;#x3D; log_2(cache的block的字节数) $$&lt;br&gt;$$ tag的位数 &amp;#x3D; 32 - index的位数 - byte\ offset的位数 $$&lt;br&gt;在32位系统中，一个word是4B；64位系统中，一个word是8B&lt;br&gt;Cache的一行构成：&lt;br&gt;| valid bit | dirty bit | tag | data |&lt;br&gt;+++primary example&lt;br&gt;&lt;img data-src=&#34;/f21.jpg&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/f22.jpg&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/f23.jpg&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/f24.jpg&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/f25.jpg&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/f26.jpg&#34;&gt;&lt;br&gt;+++&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;全相连 Full Associative&lt;br&gt;block can go anywhere in cache&lt;br&gt;主存地址：&lt;br&gt;| tag | byte offset |&lt;br&gt;好处是能降低冲突率，每次需要和所有block比较是否hit开销大，不适合大容量Cache&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;组相连 Set Associative&lt;br&gt;&lt;img data-src=&#34;/f28.jpg&#34;&gt;&lt;br&gt;物理地址构成：&lt;br&gt;| tag | set index | 块内偏移 |&lt;br&gt;set index的位数表示有多少组，&lt;br&gt;$$ setNum &amp;#x3D;  \frac{Cache大小}{blockSize * 路数} $$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;+++primary&lt;br&gt;一个四路相联cache，CPU字长为4字节，内存和cache都是以字节编址，cache和内存交换单位为块，每个块大小为512字节，cache能够容纳1024个块。如果物理内存为32位地址:&lt;br&gt;set数 &amp;#x3D; 1024&amp;#x2F;4 &amp;#x3D; 256&lt;br&gt;index位数 &amp;#x3D; log2(256) &amp;#x3D; 8&lt;br&gt;blockOffset位数 &amp;#x3D; log2(512) &amp;#x3D; 9&lt;br&gt;tag位数 &amp;#x3D; 32 - 8 - 9 &amp;#x3D; 17&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;物理地址构成：| tag 17位 | set index 8位 | block offset 9 位 |&lt;/li&gt;
&lt;li&gt;计算内存地址FAB12389（16进制）在cache中可能的位置块号:&lt;br&gt;1111 1010 1011 0001 0010 0011 1000 1001&lt;br&gt;set index是10010001也就是145，所以可能的block号是145*4 &amp;#x3D; 580, 581, 582, 583&lt;br&gt;+++&lt;br&gt;&lt;img data-src=&#34;/f29.jpg&#34;&gt;&lt;br&gt;&amp;#x3D;&amp;#x3D;n路组相连需要n个比较器，位数&amp;#x3D;tag位数&amp;#x3D;&amp;#x3D;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;替换算法&#34;&gt;&lt;a href=&#34;#替换算法&#34; class=&#34;headerlink&#34; title=&#34;替换算法&#34;&gt;&lt;/a&gt;替换算法&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Random Replacement&lt;br&gt;随机找一块替换，实现简单，命中率低&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;FIFO&lt;br&gt;选择最早进入的Cache行的进行替换&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LRU&lt;br&gt;选择近期用得最少的Cache行进行替换，对每个Cache行维护一个计数器表示访问的次数，每次替换掉数值最小的。&lt;br&gt;2-way Cache要用1 bit来记录，4-way Cache要用2 bit来记录&lt;br&gt;+++primary&lt;br&gt;4-way Cache，有五个块映射到Cache同一组，访问顺序是{1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5}&lt;br&gt;&lt;img data-src=&#34;/f30.jpg&#34;&gt;&lt;br&gt;+++&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;Cache一致性问题&#34;&gt;&lt;a href=&#34;#Cache一致性问题&#34; class=&#34;headerlink&#34; title=&#34;Cache一致性问题&#34;&gt;&lt;/a&gt;Cache一致性问题&lt;/h3&gt;&lt;p&gt;当write hit时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Write through 直写&amp;#x2F;全写法&lt;br&gt;Cache hit的时候，CPU不仅写入Cache，而且写入主存&lt;br&gt;为了减少写入主存的时间小号，增加一个write buffer，CPU同时写入Cache和write buffer，write buffer采用FIFO，当write buffer满时，将write buffer中的数据写入主存&lt;/li&gt;
&lt;li&gt;Write back 写回法&lt;br&gt;write hit时，只把数据写入Cache，只有此块被replace的时候才写入主存。减少了方寸次数，所以给cache行设置一个dirty bit，CPU写数据时将dirty bit置为1表示此块被修改过，repalce时需要写入主存&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;write miss时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Write Allocate 写分配法&lt;br&gt;如果发生write miss，会从内存中加载对应的数据块到 cache 中，然后进行写操作。和 write-back搭配使用，把后续对该块的修改都缓存在 cache 中&lt;/li&gt;
&lt;li&gt;Not-Write-Allocate 非写分配法&lt;br&gt;只更新主存不把主存写入Cache，适用于 write-through，因为即使写入 cache，也会马上写回内存，没必要占用 cache 空间。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;#x3D;&amp;#x3D;write through通常和not-write-allocate一起用，write back 通常和write allocate一起用&amp;#x3D;&amp;#x3D;&lt;/p&gt;
&lt;h4 id=&#34;使用分离的指令Cache和数据Cache&#34;&gt;&lt;a href=&#34;#使用分离的指令Cache和数据Cache&#34; class=&#34;headerlink&#34; title=&#34;使用分离的指令Cache和数据Cache&#34;&gt;&lt;/a&gt;使用分离的指令Cache和数据Cache&lt;/h4&gt;&lt;p&gt;+++primary&lt;br&gt;&lt;img data-src=&#34;/f31.jpg&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/f32.jpg&#34;&gt;&lt;br&gt;+++&lt;/p&gt;
&lt;h2 id=&#34;虚拟存储器&#34;&gt;&lt;a href=&#34;#虚拟存储器&#34; class=&#34;headerlink&#34; title=&#34;虚拟存储器&#34;&gt;&lt;/a&gt;虚拟存储器&lt;/h2&gt;&lt;h3 id=&#34;基本概念&#34;&gt;&lt;a href=&#34;#基本概念&#34; class=&#34;headerlink&#34; title=&#34;基本概念&#34;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;p&gt;主存和辅存共同构成了虚拟存储器，对于应用程序员而言，虚拟存储器是透明的。（对OS开系统程序员不透明，他们必须管理TLB）&lt;br&gt;虚拟存储器具有主存的速度和辅存的容量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;允许多个程序之间高效、安全地共享内存&lt;/li&gt;
&lt;li&gt;允许单个程序使用超过内存容量的内存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;+++primary&lt;br&gt;实地址&amp;#x3D;主存页号+页内字地址&lt;br&gt;虚地址&amp;#x3D;虚存页号+页内字地址&lt;br&gt;辅存地址&amp;#x3D;磁盘号+盘面号+磁道号+扇区号&lt;br&gt;+++&lt;/p&gt;
&lt;p&gt;虚拟存储器缺页访问辅存的代价很大，当程序访问某个virtual page时，如果该页当前不在主存中，就会发生page fault，操作系统需要从辅存加载该页到主存，访问很慢所以访问代价大。因此采用&lt;code&gt;full associative&lt;/code&gt;允许virtual page可以加载到主存的任何一个空闲物理页框中，提高命中率。&lt;br&gt;写操作中处理一致性问题时采用 &lt;code&gt;write back&lt;/code&gt;。主存中的页面状态维护一个dirty标志位。当操作系统需要将该页替换出主存时，会检查该页的脏页标志：如果dirty，说明主存页面数据修改过，必须写回辅存；如果dirty为0，说明主存数据和辅存一致，直接丢弃主存页面，无需写回&lt;/p&gt;
&lt;h3 id=&#34;页式虚拟存储器&#34;&gt;&lt;a href=&#34;#页式虚拟存储器&#34; class=&#34;headerlink&#34; title=&#34;页式虚拟存储器&#34;&gt;&lt;/a&gt;页式虚拟存储器&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;基本单位：页&lt;br&gt;主存和虚拟地址空间被划分为相同大小的页，主存中的成为物理页（实页、页框、frame），虚拟地址空间中的页称为虚拟页（虚页）&lt;br&gt;页表(page table)记录了程序的虚页调入贮存时被安排在主存中的位置&lt;br&gt;一般的page大小从4KiB ~ 64KiB不等&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;页表(page table)&lt;br&gt;页表放在主存中。&lt;br&gt;&lt;img data-src=&#34;/f33.jpg&#34;&gt;&lt;br&gt;有效位（Valid Bit）：用于指示一个页面是否已经被加载到主存中。如果有效位被设置为1，这意味着对应的页面已经在物理内存中，可以立即被访问。如果有效位为0，则表示该页面当前不在内存中，可能需要从磁盘或其他存储设备中调入。当一个程序尝试访问一个页面时，操作系统会检查页表中的有效位，如果发现页面不在内存中，就会触发一个page fault，然后将页面从磁盘加载到内存中。&lt;br&gt;引用位（Reference Bit）：引用位主要用于页面置换算法中，它记录了页面最近是否被访问过。每当一个页面被访问时，操作系统会将该页面的引用位置为1。随着时间的推移，如果一个页面长时间没有被访问，它的引用位可能会被清零。当操作系统需要选择一个页面进行置换时，它可能会优先选择那些引用位为0的页面。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;转换过程：当一个程序尝试访问内存时，它会生成一个虚拟地址。虚拟地址包含两部分信息：页号（Page Number）和页内偏移（Offset）。用VPN作为索引查询page table，检查valid bit是否为1，从页表条目中获取PPN，PPN和page offset组合成物理地址。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;页式虚拟存储器的优点：页面长度固定，页表简单，调入方便&lt;br&gt;缺点：产生内碎片&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;p&gt;地址转换&lt;br&gt;&lt;img data-src=&#34;/f34.png&#34;&gt;&lt;br&gt;每个进程都有一个页表基址寄存器，存放该进程的页表首地址。然后通过VPN作为索引在页表中查找对应的页表项。物理地址&amp;#x3D;物理页号 + 页内地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;TLB（快表）&lt;br&gt;为了减少访问主存的此书，TLB相当于page table的cache。&lt;br&gt;TLB用&lt;code&gt;SRAM&lt;/code&gt;实现，不在主存中，工作原理类似于Cache，通常采用full associative或者set associative。&lt;br&gt;&lt;img data-src=&#34;/f35.jpg&#34;&gt;&lt;br&gt;通过VPN查找TLB和Cache的查找一样，如果是全相连则直接比较tag，如果是组相连则通过低位查找set，然后用高位和tag比较。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;具有TLB和Cache的多级存储系统&lt;br&gt;&lt;img data-src=&#34;/f36.jpg&#34;&gt;&lt;br&gt;查找时，TLB和page table可以同步进行，如果在TLB中找到了，page table的查找就作废。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;/f37.jpg&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;段式虚拟存储器&#34;&gt;&lt;a href=&#34;#段式虚拟存储器&#34; class=&#34;headerlink&#34; title=&#34;段式虚拟存储器&#34;&gt;&lt;/a&gt;段式虚拟存储器&lt;/h3&gt;&lt;p&gt;&lt;img data-src=&#34;/f38.jpg&#34;&gt;&lt;br&gt;按程序的逻辑结构划分，段的长度因程序而异。虚拟地址分为段号和段内地址。虚地址和实地址的转换依靠段表。&lt;br&gt;段表每行记录某个段的&amp;#x3D;&amp;#x3D;段号、有效位、段长度、段起始地址&amp;#x3D;&amp;#x3D;。&lt;br&gt;段表本身也是段，一般驻留在主存中&lt;br&gt;&amp;#x3D;&amp;#x3D;分页对程序员是透明的，分段对程序员是不透明的&amp;#x3D;&amp;#x3D;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;段式虚拟存储器的优点：具有逻辑独立性，易于编译、管理、修改和保护，便于多道程序的共享&lt;br&gt;缺点：产生外碎片&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;段页式虚拟存储器&#34;&gt;&lt;a href=&#34;#段页式虚拟存储器&#34; class=&#34;headerlink&#34; title=&#34;段页式虚拟存储器&#34;&gt;&lt;/a&gt;段页式虚拟存储器&lt;/h3&gt;&lt;p&gt;把程序按逻辑结构分段，再在每段划分固定大小的页。因此段的长度必须是页长度的整数倍，段的起点必须是某一页的起点。&lt;br&gt;虚地址分为&amp;#x3D;&amp;#x3D;段号，段内页号，页内地址&amp;#x3D;&amp;#x3D;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;访问流程：从段表基址寄存器（STBR） 中读取段表的起始地址，用段号（s）作为索引，在段表中查找第 s 个表项，从该表项中取出该段对应的页表起始地址（即页表基址），与段内页号合成得到页表地址（页表项地址 &amp;#x3D; PTBR + p × 页表项大小），读取第 p 个页表项得到物理页号（PPN），和页内地址合成得到物理地址&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/07/01/computer-science/computer-organization/%E9%94%99%E9%A2%98%E9%9B%86%E5%90%88/</guid>
            <title>错题集合</title>
            <link>http://example.com/2025/07/01/computer-science/computer-organization/%E9%94%99%E9%A2%98%E9%9B%86%E5%90%88/</link>
            <category>错题</category>
            <pubDate>Tue, 01 Jul 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;错题集合&#34;&gt;&lt;a href=&#34;#错题集合&#34; class=&#34;headerlink&#34; title=&#34;错题集合&#34;&gt;&lt;/a&gt;错题集合&lt;/h1&gt;&lt;h2 id=&#34;Ch2&#34;&gt;&lt;a href=&#34;#Ch2&#34; class=&#34;headerlink&#34; title=&#34;Ch2&#34;&gt;&lt;/a&gt;Ch2&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;某计算机字长为8位，CPU中有一个8位加法器，已知无符号数x&amp;#x3D;69, y&amp;#x3D;38，若在该加法器中计算x-y，则加法器的两个输入短信息和输入的低位进位信息分别为（）&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;0100 0101, 1101 1001, 1 &lt;blockquote&gt;
&lt;p&gt;无符号数减法，在加法器中输入x的原码，y的取反和1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;减法指令 “sub R1, R2, R3” 的功能为 “(R1) - (R2) -&amp;gt; R3”, 该指令执行后将生成进位&amp;#x2F;借位标志CF和溢出标志OF，若(R1) &amp;#x3D; FFFF FFFFH, R2 &amp;#x3D; FFFF FFF0H, 则该减法指令执行后，CF和OF分别为：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;CF &amp;#x3D; 0, OF &amp;#x3D; 0&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;已知x, y为int类型，当x &amp;#x3D; 100, y &amp;#x3D; 200时，执行 “x - y”指令得到的溢出标志OF和结尾标志CF分别为0，1，那么当x &amp;#x3D; 1-, y &amp;#x3D; -20时，执行该指令得到的OF和CF分别为：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;OF &amp;#x3D; 0, CF &amp;#x3D; 1&lt;blockquote&gt;
&lt;p&gt;ALU生成标志位时只负责计算，不管运算对象是有符号数还是无符号数。CF&amp;#x3D;1表示当做无符号数运算时溢出，OF&amp;#x3D;1表示当做有符号数运算时溢出。当做有符号数，10-(-20)没问题，所以OF&amp;#x3D;0；把它俩当做无符号数的时候，x &amp;#x3D; 10 &amp;#x3D; 0000 0000 0000 0000 0000 0000 0000 1010，y &amp;#x3D; -20 &amp;#x3D; 1111 1111 1111 1111 1111 1111 1110 1100，此时x &amp;lt; y，所以CF&amp;#x3D;1。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;下列关于整数乘法运算的叙述中，错误的是：D&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;A. 用阵列乘法器实现的乘运算可以在一个时钟周期内完成 –正确，因为是组合逻辑理论上可以在一个clc里完成&lt;/li&gt;
&lt;li&gt;B. 用ALU和移位器实现的乘运算无法在一个时钟周期内完成&lt;/li&gt;
&lt;li&gt;C. 变量与常数的乘运算可编译优化为若干移位及家&amp;#x2F;减运算指令&lt;/li&gt;
&lt;li&gt;D. 两个变量的乘运算无法编译转换为移位及加法等指令的循环实现&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Ch4&#34;&gt;&lt;a href=&#34;#Ch4&#34; class=&#34;headerlink&#34; title=&#34;Ch4&#34;&gt;&lt;/a&gt;Ch4&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;简化地址结构的方式是尽量采用： 隐含寻址&lt;/li&gt;
&lt;/ol&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/06/19/SE/diagram/</guid>
            <title>画图题</title>
            <link>http://example.com/2025/06/19/SE/diagram/</link>
            <category>软件工程</category>
            <pubDate>Thu, 19 Jun 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;ol&gt;
&lt;li&gt;用例图 Use Case Diagram&lt;br&gt;Use-Cases: A collection of user scenarios that describe the thread of usage of a system&lt;br&gt;主要包含涉及的角色，角色对应的行为，第三方参与部分&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;参与者：与系统交互的用户或其他软硬件系统，用小人形表示&lt;/li&gt;
&lt;li&gt;用例：系统中执行的一系列动作，用椭圆表示。&lt;/li&gt;
&lt;li&gt;关系参与者与用例、参与者之间、用例之间的联系。连线&lt;/li&gt;
&lt;li&gt;边界：一组用例描述的系统或子系统，用矩形框表示。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;+++primary example: SafeHome&lt;br&gt;;;;id3 题目&lt;br&gt;Our research indicates that the market for home security systems is growing at a rate of 40% per year. We would like to enter this market by building a &amp;#x3D;&amp;#x3D;microprocessor-based&amp;#x3D;&amp;#x3D; home security system that would protect against and&amp;#x2F;or recognize a variety of &amp;#x3D;&amp;#x3D;undesirable situations&amp;#x3D;&amp;#x3D; such as illegal entry, fire, flooding, and others. The product will use appropriate &amp;#x3D;&amp;#x3D;sensors&amp;#x3D;&amp;#x3D; to detect each situation, can be programmed by the &amp;#x3D;&amp;#x3D;homeowner&amp;#x3D;&amp;#x3D;, and will automatically telephone a monitoring agency when a situation is detected.&lt;br&gt;;;;&lt;/p&gt;
&lt;p&gt;;;;id3 答案&lt;br&gt;&lt;img data-src=&#34;/useCase.jpg&#34;&gt;&lt;br&gt;我的理解是找到里面的人(onwer, monitoring agency, 然后可以加个administrator)，物件(sensor)，中间的框是个系统，然后里面的椭圆写上对应的交互行为，连上线，感觉比较主观&lt;br&gt;;;;&lt;br&gt;+++&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;p&gt;CRC Card&lt;br&gt;每个卡片应该包含：类名，类的描述信息，职责，合作类&lt;br&gt;+++primary example&lt;br&gt;&lt;img data-src=&#34;/CRC.jpg&#34;&gt;&lt;br&gt;+++&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;类图 class diagram&lt;br&gt;主要的信息：类名，属性(name: type)，方法(name(parameter): return type)&lt;br&gt;+++primary example&lt;br&gt;;;;id4 例子1&lt;br&gt;&lt;img data-src=&#34;/class.jpg&#34;&gt;&lt;br&gt;;;;&lt;br&gt;;;;id4 例子2&lt;br&gt;&lt;img data-src=&#34;/class2.jpg&#34;&gt;&lt;br&gt;;;;&lt;br&gt;+++&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;状态图 state diagram&lt;br&gt;&lt;strong&gt;节点&lt;/strong&gt;：开始状态，结束状态，状态&lt;br&gt;&lt;strong&gt;边&lt;/strong&gt;：行为&lt;br&gt;状态：圆角矩形 state name, state variables, state activities&lt;br&gt;转移：带有标记的箭头&lt;br&gt;初始状态：实心圆&lt;br&gt;终止状态：实心环&lt;br&gt;分支：菱形&lt;br&gt;+++primary example&lt;br&gt;;;;id5 状态图&lt;br&gt;&lt;img data-src=&#34;/state.png&#34;&gt;&lt;br&gt;;;;&lt;br&gt;;;;id5 状态图&lt;br&gt;&lt;img data-src=&#34;/state2.jpg&#34;&gt;&lt;br&gt;;;;&lt;br&gt;+++&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;时序图 sequence diagram&lt;br&gt;对象（参与者上面要画个人）、生命线（对象下面的虚线）、控制焦点、消息&lt;br&gt;&lt;img data-src=&#34;/seq.jpg&#34;&gt;&lt;br&gt;实心箭头表示同步消息：一个对象向另一个对象发出同步消息后，将处于阻塞状态，一直等到另一个对象的回应（图里面的请求是同步的）&lt;br&gt;简单箭头表示异步&lt;br&gt;:::warning&lt;br&gt;箭头的画法存疑&lt;br&gt;:::&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据流图 data flow diagram&lt;br&gt;外部实体（数据的原点和终点）：软件系统外部环境中的实体（包括人、组织或其他软件系统），用&amp;#x3D;&amp;#x3D;方框&amp;#x3D;&amp;#x3D;&lt;br&gt;加工Process：对数据进行处理的单元，比如内部的xx系统，用&amp;#x3D;&amp;#x3D;圆角矩形&amp;#x3D;&amp;#x3D;或椭圆&lt;br&gt;数据存储：数据库，用&amp;#x3D;&amp;#x3D;右侧开口的矩形或者左右开口的矩形&amp;#x3D;&amp;#x3D;&lt;br&gt;数据流：箭头方向即数据流动方向，数据流名标在数据流线上面&lt;br&gt;看例子：&lt;br&gt;&lt;img data-src=&#34;/dataflow.jpg&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;软件架构图 architecture&lt;br&gt;以前后端分离的系统为例（前端，后端，数据库）&lt;br&gt;&lt;img data-src=&#34;/arch.jpg&#34;&gt;&lt;br&gt;三个大框分别是客户端、服务器、数据库层&lt;br&gt;里面小框，前端就是Web app和移动app，后端就是各种系统，数据库就是各种数据库（表？）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;泳道图 Swimlane Diagram&lt;br&gt;跨职能流程图。旨在展示工作流中每个步骤涉及的流程和职能部门。在表示use-case的同时，描述对活动负责的actor&amp;#x2F;analysis class&lt;br&gt;最上面放实体，然后分成一列一列，其他的和流程图一样&lt;br&gt;&lt;img data-src=&#34;/swim.jpg&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/06/19/SE/note/</guid>
            <title>SE note</title>
            <link>http://example.com/2025/06/19/SE/note/</link>
            <category>软件工程</category>
            <pubDate>Thu, 19 Jun 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Ch2-Software-Engineering&#34;&gt;&lt;a href=&#34;#Ch2-Software-Engineering&#34; class=&#34;headerlink&#34; title=&#34;Ch2 Software Engineering&#34;&gt;&lt;/a&gt;Ch2 Software Engineering&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Definition: The application of a &amp;#x3D;&amp;#x3D;systematic&amp;#x3D;&amp;#x3D;, &amp;#x3D;&amp;#x3D;disciplined&amp;#x3D;&amp;#x3D;, &amp;#x3D;&amp;#x3D;quantifiable（可量化）&amp;#x3D;&amp;#x3D; approach to the &amp;#x3D;&amp;#x3D;development&amp;#x3D;&amp;#x3D;, &amp;#x3D;&amp;#x3D;operation&amp;#x3D;&amp;#x3D;, and &amp;#x3D;&amp;#x3D;maintenance&amp;#x3D;&amp;#x3D; of software&lt;/li&gt;
&lt;li&gt;软件工程是一个多层次的技术体系(a layered technology)&lt;ul&gt;
&lt;li&gt;从下往上是a “quality” focus, process model, methods, tools, 反映了构建高质量软件产品的逻辑流程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;软件过程（The Software Process）中的两个重要概念：通用过程框架（Common Process Framework）和 伞形活动（Umbrella Activities）&lt;ul&gt;
&lt;li&gt;通用过程框架（Common Process Framework）： 软件开发过程中的一些基本要素&lt;ul&gt;
&lt;li&gt;工作任务（work tasks）：指在软件开发的不同阶段中需要完成的具体任务。&lt;/li&gt;
&lt;li&gt;工作产品（work products）：指在执行工作任务过程中产生的各种文档、代码等成果物。&lt;/li&gt;
&lt;li&gt;里程碑与交付物（milestones &amp;amp; deliverables）：里程碑是项目进展的重要节点，而交付物是在这些节点上需要提交的成果。&lt;/li&gt;
&lt;li&gt;质量保证检查点（QA checkpoints）：在整个开发过程中设置的检查点，用于评估和确保软件产品的质量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;伞形活动（Umbrella Activities）：软件开发过程中需要执行的活动&lt;ul&gt;
&lt;li&gt;项目管理（Project management）：负责项目的规划、组织、协调和控制，确保项目按计划进行。&lt;/li&gt;
&lt;li&gt;质量保证（Quality assurance）：通过一系列措施确保软件产品的质量符合预定标准。&lt;/li&gt;
&lt;li&gt;工作产品生产（Work product production）：涉及创建和维护软件开发过程中产生的各种工作产品。&lt;/li&gt;
&lt;li&gt;测量（Measurement）：收集和分析数据以评估项目的状态和进度。&lt;/li&gt;
&lt;li&gt;正式技术评审（Formal technical reviews）：对软件的技术设计和实现进行系统性的审查。&lt;/li&gt;
&lt;li&gt;配置管理（Configuration management）：管理软件开发过程中各种配置项的变化，确保版本的一致性和可追溯性。&lt;/li&gt;
&lt;li&gt;重用管理（Reusability management）：促进软件组件和模块的重用，提高开发效率和软件质量。&lt;/li&gt;
&lt;li&gt;风险管理（Risk management）：识别、评估和应对可能影响项目成功的各种风险。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Generic Process Framework&lt;/strong&gt; 通用的软件开发过程框架&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Communication&lt;/strong&gt;: 与客户协作并收集需求&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Planning&lt;/strong&gt;: establishes engineering work plan, describes technical risks, lists resource requirements, work products produced, and defines work schedule&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Modeling&lt;/strong&gt;: 创建模型以帮助开发者和客户理解需求和设计&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Construction&lt;/strong&gt;: code &amp;amp; test&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Deployment&lt;/strong&gt;: 交付软件供客户评估和反馈&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Process Adaptation&lt;/strong&gt; 过程适配: 根据项目的具体需求、限制条件和特点，对软件开发过程进行定制和调整&lt;ul&gt;
&lt;li&gt;overall &amp;#x3D;&amp;#x3D;flow&amp;#x3D;&amp;#x3D; of activities, actions, and tasks and the interdependencies among them&lt;/li&gt;
&lt;li&gt;degree to which &amp;#x3D;&amp;#x3D;actions and tasks&amp;#x3D;&amp;#x3D; are defined within each framework activity&lt;/li&gt;
&lt;li&gt;degree to which &amp;#x3D;&amp;#x3D;work products&amp;#x3D;&amp;#x3D; are identified and required&lt;/li&gt;
&lt;li&gt;manner which &amp;#x3D;&amp;#x3D;quality assurance&amp;#x3D;&amp;#x3D; activities are applied&lt;/li&gt;
&lt;li&gt;manner in which &amp;#x3D;&amp;#x3D;project tracking and control&amp;#x3D;&amp;#x3D; activities are applied&lt;/li&gt;
&lt;li&gt;overall degree of &amp;#x3D;&amp;#x3D;detail and rigor&amp;#x3D;&amp;#x3D; with which the process is described&lt;/li&gt;
&lt;li&gt;degree to which the &amp;#x3D;&amp;#x3D;customer and other stakeholders&amp;#x3D;&amp;#x3D; are involved with the project&lt;/li&gt;
&lt;li&gt;level of autonomy given to the &amp;#x3D;&amp;#x3D;software team&amp;#x3D;&amp;#x3D;&lt;/li&gt;
&lt;li&gt;degree to which &amp;#x3D;&amp;#x3D;team organization and roles&amp;#x3D;&amp;#x3D; are prescribed&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The Essence of Practice&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Understand the problem&lt;/strong&gt; (communication and analysis).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Plan a solution&lt;/strong&gt; (modeling and software design).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Carry out the plan&lt;/strong&gt; (code generation).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Examine the result for accuracy&lt;/strong&gt; (testing and quality assurance).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;General Principles 通用原则：软件开发过程中应遵循的一些核心指导思想或基本原则&lt;ul&gt;
&lt;li&gt;The reason it all exists — Provide Value to users&lt;/li&gt;
&lt;li&gt;KISS — Keep It Simple, Stupid!&lt;/li&gt;
&lt;li&gt;Maintain the Vision&lt;/li&gt;
&lt;li&gt;What you produce, others will consume&lt;/li&gt;
&lt;li&gt;Be open to the future&lt;/li&gt;
&lt;li&gt;Plan ahead for reuse&lt;/li&gt;
&lt;li&gt;Think!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Software Development Myths 软件开发管理中常见的误解（Myth）及其背后的现实情况（Reality）&lt;ul&gt;
&lt;li&gt;Management myths&lt;ul&gt;
&lt;li&gt;标准和流程的有效性依赖于团队的理解和接受程度。&lt;/li&gt;
&lt;li&gt;软件开发是一个高度协作和复杂的创造性过程，简单地增加人力并不能解决进度问题。&lt;/li&gt;
&lt;li&gt;外包项目同样需要良好的管理和沟通能力，不能因为外包就忽视了对项目的控制和监督&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Customer myths&lt;ul&gt;
&lt;li&gt;详细的需求分析和规划&lt;/li&gt;
&lt;li&gt;充分的沟通与确认&lt;/li&gt;
&lt;li&gt;合理的进度评估&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Practitioner’s myths&lt;ul&gt;
&lt;li&gt;错误：一旦我们编写好程序并使其正常运行，我们的工作就完成了&lt;/li&gt;
&lt;li&gt;过早进入编码阶段可能会导致更多的返工和调整，从而延长项目周期&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;Ch3-Software-Process-Structure&#34;&gt;&lt;a href=&#34;#Ch3-Software-Process-Structure&#34; class=&#34;headerlink&#34; title=&#34;Ch3 Software Process Structure&#34;&gt;&lt;/a&gt;Ch3 Software Process Structure&lt;/h1&gt;&lt;p&gt;Umbrella Activities是贯穿整个软件开发过程的活动，Framework Activity是软件开发的核心阶段，如沟通、计划、建模、构建和部署，每个框架活动下都有具体的task set，每个task set中又包含多个具体的action&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Process flow&lt;/strong&gt; 过程流（对于之前提到的Generic Process Framework的五步）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;线性过程流（Linear process flow）&lt;/li&gt;
&lt;li&gt;迭代过程流（Iterative process flow）&lt;/li&gt;
&lt;li&gt;演化过程流（Evolutionary process flow）&lt;/li&gt;
&lt;li&gt;并行过程流（Parallel process flow）&lt;br&gt;&lt;img data-src=&#34;/f1.jpg&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Process Patterns&lt;/strong&gt; 过程模式&lt;br&gt;Process patterns define a set of activities, actions, work tasks, work products and&amp;#x2F;or related behaviors&lt;br&gt;提供了一种&lt;code&gt;template&lt;/code&gt;用于定义模式&lt;br&gt;&lt;strong&gt;Generic software pattern elements&lt;/strong&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;pattern name &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Intent (objective of pattern) &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Type (Task pattern, Stage pattern, Phase pattern)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Initial context&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Solution&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Resulting context&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Related patterns&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Known uses&amp;#x2F;examples&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Process Assessment&lt;/strong&gt;&lt;br&gt;几种评估软件过程的方法：&lt;br&gt;SCAMPI (Standard CMMI Appraisal Method for Process Improvement)&lt;br&gt;SPICE (ISO&amp;#x2F;IEC 15504)&lt;br&gt;CBA IPI (Capability Benchmarking Appraisal using the Integrated Process Improvement method)&lt;br&gt;ISO 9001:2000 for Software&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The Capability Maturity Model Integration 能力成熟度模型集成（CMMI）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Level 0: Incomplete &lt;/li&gt;
&lt;li&gt;Level 1: Performed &lt;/li&gt;
&lt;li&gt;Level 2: Managed&lt;/li&gt;
&lt;li&gt;Level 3: Defined&lt;/li&gt;
&lt;li&gt;Level 4: Quantitatively Managed 定量管理&lt;/li&gt;
&lt;li&gt;Level 5: Optimizing&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;Ch4-Process-Models&#34;&gt;&lt;a href=&#34;#Ch4-Process-Models&#34; class=&#34;headerlink&#34; title=&#34;Ch4 Process Models&#34;&gt;&lt;/a&gt;Ch4 Process Models&lt;/h1&gt;&lt;h2 id=&#34;Prescriptive-Models&#34;&gt;&lt;a href=&#34;#Prescriptive-Models&#34; class=&#34;headerlink&#34; title=&#34;Prescriptive Models&#34;&gt;&lt;/a&gt;Prescriptive Models&lt;/h2&gt;&lt;p&gt;Prescriptive(规范的) process models advocate an orderly approach to software engineering&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The Waterfall Model: A reasonable approach when requirements are well defined&lt;br&gt;&lt;img data-src=&#34;/4-1.jpg&#34;&gt;&lt;/li&gt;
&lt;li&gt;The V Model&lt;br&gt;&lt;img data-src=&#34;/4-2.jpg&#34;&gt;&lt;/li&gt;
&lt;li&gt;Incremental Process Models 增量过程模型&lt;ul&gt;
&lt;li&gt;The Incremental Model 增量模型: 将整个系统划分为多个可交付的“增量”部分，每个增量都作为一个独立的小项目进行五步流程: A good approach when a working core product is required quickly&lt;br&gt; &lt;img data-src=&#34;/4-3.jpg&#34;&gt;&lt;/li&gt;
&lt;li&gt;The Rapid Application Development (RAD) Model 快速应用开发模型: 短时间内交付功能完善的系统，communication和planning之后分成好几个team进行modeling和construction，最后合并deployment&lt;br&gt; &lt;img data-src=&#34;/4-4.jpg&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Evolutionary Process Models 进化式过程模型&lt;ul&gt;
&lt;li&gt;Prototyping 原型化方法: 当客户有明确的需求但不清楚具体细节时，通过原型，客户可以直观地看到系统的雏形并提出修改意见；原型通常是“抛弃型”的，即在验证概念后会被丢弃，而不是直接作为最终产品的一部分&lt;ul&gt;
&lt;li&gt;Prototype Model: Communication, Quick Plan, Modeling &amp;amp; Quick Design, Construction of prototype, Deployment Delivery &amp;amp; Feedback&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The Spiral Model 螺旋模型: 螺旋模型将整个开发过程视为一个逐渐扩大的螺旋线，每个环代表一个开发阶段或迭代周期，在每一次迭代中都进行风险分析（Risk Analysis）&lt;br&gt; &lt;img data-src=&#34;/4-5.jpg&#34;&gt; &lt;/li&gt;
&lt;li&gt;The Concurrent Development Model 并行开发模型&lt;ul&gt;
&lt;li&gt;并行开发模型定义了一系列&lt;code&gt;事件&lt;/code&gt;，这些事件将触发每个活动、动作或任务&lt;code&gt;从一个状态到另一个状态的转换&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Especially good for client&amp;#x2F;server applications&lt;/li&gt;
&lt;li&gt;并行开发模型定义了一个活动网络，而不是简单的线性事件序列&lt;/li&gt;
&lt;li&gt;需要在Flexibility, Extensibility, Speed of development 和 high quality 中权衡&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Specialized-Process-Models-专业化的软件过程模型&#34;&gt;&lt;a href=&#34;#Specialized-Process-Models-专业化的软件过程模型&#34; class=&#34;headerlink&#34; title=&#34;Specialized Process Models 专业化的软件过程模型&#34;&gt;&lt;/a&gt;Specialized Process Models 专业化的软件过程模型&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Component-Based Development （强调reuse）&lt;/li&gt;
&lt;li&gt;Formal methods （形式化方法强调使用数学手段来精确地描述需求）&lt;/li&gt;
&lt;li&gt;Aspect-Oriented Software Development （面向切面，切面指那些横跨多个模块或功能的通用关注点）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;The-Unified-Process-统一过程&#34;&gt;&lt;a href=&#34;#The-Unified-Process-统一过程&#34; class=&#34;headerlink&#34; title=&#34;The Unified Process 统一过程&#34;&gt;&lt;/a&gt;The Unified Process 统一过程&lt;/h2&gt;&lt;p&gt;统一过程是一种“用例驱动、以架构为中心、迭代和增量”的软件开发过程&lt;br&gt;A &amp;#x3D;&amp;#x3D;“use-case driven, architecture-centric, iterative and incremental”&amp;#x3D;&amp;#x3D; software process closely aligned with the Unified Modeling Language (UML)&lt;br&gt;&lt;img data-src=&#34;/4-6.png&#34;&gt;&lt;br&gt;五个阶段: &amp;#x3D;&amp;#x3D;Inception, Elaboration, Construction, Transition, Production&amp;#x3D;&amp;#x3D;&lt;/p&gt;
&lt;h3 id=&#34;统一过程（Unified-Process-UP）在各个阶段产生的工作产品（Work-Products）&#34;&gt;&lt;a href=&#34;#统一过程（Unified-Process-UP）在各个阶段产生的工作产品（Work-Products）&#34; class=&#34;headerlink&#34; title=&#34;统一过程（Unified Process, UP）在各个阶段产生的工作产品（Work Products）&#34;&gt;&lt;/a&gt;统一过程（Unified Process, UP）在各个阶段产生的工作产品（&lt;code&gt;Work Products&lt;/code&gt;）&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Inception Phase（启动阶段）&lt;br&gt;Vision Document（愿景文档）：概述项目的总体目标、范围和预期结果。&lt;br&gt;Initial Use-case Model（初始用例模型）：描述系统的主要功能和用户交互场景。&lt;br&gt;Initial Project Glossary（初始项目术语表）：定义项目中使用的专业术语和缩写。&lt;br&gt;Initial Business Case（初始商业案例）：分析项目的商业价值和可行性。&lt;br&gt;Initial Risk Assessment（初始风险评估）：识别和评估项目可能面临的风险。&lt;br&gt;Project Plan Phases and Iterations（项目计划阶段和迭代）：制定项目的整体计划，包括阶段划分和迭代安排。&lt;br&gt;Business Model（业务模型）：描述项目的业务流程和商业模式。&lt;br&gt;Prototypes（原型）：创建系统的初步原型，用于验证需求和设计。&lt;/li&gt;
&lt;li&gt;Elaboration Phase（细化阶段）&lt;br&gt;Use-case Model（用例模型）：进一步完善和细化用例模型，明确系统功能。&lt;br&gt;Functional and Non-functional Requirements（功能性与非功能性需求）：详细描述系统需要满足的功能性和非功能性要求。&lt;br&gt;Analysis Model（分析模型）：基于需求分析建立的系统逻辑模型。&lt;br&gt;Software Architecture Description（软件架构描述）：定义系统的整体架构和关键组件。&lt;br&gt;Executable Architectural Prototype（可执行架构原型）：实现一个可运行的架构原型，验证架构的可行性和性能。&lt;br&gt;Preliminary Design Model（初步设计模型）：基于架构描述进行初步的设计。&lt;br&gt;Revise Risk List（修订风险列表）：根据新的信息和发现更新风险评估。&lt;br&gt;Project Plan Iteration Plan, Workflow, Milestones（项目计划迭代计划、工作流、里程碑）：细化项目计划，包括具体的迭代安排、工作流程和关键里程碑。&lt;br&gt;Preliminary User Manual（初步用户手册）：编写系统的初步使用说明。&lt;/li&gt;
&lt;li&gt;Construction Phase（构建阶段）&lt;br&gt;Design Model（设计模型）：完成详细的系统设计，包括模块设计和接口设计。&lt;br&gt;Software Components（软件组件）：开发和实现各个软件组件。&lt;br&gt;Integrated Software Increment（集成软件增量）：将各个组件集成在一起，形成可运行的软件增量。&lt;br&gt;Test Plan（测试计划）：制定详细的测试计划，包括测试策略和资源安排。&lt;br&gt;Test Cases（测试用例）：编写具体的测试用例，用于验证系统功能和质量。&lt;br&gt;Support Documentation User Installation Increment（支持文档用户安装增量）：编写用户安装和操作指南，帮助用户正确安装和使用系统。&lt;/li&gt;
&lt;li&gt;Transition Phase（过渡阶段）&lt;br&gt;Delivered Software Increment（交付的软件增量）：向用户交付经过测试和验证的软件增量。&lt;br&gt;Beta Test Reports（Beta测试报告）：收集和整理Beta测试期间的反馈和问题报告。&lt;br&gt;User Feedback（用户反馈）：收集用户的实际使用反馈，为后续改进提供依据。&lt;/li&gt;
&lt;li&gt;Production&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;个人软件过程（Personal-Software-Process-PSP）&#34;&gt;&lt;a href=&#34;#个人软件过程（Personal-Software-Process-PSP）&#34; class=&#34;headerlink&#34; title=&#34;个人软件过程（Personal Software Process, PSP）&#34;&gt;&lt;/a&gt;个人软件过程（Personal Software Process, PSP）&lt;/h3&gt;&lt;p&gt;Five Framework Activities:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Planning&lt;/li&gt;
&lt;li&gt;High-Level Design&lt;/li&gt;
&lt;li&gt;High-Level Design Review&lt;/li&gt;
&lt;li&gt;Development&lt;/li&gt;
&lt;li&gt;Postmortem（事后分析）&lt;br&gt;Stresses the Need for Error Identification and Understanding&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;团队软件过程（Team-Software-Process-TSP）&#34;&gt;&lt;a href=&#34;#团队软件过程（Team-Software-Process-TSP）&#34; class=&#34;headerlink&#34; title=&#34;团队软件过程（Team Software Process, TSP）&#34;&gt;&lt;/a&gt;团队软件过程（Team Software Process, TSP）&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Each project is “launched” using a “script” that defines the tasks to be accomplished&lt;/li&gt;
&lt;li&gt;Teams are self-directed&lt;/li&gt;
&lt;li&gt;Measurement is encouraged&lt;/li&gt;
&lt;li&gt;Measures are analyzed with the intent of improving the team process&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;Ch5-Agile-Development-敏捷开发&#34;&gt;&lt;a href=&#34;#Ch5-Agile-Development-敏捷开发&#34; class=&#34;headerlink&#34; title=&#34;Ch5 Agile Development 敏捷开发&#34;&gt;&lt;/a&gt;Ch5 Agile Development 敏捷开发&lt;/h1&gt;&lt;p&gt;What is Agility?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Effective (rapid and adaptive) response to change&lt;/li&gt;
&lt;li&gt;Effective communication among all stakeholders&lt;/li&gt;
&lt;li&gt;Drawing the customer onto the team&lt;/li&gt;
&lt;li&gt;Organizing a team so that it is in control of the work performed&lt;/li&gt;
&lt;li&gt;Rapid, incremental delivery of software&lt;br&gt;An Agile Process&lt;/li&gt;
&lt;li&gt;Is driven by customer descriptions of what is required (scenarios)&lt;/li&gt;
&lt;li&gt;Recognizes that plans are short-lived&lt;/li&gt;
&lt;li&gt;Develops software iteratively with a heavy emphasis on construction activities&lt;/li&gt;
&lt;li&gt;Delivers multiple ‘software increments’&lt;/li&gt;
&lt;li&gt;Adapts as changes occur&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Extreme Programming 极限编程(XP): &amp;#x3D;&amp;#x3D;planning, design, coding, testing&amp;#x3D;&amp;#x3D;&lt;br&gt;XP plan:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;begin with user stories&lt;/li&gt;
&lt;li&gt;assigns a cost&lt;/li&gt;
&lt;li&gt;Stories are grouped to for a deliverable increment&lt;/li&gt;
&lt;li&gt;commitment&lt;/li&gt;
&lt;li&gt;project velocity&lt;br&gt;&lt;img data-src=&#34;/5-1.png&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Industrial XP (IXP)&lt;br&gt;IXP incorporates six new practices: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Readiness assessment 准备评估&lt;/li&gt;
&lt;li&gt;Project community 项目社区&lt;/li&gt;
&lt;li&gt;Project chartering 项目章程制定&lt;/li&gt;
&lt;li&gt;Test driven management 测试驱动管理&lt;/li&gt;
&lt;li&gt;Retrospectives 团队自省&lt;/li&gt;
&lt;li&gt;Continuous learning  持续学习&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Scrum 一种流行的敏捷开发框架&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Development work is partitioned into “packets”&lt;/li&gt;
&lt;li&gt;Testing and documentation are on-going (测试和文档贯穿开发流程)&lt;/li&gt;
&lt;li&gt;Work occurs in “sprints” and is derived from a “backlog” (Sprint 是 Scrum 的核心时间单位，通常为 1 到 4 周)&lt;/li&gt;
&lt;li&gt;Meetings are very short 高效沟通（三个问题：What did you do since the last meeting&amp;#x2F; What do you plan to accomplish by the next team meeting&amp;#x2F;What obstacles are you encountering）&lt;/li&gt;
&lt;li&gt;“demos” are delivered to the customer with the time-box allocated&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dynamic Systems Development Method  - DSDM&lt;br&gt;帕累托原则（Pareto Principle），也称为 80&amp;#x2F;20 法则&lt;br&gt;“80% 的价值来自 20% 的功能”，或者 “80% 的系统可以在 20% 的时间内交付”&lt;br&gt;DSDM 的核心理念之一就是：优先交付最有价值的功能&lt;/p&gt;
&lt;p&gt;Agile Modeling (&lt;code&gt;AM&lt;/code&gt;) principals:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Model with a purpose&lt;/li&gt;
&lt;li&gt;Use multiple models &lt;/li&gt;
&lt;li&gt;Travel light &lt;/li&gt;
&lt;li&gt;Content is more important than representation&lt;/li&gt;
&lt;li&gt;Know the models and the tools you use to create them&lt;/li&gt;
&lt;li&gt;Adapt locally&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Agile Unified Process (&lt;code&gt;AUP&lt;/code&gt;) 敏捷统一流程：一个精简的软件开发过程&lt;br&gt;Each AUP iteration addresses these activities: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Modeling&lt;/li&gt;
&lt;li&gt;Implementation&lt;/li&gt;
&lt;li&gt;Testing&lt;/li&gt;
&lt;li&gt;Deployment &lt;/li&gt;
&lt;li&gt;Configuration and project management &lt;/li&gt;
&lt;li&gt;Environment management&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;Ch6-Human-Aspects-of-Software-Engineering&#34;&gt;&lt;a href=&#34;#Ch6-Human-Aspects-of-Software-Engineering&#34; class=&#34;headerlink&#34; title=&#34;Ch6 Human Aspects of Software Engineering&#34;&gt;&lt;/a&gt;Ch6 Human Aspects of Software Engineering&lt;/h1&gt;&lt;p&gt;Traits of Successful Software Engineers: 责任感、对需求敏感、直言不讳、有弹性(Resilient under pressure)、公平意识、注重细节、务实(Pragmatic)&lt;br&gt;The Psychology Of Software Engineering 没看懂不管了&lt;br&gt;Effective Software Team Attributes&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sense of purpose&lt;/li&gt;
&lt;li&gt;Sense of involvement&lt;/li&gt;
&lt;li&gt;Sense of trust&lt;/li&gt;
&lt;li&gt;Sense of improvement&lt;/li&gt;
&lt;li&gt;Diversity of team member skill sets&lt;br&gt;Avoid Team “Toxicity” 毒性&lt;br&gt;A frenzied work atmosphere, high frustication, Fragmented or poorly coordinated procedures(或者定义不当的模型), Unclear definition of roles, Continuous and repeated exposure to failure&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Factors Affecting Team Structure&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;difficulty of the problem&lt;/li&gt;
&lt;li&gt;size of the resultant program(s)&lt;/li&gt;
&lt;li&gt;the time that the team will stay together&lt;/li&gt;
&lt;li&gt;the degree to which the problem can be modularized&lt;/li&gt;
&lt;li&gt;the required quality and reliability of the system&lt;/li&gt;
&lt;li&gt;the rigidity of the delivery date 交付日期是不是很死&lt;/li&gt;
&lt;li&gt;the degree of sociability required&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Organizational Paradigms 组织范式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Closed paradigm&lt;/li&gt;
&lt;li&gt;Random paradigm&lt;/li&gt;
&lt;li&gt;Open paradigm&lt;/li&gt;
&lt;li&gt;Synchronous paradigm&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;范式&lt;/th&gt;
&lt;th&gt;组织方式&lt;/th&gt;
&lt;th&gt;控制程度&lt;/th&gt;
&lt;th&gt;创新程度&lt;/th&gt;
&lt;th&gt;沟通频率&lt;/th&gt;
&lt;th&gt;适用项目类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Closed&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;层级权威&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;td&gt;自上而下&lt;/td&gt;
&lt;td&gt;传统行业、安全关键系统&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Random&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;松散自由&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;无固定模式&lt;/td&gt;
&lt;td&gt;初创项目、探索性任务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Open&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;半结构化&lt;/td&gt;
&lt;td&gt;中等&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;高频协作&lt;/td&gt;
&lt;td&gt;敏捷开发、创新型项目&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Synchronous&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;模块化分工&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;中等&lt;/td&gt;
&lt;td&gt;极少&lt;/td&gt;
&lt;td&gt;分布式系统、大型项目&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Generic Agile Teams（通用敏捷团队）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;individual competency coupled with group collaboration&lt;/li&gt;
&lt;li&gt;People trump process and politics can trump people&lt;/li&gt;
&lt;li&gt;self-organizing and have many structures&lt;/li&gt;
&lt;li&gt;Planning is kept to a minimum 不反对规划，但强调“轻量级规划”比如Sprint&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;XP Team Values&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Communication&lt;/li&gt;
&lt;li&gt;Simplicity: design for immediate needs nor future needs&lt;/li&gt;
&lt;li&gt;Feedback&lt;/li&gt;
&lt;li&gt;Courage&lt;/li&gt;
&lt;li&gt;Respect&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Impact of Social Media &lt;/p&gt;
&lt;p&gt;Software Engineering using the Cloud&lt;/p&gt;
&lt;p&gt;协作工具：Services of collaborative development environments(CDEs)&lt;br&gt;Namespace, Calendar, Template, Metrics support(Metrics 应用于过程改进，而不是人员奖惩), Communication analysis, Artifact clustering归类&lt;/p&gt;
&lt;p&gt;Team Decisions Making Complications&lt;br&gt;&lt;img data-src=&#34;/6-1.jpg&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;Ch7-Principles-that-Guide-Practice&#34;&gt;&lt;a href=&#34;#Ch7-Principles-that-Guide-Practice&#34; class=&#34;headerlink&#34; title=&#34;Ch7 Principles that Guide Practice&#34;&gt;&lt;/a&gt;Ch7 Principles that Guide Practice&lt;/h1&gt;&lt;p&gt;Software development knowledgehave about a three year half-life, Software engineering principles 是永久的&lt;/p&gt;
&lt;p&gt;Principles that Guide Process:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Be agile&lt;/li&gt;
&lt;li&gt;Focus on quality at every step&lt;/li&gt;
&lt;li&gt;Be ready to adapt&lt;/li&gt;
&lt;li&gt;Build an effective team&lt;/li&gt;
&lt;li&gt;Establish mechanisms for communication and coordination&lt;/li&gt;
&lt;li&gt;Manage change&lt;/li&gt;
&lt;li&gt;Assess risk&lt;/li&gt;
&lt;li&gt;Create work products that provide value for others&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Principles that Guide Practice:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Divide and conquer&lt;/li&gt;
&lt;li&gt;Understand the use of abstraction&lt;/li&gt;
&lt;li&gt;Strive for consistency&lt;/li&gt;
&lt;li&gt;Focus on the transfer of information 注意接口的设计&lt;/li&gt;
&lt;li&gt;Build software that exhibits effective modularity&lt;/li&gt;
&lt;li&gt;Look for patterns&lt;/li&gt;
&lt;li&gt;When possible, represent the problem and its solution from a number of different perspectives&lt;/li&gt;
&lt;li&gt;Remember that someone will maintain the software&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Communication Principle： &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Listen&lt;/li&gt;
&lt;li&gt;Prepare before you communicate&lt;/li&gt;
&lt;li&gt;Someone should facilitate the activity&lt;/li&gt;
&lt;li&gt;Face-to-face communication is best&lt;/li&gt;
&lt;li&gt;Take notes and document decisions&lt;/li&gt;
&lt;li&gt;Strive for collaboration&lt;/li&gt;
&lt;li&gt;Stay focused, modularize your discussion&lt;/li&gt;
&lt;li&gt;If something is unclear, draw a picture&lt;/li&gt;
&lt;li&gt;不管怎样, Move on&lt;/li&gt;
&lt;li&gt;Nigotiation(谈判) works best when both parties win&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Planning Principles：&lt;br&gt;懒得写了考了我吃&lt;/p&gt;
&lt;p&gt;Modeling Principles： 创建两类模型&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Requirements models (also called analysis models) 需求模型&lt;/li&gt;
&lt;li&gt;Design models 设计模型&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Agile Modeling Principles 记不住，懒得写了再说&lt;/p&gt;
&lt;p&gt;Requirements Modeling Principles&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The information domain of a problem must be represented and understood  对问题领域内信息的全面了解是构建有效软件的基础&lt;/li&gt;
&lt;li&gt;The functions that the software performs must be defined  定义软件的功能，明确描述软件应提供的功能和服务&lt;/li&gt;
&lt;li&gt;The behavior of the software (as a consequence of external events) must be represented  定义软件的行为，如何响应外界事件或输入&lt;/li&gt;
&lt;li&gt;The models that depict information, function, and behavior must be partitioned in a manner that uncovers detail in a layered (or hierarchical) fashion  使用结构化的、分层次的方法来组织模型&lt;/li&gt;
&lt;li&gt;The analysis task should move from essential information toward implementation detail  先关注核心需求和架构设计，再细化到具体的实现方案&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Design Modeling Principles&lt;br&gt;太多了懒得看&lt;/p&gt;
&lt;p&gt;Living Modeling Principles&lt;br&gt;懒得看&lt;/p&gt;
&lt;p&gt;Construction Principles&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The construction activity encompasses a set of coding and testing tasks&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Coding principles and concepts&lt;/code&gt; are closely aligned programming style, programming languages, and programming methods&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Testing principles and concepts&lt;/code&gt; lead to the design of tests that systematically uncover different classes of errors and to do so with a minimum amount of time and effort&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;…..一堆principle，看了也记不住，不看了&lt;/p&gt;
&lt;h1 id=&#34;Ch8-Understanding-Requirements&#34;&gt;&lt;a href=&#34;#Ch8-Understanding-Requirements&#34; class=&#34;headerlink&#34; title=&#34;Ch8 Understanding Requirements&#34;&gt;&lt;/a&gt;Ch8 Understanding Requirements&lt;/h1&gt;&lt;p&gt;Requirements Engineering:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Inception: ask a set of questions – basic understanding of the problem, the people who want a solution, the nature of the solution, the effectiveness of preliminary communication and collaboration&lt;/li&gt;
&lt;li&gt;Elicitation: elicit requirements&lt;/li&gt;
&lt;li&gt;Elaboration: create an analysis model&lt;/li&gt;
&lt;li&gt;Negotiation: agree on a deliverable system&lt;/li&gt;
&lt;li&gt;Specification: written document&amp;#x2F;set of models&amp;#x2F;formal mathematical&amp;#x2F;use-cases&amp;#x2F;prototype&lt;/li&gt;
&lt;li&gt;Validation: a review mechanism that looks for – errors in content or interpretation&amp;#x2F;areas where clarification may be required&amp;#x2F;missing information&amp;#x2F;inconsistencies&amp;#x2F;conflicting or unrealistic (unachievable) requirements&lt;/li&gt;
&lt;li&gt;Requirements management&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Elicitation Work Products:&lt;br&gt;feasibility, scope, stakeholders, description of environment, constraints, usage scenarios, prototypes&lt;/p&gt;
&lt;p&gt;Negotiating Requirements:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Identify the key stakeholders&lt;/li&gt;
&lt;li&gt;Determine each of the stakeholders “win conditions”&lt;/li&gt;
&lt;li&gt;Negotiate&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Requirements Monitoring:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Distributed debugging&lt;/li&gt;
&lt;li&gt;Run-time verification&lt;/li&gt;
&lt;li&gt;Run-time validation&lt;/li&gt;
&lt;li&gt;Business activity monitoring&lt;/li&gt;
&lt;li&gt;Evolution and co-design&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Validating Requirements:&lt;br&gt;consistent, 是否在level of abstraction规定了, 是否essential, unambiguous, 每个要求注明来源, requirements 之间是否 conflict, achievable, testable, properly reflect the information, function and behavior, partitioned方式, …&lt;/p&gt;
&lt;p&gt;Quality Function Deployment (QFD):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function deployment&lt;/li&gt;
&lt;li&gt;Information deployment&lt;/li&gt;
&lt;li&gt;Task deployment&lt;/li&gt;
&lt;li&gt;Value analysis&lt;/li&gt;
&lt;li&gt;identifies three types of requirements: Normal&amp;#x2F;Expected&amp;#x2F;Exciting&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Non-Functional Requirement (NFR): quality attribute, performance attribute, security attribute, or general system constraint&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The first phase is to create a matrix using each NFR&lt;/li&gt;
&lt;li&gt;The second phase is for the team to prioritize each NFR using a set of decision rules&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;Ch9-Requirements-Modeling：Scenario-Based-Methods-基于场景的需求建模方法&#34;&gt;&lt;a href=&#34;#Ch9-Requirements-Modeling：Scenario-Based-Methods-基于场景的需求建模方法&#34; class=&#34;headerlink&#34; title=&#34;Ch9 Requirements Modeling：Scenario-Based Methods 基于场景的需求建模方法&#34;&gt;&lt;/a&gt;Ch9 Requirements Modeling：Scenario-Based Methods 基于场景的需求建模方法&lt;/h1&gt;&lt;p&gt;需求分析的目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;描述客户所需的内容 Describe what the customer requires&lt;/li&gt;
&lt;li&gt;为软件设计提供基础 Establish a basis for the creation of a software design&lt;/li&gt;
&lt;li&gt;定义一组可以验证的需求 Define a set of requirements that can be validated&lt;br&gt;Rules of Thumb（基本原则）：&lt;/li&gt;
&lt;li&gt;The model should focus on requirements that are visible within the problem or business domain. The level of abstraction should be relatively high.&lt;/li&gt;
&lt;li&gt;Each element of the analysis model should add to an overall understanding of software requirements and provide insight into the information domain, function and behavior of the system.&lt;/li&gt;
&lt;li&gt;Delay consideration of infrastructure and other non-functional models until design.&lt;/li&gt;
&lt;li&gt;Minimize coupling throughout the system.&lt;/li&gt;
&lt;li&gt;Be certain that the analysis model provides value to all stakeholders.&lt;/li&gt;
&lt;li&gt;Keep the model as simple as it can be.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;system description -&amp;gt; analysis model -&amp;gt; design model&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/9-1.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;Domain Analysis（领域分析）：&lt;br&gt;Software domain analysis is the identification, analysis, and specification of common requirements from a specific application domain, typically for &lt;code&gt;reuse&lt;/code&gt; on multiple projects within that application domain…&lt;/p&gt;
&lt;p&gt;Use-Case Diagram, Activity Diagrams, Swim Lane Diagrams&lt;/p&gt;
&lt;p&gt;In structured analysis, models focus on data flow and functional decomposition of the system;&lt;br&gt;In object-oriented analysis, models focus on the structure of the classes defined for a system along with their interactions&lt;/p&gt;
&lt;p&gt;Each primary scenario should be &lt;code&gt;reviewed&lt;/code&gt; and &lt;code&gt;refined&lt;/code&gt; to see ifalternative interactions are possible&lt;/p&gt;
&lt;h1 id=&#34;Ch10-Requirements-Modeling-Class-Based-Methods&#34;&gt;&lt;a href=&#34;#Ch10-Requirements-Modeling-Class-Based-Methods&#34; class=&#34;headerlink&#34; title=&#34;Ch10 Requirements Modeling: Class-Based Methods&#34;&gt;&lt;/a&gt;Ch10 Requirements Modeling: Class-Based Methods&lt;/h1&gt;&lt;p&gt;Class-Based需求建模的方法：structured analysis(数据对象和数据的转换), object- oriented analysis(类和类的协作)&lt;br&gt;the broad categories used to classify operations: computation, data manipulation, event monitors&lt;br&gt;Class-Based Modeling: objects, operations, relationships, collaborations&lt;br&gt;类图&lt;br&gt;CRC Cards&lt;br&gt;见画图题&lt;/p&gt;
&lt;h1 id=&#34;Ch11-Requirements-Modeling-Behavior-Patterns-and-Web-Mobile-Apps&#34;&gt;&lt;a href=&#34;#Ch11-Requirements-Modeling-Behavior-Patterns-and-Web-Mobile-Apps&#34; class=&#34;headerlink&#34; title=&#34;Ch11 Requirements Modeling: Behavior, Patterns, and Web&amp;#x2F;Mobile Apps&#34;&gt;&lt;/a&gt;Ch11 Requirements Modeling: Behavior, Patterns, and Web&amp;#x2F;Mobile Apps&lt;/h1&gt;&lt;p&gt;For purposes of behavior modeling a state is any observable mode of behavior&lt;br&gt;Analysis patterns are discovered, they are not explicitly created&lt;br&gt;行为建模: use-cases, events, sequences, state diagram, 审查&lt;br&gt;行为建模三种图：state diagram, sequence diagram, data-flow diagram&lt;br&gt;The state transition diagram indicates system reactions to external events.&lt;br&gt;events由系统外部的参与者触发&lt;/p&gt;
&lt;h2 id=&#34;Requirements-Modeling-for-WebApps&#34;&gt;&lt;a href=&#34;#Requirements-Modeling-for-WebApps&#34; class=&#34;headerlink&#34; title=&#34;Requirements Modeling for WebApps:&#34;&gt;&lt;/a&gt;Requirements Modeling for WebApps:&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;内容分析 Content Analysis：描述文本、图形和图像、视频、音频等。&lt;/li&gt;
&lt;li&gt;交互分析 Interaction Analysis：使用案例。&lt;/li&gt;
&lt;li&gt;功能分析 Functional Analysis：定义应用于WebApp内容的操作，暗示其他处理功能。&lt;/li&gt;
&lt;li&gt;配置分析 Configuration Analysis：环境和基础设施。&lt;/li&gt;
&lt;li&gt;导航分析 Navigation Analysis：关注总体要求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配置模型 Configuration Model&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器端 Server-side：必须指定服务器硬件和操作系统环境、考虑服务器端互操作性、指定适当的接口、通信协议及相关协作信息。&lt;/li&gt;
&lt;li&gt;客户端 Client-side：必须识别浏览器配置问题、定义测试要求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;导航建模 Navigation Modeling&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;考虑哪些元素应更容易到达（需要更少的导航步骤），优先级如何？&lt;/li&gt;
&lt;li&gt;如何处理导航错误？&lt;/li&gt;
&lt;li&gt;是否应该通过链接、基于搜索的访问或其他方式完成导航？&lt;/li&gt;
&lt;li&gt;是否应根据之前导航动作的上下文向用户展示某些元素？&lt;/li&gt;
&lt;li&gt;是否应维护用户的导航日志？&lt;br&gt; WebApps interaction model: use-cases, sequence diagrams, state diagrams, interface prototype&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;Ch12-Design-Concepts&#34;&gt;&lt;a href=&#34;#Ch12-Design-Concepts&#34; class=&#34;headerlink&#34; title=&#34;Ch12 Design Concepts&#34;&gt;&lt;/a&gt;Ch12 Design Concepts&lt;/h1&gt;&lt;p&gt;好的软件设计应该具备：坚固性 Firmness, 实用性 Commodity, 愉悦感 Delight&lt;br&gt;Software Engineering Design：设计原则与质量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Data&amp;#x2F;Class design&lt;/li&gt;
&lt;li&gt;Architectural design&lt;/li&gt;
&lt;li&gt;Interface design&lt;/li&gt;
&lt;li&gt;Component-level design&lt;br&gt;自上而下是金字塔，见下图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;/12-1.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;Analysis Model -&amp;gt; Design Model（需求模型到设计模型）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设计必须实施分析模型中包含的所有显式需求(explicit requirements)，并适应客户希望的所有隐式需求。&lt;/li&gt;
&lt;li&gt;设计应当是可读且易于理解(readable, understandable guide)的指南，帮助编写代码的人以及测试和支持软件的人。&lt;/li&gt;
&lt;li&gt;设计应该提供软件的完整画面(a complete picture)，从实现的角度解决数据、功能和行为领域的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;质量指南 Quality Guidelines&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设计应展示一种使用公认的架构风格创建的架构。&lt;/li&gt;
&lt;li&gt;设计应由展现良好设计特性的组件组成。&lt;/li&gt;
&lt;li&gt;设计可以逐步实现。&lt;/li&gt;
&lt;li&gt;设计应模块化，即将软件逻辑划分为元素或子系统。&lt;/li&gt;
&lt;li&gt;设计应包含数据、架构、接口和组件的不同表示形式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设计原则 Design Principles&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设计过程不应有“隧道视野”，即应全面考虑各种因素。&lt;/li&gt;
&lt;li&gt;设计应可追溯到分析模型。&lt;/li&gt;
&lt;li&gt;设计不应重新发明轮子（即不应重复已有的解决方案）。&lt;/li&gt;
&lt;li&gt;设计应“最小化软件与现实世界中存在的问题之间的智力距离”。&lt;/li&gt;
&lt;li&gt;设计应统一且整合。&lt;/li&gt;
&lt;li&gt;设计应能够适应变化。&lt;/li&gt;
&lt;li&gt;设计应以温和的方式降级，即使遇到异常数据、事件或操作条件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OO Design Concepts: Design classes(&lt;code&gt;Entity classes&lt;/code&gt;, &lt;code&gt;Boundary classes&lt;/code&gt;, &lt;code&gt;Controller classes&lt;/code&gt;), Inheritance, Messages, Polymorphism&lt;br&gt;:::warning&lt;br&gt;后面看不下去先不管了&lt;br&gt;:::&lt;/p&gt;
&lt;h1 id=&#34;Ch13-Architectural-Design&#34;&gt;&lt;a href=&#34;#Ch13-Architectural-Design&#34; class=&#34;headerlink&#34; title=&#34;Ch13 Architectural Design&#34;&gt;&lt;/a&gt;Ch13 Architectural Design&lt;/h1&gt;&lt;p&gt;架构风格：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Data-centered architectures&lt;/li&gt;
&lt;li&gt;Data flow architectures &lt;/li&gt;
&lt;li&gt;Call and return architectures&lt;/li&gt;
&lt;li&gt;Object-oriented architectures&lt;/li&gt;
&lt;li&gt;Layered architectures&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;Ch14-Component-Level-Design&#34;&gt;&lt;a href=&#34;#Ch14-Component-Level-Design&#34; class=&#34;headerlink&#34; title=&#34;Ch14 Component-Level Design&#34;&gt;&lt;/a&gt;Ch14 Component-Level Design&lt;/h1&gt;&lt;p&gt;Component: a modular, deployable, and replaceable part of a system&lt;br&gt;OO角度：一个组件包含一组协作类&lt;br&gt;传统角度：数据结构和接口&lt;br&gt;Basic Design Principles：OCP, LSP, DIP, ISP, REP, CCP, CRP&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Open-Closed Principle: 开放扩展，关闭修改&lt;/li&gt;
&lt;li&gt;Liskov Substitution Principle: 子类可被父类替换&lt;/li&gt;
&lt;li&gt;Dependency Inversion Principles: 依赖抽象，不要依赖具体实现&lt;/li&gt;
&lt;li&gt;Interface Segregation Principle: 多个特定于客户端的接口比一个通用接口更好&lt;/li&gt;
&lt;li&gt;Release Reuse Equivalency Principle: 发布的粒度是重用的粒度&lt;/li&gt;
&lt;li&gt;Common Closure Principle: 一起变化的类应该放在一起&lt;/li&gt;
&lt;li&gt;Common Reuse Principle: 不一起重用的类不应放在一起&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本设计原则（Basic Design Principles）:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;命名约定 Components &lt;/li&gt;
&lt;li&gt;接口 Interfaces&lt;/li&gt;
&lt;li&gt;依赖关系和继承：建议从左到右建模依赖关系，从底向上（派生类）到底部（基类）建模继承关系&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;设计指南（Design Guidelines）:&lt;br&gt;内聚性 Cohension&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the &amp;#x3D;&amp;#x3D;“single-mindedness”&amp;#x3D;&amp;#x3D; of a module&lt;/li&gt;
&lt;li&gt;OO view: – cohesion implies that a component or class encapsulates only attributes and operations that are closely related to one another and to the class or component itself&lt;/li&gt;
&lt;li&gt;Levels of cohesion： Functional – Layer – Communicational – Sequential – Procedural – Temporal – Utility&lt;br&gt;耦合度级别：内容耦合、公共耦合、控制耦合等 Coupling&lt;/li&gt;
&lt;li&gt;The degree to which a component is &amp;#x3D;&amp;#x3D;connected to other components and to the external world&amp;#x3D;&amp;#x3D;&lt;/li&gt;
&lt;li&gt;OO观点: 衡量classes are connected to one another的程度&lt;/li&gt;
&lt;li&gt;Level of coupling: Content – Common – Control – Stamp – Data – Routine call – Type use – Inclusion or import – External&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;WebApps 组件设计：通常包含content design and functional design&lt;br&gt;……&lt;/p&gt;
&lt;h1 id=&#34;Ch15-User-Interface-Design&#34;&gt;&lt;a href=&#34;#Ch15-User-Interface-Design&#34; class=&#34;headerlink&#34; title=&#34;Ch15 User Interface Design&#34;&gt;&lt;/a&gt;Ch15 User Interface Design&lt;/h1&gt;&lt;p&gt;Golden Rule：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Place the user in control&lt;/li&gt;
&lt;li&gt;Reduce the user’s memory load&lt;/li&gt;
&lt;li&gt;Make the interface consistent&lt;br&gt;User Interface Design Model:&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;模型名称&lt;/th&gt;
&lt;th&gt;中文解释&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;User Model&lt;/td&gt;
&lt;td&gt;用户模型&lt;/td&gt;
&lt;td&gt;描述用户是谁、他们的需求和行为&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Design Model&lt;/td&gt;
&lt;td&gt;设计模型&lt;/td&gt;
&lt;td&gt;将用户模型转化为界面设计方案&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mental Model&lt;/td&gt;
&lt;td&gt;心理模型&lt;/td&gt;
&lt;td&gt;用户对界面的主观理解和预期&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Implementation Model&lt;/td&gt;
&lt;td&gt;实现模型&lt;/td&gt;
&lt;td&gt;开发者实际构建的界面及其交互逻辑&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;User Interface Design Process: 螺旋模型&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Interface Analysis&lt;br&gt;Interface Analysis旨在理解以下几点：people(user), task, content, environment&lt;/p&gt;
&lt;h1 id=&#34;Ch16-Pattern-Based-Design&#34;&gt;&lt;a href=&#34;#Ch16-Pattern-Based-Design&#34; class=&#34;headerlink&#34; title=&#34;Ch16 Pattern-Based Design&#34;&gt;&lt;/a&gt;Ch16 Pattern-Based Design&lt;/h1&gt;&lt;p&gt;A design pattern is a three-part rule which expresses a relation between a certain &amp;#x3D;&amp;#x3D;context&amp;#x3D;&amp;#x3D;, a &amp;#x3D;&amp;#x3D;problem&amp;#x3D;&amp;#x3D;, and a &amp;#x3D;&amp;#x3D;solution&amp;#x3D;&amp;#x3D;.&lt;/p&gt;
&lt;p&gt;Describing a Pattern: By detailing various dimensions such as pattern name, problem, motivation, context, forces, solution, intent, collaborations, consequences, implementation, known uses, related patterns, etc. &lt;/p&gt;
&lt;h1 id=&#34;Ch17-WebApp-Design&#34;&gt;&lt;a href=&#34;#Ch17-WebApp-Design&#34; class=&#34;headerlink&#34; title=&#34;Ch17 WebApp Design&#34;&gt;&lt;/a&gt;Ch17 WebApp Design&lt;/h1&gt;&lt;p&gt;two basic approaches to design: 1. artistic ideal of designers; 2. the requirements of customers&lt;/p&gt;
&lt;p&gt;Design &amp;amp; WebApp Quality的几个关键：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Security: 抵御攻击、排除未经授权的访问、保护用户隐私&lt;/li&gt;
&lt;li&gt;Availability: 确保系统在需要的时候可用 The measure of the percentage of time that a WebApp is available for use&lt;/li&gt;
&lt;li&gt;Scalability（可扩展性）: Can the WebApp and the systems with which it is interfaced handle significant variation in user or transaction volume 系统在用户数量或交易量增加时，仍能保持良好的性能和响应速度的能力&lt;/li&gt;
&lt;li&gt;Time to Market（上市时间）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Quality Dimensions for End-Users:&lt;br&gt;对于用户而言&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Time: 网站更新的频率和程度&lt;/li&gt;
&lt;li&gt;Structural: 网站的结构、链接、图片正常显示、组件连接&lt;/li&gt;
&lt;li&gt;Content: 关键页面的内容、关键短语、关键页面的不同版本、动态生成页面的质量和一致性&lt;/li&gt;
&lt;li&gt;Accuracy and Consistency: &lt;/li&gt;
&lt;li&gt;Response Time and Latency: 响应、加载速度&lt;/li&gt;
&lt;li&gt;Performance: 站点连接速度、负载&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;WebApp Design Goals：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Consistency: Content, Graphic design (aesthetics), Architectural design, Interface design, Navigation mechanisms&lt;/li&gt;
&lt;li&gt;Identity: Web应用需要有一个清晰且与业务目标相匹配的品牌形象或身份&lt;/li&gt;
&lt;li&gt;Robustness: Web应用的内容和功能的质量和可靠性&lt;/li&gt;
&lt;li&gt;Navigability: Designed in a manner that is intuitive and predictable（以直观和可预测的方式设计）&lt;/li&gt;
&lt;li&gt;Visual appeal&lt;/li&gt;
&lt;li&gt;Compatibility 兼容性&lt;br&gt;&lt;img data-src=&#34;/17-1.jpg&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Interface Design需要回答: Where am I? What can I do now? Where have I been, where am I going?&lt;/p&gt;
&lt;p&gt;Interface Design Principles 太多了懒得写&lt;/p&gt;
&lt;p&gt;&amp;#x3D;&amp;#x3D;Aesthetic Design&amp;#x3D;&amp;#x3D;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Don’t be afraid of white space.&lt;/li&gt;
&lt;li&gt;Emphasize content.&lt;/li&gt;
&lt;li&gt;Organize layout elements from top-left to bottom right.&lt;/li&gt;
&lt;li&gt;Group navigation, content, and function geographically within the page.&lt;/li&gt;
&lt;li&gt;Don’t extend your real estate with the scrolling bar.&lt;/li&gt;
&lt;li&gt;Consider resolution and browser window size when designing layout.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Content Design&lt;/p&gt;
&lt;p&gt;Architecture Design&lt;br&gt;Content architecture focuses on &amp;#x3D;&amp;#x3D;the manner in which content objects (or composite objects such as Web pages) are structured&amp;#x3D;&amp;#x3D; for presentation and navigation.&lt;br&gt;WebApp architecture addresses &amp;#x3D;&amp;#x3D;the manner in which the application is structured&amp;#x3D;&amp;#x3D; to manage user interaction, handle internal processing tasks, effect navigation, and presentcontent.&lt;br&gt;Architecture design is conducted in parallel with &lt;code&gt;interface design&lt;/code&gt;, &lt;code&gt;aesthetic design&lt;/code&gt; and &lt;code&gt;content design&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;MVC（Model-View-Controller）架构，一种广泛应用于软件工程中的设计模式&lt;br&gt;MVC将应用程序分为三个主要部分：模型（Model）、视图（View）和控制器（Controller）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;model: all application specific content and processing logic&lt;/li&gt;
&lt;li&gt;view: The view contains all interface specific functions and enables&lt;/li&gt;
&lt;li&gt;controller: The controller manages access to the model and the view and coordinates the &amp;#x3D;&amp;#x3D;flow of data&amp;#x3D;&amp;#x3D; between them&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Navigation Design&lt;br&gt;Navigation Syntax&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Individual navigation link（独立导航链接）&lt;br&gt;指单个用于跳转的元素，如文字链接、图标、按钮或开关。&lt;/li&gt;
&lt;li&gt;Horizontal navigation bar（水平导航栏）&lt;br&gt;水平排列的主要内容或功能分类链接。&lt;br&gt;通常包含4到7个选项，适合展示网站的核心栏目。&lt;/li&gt;
&lt;li&gt;Vertical navigation column（垂直导航列）&lt;br&gt;垂直排列的导航结构，常用于侧边栏。&lt;br&gt;可以列出主要内容类别或几乎所有的内容对象。&lt;/li&gt;
&lt;li&gt;Tabs（标签页）&lt;br&gt;类似浏览器的多标签页设计，是导航栏或列的一种变体。&lt;br&gt;每个标签代表一个内容区域或功能模块，点击切换。&lt;/li&gt;
&lt;li&gt;Site maps（站点地图）&lt;br&gt;提供整个Web应用内容与功能的完整目录，帮助用户全面了解和访问所有页面。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Component-Level Design&lt;/p&gt;
&lt;h1 id=&#34;Ch18-MobileApp-Design&#34;&gt;&lt;a href=&#34;#Ch18-MobileApp-Design&#34; class=&#34;headerlink&#34; title=&#34;Ch18 MobileApp Design&#34;&gt;&lt;/a&gt;Ch18 MobileApp Design&lt;/h1&gt;&lt;p&gt;MobileApp Design需要注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Multiple hardware and software platforms&lt;/li&gt;
&lt;li&gt;Many development frameworks and programming languages&lt;/li&gt;
&lt;li&gt;Many app stores&lt;/li&gt;
&lt;li&gt;Short development cycles&lt;/li&gt;
&lt;li&gt;User interface limitations&lt;/li&gt;
&lt;li&gt;Complex camera&amp;#x2F;sensor interaction&lt;/li&gt;
&lt;li&gt;Effective use of context&lt;/li&gt;
&lt;li&gt;Power management&lt;/li&gt;
&lt;li&gt;Security and privacy models&amp;#x2F;policies&lt;/li&gt;
&lt;li&gt;Device limitations (computation and storage)&lt;/li&gt;
&lt;li&gt;Integration of external services&lt;/li&gt;
&lt;li&gt;Texting complexities&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MobileApp Development Process Model：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Formulation&lt;/li&gt;
&lt;li&gt;Planning&lt;/li&gt;
&lt;li&gt;Analysis&lt;/li&gt;
&lt;li&gt;Engineering&lt;/li&gt;
&lt;li&gt;Implementation and testing&lt;/li&gt;
&lt;li&gt;User evaluation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MobileApp Quality Checklist 略&lt;/p&gt;
&lt;p&gt;MobileApp User Interface Design Considerations&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Define user interface brand signatures&lt;/li&gt;
&lt;li&gt;Focus the portfolio of products&lt;/li&gt;
&lt;li&gt;Identify core user stories&lt;/li&gt;
&lt;li&gt;Optimize UI flows and elements&lt;/li&gt;
&lt;li&gt;Define scaling rules 适应屏幕尺寸&lt;/li&gt;
&lt;li&gt;Create user performance dashboard 收集和分析用户行为数据&lt;/li&gt;
&lt;li&gt;Rely on dedicated champion with user interface engineering skills 在项目中设立一名专门负责用户界面设计和开发的角色&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MobileApp Design Mistakes&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kitchen sink 功能堆砌&lt;/li&gt;
&lt;li&gt;Inconsistency&lt;/li&gt;
&lt;li&gt;Overdesigning 过度设计&lt;/li&gt;
&lt;li&gt;Lack of speed&lt;/li&gt;
&lt;li&gt;Verbiage 过多、过于正式或复杂的文字描述&lt;/li&gt;
&lt;li&gt;Non-standard interaction&lt;/li&gt;
&lt;li&gt;Help-and–FAQ-itis 应用本身不好用，于是靠大量的帮助提示、FAQ、引导流程来弥补&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MobileApp Design Best Practices&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Identify the audience 识别目标用户&lt;/li&gt;
&lt;li&gt;Design for context of use 根据使用场景来设计&lt;/li&gt;
&lt;li&gt;Recognize line between simplicity is not laziness 简化 ≠ 懒惰&lt;/li&gt;
&lt;li&gt;Use the platform to its advantage&lt;/li&gt;
&lt;li&gt;Allow for discoverability of advanced functionality 让高级功能易于被发现&lt;/li&gt;
&lt;li&gt;Use clear and consistent labels&lt;/li&gt;
&lt;li&gt;Cleaver icons should never be developed at the expense of user understanding&lt;/li&gt;
&lt;li&gt;Long scrolling forms trump multiple screens 长滚动表单优于多页面跳转&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Assessing Mobile Interactive Development Environments&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;General productivity features 指开发工具是否提供提高效率的功能&lt;/li&gt;
&lt;li&gt;Third-party SDK integration 是否支持主流的第三方服务和库（SDK）&lt;/li&gt;
&lt;li&gt;Post-compilation tools&lt;/li&gt;
&lt;li&gt;Over the air development support&lt;/li&gt;
&lt;li&gt;End-to-end mobile application development&lt;/li&gt;
&lt;li&gt;Documentation and tutorials&lt;/li&gt;
&lt;li&gt;Graphical user interface builders&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MobileApp Middleware 介于操作系统、网络服务与应用程序之间的一层软件，用于简化复杂的分布式系统之间的通信和数据管理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Facilitates communication and coordination of distributed components&lt;/li&gt;
&lt;li&gt;Allows developers to rely on abstractions and hide mobile environment details&lt;/li&gt;
&lt;li&gt;Helps MobileApps to achieve context awareness as required&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;Ch19-Quality-Concepts&#34;&gt;&lt;a href=&#34;#Ch19-Quality-Concepts&#34; class=&#34;headerlink&#34; title=&#34;Ch19 Quality Concepts&#34;&gt;&lt;/a&gt;Ch19 Quality Concepts&lt;/h1&gt;&lt;h1 id=&#34;Ch20-Review-Techniques&#34;&gt;&lt;a href=&#34;#Ch20-Review-Techniques&#34; class=&#34;headerlink&#34; title=&#34;Ch20 Review Techniques&#34;&gt;&lt;/a&gt;Ch20 Review Techniques&lt;/h1&gt;&lt;p&gt;Reviews: 由技术人员为技术人员进行的会议，是对软件工程过程中产生的工作产品的技术评估，是软件质量保证机制之一，并作为培训场所&lt;br&gt;Errors(软件发布前发现的问题) and defects(软件发布后发现的问题)&lt;/p&gt;
&lt;p&gt;Defect Amplification Model 描述了开发步骤中的错误如何从前一步骤传递到下一步骤以及如何被检测出来&lt;br&gt;缺陷放大模型&lt;br&gt;&lt;img data-src=&#34;/20-1.jpg&#34;&gt;&lt;br&gt;$$&lt;br&gt;E_{review} &amp;#x3D; E_p + E_a + E_r&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;Err_{tot} &amp;#x3D; Err_{minor} + Err_{major}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;Defect\ density &amp;#x3D; Err_{tot} &amp;#x2F; WPS&lt;br&gt;$$&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/06/18/computer-science/compile-principles/ch10/</guid>
            <title>Liveness Analysis</title>
            <link>http://example.com/2025/06/18/computer-science/compile-principles/ch10/</link>
            <category>Liveness Analysis</category>
            <pubDate>Wed, 18 Jun 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Liveness-Analysis-活跃变量分析&#34;&gt;&lt;a href=&#34;#Liveness-Analysis-活跃变量分析&#34; class=&#34;headerlink&#34; title=&#34;Liveness Analysis 活跃变量分析&#34;&gt;&lt;/a&gt;Liveness Analysis 活跃变量分析&lt;/h1&gt;&lt;p&gt;判断在程序执行的某个点上，一个变量的值是否可能在未来被使用，是寄存器分配、死代码消除的基础&lt;/p&gt;
&lt;h2 id=&#34;Compiler-Optimizations&#34;&gt;&lt;a href=&#34;#Compiler-Optimizations&#34; class=&#34;headerlink&#34; title=&#34;Compiler Optimizations&#34;&gt;&lt;/a&gt;Compiler Optimizations&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Local: 基于basic blocks&lt;/li&gt;
&lt;li&gt;Intraprocedural (or “global’): 基本块的控制流转移&lt;/li&gt;
&lt;li&gt;Interprocedural (or “whole-program”): Operate on &amp;gt; 1 procedure, up to whole program; Sometimes, at link time (LTO, link time optimization)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Analyze program to gather “facts”&lt;/li&gt;
&lt;li&gt;Apply transformation (e.g., optimizations)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Dataflow-Analysis&#34;&gt;&lt;a href=&#34;#Dataflow-Analysis&#34; class=&#34;headerlink&#34; title=&#34;Dataflow Analysis&#34;&gt;&lt;/a&gt;Dataflow Analysis&lt;/h2&gt;&lt;p&gt;Control Flow Graph: A directed graph 数据流图&lt;br&gt;– Nodes represent statements&lt;br&gt;– Edges represent control flow&lt;/p&gt;
&lt;p&gt;CFG的简化：基本块&lt;br&gt;&lt;img data-src=&#34;/f1.jpg&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;变量的活跃性：&#34;&gt;&lt;a href=&#34;#变量的活跃性：&#34; class=&#34;headerlink&#34; title=&#34;变量的活跃性：&#34;&gt;&lt;/a&gt;变量的活跃性：&lt;/h3&gt;&lt;p&gt;变量x在语句s处（执行s之前）处于活动状态，当且仅当满足以下三个条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;存在一个使用x的语句s’；&lt;/li&gt;
&lt;li&gt;存在从s到s’的路径；&lt;/li&gt;
&lt;li&gt;这条路径上没有对x进行任何赋值操作&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过分析liveness，我们可以实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Register Allocation&lt;/li&gt;
&lt;li&gt;Code Optimizations：Remove unused assignments&lt;/li&gt;
&lt;li&gt;IR Construction： Optimize the construction of SSA&lt;/li&gt;
&lt;li&gt;Security&amp;#x2F;Reliability: Detect the use of uninitialized variables&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;Dataflow-Equations-for-Liveness-构建数据流方程&#34;&gt;&lt;a href=&#34;#Dataflow-Equations-for-Liveness-构建数据流方程&#34; class=&#34;headerlink&#34; title=&#34;Dataflow Equations for Liveness 构建数据流方程&#34;&gt;&lt;/a&gt;Dataflow Equations for Liveness 构建数据流方程&lt;/h2&gt;&lt;p&gt;A CFG node has&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;out-edges: lead to successor nodes&lt;/li&gt;
&lt;li&gt;in-edges: come from predecessor nodes&lt;/li&gt;
&lt;li&gt;pred[n]: the predecessors of node n       前驱&lt;/li&gt;
&lt;li&gt;succ[n]: the successors of node n     后继&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;几个定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;use[n]: 在节点n被读取或使用(x &amp;#x3D; a + b的a和b, if(a &amp;lt; b)的a和b, return c的c)&lt;/li&gt;
&lt;li&gt;def[n]: 在节点n被定义(x &amp;#x3D; a + b的x)&lt;/li&gt;
&lt;li&gt;in[n]: 在节点n之前，所有活跃变量的集合&lt;/li&gt;
&lt;li&gt;out[n]: 在节点n之后，所有活跃变量的集合&lt;br&gt;三条活跃性规则：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;if $a \in in[n]$ then for $\all m \in pred[n]$ we have $a \in out[m]$&lt;/li&gt;
&lt;li&gt;if $a \in use[n]$ then $a \in in[n]$&lt;/li&gt;
&lt;li&gt;if $a \in out[n]$ and $a \notin def[n]$ then $a \in in[n]$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;得到以下两个数据流方程：&lt;br&gt;$$&lt;br&gt;out[n] &amp;#x3D; \cup_{s \in succ[n]} in[s]&lt;br&gt;$$&lt;br&gt; 一个节点在n的出口处活跃当且仅当在它后继的入口处是活跃的（活跃性的反向传播）&lt;br&gt;$$&lt;br&gt;in[n] &amp;#x3D; use[n] \cup (out[n] - def[n])&lt;br&gt;$$&lt;/p&gt;
&lt;h2 id=&#34;求解数据流方程&#34;&gt;&lt;a href=&#34;#求解数据流方程&#34; class=&#34;headerlink&#34; title=&#34;求解数据流方程&#34;&gt;&lt;/a&gt;求解数据流方程&lt;/h2&gt;&lt;p&gt;有了上面的两个数据流方程，就可以求解数据流方程了&lt;br&gt;算法：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;figcaption&gt;&lt;span&gt;pseudo&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;for each n&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    in[n] ←&amp;#123;&amp;#125;; out[n] ←&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;repeat&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    for each n&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        in′[n] ← in[n]; out′[n] ← out[n]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        in[n] ← use[n] ∪ (out[n] − def[n])&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        out[n] ← ⋃( ∈()**[+] in[s]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;until in′[n] = in[n] and out′[n] = out[n] for all n&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;将所有节点的 &lt;code&gt;in&lt;/code&gt; 和 &lt;code&gt;out&lt;/code&gt; 集合初始化为空集。&lt;/li&gt;
&lt;li&gt;写出&lt;code&gt;use[n]&lt;/code&gt;和&lt;code&gt;def[n]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用数据流方程更新&lt;code&gt;in&lt;/code&gt;和&lt;code&gt;out&lt;/code&gt;集合&lt;/li&gt;
&lt;li&gt;直到&lt;code&gt;in&lt;/code&gt;和&lt;code&gt;out&lt;/code&gt;集合不再改变为止&lt;br&gt;例：&lt;br&gt;&lt;img data-src=&#34;/f2.jpg&#34;&gt;&lt;br&gt;对于这个CFG&lt;br&gt;每一次迭代如图：&lt;br&gt;&lt;img data-src=&#34;/f3.jpg&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;Improvements&#34;&gt;&lt;a href=&#34;#Improvements&#34; class=&#34;headerlink&#34; title=&#34;Improvements&#34;&gt;&lt;/a&gt;Improvements&lt;/h2&gt;&lt;h3 id=&#34;Use-Basic-Block&#34;&gt;&lt;a href=&#34;#Use-Basic-Block&#34; class=&#34;headerlink&#34; title=&#34;Use Basic Block&#34;&gt;&lt;/a&gt;Use Basic Block&lt;/h3&gt;&lt;p&gt;后面有点懒得看，先放着&lt;/p&gt;
&lt;h2 id=&#34;集合的表示方法&#34;&gt;&lt;a href=&#34;#集合的表示方法&#34; class=&#34;headerlink&#34; title=&#34;集合的表示方法&#34;&gt;&lt;/a&gt;集合的表示方法&lt;/h2&gt;&lt;p&gt;对于in, out, use, def集合的表示和操作对性能有很大影响&lt;/p&gt;
&lt;h3 id=&#34;Bit-Arrays&#34;&gt;&lt;a href=&#34;#Bit-Arrays&#34; class=&#34;headerlink&#34; title=&#34;Bit Arrays&#34;&gt;&lt;/a&gt;Bit Arrays&lt;/h3&gt;&lt;p&gt;有点像bit map，适用于稠密集合（1比较多的，如果0太多就浪费了）&lt;/p&gt;
&lt;h3 id=&#34;Sorted-Lists&#34;&gt;&lt;a href=&#34;#Sorted-Lists&#34; class=&#34;headerlink&#34; title=&#34;Sorted Lists&#34;&gt;&lt;/a&gt;Sorted Lists&lt;/h3&gt;&lt;p&gt;适合稀疏集合（用一个链表存集合中的变量, Sorted by variable name&amp;#x2F;ID）&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/06/18/computer-science/compile-principles/ch11/</guid>
            <title>Register Allocation</title>
            <link>http://example.com/2025/06/18/computer-science/compile-principles/ch11/</link>
            <category>Register Allocation</category>
            <pubDate>Wed, 18 Jun 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Register-Allocation&#34;&gt;&lt;a href=&#34;#Register-Allocation&#34; class=&#34;headerlink&#34; title=&#34;Register Allocation&#34;&gt;&lt;/a&gt;Register Allocation&lt;/h1&gt;&lt;p&gt;目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Map temporaries to registers&lt;/li&gt;
&lt;li&gt;Preserve program semantics&lt;/li&gt;
&lt;li&gt;Optimize performance&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;图着色算法&#34;&gt;&lt;a href=&#34;#图着色算法&#34; class=&#34;headerlink&#34; title=&#34;图着色算法&#34;&gt;&lt;/a&gt;图着色算法&lt;/h2&gt;&lt;p&gt;冲突图是一个无向图，冲突图中，每个节点是一个变量（寄存器分配的候选对象）。&lt;br&gt;如果两个变量在同一时刻是活跃的（live），它们就有冲突边（interference edge），表示它们不能被分配到同一个寄存器&lt;br&gt;冲突信息可以用矩阵或者图来表示&lt;/p&gt;
&lt;h3 id=&#34;冲突图构建&#34;&gt;&lt;a href=&#34;#冲突图构建&#34; class=&#34;headerlink&#34; title=&#34;冲突图构建&#34;&gt;&lt;/a&gt;冲突图构建&lt;/h3&gt;&lt;p&gt;我们从一个中间代码的指令出发，根据live-out（就是out集合）添加冲突边：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;非 move 指令（不是a :&amp;#x3D; b这种）&lt;br&gt;比如a :&amp;#x3D; b1 + b2&lt;br&gt;对于每个bn和a之间都添加冲突边&lt;br&gt;比如下面这个例子：&lt;br&gt;&lt;img data-src=&#34;/f1.jpg&#34;&gt;&lt;br&gt;可以看到有ab ac同时live了，所以为a和b，a和c添加冲突边&lt;/li&gt;
&lt;li&gt;move指令&lt;br&gt;对于move指令，不添加冲突边：&lt;br&gt;比如对于第 2 条指令 d ← a，out[2] &amp;#x3D; {a, e}，那么只对d和e添加冲突边，对d和a不添加&lt;br&gt;但如果move之后又对d重新赋值了，那么还是要添加上d和a之间的冲突边&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;冲突图着色&#34;&gt;&lt;a href=&#34;#冲突图着色&#34; class=&#34;headerlink&#34; title=&#34;冲突图着色&#34;&gt;&lt;/a&gt;冲突图着色&lt;/h3&gt;&lt;p&gt;Vertex Coloring: 给图中的顶点着色，使得图中没有边连接相同颜色的顶点&lt;br&gt;K-Coloring: 颜色数小于K&lt;/p&gt;
&lt;h4 id=&#34;Kempe-简化&#34;&gt;&lt;a href=&#34;#Kempe-简化&#34; class=&#34;headerlink&#34; title=&#34;Kempe 简化&#34;&gt;&lt;/a&gt;Kempe 简化&lt;/h4&gt;&lt;p&gt;如果图中有一个节点 n 的度数 &amp;lt; K（也就是它的冲突数少于寄存器数），那我们可以“临时删掉”这个节点，并递归给剩下的图上色。之后再把这个节点加回来，它一定可以找到一个合法颜色。&lt;/p&gt;
&lt;p&gt;如果图中所有节点的度数都 ≥ K，那就可能要进入溢出（spill）处理&lt;br&gt;算法步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;build: 画冲突图&lt;/li&gt;
&lt;li&gt;simplify the nodes with insignificant degree: 选取degree &amp;lt; k的节点，压栈&lt;/li&gt;
&lt;li&gt;select (or color) while rebuilding the graph: 出栈，分配颜色&lt;br&gt;A vertex such that its degree &amp;lt; k is always k-colorable&lt;br&gt;Remove such vertices and push them to a stack until the graph becomes empty&lt;br&gt;移除顶点的同时移除相关边&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;Coalescing&#34;&gt;&lt;a href=&#34;#Coalescing&#34; class=&#34;headerlink&#34; title=&#34;Coalescing&#34;&gt;&lt;/a&gt;Coalescing&lt;/h4&gt;&lt;p&gt;遵循两种策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Briggs Criteria&lt;/strong&gt;: 如果将节点 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 合并后得到的新节点 &lt;code&gt;ab&lt;/code&gt;，其相邻节点中degree &amp;gt;&amp;#x3D; K 的节点（significant-degree neighbors）的数量 小于 K，则可以合并&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;George Criteria&lt;/strong&gt;: 如果对节点 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt;，对于 &lt;code&gt;a&lt;/code&gt; 的每一个邻居 &lt;code&gt;t&lt;/code&gt;， 满足二者其中之一，就能合并：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt; 本来就和 &lt;code&gt;b&lt;/code&gt; 有冲突&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt;的degree &amp;lt; K&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整体流程：&lt;br&gt;&lt;img data-src=&#34;/f2.jpg&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么要simplify non-move-related node: 保留move-related的后续可以合并&lt;/li&gt;
&lt;li&gt;freeze: 当我们遇到两个变量 a ← b 有 move 指令，但现在还不能安全合并，我们又不想立刻 spill，于是我们“冻结”这条 move 指令：不再试图合并 a 和 b，而是让其中一个变成非 move 相关（non-move-related），进入 Simplify 阶段继续处理&lt;/li&gt;
&lt;li&gt;spill规则：优先移除不被经常使用、degree大的节点&lt;ul&gt;
&lt;li&gt;实际溢出的priority计算，对于节点a：&lt;br&gt;$$&lt;br&gt;priority(t) &amp;#x3D; \frac{(use + def outside loop) + loop_num * (use + def inside loop)}{D}&lt;br&gt;$$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/06/17/computer-science/compile-principles/ch8/</guid>
            <title>Basic Blocks &amp; Traces</title>
            <link>http://example.com/2025/06/17/computer-science/compile-principles/ch8/</link>
            <category>Basic Blocks and Traces</category>
            <pubDate>Tue, 17 Jun 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Basic-Blocks-and-Traces&#34;&gt;&lt;a href=&#34;#Basic-Blocks-and-Traces&#34; class=&#34;headerlink&#34; title=&#34;Basic Blocks and Traces&#34;&gt;&lt;/a&gt;Basic Blocks and Traces&lt;/h1&gt;&lt;h2 id=&#34;Canonical-Form&#34;&gt;&lt;a href=&#34;#Canonical-Form&#34; class=&#34;headerlink&#34; title=&#34;Canonical Form&#34;&gt;&lt;/a&gt;Canonical Form&lt;/h2&gt;&lt;p&gt;IR存在一些与机器语言不能完全对应的情况，和与编译优化分析相冲突的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CJUMP能够转移到t或者f，但是真正的机器语言在条件为假的时候直接下降至下一条指令（条件为真才跳转）&lt;/li&gt;
&lt;li&gt;在表达式中使用ESEQ不太方便，会使子树不同的计算顺序产生不同的计算结果&lt;/li&gt;
&lt;li&gt;CALL调用CALL作为参数的时候会有寄存器冲突、语句副作用（修改全局变量、改变堆内存, etc.）等问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Linearize: Transform trees into a list of canonical&lt;br&gt;trees without SEQ or ESEQ nodes&lt;/li&gt;
&lt;li&gt;Basic blocks: Group statements into sequences with&lt;br&gt;no internal jumps&amp;#x2F;labels&lt;/li&gt;
&lt;li&gt;Trace schedule: Order basic blocks so every CJUMP is followed by its false label&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;线性化&#34;&gt;&lt;a href=&#34;#线性化&#34; class=&#34;headerlink&#34; title=&#34;线性化&#34;&gt;&lt;/a&gt;线性化&lt;/h3&gt;&lt;p&gt;&amp;#x3D;&amp;#x3D;规范树（Canonical Tree）定义：&amp;#x3D;&amp;#x3D;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无SEQ或ESEQ&lt;/li&gt;
&lt;li&gt;每一个CALL的父亲不是EXP(…)就是MOVE(TEMP t, …)&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;消除ESEQ&#34;&gt;&lt;a href=&#34;#消除ESEQ&#34; class=&#34;headerlink&#34; title=&#34;消除ESEQ&#34;&gt;&lt;/a&gt;消除ESEQ&lt;/h4&gt;&lt;h5 id=&#34;规则&#34;&gt;&lt;a href=&#34;#规则&#34; class=&#34;headerlink&#34; title=&#34;规则&#34;&gt;&lt;/a&gt;规则&lt;/h5&gt;&lt;p&gt;合并副作用，提升ESEQ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ESEQ(s1, ESEQ(s2,e)) &amp;#x3D;&amp;gt; ESEQ(SEQ(s1,s2),e)&lt;/li&gt;
&lt;li&gt;BINOP(op, ESEQ(s, e1), e2) ⇒ ESEQ(s, BINOP(op, e1, e2))&lt;/li&gt;
&lt;li&gt;MEM(ESEQ(s, e1)) ⇒ ESEQ(s, MEM(e1))&lt;/li&gt;
&lt;li&gt;JUMP(ESEQ(s, e1)) ⇒ SEQ(s, JUMP(e1))&lt;/li&gt;
&lt;li&gt;CJUMP(op, ESEQ(s, e1), e2, l1, l2) ⇒ SEQ(s, CJUMP(op, e1, e2, l1, l2))&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;Commutativity（重点）&#34;&gt;&lt;a href=&#34;#Commutativity（重点）&#34; class=&#34;headerlink&#34; title=&#34;Commutativity（重点）&#34;&gt;&lt;/a&gt;Commutativity（重点）&lt;/h5&gt;&lt;p&gt;当&lt;code&gt;ESEQ&lt;/code&gt;出现在&lt;code&gt;BINOP&lt;/code&gt;的右操作数，即$BINOP(op, e1, ESEQ(s, e2))$时，我们不能再像之前那样简单地把&lt;code&gt;s&lt;/code&gt;提升到整个&lt;code&gt;BINOP&lt;/code&gt;之前，因为&lt;code&gt;e1&lt;/code&gt;的求值在&lt;code&gt;e2&lt;/code&gt;之前，否则可能影响&lt;code&gt;e1&lt;/code&gt;的计算结果&lt;/p&gt;
&lt;p&gt;Commutativity：交换性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Commuting: s不影响e1的结果&lt;ul&gt;
&lt;li&gt;rule: $BINOP(op, e1, ESEQ(s, e2)) &amp;#x3D; ESEQ(s, BINOP(op, e1, e2))$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Non-commuting: s会影响e1的结果，把e1的结果显算出来放到临时变量t里，再提升s&lt;ul&gt;
&lt;li&gt;rule: $BINOP(op, ESEQ(s, e1), e2) &amp;#x3D; ESEQ(MOVE(TEMP t, e1), ESEQ(s, BINOP(op, TEMP t, e2)))$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;将CALL移到顶层&#34;&gt;&lt;a href=&#34;#将CALL移到顶层&#34; class=&#34;headerlink&#34; title=&#34;将CALL移到顶层&#34;&gt;&lt;/a&gt;将CALL移到顶层&lt;/h4&gt;&lt;p&gt;方法：立即将每一个返回值赋给一个新的临时寄存器&lt;br&gt;$$&lt;br&gt;CALL(fun, args) ⇒ ESEQ(MOVE(TEMP t, CALL(fun, args)), TEMP t)&lt;br&gt;$$&lt;/p&gt;
&lt;h4 id=&#34;消除SEQ&#34;&gt;&lt;a href=&#34;#消除SEQ&#34; class=&#34;headerlink&#34; title=&#34;消除SEQ&#34;&gt;&lt;/a&gt;消除SEQ&lt;/h4&gt;&lt;p&gt;$$&lt;br&gt;SEQ(SEQ(a, b), c) &amp;#x3D; SEQ(a, SEQ(b, c))&lt;br&gt;$$&lt;br&gt;把SEQ变成一个线性语句表：$SEQ(s_1, SEQ(s_2, …, SEQ(s_{n-1}, s_n) …))$&lt;br&gt;就可以认为是由语句组成的简单列表$s_1, s_2, …, s_n$&lt;/p&gt;
&lt;h3 id=&#34;处理CJUMP&#34;&gt;&lt;a href=&#34;#处理CJUMP&#34; class=&#34;headerlink&#34; title=&#34;处理CJUMP&#34;&gt;&lt;/a&gt;处理CJUMP&lt;/h3&gt;&lt;p&gt;重排CJUMP，使得每个$CJUMP(op, e_1, e_2, l_t, l_f)后面都紧跟着$LABEL(l_f)$&lt;br&gt;分两步：1. 取一列canonical tree由它们形成basic block 2. 对basic block进行排序形成trace&lt;/p&gt;
&lt;h4 id=&#34;Basic-Block&#34;&gt;&lt;a href=&#34;#Basic-Block&#34; class=&#34;headerlink&#34; title=&#34;Basic Block&#34;&gt;&lt;/a&gt;Basic Block&lt;/h4&gt;&lt;p&gt;一个基本块是一段连续的指令序列，即:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个语句是一个&lt;code&gt;LABEL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;最后一个语句是&lt;code&gt;JUMP&lt;/code&gt;或&lt;code&gt;CJUMP&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;没有其他的&lt;code&gt;LABEL&lt;/code&gt;, &lt;code&gt;JUMP&lt;/code&gt;或&lt;code&gt;CJUMP&lt;/code&gt;&lt;br&gt;划分方法：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;每一个&lt;code&gt;LABEL&lt;/code&gt;都对应一个基本块的开始&lt;/li&gt;
&lt;li&gt;每一个&lt;code&gt;JUMP&lt;/code&gt;或&lt;code&gt;CJUMP&lt;/code&gt;都对应一个基本块的结束&lt;/li&gt;
&lt;li&gt;如果遇到&lt;code&gt;LABEL1&lt;/code&gt; -&amp;gt; &lt;code&gt;LABEL2&lt;/code&gt;,就在&lt;code&gt;LABEL2&lt;/code&gt;前面加一个&lt;code&gt;JUMP&lt;/code&gt;到&lt;code&gt;LABEL2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果遇到开头没有&lt;code&gt;LABEL&lt;/code&gt;的，则加一个&lt;code&gt;LABEL&lt;/code&gt;（比如程序的开头）&lt;/li&gt;
&lt;li&gt;出口处理：添加一个LABEL &lt;code&gt;done&lt;/code&gt;表示出口处理的开始，并把$JUMP done$放最后一个block末尾&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;Trace&#34;&gt;&lt;a href=&#34;#Trace&#34; class=&#34;headerlink&#34; title=&#34;Trace&#34;&gt;&lt;/a&gt;Trace&lt;/h4&gt;&lt;p&gt;现在我们可以按任意顺序来安排这些基本块，并且程序执行的结果仍是相同的——因为无论怎么排序，每个基本块的末尾都能转移到一个正确的位置。我们可以利用这一点来选择适当的基本块排列顺序，以满足每个&lt;code&gt;CJUMP&lt;/code&gt;之后都跟随它的false标号这一条件。&lt;br&gt;与此同时，我们也可以安排基本块使得无条件转移&lt;code&gt;JUMP&lt;/code&gt;之后直接跟随的是它们的目标标号。这样便可以删除这些无条件转移，从而使编译生成的程序的执行速度更快。&lt;/p&gt;
&lt;p&gt;把basic block排成trace的方法也很简单：&amp;#x3D;&amp;#x3D;从每个基本块开始，追踪JUMP链，标记遇到的每一个未标记的基本快并添加到当前trace中，最终到达一个其后继都标记过的块，就是结束块。之后再选则一个未标记的基本块开始，重复上述过程。&amp;#x3D;&amp;#x3D;&lt;/p&gt;
&lt;p&gt;因为轨迹调度不可能覆盖所有情况，所以：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果CJUMP 后跟 true label: 条件取反，交换 true&amp;#x2F;false，改成：&lt;br&gt;$$&lt;br&gt;CJUMP(!cond, lf, lt)&lt;br&gt;$$&lt;/li&gt;
&lt;li&gt;CJUMP 后跟的不是 true 也不是 false: 创建中间 label，插入 JUMP&lt;br&gt;$$&lt;br&gt;CJUMP(cond, lt, lf) &amp;#x3D;&amp;gt; CJUMP(cond, lt, l’f) LABEL l’f   JUMP NAME(lf)&lt;br&gt;$$&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;最优轨迹-Optimal-Trace&#34;&gt;&lt;a href=&#34;#最优轨迹-Optimal-Trace&#34; class=&#34;headerlink&#34; title=&#34;最优轨迹(Optimal Trace)&#34;&gt;&lt;/a&gt;最优轨迹(Optimal Trace)&lt;/h4&gt;&lt;p&gt;对于basic block可能有不同的trace划分方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hot Path Prioritization（优先热路径）: 优先将**运行频率高的基本块（hot blocks）**合并在同一条轨迹（trace）里，减少跳转，提高局部性。&lt;br&gt;+++info example&lt;br&gt;假设 if-else 中 if 分支占 90% 执行概率，else 只有 10%：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;tiger&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; x &amp;gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt; then&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    a := a + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;   -- 热路径&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    a := a - &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;生成时应把 x &amp;gt; 0 为真的路径（包括 CJUMP 的 false 分支）安排成 fall-through，避免跳转开销出现在热路径上。&lt;br&gt;+++&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Locality Enhancement（增强局部性）: 把逻辑上相关联的代码块放得更近一些，让它们在内存中“邻近”。&lt;ul&gt;
&lt;li&gt;原因：&lt;ul&gt;
&lt;li&gt;更好地利用 CPU cache、预取机制。&lt;/li&gt;
&lt;li&gt;避免指令 cache miss 导致性能下降。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如：将循环体和循环条件代码块排在一起（而不是让条件跳到远处），从而保持指令流顺序性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Jump Minimization（最小化跳转）: 尽量减少无条件跳转（JUMP）和不必要的条件跳转（CJUMP），尤其在常走路径上，	减少分支预测失败。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;/f1.jpg&#34;&gt;&lt;br&gt;哪个划分比较好？&lt;br&gt;根据3，c比a好；&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/06/17/computer-science/compile-principles/ch9/</guid>
            <title>指令选择</title>
            <link>http://example.com/2025/06/17/computer-science/compile-principles/ch9/</link>
            <category>指令选择</category>
            <pubDate>Tue, 17 Jun 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;指令选择&#34;&gt;&lt;a href=&#34;#指令选择&#34; class=&#34;headerlink&#34; title=&#34;指令选择&#34;&gt;&lt;/a&gt;指令选择&lt;/h1&gt;&lt;p&gt;找出实现一个给定的IR Tree的恰当机器指令序列。Mapping IR into abstract assembly code&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Abstract assembly &amp;#x3D; assembly with infinite registers&lt;ul&gt;
&lt;li&gt;Invent new temporaries for intermediate results&lt;/li&gt;
&lt;li&gt;Map to actual registers later&lt;br&gt;Tree pattern, 也叫tile&lt;br&gt;本质上是pattern matching, 我们使用tree covering 来实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们&lt;code&gt;Jouette&lt;/code&gt;体系将树模式映射为指令:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;寄存器中可以存储数据或地址，每条指令可以访问任意寄存器&lt;/li&gt;
&lt;li&gt;寄存器r0的值永远是0&lt;/li&gt;
&lt;li&gt;每条指令的latency都是一周期（除了MOVEM的周期是m）&lt;/li&gt;
&lt;li&gt;每个周期执行一条指令&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;/f2.jpg&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/f1.jpg&#34;&gt;&lt;br&gt;将IR与后端的机器指令都转换为树结构。这样就把指令选择问题转换为机器指令树覆盖全IR Tree的问题。&lt;br&gt;一棵树可以有多种tiling方式&lt;/p&gt;
&lt;h2 id=&#34;Optimal-Tiling-Optimum-Tiling&#34;&gt;&lt;a href=&#34;#Optimal-Tiling-Optimum-Tiling&#34; class=&#34;headerlink&#34; title=&#34;Optimal Tiling &amp;amp; Optimum Tiling&#34;&gt;&lt;/a&gt;Optimal Tiling &amp;amp; Optimum Tiling&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Optimum Tiling：使得tiling数最少，是&amp;#x3D;&amp;#x3D;全局最优&amp;#x3D;&amp;#x3D;&lt;/li&gt;
&lt;li&gt;Optimal Tiling：No two adjacent tiles can be combined into a single tile of lower cost，是&amp;#x3D;&amp;#x3D;局部最优&amp;#x3D;&amp;#x3D;&lt;br&gt;一个optimum tiling必定是optimal tiling&lt;br&gt;&lt;img data-src=&#34;/f3.jpg&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Algorithms-for-Instruction-Selection&#34;&gt;&lt;a href=&#34;#Algorithms-for-Instruction-Selection&#34; class=&#34;headerlink&#34; title=&#34;Algorithms for Instruction Selection&#34;&gt;&lt;/a&gt;Algorithms for Instruction Selection&lt;/h2&gt;&lt;h3 id=&#34;Maximal-Munch-Find-an-optimal-tiling&#34;&gt;&lt;a href=&#34;#Maximal-Munch-Find-an-optimal-tiling&#34; class=&#34;headerlink&#34; title=&#34;Maximal Munch: Find an optimal tiling&#34;&gt;&lt;/a&gt;Maximal Munch: Find an optimal tiling&lt;/h3&gt;&lt;p&gt;最大匹配：贪心算法、自顶向下&lt;br&gt;方法：从IR树的根节点开始，用&amp;#x3D;&amp;#x3D;最大的&amp;#x3D;&amp;#x3D;tile覆盖当前节点（包含最多节点的），然后在子树中重复此过程&lt;/p&gt;
&lt;h3 id=&#34;DP&#34;&gt;&lt;a href=&#34;#DP&#34; class=&#34;headerlink&#34; title=&#34;DP&#34;&gt;&lt;/a&gt;DP&lt;/h3&gt;&lt;p&gt;动态规划：自底向上&lt;br&gt;方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;递归计算每个子树的最优平铺成本&lt;/li&gt;
&lt;li&gt;对于每个节点，考虑所有可能的匹配平铺&lt;/li&gt;
&lt;li&gt;对于每个匹配平铺，计算其成本如下：cost &amp;#x3D; tile_cost + sum（costs_of_children）&lt;/li&gt;
&lt;li&gt;选择成本最低的平铺&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;对于$CONST i$，它的代价为1( ADD r1, r0, i)&lt;/li&gt;
&lt;li&gt;对于这棵树，有三种匹配方法&lt;br&gt;&lt;img data-src=&#34;/f4.jpg&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/f5.jpg&#34;&gt;&lt;br&gt;因为2&amp;lt;3，所以我们从cost&amp;#x3D;2的两个任选一个&lt;br&gt;接下来对于MEM，用的都是LOAD，代价都是1，2&amp;lt;3所以选cost&amp;#x3D;2的&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;指令发射&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;function &lt;span class=&#34;title function_&#34;&gt;Emission&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(node n)&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    For each leaf l_i of the tile selected at node n:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;title function_&#34;&gt;Emission&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(l_i)&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    Emit the instruction matched at node n&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;最大匹配-vs-动态规划&#34;&gt;&lt;a href=&#34;#最大匹配-vs-动态规划&#34; class=&#34;headerlink&#34; title=&#34;最大匹配 vs 动态规划&#34;&gt;&lt;/a&gt;最大匹配 vs 动态规划&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;T&lt;/strong&gt; - tile的总种类数  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;K&lt;/strong&gt; - 一个matching tile平均覆盖的节点数  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;K’&lt;/strong&gt; - 需要检查的最大tile尺寸（即最大的瓦片包含的节点数）  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;T’&lt;/strong&gt; - 每个树节点平均能匹配上的tile数量  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;N&lt;/strong&gt; - 输入的中间表示IR Tree中的总节点数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两种算法的运行时间复杂度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;最大匹配（Maximal Munch）&lt;/strong&gt; - 其时间复杂度与&lt;br&gt;$$&lt;br&gt;\frac{(K’ + T’) * K}{K} * N &amp;#x3D; (K’ + T’) * N&lt;br&gt;$$&lt;br&gt;成正比&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;动态规划（Dynamic Programming）&lt;/strong&gt; - 其时间复杂度与&lt;br&gt;$$&lt;br&gt;(K’ + T’) * N&lt;br&gt;$$&lt;br&gt;成正比&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Tree-Grammar-树文法&#34;&gt;&lt;a href=&#34;#Tree-Grammar-树文法&#34; class=&#34;headerlink&#34; title=&#34;Tree Grammar 树文法&#34;&gt;&lt;/a&gt;Tree Grammar 树文法&lt;/h2&gt;&lt;p&gt;问题：对于具有复杂指令集和多种寄存器类型及寻址模式的机器，难以使用简单的tree pattern和tiling算法。&lt;br&gt;用一种文法来描述tiles，代替手写过程式匹配代码，支持自动化的指令选择，增强了可移植性&lt;br&gt;图没看懂，后面再回来研究&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/06/16/AI/week10-11/</guid>
            <title>Week10-11</title>
            <link>http://example.com/2025/06/16/AI/week10-11/</link>
            <category>人工智能</category>
            <pubDate>Mon, 16 Jun 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;深度学习&#34;&gt;&lt;a href=&#34;#深度学习&#34; class=&#34;headerlink&#34; title=&#34;深度学习&#34;&gt;&lt;/a&gt;深度学习&lt;/h1&gt;&lt;h2 id=&#34;前馈神经网络&#34;&gt;&lt;a href=&#34;#前馈神经网络&#34; class=&#34;headerlink&#34; title=&#34;前馈神经网络&#34;&gt;&lt;/a&gt;前馈神经网络&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;神经元&lt;/li&gt;
&lt;li&gt;感知机（多一个激活函数）&lt;/li&gt;
&lt;li&gt;激活函数: .RelU, Sigmoid, Softmax, tanh..&lt;/li&gt;
&lt;li&gt;损失函数: MSE, Cross Entropy…s&lt;/li&gt;
&lt;li&gt;参数优化: BP, 梯度下降&lt;br&gt;具体懒得写了，都说烂了&lt;br&gt;记一下这几个激活函数的形状和应用: tanh和sigmoid大多用于二分类，RelU一般用在隐藏层，Softmax用在多分类而且概率和为1&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;CNN&#34;&gt;&lt;a href=&#34;#CNN&#34; class=&#34;headerlink&#34; title=&#34;CNN&#34;&gt;&lt;/a&gt;CNN&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;了解卷积操作和操作之后的结果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;池化操作（最大池化、平均池化）&lt;br&gt;卷积层负责提取图像中的局部特征；&lt;br&gt;池化层用来大幅降低参数量级(降维)；&lt;br&gt;激活函数负责非线性化；&lt;br&gt;全连接层类似传统神经网络的部分，用来输出想要的结果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;神经网络正则化：为了缓解神经网络在训练过程中出现的过拟合问题，需要采取一些正则化技术来提升神经网络的泛化能力(generalization)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dropout：在训练神经网络过程中，每次参数更新时随机丢掉一部分神经元来减少神经网络复杂度，防止过拟合&lt;br&gt; &lt;img data-src=&#34;/f1.jpg&#34;&gt;&lt;/li&gt;
&lt;li&gt;Batch-Normalization（批归一化）:通过规范化的手段，把神经网络每层中任意神经元的输入值分布改变到均值为0、方差为1的标准正态分布。防止梯度消失，收敛更快&lt;/li&gt;
&lt;li&gt;L1-Norm &amp;amp; L2-Norm&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;循环神经网络（RNN）&#34;&gt;&lt;a href=&#34;#循环神经网络（RNN）&#34; class=&#34;headerlink&#34; title=&#34;循环神经网络（RNN）&#34;&gt;&lt;/a&gt;循环神经网络（RNN）&lt;/h2&gt;&lt;p&gt;RNN对具有序列特性的数据非常有效，它能挖掘数据中的时序信息以及语义信息&lt;/p&gt;
&lt;p&gt;为了解决&amp;#x3D;&amp;#x3D;梯度消失问题&amp;#x3D;&amp;#x3D;，长短时记忆模型（Long Short-Term Memory，LSTM）被提出&lt;br&gt;LSTM：&lt;br&gt;与简单的循环神经网络结构不同，长短时记忆网络（Long Short-Term Memory，LSTM）中引入了&amp;#x3D;&amp;#x3D;内部记忆单元&amp;#x3D;&amp;#x3D;（internal memory cell）和&amp;#x3D;&amp;#x3D;门&amp;#x3D;&amp;#x3D;（gates）两种结构来对当前时刻输入信息以及前序时刻所生成信息进行整合和传递。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入门(input gate)、遗忘门(forget gate)和输出门(output gate)三种gate&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;门控循环单元（GRU）是一种对LSTM简化的深度学习模型。与长短时记忆网络相比，GRU不再使用记忆单元来传递信息，仅使用隐藏状态来进行信息的传递。相比于长短时记忆网络来说，GRU有更高的计算速度。&lt;/p&gt;
&lt;h3 id=&#34;注意力机制&#34;&gt;&lt;a href=&#34;#注意力机制&#34; class=&#34;headerlink&#34; title=&#34;注意力机制&#34;&gt;&lt;/a&gt;注意力机制&lt;/h3&gt;&lt;p&gt;注意力机制对不同信息的关注程度（重要程度）由权值来体现，注意力机制可以视为&amp;#x3D;&amp;#x3D;查询矩阵(Query)&amp;#x3D;&amp;#x3D;&amp;#x3D;&amp;#x3D;、键(key)&amp;#x3D;&amp;#x3D;以及&amp;#x3D;&amp;#x3D;加权平均值&amp;#x3D;&amp;#x3D;构成了多层感知机(Multilayer Perceptron, MLP)&lt;/p&gt;
&lt;h2 id=&#34;深度生成学习（deep-generative-learning-model）&#34;&gt;&lt;a href=&#34;#深度生成学习（deep-generative-learning-model）&#34; class=&#34;headerlink&#34; title=&#34;深度生成学习（deep generative learning model）&#34;&gt;&lt;/a&gt;深度生成学习（deep generative learning model）&lt;/h2&gt;&lt;p&gt;判别模型vs生成模型&lt;br&gt;变分自编码器 (variational auto-encoder, VAE) 、 自回归模型 (Autoregressivemodels)与生成对抗网络（generative adversarial network，GAN）等&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/06/16/AI/week12-13/</guid>
            <title>Week12-13</title>
            <link>http://example.com/2025/06/16/AI/week12-13/</link>
            <category>人工智能</category>
            <pubDate>Mon, 16 Jun 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;强化学习&#34;&gt;&lt;a href=&#34;#强化学习&#34; class=&#34;headerlink&#34; title=&#34;强化学习&#34;&gt;&lt;/a&gt;强化学习&lt;/h1&gt;&lt;p&gt;根据环境所提供的奖罚反馈来学习所处状态可施加的最佳行动，在“探索（未知空间）-利用（已有经验）（exploration vs. exploitation）”之间寻找平衡，完成某个序列化任务，具备自我学习能力&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;智能体（agent）：智能体是强化学习算法的主体，它能够根据经验做出主观判断并执行动作，是整个智能系统的核心。&lt;/li&gt;
&lt;li&gt;环境（environment）：智能体以外的一切统称为环境，环境在与智能体的交互中，能被智能体所采取的动作影响，同时环境也能向智能体反馈状态和奖励。虽说智能体以外的一切都可视为环境，但在设计算法时常常会排除不相关的因素建立一个理想的环境模型来对算法功能进行模拟。&lt;/li&gt;
&lt;li&gt;状态（state）：状态可以理解为智能体对环境的一种理解和编码，通常包含了对智能体所采取决策产生影响的信息。&lt;/li&gt;
&lt;li&gt;动作（action）：动作是智能体对环境产生影响的方式，这里说的动作常常指概念上的动作，如果是在设计机器人时还需考虑动作的执行机构。&lt;/li&gt;
&lt;li&gt;策略（policy）：策略是智能体在所处状态下去执行某个动作的依据，即给定一个状态，智能体可根据一个策略来选择应该采取的动作。&lt;/li&gt;
&lt;li&gt;奖励（reward）：奖励是智能体序贯式采取一系列动作后从环境获得的收益。注意奖励概念是现实中奖励和惩罚的统合，一般用正值来代表实际奖励，用负值来代表实际惩罚。&lt;br&gt;&lt;img data-src=&#34;/f1.jpg&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;强化学习的特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;#x3D;&amp;#x3D;基于评估&amp;#x3D;&amp;#x3D;：强化学习利用环境评估当前策略，以此为依据进行优化&lt;/li&gt;
&lt;li&gt;&amp;#x3D;&amp;#x3D;交互性&amp;#x3D;&amp;#x3D;：强化学习的数据在与环境的交互中产生&lt;/li&gt;
&lt;li&gt;&amp;#x3D;&amp;#x3D;序列决策过程&amp;#x3D;&amp;#x3D;：智能主体在与环境的交互中需要作出一系列的决策，这些决策往往是前后关联的&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;离散马尔可夫过程（Discrete-Markov-Process）&#34;&gt;&lt;a href=&#34;#离散马尔可夫过程（Discrete-Markov-Process）&#34; class=&#34;headerlink&#34; title=&#34;离散马尔可夫过程（Discrete Markov Process）&#34;&gt;&lt;/a&gt;离散马尔可夫过程（Discrete Markov Process）&lt;/h2&gt;&lt;p&gt;满足马尔可夫性的离散随机过程&lt;br&gt;用数学归纳法，推出t+1时刻状态仅与t时刻状态有关（一阶马尔可夫链）&lt;br&gt;强化学习是一种机器学习方法，通过与环境的交互来学习最优策略。下面我将通过具体的例子来解释这些公式和概念。&lt;/p&gt;
&lt;h3 id=&#34;马尔可夫奖励过程&#34;&gt;&lt;a href=&#34;#马尔可夫奖励过程&#34; class=&#34;headerlink&#34; title=&#34;马尔可夫奖励过程&#34;&gt;&lt;/a&gt;马尔可夫奖励过程&lt;/h3&gt;&lt;p&gt;$$&lt;br&gt;G_t &amp;#x3D; R_{t+1} + \gamma R_{t+2} + \gamma^2 R_{t+3} + \ldots&lt;br&gt;$$&lt;br&gt;这个公式表示从时间步 t开始的累积回报 $G_t$，其中 $R_{t+i}$ 是在时间步 $t+i$ 获得的即时奖励，$\gamma$ 是折扣因子（范围在 [0, 1] 之间），用于减少未来奖励对当前决策的影响。&lt;/p&gt;
&lt;p&gt;例: 假在一个迷宫中寻找宝藏，每走一步都有可能获得或失去一些分数（奖励）。如果你在第 1 步获得 10 分，在第 2 步获得 5 分，在第 3 步获得 2 分，且折扣因子 $\gamma &amp;#x3D; 0.9$，那么从第 0 步开始的累积回报 $G_0$ 就是：&lt;br&gt;$$&lt;br&gt;G_0 &amp;#x3D; 10 + 0.9 \times 5 + 0.9^2 \times 2 &amp;#x3D; 10 + 4.5 + 1.62 &amp;#x3D; 16.12&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;强化学习的求解方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于价值（1.策略优化 2.策略评估）&lt;/li&gt;
&lt;li&gt;基于策略&lt;/li&gt;
&lt;li&gt;基于模型&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;策略学习&#34;&gt;&lt;a href=&#34;#策略学习&#34; class=&#34;headerlink&#34; title=&#34;策略学习&#34;&gt;&lt;/a&gt;策略学习&lt;/h3&gt;&lt;p&gt;价值函数 (value function):&lt;br&gt;$$&lt;br&gt;V_\pi(s) &amp;#x3D; E_\pi[G_t | S_t &amp;#x3D; s]&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;在状态 s 下，按照策略 $\pi$ 行动后在未来所获得的回报的期望值。&lt;/p&gt;
&lt;p&gt;动作-价值函数 (action-value function):&lt;br&gt;$$&lt;br&gt;q_\pi(s, a) &amp;#x3D; E_\pi[G_t | S_t &amp;#x3D; s, A_t &amp;#x3D; a]&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;在状态 s 下采取动作 a，按照策略 $\pi 行动后在未来获得的回报值。&lt;/p&gt;
&lt;p&gt;例: 继续迷宫的例子，假设在某个位置（状态 s有两个选择：向左走（动作 $a_1$ 或向右走（动作 $a_2$）。根据历史数据，向左走的平均回报是 8 分，向右走的平均回报是 12 分。那么在这个状态下，动作-价值函数 $q_\pi(s, a_1) &amp;#x3D; 8$，$q_\pi(s, a_2) &amp;#x3D; 12$。&lt;/p&gt;
&lt;h3 id=&#34;贝尔曼方程&#34;&gt;&lt;a href=&#34;#贝尔曼方程&#34; class=&#34;headerlink&#34; title=&#34;贝尔曼方程&#34;&gt;&lt;/a&gt;贝尔曼方程&lt;/h3&gt;&lt;p&gt;价值函数的贝尔曼方程:&lt;br&gt;$$&lt;br&gt;V_\pi(s) &amp;#x3D; \sum_a \pi(s, a) q_\pi(s, a)&lt;br&gt;$$&lt;br&gt;在状态 s 下，采取各个动作的概率加权平均的动作-价值函数。&lt;/p&gt;
&lt;p&gt;动作-价值函数的贝尔曼方程:&lt;br&gt;$$&lt;br&gt;q_\pi(s, a) &amp;#x3D; \sum_{s’} P(s’ | s, a) [R(s, a, s’) + \gamma V_\pi(s’)]&lt;br&gt;$$&lt;br&gt;在状态s采取动作a的概率*（采取a进入s’得到的回报+处于s’可以得到的回报）。&lt;/p&gt;
&lt;h3 id=&#34;策略评估算法步骤&#34;&gt;&lt;a href=&#34;#策略评估算法步骤&#34; class=&#34;headerlink&#34; title=&#34;策略评估算法步骤&#34;&gt;&lt;/a&gt;策略评估算法步骤&lt;/h3&gt;&lt;h4 id=&#34;动态规划&#34;&gt;&lt;a href=&#34;#动态规划&#34; class=&#34;headerlink&#34; title=&#34;动态规划&#34;&gt;&lt;/a&gt;动态规划&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;初始化 $V_\pi$ 函数：首先需要对所有状态 s 的价值函数 $V_\pi(s)$ 进行初始化，通常可以设置为0或者任意合理的初始值。&lt;/li&gt;
&lt;li&gt;循环迭代：&lt;ul&gt;
&lt;li&gt;对于每一个状态 $s \in S$，根据当前的策略 $\pi$ 和已知的状态转移概率 $Pr(s’|s, a)$，以及即时奖励 $R(s, a, s’)$，更新该状态的价值函数 $V_\pi(s)$。&lt;/li&gt;
&lt;li&gt;更新公式如下：&lt;br&gt;$$&lt;br&gt;V_\pi(s) \leftarrow \sum_{a \in A} \pi(a|s) \sum_{s’ \in S} Pr(s’|s, a) [R(s, a, s’) + \gamma V_\pi(s’)]&lt;br&gt;$$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;直到收敛：重复上述迭代过程，直到价值函数 $V_\pi(s)$ 在所有状态上都几乎不再发生变化，即达到收敛状态。这表明我们已经找到了在当前策略 $\pi$ 下各个状态的稳定价值。&lt;br&gt;&amp;#x3D;&amp;#x3D;当前状态的价值是由后续状态的价值通过贝尔曼方程传播回来的&amp;#x3D;&amp;#x3D;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;策略评估：动态规划、蒙特卡洛采样、时序差分&lt;/p&gt;
&lt;h4 id=&#34;蒙特卡洛采样&#34;&gt;&lt;a href=&#34;#蒙特卡洛采样&#34; class=&#34;headerlink&#34; title=&#34;蒙特卡洛采样&#34;&gt;&lt;/a&gt;蒙特卡洛采样&lt;/h4&gt;&lt;p&gt;通过随机采样来估计期望值&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;选择起始状态：从状态空间 S 中选择不同的起始状态。&lt;/li&gt;
&lt;li&gt;按照当前策略采样轨迹：从每个起始状态出发，按照当前策略 $\pi$ 生成若干条完整的轨迹（episode）。这些轨迹构成了集合 D。&lt;/li&gt;
&lt;li&gt;计算反馈：对于每条轨迹中的每个状态 s，记录该状态出现时对应的回报 $G_i$ 。&lt;/li&gt;
&lt;li&gt;平均回报：对所有轨迹中状态 s 出现时的回报进行平均，得到该状态的价值 $V_\pi(s)$。&lt;br&gt;假设我们有 k 条轨迹，每条轨迹中状态 s 出现时对应的回报分别为$G_1, G_2, \ldots, G_k$，那么该状态的价值 $V_\pi(s)$ 可以通过以下公式计算：&lt;br&gt;$$&lt;br&gt;V_\pi(s) &amp;#x3D; \frac{1}{k} \sum_{i&amp;#x3D;1}^k G_i&lt;br&gt;$$&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;时序差分-TD&#34;&gt;&lt;a href=&#34;#时序差分-TD&#34; class=&#34;headerlink&#34; title=&#34;时序差分(TD)&#34;&gt;&lt;/a&gt;时序差分(TD)&lt;/h4&gt;&lt;p&gt;时序差分算法通过在每个时间步 t 上更新状态价值函数 $V_\pi(s_t)$，而不是在每个状态 $s_t$ 上进行批量更新。&lt;br&gt;$$&lt;br&gt;V_\pi(s) \leftarrow V_\pi(s) + \alpha [R(s, a, s’) + \gamma V_\pi(s’) - V_\pi(s)]&lt;br&gt;$$&lt;br&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\alpha$ 是学习率，通常取较小的值，如0.1。&lt;/li&gt;
&lt;li&gt;$R(s, a, s’)$ 是即时奖励&lt;/li&gt;
&lt;li&gt;$V_\pi(s’)$ 是状态 $s’$ 的价值函数&lt;/li&gt;
&lt;li&gt;$\gamma$ 是折扣因子，通常取较小的值，如0.9。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;Q-learning&#34;&gt;&lt;a href=&#34;#Q-learning&#34; class=&#34;headerlink&#34; title=&#34;Q-learning&#34;&gt;&lt;/a&gt;Q-learning&lt;/h4&gt;&lt;h4 id=&#34;DQN&#34;&gt;&lt;a href=&#34;#DQN&#34; class=&#34;headerlink&#34; title=&#34;DQN&#34;&gt;&lt;/a&gt;DQN&lt;/h4&gt; ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/06/16/AI/week14-15/</guid>
            <title>Week14-15</title>
            <link>http://example.com/2025/06/16/AI/week14-15/</link>
            <category>人工智能</category>
            <pubDate>Mon, 16 Jun 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;人工智能博弈&#34;&gt;&lt;a href=&#34;#人工智能博弈&#34; class=&#34;headerlink&#34; title=&#34;人工智能博弈&#34;&gt;&lt;/a&gt;人工智能博弈&lt;/h1&gt;&lt;h2 id=&#34;博弈论&#34;&gt;&lt;a href=&#34;#博弈论&#34; class=&#34;headerlink&#34; title=&#34;博弈论&#34;&gt;&lt;/a&gt;博弈论&lt;/h2&gt;&lt;p&gt;博弈的要素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;player&lt;/li&gt;
&lt;li&gt;strategy&lt;/li&gt;
&lt;li&gt;payoff&lt;/li&gt;
&lt;li&gt;rule&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;博弈策略求解&#34;&gt;&lt;a href=&#34;#博弈策略求解&#34; class=&#34;headerlink&#34; title=&#34;博弈策略求解&#34;&gt;&lt;/a&gt;博弈策略求解&lt;/h2&gt;&lt;h3 id=&#34;遗憾最小化算法（Regret-Minimization）&#34;&gt;&lt;a href=&#34;#遗憾最小化算法（Regret-Minimization）&#34; class=&#34;headerlink&#34; title=&#34;遗憾最小化算法（Regret Minimization）&#34;&gt;&lt;/a&gt;遗憾最小化算法（Regret Minimization）&lt;/h3&gt;&lt;p&gt;下一步选择策略$\Sigma_i$的概率P:&lt;br&gt;$$&lt;br&gt;P(\sigma_i^{T+1}) &amp;#x3D; \begin{cases}&lt;br&gt;\frac{\text{Regret}&lt;em&gt;i^{T,+}(\sigma_i)}{\sum&lt;/em&gt;{\sigma_i’ \in \Sigma_i} \text{Regret}&lt;em&gt;i^{T,+}(\sigma_i’)} &amp;amp; \text{if } \sum&lt;/em&gt;{\sigma_i’ \in \Sigma_i} \text{Regret}_i^{T,+}(\sigma_i’) &amp;gt; 0 \&lt;br&gt;\frac{1}{|\Sigma_i|} &amp;amp; \text{otherwise}&lt;br&gt;\end{cases}&lt;br&gt;$$&lt;br&gt;为什么不直接选遗憾最大的：防止对手发现自己所采取的策略&lt;br&gt;+++info 例子&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假设两个玩家A和B进行石头-剪刀-布（Rock-Paper-Scissors, RPS）的游戏，获胜玩家收益为1分，失败玩家收益为-1分，平局则两个玩家收益均为零分。&lt;/li&gt;
&lt;li&gt;第一局时，若玩家A出石头（R），玩家B出布（P），则此时玩家A的收益 $\mu_A(R, P) &amp;#x3D; -1$，玩家B的收益为 $\mu_B(P, R) &amp;#x3D; 1$。&lt;/li&gt;
&lt;li&gt;对于玩家A来说，在玩家B出布（P）这个策略情况下，如果玩家A选择出布（P）或者剪刀（S），则玩家A对应的收益值 $\mu_A(P, P) &amp;#x3D; 0$ 或者 $\mu_A(S, P) &amp;#x3D; 1$。&lt;/li&gt;
&lt;li&gt;所以第一局之后，玩家A没有出布的遗憾值为 $\mu_A(P, P) - \mu_A(R, P) &amp;#x3D; 0 - (-1) &amp;#x3D; 1$，没有出剪刀的遗憾值为 $\mu_A(S, P) - \mu_A(R, P) &amp;#x3D; 1 - (-1) &amp;#x3D; 2$。&lt;/li&gt;
&lt;li&gt;所以在第二局中，玩家A选择石头、剪刀和布这三个策略的概率分别为 0、$\frac{2}{3}$、$\frac{1}{3}$。因此，玩家A趋向于在第二局中选择出剪刀这个策略。&lt;/li&gt;
&lt;li&gt;第二局中，玩家A选择剪刀和玩家B选择石头情况下，第二轮石头、剪刀、布的Regret分别为1，0，2，把前两轮的regret加起来计算概率，得到出石头、剪刀、布的概率分别为$\frac{1}{6}$、$\frac{2}{6}$、$\frac{3}{6}$。&lt;br&gt;+++&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;双边匹配算法&#34;&gt;&lt;a href=&#34;#双边匹配算法&#34; class=&#34;headerlink&#34; title=&#34;双边匹配算法&#34;&gt;&lt;/a&gt;双边匹配算法&lt;/h3&gt;&lt;p&gt;&lt;img data-src=&#34;/f2.jpg&#34;&gt;&lt;br&gt;在第一轮中，4名男性分别向自己最喜欢的女性表白，而收到3人表白的女性A选择了自己最喜欢的男性3，另一个收到表白的女性B选择了男性4；在第二轮中，尚未匹配的男性1和男性2继续向自己第二喜欢的对象表白，收到表白的女性B选择了自己更喜欢的男性2而放弃了男性4；同理，继续三轮表白和选择，所有人都找到了自己的伴侣，且所有匹配都是稳定的。可以看出，使用G-S算法得到了稳定匹配的结果。&lt;/p&gt;
&lt;h3 id=&#34;单边匹配算法-最大交易圈&#34;&gt;&lt;a href=&#34;#单边匹配算法-最大交易圈&#34; class=&#34;headerlink&#34; title=&#34;单边匹配算法-最大交易圈&#34;&gt;&lt;/a&gt;单边匹配算法-最大交易圈&lt;/h3&gt;&lt;p&gt;&lt;img data-src=&#34;/f3.jpg&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个人指向最喜欢的物，每个物指向占有它的人&lt;/li&gt;
&lt;li&gt;如果有圈，就把打成交易的人和物和相关边都删掉&lt;/li&gt;
&lt;li&gt;继续&lt;br&gt;&lt;img data-src=&#34;/f4.jpg&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/06/16/computer-science/compile-principles/ch7/</guid>
            <title>IR</title>
            <link>http://example.com/2025/06/16/computer-science/compile-principles/ch7/</link>
            <category>中间代码</category>
            <pubDate>Mon, 16 Jun 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;IR&#34;&gt;&lt;a href=&#34;#IR&#34; class=&#34;headerlink&#34; title=&#34;IR&#34;&gt;&lt;/a&gt;IR&lt;/h1&gt;&lt;p&gt;Intermediate Representation&lt;br&gt;解决高级语言和目标机器汇编语言之间的转化&lt;br&gt;为什么需要IR:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更模块化、可迁移&lt;/li&gt;
&lt;li&gt;分层分析和优化&lt;br&gt;IR可以有好多层：IR1-&amp;gt;IR2-&amp;gt;…-&amp;gt;IRn&lt;br&gt;+++info 编译流程划分&lt;br&gt;前端：源代码-&amp;gt;词法分析-&amp;gt;语法分析-&amp;gt;语义分析（IR之前的都是）&lt;br&gt;中端：基于IR的分析与变换（可能生成新IR，可以做一些机器无关优化比如循环展开等）&lt;br&gt;后端：指令选择-&amp;gt;寄存器分配-&amp;gt;指令调度-&amp;gt;机器码（IR之后的）&lt;br&gt;+++&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Three-Address-Code&#34;&gt;&lt;a href=&#34;#Three-Address-Code&#34; class=&#34;headerlink&#34; title=&#34;Three-Address Code&#34;&gt;&lt;/a&gt;Three-Address Code&lt;/h2&gt;&lt;p&gt;最多有三个操作数&lt;br&gt;x &amp;#x3D; y op z&lt;br&gt;“地址”可以具有如下形式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源程序中的名字(name)&lt;/li&gt;
&lt;li&gt;常量 (constant)&lt;/li&gt;
&lt;li&gt;临时变量(temporary)&lt;br&gt;&lt;img data-src=&#34;/f1.jpg&#34;&gt;&lt;br&gt;最常见的实现方法是将三地址代码作为四元组实现&lt;br&gt;+++info example&lt;br&gt;t1&amp;#x3D;x&amp;gt;0                  (gt, x, 0, t1)&lt;br&gt;if_false t1 goto L1     (if_f, t1, L1, _)&lt;br&gt;fact&amp;#x3D;1                  (asn, 1, fact, _)&lt;br&gt;label L2                (lab, L2, _, _)&lt;br&gt;+++&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;IR-Tree&#34;&gt;&lt;a href=&#34;#IR-Tree&#34; class=&#34;headerlink&#34; title=&#34;IR Tree&#34;&gt;&lt;/a&gt;IR Tree&lt;/h2&gt;&lt;p&gt;两大类节点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;表达式Exp&lt;/li&gt;
&lt;li&gt;语句Stmt&lt;br&gt;文法：&lt;br&gt;&lt;img data-src=&#34;/f2.jpg&#34;&gt;&lt;br&gt;表达式：&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Node&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;CONST(i)&lt;/td&gt;
&lt;td&gt;整数常量i&lt;/td&gt;
&lt;td&gt;CONST(42) → the value 42&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NAME(n)&lt;/td&gt;
&lt;td&gt;符号常量n，通常是一个label，值是label的地址&lt;/td&gt;
&lt;td&gt;NAME(L1) → address of label L1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TEMP(t)&lt;/td&gt;
&lt;td&gt;临时变量t (like register)&lt;/td&gt;
&lt;td&gt;TEMP(t123) → contents of temporary t123&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BINOP(o,e1,e2)&lt;/td&gt;
&lt;td&gt;对e1和e2执行二元操作o&lt;/td&gt;
&lt;td&gt;BINOP(PLUS,TEMP(t1),CONST(1)) → t1+1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MEM(e)&lt;/td&gt;
&lt;td&gt;Memory access&lt;/td&gt;
&lt;td&gt;MEM(CONST(100)) → contents at address 100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CALL(f,l)&lt;/td&gt;
&lt;td&gt;Function call, l是参数列表&lt;/td&gt;
&lt;td&gt;CALL(NAME(print),[TEMP(t1)]) → call print(t1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ESEQ(s,e)&lt;/td&gt;
&lt;td&gt;先执行语句s，再求值表达式e并返回e的结果&lt;/td&gt;
&lt;td&gt;ESEQ(MOVE(TEMP(t),CONST(1)),TEMP(t)) → (t&amp;#x3D;1; t)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;语句：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Node&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;MOVE(TEMP t, e)&lt;/td&gt;
&lt;td&gt;将表达式e的值赋给临时变量t&lt;/td&gt;
&lt;td&gt;MOVE(TEMP(t1), CONST(42)) → t1 &amp;#x3D; 42&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MOVE(MEM(e1), e2)&lt;/td&gt;
&lt;td&gt;将表达式e2的值存储到由e1指定的内存地址中&lt;/td&gt;
&lt;td&gt;MOVE(MEM(TEMP(t1)), CONST(42)) → *t1 &amp;#x3D; 42&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EXP(e)&lt;/td&gt;
&lt;td&gt;计算表达式e的值但不返回结果，通常用于有副作用的操作（如函数调用）&lt;/td&gt;
&lt;td&gt;EXP(CALL(NAME(print), …)) → 调用print()函数以产生效果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JUMP(e, labs)&lt;/td&gt;
&lt;td&gt;无条件跳转到由e指定的地址&lt;/td&gt;
&lt;td&gt;JUMP(NAME(L1), [L1]) → goto L1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CJUMP(o,e1,e2,t,f)&lt;/td&gt;
&lt;td&gt;条件跳转，根据操作o对e1和e2的结果决定跳转到t或f&lt;/td&gt;
&lt;td&gt;CJUMP(LT, TEMP(t1), CONST(0), L1, L2) → 如果t1 &amp;lt; 0则跳转到L1，否则跳转到L2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SEQ(s1, s2)&lt;/td&gt;
&lt;td&gt;语句序列，先执行s1再执行s2&lt;/td&gt;
&lt;td&gt;SEQ(MOVE(…), JUMP(…)) → 先赋值再跳转&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LABEL(n)&lt;/td&gt;
&lt;td&gt;定义一个标签&lt;/td&gt;
&lt;td&gt;LABEL(L1) → L1:&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;例子：&lt;br&gt;&lt;img data-src=&#34;/f3.jpg&#34;&gt;&lt;br&gt;ADD那个地方写成BINOP的写法也可以&lt;/p&gt;
&lt;h2 id=&#34;翻译AST成IR-Tree&#34;&gt;&lt;a href=&#34;#翻译AST成IR-Tree&#34; class=&#34;headerlink&#34; title=&#34;翻译AST成IR Tree&#34;&gt;&lt;/a&gt;翻译AST成IR Tree&lt;/h2&gt;&lt;p&gt;把AST表达式分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ex: 有结果的AST表达式比如a+b&lt;/li&gt;
&lt;li&gt;Nx：无结果的语句的比如print&lt;/li&gt;
&lt;li&gt;Cx：条件语句，值为bool的AST表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;translate-Exp&#34;&gt;&lt;a href=&#34;#translate-Exp&#34; class=&#34;headerlink&#34; title=&#34;translate Exp&#34;&gt;&lt;/a&gt;translate Exp&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;翻译简单变量：&lt;br&gt;在函数中访问一个局部变量实际上是访问它在当前栈帧中的位置，所以访问一个距离fp的offset为k的局部变量v，其IR Tree表示为:&lt;br&gt;$$&lt;br&gt;MEM(BINOP(PLUS, TEMP fp, CONST k))&lt;br&gt;$$&lt;br&gt;&lt;img data-src=&#34;/f4.jpg&#34;&gt;&lt;br&gt;如果通过static link访问一个变量，就要嵌套好几层MEM和BINOP&lt;br&gt;比如这个访问嵌套两层外面的x&lt;br&gt;最内层使用 CONST(8)：是因为需要从 inner 函数的帧指针 FP 开始，偏移 8 字节来访问静态链，该静态链指向 middle 函数的帧。&lt;br&gt;中间层和最外层使用 CONST(0)：是因为它们分别通过静态链直接访问 outer 函数的帧和变量 x，不需要额外的偏移&lt;br&gt;&lt;img data-src=&#34;/f5.jpg&#34;&gt;&lt;br&gt;:::danger&lt;br&gt;这个地方为什么内层是8中层是0存疑&lt;br&gt;:::&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;左值和右值：&amp;#x3D;左右的&lt;br&gt;MEM(addr)可以是左值也可以是右值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Scalar L-value(Tiger): 一个地址&lt;/li&gt;
&lt;li&gt;Structured L-value(Pascal&amp;#x2F;C): 一块内存&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;翻译算术运算&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;二元: BINOP(op, e1, e2)&lt;/li&gt;
&lt;li&gt;一元: &lt;ul&gt;
&lt;li&gt;-x &amp;#x3D;&amp;#x3D;&amp;gt; BINOP(MINUS, CONST(0), e_x)&lt;/li&gt;
&lt;li&gt;~x &amp;#x3D;&amp;#x3D;&amp;gt; BINOP(XOR, e_x, CONST(-1))&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;数组访问&lt;br&gt;$$&lt;br&gt;MEM(BINOP(PLUS, MEM(e_a), BINOP(MUL, e_i, CONST(W))))&lt;br&gt;$$&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;e_a&lt;/code&gt; 是表示变量 &lt;code&gt;a&lt;/code&gt; 的表达式，通常是&amp;#x3D;&amp;#x3D; &lt;code&gt;MEM(+(TEMP(fp), CONST(k_a)))&lt;/code&gt;&amp;#x3D;&amp;#x3D;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MEM(e_a)&lt;/code&gt;：&amp;#x3D;&amp;#x3D;获取存储在变量 &lt;code&gt;a&lt;/code&gt; 中的值，即数组基地址&amp;#x3D;&amp;#x3D;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;e_i&lt;/code&gt; 是计算索引 &lt;code&gt;i&lt;/code&gt; 的表达式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BINOP(MUL, e_i, CONST(W))&lt;/code&gt;：计算偏移&lt;br&gt;&lt;img data-src=&#34;/f6.jpg&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;记录字段r.f访问:&lt;br&gt;$$&lt;br&gt;MEM(BINOP(PLUS, MEM(e_r), BINOP(MUL, n, CONST(W))))&lt;br&gt;$$&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;翻译控制流&lt;br&gt;对于if e1 op e2 then stmt1 else stmt2翻译成&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;IR&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 6个SEQ&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;SEQ(&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    CJUMP(op, e1, e2, t, f),&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    SEQ(&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        LABEL(t),&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        SEQ(&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            stm1,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            SEQ(&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                JUMP(NAME(end)),&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                SEQ(&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    LABEL(f),&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    SEQ(stm2, LABEL(end))&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                )&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            )&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        )&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    )&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;Tiger的逻辑运算符&amp;amp;(and)和|(or)需要实现短路求值：只计算必要的操作数&lt;br&gt;每个Cx是一个Label&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;逻辑与 (a &amp;amp; b)的短路规则：&lt;ul&gt;
&lt;li&gt;计算a&lt;br&gt;  -若a为假，直接得到假结果（不计算b）&lt;br&gt;  -若a为真，继续计算b，最终结果即为b的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;逻辑或 (a | b)的短路规则：&lt;br&gt;  -计算a&lt;br&gt;  -若a为真，直接得到真结果（不计算b）&lt;ul&gt;
&lt;li&gt;若a为假，继续计算b，最终结果即为b的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;循环语句&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;tiger&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt; a &amp;gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;a := a - &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;翻译成&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;IR&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;SEQ(LABEL test, &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    SEQ(CJUMP(GT, TEMP a, CONST &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;, body, done), &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        SEQ(LABEL body, &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            SEQ(MOVE(TEMP a, BINOP(MINUS, TEMP a, CONST &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;)), &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                SEQ(JUMP(NAME(test), [test]), &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    LABEL done)))))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;break翻译为直接跳转到done&lt;br&gt;for循环我懒得写了，也是一个道理&lt;br&gt;和汇编差不多意思&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;翻译函数&lt;br&gt;$$&lt;br&gt;CALL(NAME(l_f), [sl, a_1, …, a_n])&lt;br&gt;$$&lt;br&gt;sl是static link。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;translate-Declaration&#34;&gt;&lt;a href=&#34;#translate-Declaration&#34; class=&#34;headerlink&#34; title=&#34;translate Declaration&#34;&gt;&lt;/a&gt;translate Declaration&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Variable declaration&lt;/li&gt;
&lt;li&gt;Type declaration&lt;/li&gt;
&lt;li&gt;Function declaration&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;翻译变量声明&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;tiger&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;let&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    var x := &lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    var y := x + &lt;span class=&#34;number&#34;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;in &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    x + y&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;IR&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;ESEQ( &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    SEQ( &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        MOVE(MEM(+(FP, CONST(x_offset))), CONST(&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;)), &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        MOVE(MEM(+(FP, CONST(y_offset))), &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        BINOP(PLUS, &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        MEM(+(FP, CONST(x_offset))), &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        CONST(&lt;span class=&#34;number&#34;&gt;5&lt;/span&gt;))) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    ), &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    BINOP(PLUS, &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    MEM(+(FP, CONST(x_offset))), &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    MEM(+(FP, CONST(y_offset)))) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;let body in e end翻译成ESEQ(body, e)&lt;br&gt;变量定义翻译成 MEM(+(FP, CONST(offset)))&lt;br&gt;初始化翻译成 MOVE(MEM(+(FP, CONST(offset))), CONST(value))&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;p&gt;类型声明&lt;br&gt;No need to generate any IR tree code&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数声明&lt;br&gt; – Prologue（序言）&lt;br&gt; – Body（函数体）&lt;br&gt; – Epilogue（尾声）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Prologue&lt;ul&gt;
&lt;li&gt;pseudo-instructions to announce the beginning of a function&lt;/li&gt;
&lt;li&gt;定义函数标签用于跳转&amp;#x2F;调用&lt;/li&gt;
&lt;li&gt;修改栈指针（SP），为新栈帧分配空间，一般是$SP :&amp;#x3D; SP - frame_size$&lt;/li&gt;
&lt;li&gt;保存被调用者需要保存的寄存器（callee-save），如 $s0-$s7；保存返回地址（RA）&lt;/li&gt;
&lt;li&gt;保存函数参数到栈中（尤其是传值调用时）；保存静态链（static link）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/06/15/AI/week8-9/</guid>
            <title>Week8-9</title>
            <link>http://example.com/2025/06/15/AI/week8-9/</link>
            <category>人工智能</category>
            <pubDate>Sun, 15 Jun 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;K-Means&#34;&gt;&lt;a href=&#34;#K-Means&#34; class=&#34;headerlink&#34; title=&#34;K-Means&#34;&gt;&lt;/a&gt;K-Means&lt;/h1&gt;&lt;p&gt;问题描述：如何将n个数据依据其相似度大小将它们分别聚类到k个集合，使得每个数据仅属于一个聚类集合。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化质心：随机选择k个数据点作为初始质心$c_1, c_2, …, c_k$。&lt;/li&gt;
&lt;li&gt;分配数据点：对于每个数据点$x_i$，计算它与所有质心的距离，并将其分配到距离最近的质心所在的簇中&lt;/li&gt;
&lt;li&gt;更新质心：对于每个簇，计算该簇内所有数据点的平均值，将该平均值作为新的质心。&lt;/li&gt;
&lt;li&gt;迭代过程：重复执行分配和更新步骤，直到质心不再发生变化或达到预设的最大迭代次数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;主成分分析-PCA&#34;&gt;&lt;a href=&#34;#主成分分析-PCA&#34; class=&#34;headerlink&#34; title=&#34;主成分分析(PCA)&#34;&gt;&lt;/a&gt;主成分分析(PCA)&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;输入：n个d维样本数据所构成的矩阵$\mathbf{X}$，降维后的维数l&lt;/li&gt;
&lt;li&gt;输出：映射矩阵$\mathbf{W} &amp;#x3D; {\mathbf{w}_1, \mathbf{w}_2, …, \mathbf{w}_l}$&lt;br&gt;算法步骤：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;对于每个样本数据$\mathbf{x}_i$进行中心化处理：&lt;br&gt;$$&lt;br&gt;\mathbf{x}_i’ &amp;#x3D; \mathbf{x}&lt;em&gt;i - \mu, \quad \mu &amp;#x3D; \frac{1}{n}\sum&lt;/em&gt;{j&amp;#x3D;1}^{n} \mathbf{x}_j&lt;br&gt;$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;计算原始样本数据的协方差矩阵：&lt;br&gt;$$&lt;br&gt;\Sigma &amp;#x3D; \frac{1}{n-1} \mathbf{X}^T \mathbf{X}&lt;br&gt;$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对协方差矩阵$\Sigma$进行特征值分解，对所得特征根按其值大到小排序$\lambda_1 \geq \lambda_2 \geq \cdots \geq \lambda_d$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;取前$l$个最大特征根所对应特征向量$\mathbf{w}_1, \mathbf{w}_2, …, \mathbf{w}_l$组成映射矩阵$\mathbf{W}$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将每个样本数据$\mathbf{x}&lt;em&gt;i$按照如下方法降维：&lt;br&gt;$$&lt;br&gt;(\mathbf{x}&lt;em&gt;i)&lt;/em&gt;{1 \times d} (\mathbf{W})&lt;/em&gt;{d \times l} &amp;#x3D; 1 \times l&lt;br&gt;$$&lt;br&gt;区分：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;维度&lt;/th&gt;
&lt;th&gt;PCA&lt;/th&gt;
&lt;th&gt;LDA&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;无监督&lt;/td&gt;
&lt;td&gt;有监督&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;目标&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;最大化方差，保留主要分布信息&lt;/td&gt;
&lt;td&gt;最大化类间距离，最小化类内距离&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;是否使用类别信息&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;? 不使用&lt;/td&gt;
&lt;td&gt;? 使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;适用任务&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;数据压缩、可视化、去噪&lt;/td&gt;
&lt;td&gt;分类任务的特征提取&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;降维后维度上限&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;可任意，但一般小于原维度&lt;/td&gt;
&lt;td&gt;最多降到 $k-1$ 维（$k$ 是类别数）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;数学基础&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;协方差矩阵的特征值分解&lt;/td&gt;
&lt;td&gt;类间&amp;#x2F;类内散度矩阵的广义特征值分解&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;其他降维方法：&lt;ul&gt;
&lt;li&gt;非负矩阵分解 （non-negative matrix factorization, NMF）&lt;/li&gt;
&lt;li&gt;多维尺度法（Metric multidimensional scaling, MDS）&lt;/li&gt;
&lt;li&gt;局部线性嵌入（Locally Linear Embedding，LLE）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;特征人脸方法&#34;&gt;&lt;a href=&#34;#特征人脸方法&#34; class=&#34;headerlink&#34; title=&#34;特征人脸方法&#34;&gt;&lt;/a&gt;特征人脸方法&lt;/h1&gt;&lt;p&gt;输入时将每幅人脸图像转换成列向量&lt;br&gt;&lt;img data-src=&#34;/f1.jpg&#34;&gt;&lt;br&gt;算法描述&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入：$n$个1024维人脸样本数据所构成的矩阵$\mathbf{X}$，降维后的维数$l$&lt;/li&gt;
&lt;li&gt;输出：映射矩阵$\mathbf{W} &amp;#x3D; {\mathbf{w}_1, \mathbf{w}_2, …, \mathbf{w}_l}$（其中每个$\mathbf{w}_j (1 \leq j \leq l)$是一个特征人脸）&lt;br&gt;算法步骤&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;中心化处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对每个人脸样本数据$x_i$进行中心化处理：&lt;br&gt;$$&lt;br&gt;x_i’ &amp;#x3D; x_i - \mu, \quad \mu &amp;#x3D; \frac{1}{n}\sum_{j&amp;#x3D;1}^{n} x_j&lt;br&gt;$$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;计算协方差矩阵：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算原始人脸样本数据的协方差矩阵：&lt;br&gt;$$&lt;br&gt;\Sigma &amp;#x3D; \frac{1}{n-1} \mathbf{X}^T \mathbf{X}&lt;br&gt;$$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;特征值分解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对协方差矩阵$\Sigma$进行特征值分解，对所得特征根按从大到小排序：&lt;br&gt;$$&lt;br&gt;\lambda_1 \geq \lambda_2 \geq \cdots \geq \lambda_d&lt;br&gt;$$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;构建映射矩阵：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;取前$l$个最大特征根所对应特征向量$\mathbf{w}_1, \mathbf{w}_2, …, \mathbf{w}_l$组成映射矩阵$\mathbf{W}$。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据降维：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将每个人脸图像$x_i$按照如下方法降维：&lt;br&gt;$$&lt;br&gt;(\mathbf{x}&lt;em&gt;i)&lt;/em&gt;{1 \times d} (\mathbf{W})_{d \times l} &amp;#x3D; 1 \times l&lt;br&gt;$$&lt;br&gt;（其实用的是pca，多的一步就是输入的时候把32*32的图摊开成1024*1的列向量而已）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;潜在语义分析（Latent-Semantic-Analysis-LSA）&#34;&gt;&lt;a href=&#34;#潜在语义分析（Latent-Semantic-Analysis-LSA）&#34; class=&#34;headerlink&#34; title=&#34;潜在语义分析（Latent Semantic Analysis, LSA）&#34;&gt;&lt;/a&gt;潜在语义分析（Latent Semantic Analysis, LSA）&lt;/h1&gt;&lt;p&gt;步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;构建单词-文档矩阵：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建一个单词-文档矩阵$A$，其中每个元素$a_{ij}$表示第$i$个单词在第$j$个文档中的频率（通常使用词频-逆文档频率TF-IDF进行加权）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;奇异值分解（SVD）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对单词-文档矩阵$A$进行奇异值分解，即$A &amp;#x3D; U \Sigma V^T$，其中$U$和$V$分别是左奇异向量和右奇异向量组成的矩阵，$\Sigma$是对角矩阵，其对角线上的元素是$A$的奇异值（按降序排列）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;选择前$k$个最大奇异值及对应的奇异向量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选取前$k$个最大的奇异值及其对应的奇异向量，形成低秩逼近矩阵$A_k &amp;#x3D; U_k \Sigma_k V_k^T$。这里$k$的选择取决于保留多少原始信息量，通常根据累积能量准则或经验确定。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;重建矩阵并挖掘语义关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用$A_k$代替原始矩阵$A$，可以计算任意两个文档之间的相似度（如皮尔逊相关系数），从而发现文档-文档之间的关联关系。&lt;/li&gt;
&lt;li&gt;同样地，也可以用于探索单词-单词、单词-文档间的隐含关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;期望最大化算法（Expectation-Maximization-Algorithm-EM）&#34;&gt;&lt;a href=&#34;#期望最大化算法（Expectation-Maximization-Algorithm-EM）&#34; class=&#34;headerlink&#34; title=&#34;期望最大化算法（Expectation-Maximization Algorithm, EM）&#34;&gt;&lt;/a&gt;期望最大化算法（Expectation-Maximization Algorithm, EM）&lt;/h1&gt;&lt;p&gt;EM算法是一种迭代方法，主要用于含有隐变量的概率模型参数估计问题。它分为&amp;#x3D;&amp;#x3D;E步（求期望）&amp;#x3D;&amp;#x3D;和&amp;#x3D;&amp;#x3D;M步（最大化）&amp;#x3D;&amp;#x3D;，通过迭代方式逼近模型参数的最大似然估计值。&lt;/p&gt;
&lt;p&gt;步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;初始化模型参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先为模型参数设定初始值（例如高斯混合模型中的均值、方差等）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;E步（Expectation Step）：计算隐变量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于当前的模型参数，计算隐变量的后验概率分布。对于每一个样本$x_i$和可能的隐变量$z_i$，计算$p(z_i|x_i, \theta)$，其中$\theta$表示当前的模型参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;M步（Maximization Step）：最大化似然函数和更新模型参数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据观测数据$x_i$、隐变量$z_i$的后验概率分布，重新估计模型参数$\theta$，以最大化完整数据的对数似然函数$\log p(x,z|\theta)$的期望。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;重复E步和M步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不断重复执行E步和M步，直到模型参数收敛或者达到预定的迭代次数为止。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体的没看懂，等我懂了再说&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/06/15/computer-science/compile-principles/ch6/</guid>
            <title>活动记录</title>
            <link>http://example.com/2025/06/15/computer-science/compile-principles/ch6/</link>
            <category>活动记录</category>
            <pubDate>Sun, 15 Jun 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Activation-Record-Stack-Frame&#34;&gt;&lt;a href=&#34;#Activation-Record-Stack-Frame&#34; class=&#34;headerlink&#34; title=&#34;Activation Record&amp;#x2F;Stack Frame&#34;&gt;&lt;/a&gt;Activation Record&amp;#x2F;Stack Frame&lt;/h1&gt;&lt;p&gt;函数的栈帧是栈上用来放函数的局部变量、参数、返回地址以及其他临时变量的区域&lt;br&gt;stack一般从高地址向低地址，heap从低地址向高地址&lt;br&gt;layout:&lt;br&gt;&lt;img data-src=&#34;/f1.jpg&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;incoming arguments: 存储caller传递给callee的参数&lt;/li&gt;
&lt;li&gt;frame pointer: 帧指针，用来访问incoming arguments，从低向高是argument 1, argument 2, …&lt;/li&gt;
&lt;li&gt;local variables: 存储函数的局部变量（还有一些保存在寄存器里）&lt;/li&gt;
&lt;li&gt;return address: 存储需要返回caller的哪里；non-leaf过程会把return address写入栈帧里面&lt;/li&gt;
&lt;li&gt;temporaries: 存储临时变量，复杂表达式拆出来的中间变量放的地方&lt;/li&gt;
&lt;li&gt;saved registers&lt;/li&gt;
&lt;li&gt;outgoing arguments: 存储当前函数要传递给别的函数的参数&lt;/li&gt;
&lt;li&gt;stack pointer: 栈指针，从低向高&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;函数调用流程：&#34;&gt;&lt;a href=&#34;#函数调用流程：&#34; class=&#34;headerlink&#34; title=&#34;函数调用流程：&#34;&gt;&lt;/a&gt;函数调用流程：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;g调用f的时候&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;进入f的时候，保存旧的FP(g的FP)&lt;/li&gt;
&lt;li&gt;把FP设置为原来的SP，把SP &amp;#x3D; SP - frame size&lt;br&gt;&lt;img data-src=&#34;/f2.jpg&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;f返回的时候&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;让SP &amp;#x3D; FP(恢复g的SP)&lt;/li&gt;
&lt;li&gt;从内存中读出g的FP恢复回去&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果栈帧大小固定就只需要FP不需要SP了，因为FP &amp;#x3D; SP + frame size&lt;/p&gt;
&lt;h2 id=&#34;saved-register&#34;&gt;&lt;a href=&#34;#saved-register&#34; class=&#34;headerlink&#34; title=&#34;saved register&#34;&gt;&lt;/a&gt;saved register&lt;/h2&gt;&lt;p&gt;函数g调用f的时候，用到了寄存器r，调用f的时候要把r保存在saved register中，等调用结束再恢复回去&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;caller-saved register: 函数调用的时候用到的寄存器，调用结束后可以恢复&lt;/li&gt;
&lt;li&gt;callee-saved register: 函数调用的时候用不到的寄存器，调用结束后不能恢复&lt;br&gt;&amp;#x3D;&amp;#x3D;FP是由callee保存和恢复的&amp;#x3D;&amp;#x3D;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参数传递&#34;&gt;&lt;a href=&#34;#参数传递&#34; class=&#34;headerlink&#34; title=&#34;参数传递&#34;&gt;&lt;/a&gt;参数传递&lt;/h2&gt;&lt;p&gt;一般约定把前k(4 or 6)个参数放在寄存器传递，剩下的参数放在栈中传递&lt;br&gt;四种传参方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不给叶过程 (leaf procedure) 分配栈帧&lt;br&gt;叶过程是指不调用其他过程的过程。在这种情况下，可以不为叶过程分配栈帧&lt;/li&gt;
&lt;li&gt;过程间寄存器分配 (interprocedural register allocation)&lt;br&gt;这种方法需要先分析代码中全部的函数，然后再根据分析结果来分配寄存器。&lt;br&gt;假设有一个程序包含多个函数，通过全局分析发现某些变量在多个函数之间频繁使用，可以为其分配固定的寄存器，避免频繁的内存读写&lt;/li&gt;
&lt;li&gt;若变量 x 不再被使用，可以直接写其寄存器，不需要再保存 x 到栈帧中&lt;br&gt;当一个变量在当前作用域内不再被使用时，可以直接将其值写入寄存器，而无需保存到栈帧中&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;example&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;exampleFunction&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; x = &lt;span class=&#34;number&#34;&gt;5&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; y = x * &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;;  &lt;span class=&#34;comment&#34;&gt;// 使用x后，x不再被使用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 直接将y的值写入寄存器，无需保存x到栈帧中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;Result: %d\n&amp;quot;&lt;/span&gt;, y);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;寄存器窗口技术 (register windows)&lt;br&gt;在每次函数调用时，系统会自动切换到一组新的寄存器，称为寄存器窗口。这样，每个函数都可以独立地使用自己的寄存器，而不会影响其他函数的寄存器状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption&gt;&lt;span&gt;example&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;functionA&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 使用寄存器窗口A&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;functionB&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 使用寄存器窗口B&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    functionA();  &lt;span class=&#34;comment&#34;&gt;// 调用functionA时，自动切换到寄存器窗口A&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&#34;Frame-Resident-Variables&#34;&gt;&lt;a href=&#34;#Frame-Resident-Variables&#34; class=&#34;headerlink&#34; title=&#34;Frame-Resident Variables&#34;&gt;&lt;/a&gt;Frame-Resident Variables&lt;/h2&gt;&lt;p&gt;什么情况下要把变量写入栈帧里面？、&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;the varibles will be passed by reference 变量传地址&amp;#x2F;引用&lt;/li&gt;
&lt;li&gt;变量被嵌套在函数内部的函数访问（不绝对）&lt;/li&gt;
&lt;li&gt;变量太大了没法直接放寄存器&lt;/li&gt;
&lt;li&gt;变量是一个数组&lt;/li&gt;
&lt;li&gt;传递参数&lt;/li&gt;
&lt;li&gt;有太多局部变量和临时变量放不下了&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;escape 逃逸：如果一个变量需要传地址&amp;#x2F;取地址&amp;#x2F;被过程内部嵌套的函数访问，那么这个变量就会逃逸。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;static-links&#34;&gt;&lt;a href=&#34;#static-links&#34; class=&#34;headerlink&#34; title=&#34;static links&#34;&gt;&lt;/a&gt;static links&lt;/h2&gt;&lt;p&gt;在嵌套的函数声明中，内层函数是有可能用到外层函数的局部变量的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;static links是指向上一层嵌套层级的栈帧的指针。内层嵌套函数调用外层定义的变量的时候需要用到static links，否则无法寻址。&lt;br&gt;&lt;img data-src=&#34;/f3.jpg&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/f4.jpg&#34;&gt;&lt;br&gt;只有调用自身的时候才传递自己的static link作为static link，其他的都是把外层函数的fp作为static link&lt;br&gt;如果要访问外层变量，就顺着static一层一层查上去直到找到了为止。&lt;br&gt;其他访问方法：&lt;/li&gt;
&lt;li&gt;嵌套层次显示表(display)&lt;br&gt;建立一个全局数组，位置i包含一个指针，指向最近一次进入的，其静态嵌套深度是i的过程的栈帧&lt;br&gt;&lt;img data-src=&#34;/f5.jpg&#34;&gt;&lt;br&gt;先给它们标上嵌套深度&lt;br&gt;直接把链表变成数组了，需要用到一个变量，就查看当前变量的嵌套深度i然后直接找那个数组i位置的座位fp地址来找&lt;/li&gt;
&lt;li&gt;lambda lifting&lt;br&gt;g调用f时，g中每一个实际（或被嵌套在f内的任意函数）访问了的变量，都将作为额外的参数传递给f&lt;br&gt;把内部的函数，从内往外进行改写，改写函数的参数实现lambda lifting&lt;br&gt;&lt;img data-src=&#34;/f6.jpg&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tiger编译器的栈帧&#34;&gt;&lt;a href=&#34;#tiger编译器的栈帧&#34; class=&#34;headerlink&#34; title=&#34;tiger编译器的栈帧&#34;&gt;&lt;/a&gt;tiger编译器的栈帧&lt;/h2&gt;&lt;p&gt;tiger不支持高阶函数&lt;br&gt;看不完了。。再说吧&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/06/12/AI/week6-7/</guid>
            <title>Week6-7</title>
            <link>http://example.com/2025/06/12/AI/week6-7/</link>
            <category>人工智能</category>
            <pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Ch4-机器学习&#34;&gt;&lt;a href=&#34;#Ch4-机器学习&#34; class=&#34;headerlink&#34; title=&#34;Ch4 机器学习&#34;&gt;&lt;/a&gt;Ch4 机器学习&lt;/h1&gt;&lt;h2 id=&#34;监督学习&#34;&gt;&lt;a href=&#34;#监督学习&#34; class=&#34;headerlink&#34; title=&#34;监督学习&#34;&gt;&lt;/a&gt;监督学习&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;标注数据&lt;/li&gt;
&lt;li&gt;学习模型&lt;/li&gt;
&lt;li&gt;损失函数&lt;br&gt;典型的损失函数&lt;br&gt;&lt;img data-src=&#34;/figure2.png&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;经验风险(empirical risk )&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;训练集中数据产生的损失。&lt;/li&gt;
&lt;li&gt;经验风险越小说明学习模型对训练数据拟合程度越好。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;期望风险(expected risk):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当测试集中存在无穷多数据时产生的损失。&lt;/li&gt;
&lt;li&gt;期望风险越小，学习所得模型越好。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;经验风险最小化&lt;/p&gt;
&lt;p&gt;$$\min_{f \in \Phi} \frac{1}{n} \sum_{i&amp;#x3D;1}^{n} Loss(y_i, f(x_i))$$&lt;/p&gt;
&lt;p&gt;期望风险最小化&lt;/p&gt;
&lt;p&gt;$$\min_{f \in \Phi} \int_{x \times y} Loss(y, f(x)) P(x, y) dx dy$$&lt;/p&gt;
&lt;p&gt;模型泛化能力与经验风险、期望风险的关系&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;经验风险小（训练集上表现好）&lt;/th&gt;
&lt;th&gt;期望风险小（测试集上表现好）&lt;/th&gt;
&lt;th&gt;泛化能力强&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;经验风险小（训练集上表现好）&lt;/td&gt;
&lt;td&gt;期望风险大（测试集上表现不好）&lt;/td&gt;
&lt;td&gt;过学习（模型过于复杂）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;经验风险大（训练集上表现不好）&lt;/td&gt;
&lt;td&gt;期望风险大（测试集上表现不好）&lt;/td&gt;
&lt;td&gt;欠学习&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;经验风险大（训练集上表现不好）&lt;/td&gt;
&lt;td&gt;期望风险小（测试集上表现好）&lt;/td&gt;
&lt;td&gt;“神仙算法”或“黄粱美梦”&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;结构风险最小化 (structural risk minimization)&lt;/p&gt;
&lt;p&gt;为了防止过拟合，在经验风险上加上表示模型复杂度的正则化项 (regularizer) 或惩罚项 (penalty term):&lt;/p&gt;
&lt;p&gt;$$\min_{f \in \Phi} \frac{1}{n} \sum_{i&amp;#x3D;1}^{n} Loss(y_i, f(x_i)) + \lambda J(f)$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;经验风险: $\frac{1}{n} \sum_{i&amp;#x3D;1}^{n} Loss(y_i, f(x_i))$&lt;/li&gt;
&lt;li&gt;模型复杂度: $\lambda J(f)$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;监督学习方法又可以分为 生成方法 (generative approach) 和 判别方法(discriminative approach)。所学到的模型分别称为生成模型(generative model)和判别模型(discriminative model)&lt;br&gt;&lt;img data-src=&#34;/figure1.png&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;回归分析&#34;&gt;&lt;a href=&#34;#回归分析&#34; class=&#34;headerlink&#34; title=&#34;回归分析&#34;&gt;&lt;/a&gt;回归分析&lt;/h1&gt;&lt;h2 id=&#34;线性回归&#34;&gt;&lt;a href=&#34;#线性回归&#34; class=&#34;headerlink&#34; title=&#34;线性回归&#34;&gt;&lt;/a&gt;线性回归&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一元线性回归&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$y_i &amp;#x3D; ax_i + b \quad (1 \leq i \leq n)$$&lt;/p&gt;
&lt;p&gt;$$a &amp;#x3D; \frac{\sum_{i&amp;#x3D;1}^{n} x_i y_i - n \bar{x} \bar{y}}{\sum_{i&amp;#x3D;1}^{n} x_i^2 - n \bar{x}^2}$$&lt;/p&gt;
&lt;p&gt;$$b &amp;#x3D; \bar{y} - a \bar{x}$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;多元线性回归&lt;br&gt;$$f(x_i) &amp;#x3D; a_0 + \sum_{j&amp;#x3D;1}^{D} a_j x_{i,j} &amp;#x3D; a_0 + \mathbf{a}^T \mathbf{x}_i$$&lt;br&gt;a是要求的参数，x是输入的数据，f是预测值。&lt;br&gt;为了方便，使用矩阵来表示所有的训练数据和数据标签。&lt;br&gt;$$X &amp;#x3D; [x_1, …, x_m], \quad y &amp;#x3D; [y_1, …, y_m]$$&lt;br&gt;最小化均方误差得到：&lt;br&gt;$$a &amp;#x3D; (XX^T)^{-1}X^Ty$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;逻辑斯蒂回归&amp;#x2F;对数几率回归&lt;br&gt;线性回归一个明显的问题是对离群点导致模型建模不稳定，使结果有偏，为了缓解这个问题（特别是在二分类场景中）带来的影响，可考虑逻辑斯蒂回归&lt;br&gt;逻辑斯蒂回归就是在回归模型中引入 sigmoid函数的一种非线性回归模型&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;逻辑斯蒂回归-Logistic-Regression&#34;&gt;&lt;a href=&#34;#逻辑斯蒂回归-Logistic-Regression&#34; class=&#34;headerlink&#34; title=&#34;逻辑斯蒂回归 (Logistic Regression)&#34;&gt;&lt;/a&gt;逻辑斯蒂回归 (Logistic Regression)&lt;/h2&gt;&lt;p&gt;逻辑斯蒂回归（logistic regression）就是在回归模型中引入 sigmoid 函数的一种非线性回归模型。Logistic 回归模型可如下表示：&lt;/p&gt;
&lt;p&gt;$$ y &amp;#x3D; \frac{1}{1 + e^{-z}} &amp;#x3D; \frac{1}{1 + e^{-(w^T x + b)}} $$&lt;br&gt;其中 $y \in (0, 1)$，$z &amp;#x3D; w^T x + b$。&lt;br&gt;这里 $\frac{1}{1 + e^{-z}}$ 是 sigmoid 函数，$x \in \mathbb{R}^d$ 是输入数据，$w \in \mathbb{R}^d$ 和 $b \in \mathbb{R}$ 是回归函数的参数。&lt;/p&gt;
&lt;p&gt;逻辑斯蒂回归多用于&amp;#x3D;&amp;#x3D;二分类&amp;#x3D;&amp;#x3D;问题&lt;br&gt;Sigmoid 函数将任意实数映射到区间(0,1)，这正好符合“概率”的取值范围，所以函数的输出y可以被解释为输入数据x属于正例的概率&lt;br&gt;因此我们可以将输出 y 解释为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在给定输入特征 x 的条件下，该样本属于正类（例如类别 1）的概率。&lt;br&gt;即：&lt;br&gt;$$&lt;br&gt;y &amp;#x3D; P(y &amp;#x3D; 1 \mid x)&lt;br&gt;$$&lt;br&gt;如果 $P(y&amp;#x3D;1|x)$ 表示给定输入 $x$ 属于正类的概率，则 $1 - P(y&amp;#x3D;1|x)$ 表示属于负类的概率。&lt;br&gt;$\frac{P(y&amp;#x3D;1|x)}{1 - P(y&amp;#x3D;1|x)}$ 就是正类相对于负类的优势比。所以&amp;gt;1就归为正类，反之就是负类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;$$&lt;br&gt;\log \frac{P(y&amp;#x3D;1|x)}{P(y&amp;#x3D;0|x)} &amp;#x3D; {w^T x + b} &amp;gt; \log{1} &amp;#x3D; 0&lt;br&gt;$$&lt;br&gt;从这里可以看出，logistic回归本质上是一个线性模型。在预测时，可以计算线性函数$w^T x + b$取值是否大于0来判断输入数据x的类别归属&lt;/p&gt;
&lt;p&gt;为了找到最优参数w和b，我们使用最大似然估计，假设每个样本独立同分布，则&lt;br&gt;……&lt;br&gt;公式懒得敲了，&lt;/p&gt;
&lt;p&gt;为什么基于相关性的方法可能会导致模型的不可解释性和不稳定性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因果特征和非因果特征&lt;/li&gt;
&lt;li&gt;Making V⊥Y: 最终目标是让非因果特征 V 与输出 Y 独立，即消除虚假相关性，使得模型更加稳定和可解释&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;决策树&#34;&gt;&lt;a href=&#34;#决策树&#34; class=&#34;headerlink&#34; title=&#34;决策树&#34;&gt;&lt;/a&gt;决策树&lt;/h1&gt;&lt;p&gt;决策树是一种通过树形结构来进行分类的方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信息熵（entropy）是度量样本集合纯度最常用的一种指标&lt;br&gt;假设有一个K个信息（类别），其组成了集合样本D，记第k个信息（类别）发生的概率为$p_k (1 \leq k \leq K)$。如下定义这K个信息的信息熵：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$Ent(D) &amp;#x3D; -\sum_{k&amp;#x3D;1}^{K} p_k \log_2 p_k$$&lt;/p&gt;
&lt;p&gt;&amp;#x3D;&amp;#x3D;$Ent(D)$值越小，表示D包含的信息越确定，也称D的纯度越高。&amp;#x3D;&amp;#x3D;所有$p_k$累加起来的和为1。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信息增益:衡量使用某个属性进行划分后，数据集不确定性减少的程度&lt;br&gt;得到信息熵后可以进一步计算信息增益：&lt;br&gt;$$Gain(D, A) &amp;#x3D; Ent(D) - \sum_{i&amp;#x3D;1}^{n} \frac{|D_i|}{|D|} Ent(D_i)$$&lt;br&gt;&lt;img data-src=&#34;/f3.png&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/f4.png&#34;&gt;&lt;br&gt;ID3决策树学习算法[Quinlan, 1986]以信息增益为准则来选择划分属性&lt;br&gt;目标：通过不断划分，使得每个子集尽可能“纯净”，即子集内的样本属于同一类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;信息熵（和上面的一样的）&lt;br&gt;$$&lt;br&gt;info &amp;#x3D; -\sum_{i&amp;#x3D;1}^{n} \frac{|D_i|}{|D|} \log_2 \frac{|D_i|}{|D|}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;增益率（Gain-ratio）：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;Gain-ratio &amp;#x3D; \frac{Gain(D, A)}{info}&lt;br&gt;$$&lt;br&gt;存在的问题：增益率准则对可取数目较少的属性有所偏好&lt;/p&gt;
&lt;p&gt;另一种计算更简的度量指标是如下的 Gini 指数（基尼指数）：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;Gini(D) &amp;#x3D; 1 - \sum_{k&amp;#x3D;1}^{K} p_k^2&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;相对于信息熵的计算 $E(D) &amp;#x3D; -\sum_{k&amp;#x3D;1}^{K} p_k \log_2 p_k$，不用计算对数 log，计算更为简易。&lt;/p&gt;
&lt;h2 id=&#34;连续属性离散化&#34;&gt;&lt;a href=&#34;#连续属性离散化&#34; class=&#34;headerlink&#34; title=&#34;连续属性离散化&#34;&gt;&lt;/a&gt;连续属性离散化&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;确定连续属性的取值范围，确定划分点集合&lt;br&gt;考虑包含 n-1 个元素的候选划分点集合：&lt;br&gt;$$&lt;br&gt;T_a &amp;#x3D; \left{ \frac{a^i + a^{i+1}}{2} ,\middle|, 1 \leq i \leq n - 1 \right}&lt;br&gt;$$&lt;br&gt;这里的每个候选划分点是相邻两个取值的中点，即区间 $[a^i, a^{i+1})$ 的中位点 $\frac{a^i + a^{i+1}}{2}$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;计算信息增益&lt;br&gt;$$&lt;br&gt;\text{Gain}(D, a, t) &amp;#x3D; \text{Ent}(D) - \sum_{\lambda \in {-, +}} \frac{|D_t^\lambda|}{|D|} \cdot \text{Ent}(D_t^\lambda)&lt;br&gt;$$&lt;br&gt;计算每个划分点的信息增益率，选择信息增益最大的划分点&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;+++info example&lt;br&gt;;;;id3 example&lt;br&gt;给定数据点及其对应的类别标签如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$a_1 &amp;#x3D; 1$ -&amp;gt; 类别为 0&lt;/li&gt;
&lt;li&gt;$a_2 &amp;#x3D; 3$ -&amp;gt; 类别为 1&lt;/li&gt;
&lt;li&gt;$a_3 &amp;#x3D; 5$ -&amp;gt; 类别为 0&lt;/li&gt;
&lt;li&gt;$a_4 &amp;#x3D; 7$ -&amp;gt; 类别为 1&lt;/li&gt;
&lt;li&gt;$a_5 &amp;#x3D; 9$ -&amp;gt; 类别为 0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，我们的数据集 $D$ 是 ${1, 3, 5, 7, 9}$，对应的类别标签分别为 ${0, 1, 0, 1, 0}$。&lt;/p&gt;
&lt;p&gt;第一步：计算原始数据集的信息熵&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;Ent(D) &amp;#x3D; -\left( p_0 \log_2 p_0 + p_1 \log_2 p_1 \right)&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;其中，$p_0 &amp;#x3D; \frac{3}{5}$，$p_1 &amp;#x3D; \frac{2}{5}$，则：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;Ent(D) &amp;#x3D; -\left( \frac{3}{5} \log_2 \frac{3}{5} + \frac{2}{5} \log_2 \frac{2}{5} \right) \approx 0.971&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;第二步：确定候选划分点集合&lt;/p&gt;
&lt;p&gt;根据公式 $T_a &amp;#x3D; \left{ \frac{a^i + a^{i+1}}{2} ,\middle|, 1 \leq i \leq n - 1 \right}$，我们得到候选划分点集合：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;T_a &amp;#x3D; {2, 4, 6, 8}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;第三步：计算每个候选划分点的信息增益&lt;/p&gt;
&lt;p&gt;以划分点 $t &amp;#x3D; 4$ 为例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$D_t^{-} &amp;#x3D; {1, 3}$，类别为 ${0, 1}$&lt;/li&gt;
&lt;li&gt;$D_t^{+} &amp;#x3D; {5, 7, 9}$，类别为 ${0, 1, 0}$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;计算这两个子集的熵：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$$Ent(D_t^{-}) &amp;#x3D; -\left( \frac{1}{2} \log_2 \frac{1}{2} + \frac{1}{2} \log_2 \frac{1}{2} \right) &amp;#x3D; 1$$&lt;/li&gt;
&lt;li&gt;$$Ent(D_t^{+}) &amp;#x3D; -\left( \frac{2}{3} \log_2 \frac{2}{3} + \frac{1}{3} \log_2 \frac{1}{3} \right) \approx 0.918$$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;计算信息增益：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;Gain(D, a, t&amp;#x3D;4) &amp;#x3D; Ent(D) - \left( \frac{|D_t^{-}|}{|D|} \cdot Ent(D_t^{-}) + \frac{|D_t^{+}|}{|D|} \cdot Ent(D_t^{+}) \right)&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;代入数值：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;Gain(D, a, t&amp;#x3D;4) &amp;#x3D; 0.971 - \left( \frac{2}{5} \cdot 1 + \frac{3}{5} \cdot 0.918 \right) \approx 0.029&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;重复上述过程，对所有划分点 $t &amp;#x3D; 2, 4, 6, 8$ 进行类似计算，并选择使 $Gain(D, a, t)$ 最大的那个作为最优划分点。&lt;br&gt;;;;&lt;br&gt;+++&lt;/p&gt;
&lt;h1 id=&#34;线性区别分析-LDA-FDA&#34;&gt;&lt;a href=&#34;#线性区别分析-LDA-FDA&#34; class=&#34;headerlink&#34; title=&#34;线性区别分析 (LDA&amp;#x2F;FDA)&#34;&gt;&lt;/a&gt;线性区别分析 (LDA&amp;#x2F;FDA)&lt;/h1&gt;&lt;p&gt;线性判别分析(linear discriminant analysis， LDA)是一种基于监督学习的降维方法，也称为Fisher线性判别分析(fisher’s discriminant analysis，FDA),对于一组具有标签信息的高维数据样本，LDA利用其类别信息，将其线性投影到一个低维空间上，在低维空间中同一类别样本尽可能靠近，不同类别样本尽可能彼此远离。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算数据样本集中每个类别样本的均值&lt;/li&gt;
&lt;li&gt;计算类内散度矩阵$S_w$和类间散度矩阵$S_b$&lt;/li&gt;
&lt;li&gt;根据$S_w^{-1}S_bW&amp;#x3D;\lambda W$来求解$S_w^{-1}S_b$所对应前$r$个最大特征值所对应特征向量$(w_1,w_2,…,w_r)$，构成矩阵W&lt;/li&gt;
&lt;li&gt;通过矩阵$W$将每个样本映射到低维空间，实现特征降维。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体不想看，考到就给了&lt;/p&gt;
&lt;h1 id=&#34;Ada-Boosting&#34;&gt;&lt;a href=&#34;#Ada-Boosting&#34; class=&#34;headerlink&#34; title=&#34;Ada Boosting&#34;&gt;&lt;/a&gt;Ada Boosting&lt;/h1&gt;&lt;p&gt;。。看不懂懒得看&lt;/p&gt;
&lt;h1 id=&#34;支持向量机&#34;&gt;&lt;a href=&#34;#支持向量机&#34; class=&#34;headerlink&#34; title=&#34;支持向量机&#34;&gt;&lt;/a&gt;支持向量机&lt;/h1&gt;&lt;h1 id=&#34;生成学习模型&#34;&gt;&lt;a href=&#34;#生成学习模型&#34; class=&#34;headerlink&#34; title=&#34;生成学习模型&#34;&gt;&lt;/a&gt;生成学习模型&lt;/h1&gt; ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/06/11/AI/week4-5/</guid>
            <title>Week4-5</title>
            <link>http://example.com/2025/06/11/AI/week4-5/</link>
            <category>人工智能</category>
            <pubDate>Wed, 11 Jun 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;#Ch3 搜索算法&lt;/p&gt;
&lt;h2 id=&#34;无信息搜索&#34;&gt;&lt;a href=&#34;#无信息搜索&#34; class=&#34;headerlink&#34; title=&#34;无信息搜索&#34;&gt;&lt;/a&gt;无信息搜索&lt;/h2&gt;&lt;p&gt;BFS DFS 略&lt;/p&gt;
&lt;h2 id=&#34;启发式搜索&#34;&gt;&lt;a href=&#34;#启发式搜索&#34; class=&#34;headerlink&#34; title=&#34;启发式搜索&#34;&gt;&lt;/a&gt;启发式搜索&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;贪婪优先搜索&lt;ul&gt;
&lt;li&gt;每次取最短的；缺点：不一定是最优的&lt;/li&gt;
&lt;li&gt;时间和空间复杂度均为 $O(b_m)$，b是搜索树分支因子，m是最大深度&lt;br&gt;&lt;img data-src=&#34;/figure1.png&#34;&gt;&lt;br&gt;:::info&lt;br&gt;每次取当前节点的下一个节点到终点中直线距离最短的&lt;br&gt;:::&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A*算法&lt;ul&gt;
&lt;li&gt;评价函数：f(n) &amp;#x3D; g(n) + h(n)&lt;/li&gt;
&lt;li&gt;代价函数 g(n) 表示从起始结点到结点n的开销代价值&lt;/li&gt;
&lt;li&gt;启发函数 h(n) 表示从结点n到目标结点路径中所估算的最小开销代价值。&lt;/li&gt;
&lt;li&gt;评价函数 f(n) 可视为经过结点n、具有最小开销代价值的路径。&lt;ul&gt;
&lt;li&gt;在最短路径问题中，g(?)为当前选择的路径的实际距离，即从上一个节点到下一个节点的实际距离，?(?)为下一个节点到目标城市的直线距离。每一次搜索，下一个节点选择与此刻城市连接的所有节点中，g(?)+?(?)最小的城市节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;:::info&lt;br&gt;取（当前节点到下一节点的距离+下一节点到目标城市的距离）最短的&lt;br&gt;:::&lt;br&gt;A*算法的完备性和最优性取决于搜索问题和启发函数的性质&lt;br&gt;一个良好的启发函数需要满足:可容性（admissible）;一致性（consistency）&lt;br&gt;如果启发函数是可容的，那么树搜索的A*算法满足最优性(最优性:搜索算法是否能保证找到的第一个解是最优解)&lt;br&gt;满足一致性条件的启发函数一定满足可容性条件，反之不一定&lt;/p&gt;
&lt;h2 id=&#34;对抗搜索&#34;&gt;&lt;a href=&#34;#对抗搜索&#34; class=&#34;headerlink&#34; title=&#34;对抗搜索&#34;&gt;&lt;/a&gt;对抗搜索&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;最小最大搜索（minimax）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最小最大搜索是一个在你和对手轮流行动的情况下，为你自己寻找最优策略的算法。&lt;/li&gt;
&lt;li&gt;算法：略&lt;/li&gt;
&lt;li&gt;时间复杂度：$O(b^m)$&lt;/li&gt;
&lt;li&gt;空间复杂度：$O(bm)$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\alpha-\beta剪枝&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Minimax 会穷举整个博弈树，但我们可以用剪枝技巧跳过一些无用分支，让它跑得更快&lt;/li&gt;
&lt;li&gt;max层的下界取下一层（上界）里面最大的；min层的上界取下一层（下界）里面最小的&lt;br&gt;懒得写直接看例子：&lt;br&gt;&lt;img data-src=&#34;/figure2.png&#34;&gt;&lt;br&gt; Alpha-Beta 剪枝算法什么时候扩展的结点数量最少？&lt;/li&gt;
&lt;li&gt;每一层最左端结点的所有孩子结点均被访问，其他节点仅有最左端孩子结点被访问、其他孩子结点被剪枝。&lt;br&gt; 如果一个节点导致了其兄弟节点被剪枝，可知其孩子节点必然被扩展。&lt;/li&gt;
&lt;li&gt;最优效率下时间复杂度：$O(b^{m&amp;#x2F;2})$  (或者m+1);最差的就是完全没剪枝和minimax一样&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;蒙特卡洛树搜索&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择(UCB)、扩展、模拟(随机)、反向传播&lt;/li&gt;
&lt;li&gt;悔值函数&lt;br&gt;:::info&lt;br&gt;没完全懂，后面再回来研究&lt;br&gt;:::&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/05/20/AI/week1/</guid>
            <title>Week1</title>
            <link>http://example.com/2025/05/20/AI/week1/</link>
            <category>人工智能</category>
            <pubDate>Tue, 20 May 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;blockquote&gt;
&lt;p&gt;2025-2026春夏人工智能课程笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;Ch1-绪论&#34;&gt;&lt;a href=&#34;#Ch1-绪论&#34; class=&#34;headerlink&#34; title=&#34;Ch1 绪论&#34;&gt;&lt;/a&gt;Ch1 绪论&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;人工智能求解：&lt;ul&gt;
&lt;li&gt;以符号主义为核心的逻辑推理：将概念（如命题等）符号化，从若干判断（前提）出发得到新判断（结论）&lt;/li&gt;
&lt;li&gt;以问题求解为核心的探寻搜索:探寻搜索依据已有信息来寻找满足约束条件的待求解问题的答案&lt;/li&gt;
&lt;li&gt;以数据驱动为核心的机器学习:从数据中发现数据所承载语义（如概念）的内在模式&lt;/li&gt;
&lt;li&gt;以行为主义为核心的强化学习:根据环境所提供的奖罚反馈来学习所处状态可施加的最佳行动，在“探索（未知空间）-利用（已有经验）（exploration vs. exploitation）”之间寻找平衡，完成某个序列化任务，具备自我学习能力&lt;/li&gt;
&lt;li&gt;以博弈对抗为核心的群体智能:从“数据拟合”优化解的求取向“均衡解”的求取迈进&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/05/20/AI/week2-3/</guid>
            <title>Week2-3</title>
            <link>http://example.com/2025/05/20/AI/week2-3/</link>
            <category>人工智能</category>
            <pubDate>Tue, 20 May 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Ch2-知识表达与推理&#34;&gt;&lt;a href=&#34;#Ch2-知识表达与推理&#34; class=&#34;headerlink&#34; title=&#34;Ch2 知识表达与推理&#34;&gt;&lt;/a&gt;Ch2 知识表达与推理&lt;/h1&gt;&lt;h2 id=&#34;命题逻辑&#34;&gt;&lt;a href=&#34;#命题逻辑&#34; class=&#34;headerlink&#34; title=&#34;命题逻辑&#34;&gt;&lt;/a&gt;命题逻辑&lt;/h2&gt;&lt;p&gt;&lt;img data-src=&#34;/img1.png&#34;&gt;&lt;br&gt;真值表：&lt;br&gt;&lt;img data-src=&#34;/img2.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“条件”命题联结词中前提为假时命题结论永远为真，bi-conditional只有两个都是true或者都是false才是true&lt;br&gt;逻辑等价：给定命题p和命题q，如果&amp;#x3D;&amp;#x3D;p和q在所有情况下都具有同样真假结果&amp;#x3D;&amp;#x3D;，那么p和q在逻辑上等价，一般用 $\equiv$ 来表示，即p $\equiv$ q。&lt;br&gt;判断逻辑等价：画真值表&lt;br&gt;逻辑等价式：&lt;br&gt;&lt;img data-src=&#34;/img3.jpg&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/img4.png&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;normal form&lt;ul&gt;
&lt;li&gt;有限个简单合取式构成的析取式称为析取(or)范式&lt;/li&gt;
&lt;li&gt;由有限个简单析取式构成的合取式称为合取(and)范式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;谓词逻辑&#34;&gt;&lt;a href=&#34;#谓词逻辑&#34; class=&#34;headerlink&#34; title=&#34;谓词逻辑&#34;&gt;&lt;/a&gt;谓词逻辑&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;全称量词与存在量词&lt;/li&gt;
&lt;li&gt;约束变元、自由变元&lt;br&gt;:::info&lt;br&gt;在约束变元相同的情况下，量词的运算满足分配律：全称量词对析取没有分配律、存在量词对合取没有分配律&lt;br&gt;:::&lt;br&gt;$$\begin{aligned}&lt;br&gt;(\forall x)(A(x) \lor B(x)) \equiv (\forall x)A(x) \lor (\forall x)B(x) 不成立&lt;br&gt;\end{aligned}$$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$\begin{aligned}&lt;br&gt;(\forall x)(A(x) \land B(x)) \equiv (\forall x)A(x) \land (\forall x)B(x) 成立&lt;br&gt;\end{aligned}$$&lt;/p&gt;
&lt;p&gt;$$\begin{aligned}&lt;br&gt;(\exists x)(A(x) \lor B(x)) \equiv (\exists x)A(x) \lor (\exists x)B(x) 成立&lt;br&gt;\end{aligned}$$&lt;/p&gt;
&lt;p&gt;$$\begin{aligned}&lt;br&gt;(\exists x)(A(x) \land B(x)) \equiv (\exists x)A(x) \land (\exists x)B(x) 不成立&lt;br&gt;\end{aligned}$$&lt;br&gt;:::info&lt;br&gt;当公式中存在多个量词时，若多个量词都是全称量词或者都是存在量词，则量词的位置可以互换；若多个量词中既有全称量词又有存在量词，则量词的位置不可以随意互换&lt;br&gt;:::&lt;br&gt;$$\begin{aligned}&lt;br&gt;(\forall x)(\forall y)A(x, y) \equiv (\forall y)(\forall x)A(x, y)&lt;br&gt;\end{aligned}$$&lt;/p&gt;
&lt;p&gt;$$\begin{aligned}&lt;br&gt;(\exists x)(\exists y)A(x, y) \equiv (\exists y)(\exists x)A(x, y)&lt;br&gt;\end{aligned}$$&lt;/p&gt;
&lt;p&gt;$$\begin{aligned}&lt;br&gt;(\forall x)(\forall y)A(x, y) \equiv (\exists y)(\forall x)A(x, y)&lt;br&gt;\end{aligned}$$&lt;/p&gt;
&lt;p&gt;$$\begin{aligned}&lt;br&gt;(\forall x)(\forall y)A(x, y) \equiv (\exists x)(\forall y)A(x, y)&lt;br&gt;\end{aligned}$$&lt;/p&gt;
&lt;p&gt;$$\begin{aligned}&lt;br&gt;(\exists y)(\forall x)A(x, y) \equiv (\forall x)(\exists y)A(x, y)&lt;br&gt;\end{aligned}$$&lt;/p&gt;
&lt;p&gt;$$\begin{aligned}&lt;br&gt;(\exists x)(\forall y)A(x, y) \equiv (\forall y)(\exists x)A(x, y)&lt;br&gt;\end{aligned}$$&lt;/p&gt;
&lt;p&gt;$$\begin{aligned}&lt;br&gt;(\forall x)(\exists y)A(x, y) \equiv (\exists y)(\exists x)A(x, y)&lt;br&gt;\end{aligned}$$&lt;/p&gt;
&lt;p&gt;$$\begin{aligned}&lt;br&gt;(\forall y)(\exists x)A(x, y) \equiv (\exists x)(\exists y)A(x, y)&lt;br&gt;\end{aligned}$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用谓词逻辑进行推理&lt;ul&gt;
&lt;li&gt;全称量词消去： $(\forall x) A(x) \equiv A(y)$&lt;/li&gt;
&lt;li&gt;全称量词引入： $A(y) \equiv (\forall x) A(x)$&lt;/li&gt;
&lt;li&gt;存在量词消去： $(\exists x) A(x) \equiv A(c)$&lt;/li&gt;
&lt;li&gt;存在量词引入： $A(c) \equiv (\exists x) A(x)$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;知识图谱推理&#34;&gt;&lt;a href=&#34;#知识图谱推理&#34; class=&#34;headerlink&#34; title=&#34;知识图谱推理&#34;&gt;&lt;/a&gt;知识图谱推理&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;知识图谱可视为包含多种关系的图。在图中，每个节点是一个实体（如人名、地名、事件和活动等），任意两个节点之间的边表示这两个节点之间存在的关系。&lt;/li&gt;
&lt;li&gt;可将知识图谱中任意两个相连节点及其连接边表示成一个三元组（triplet）,即 (left_node, relation, right_node)&lt;br&gt;两类代表性方法：&lt;/li&gt;
&lt;li&gt;归纳逻辑程序设计 (inductive logic programming，ILP)算法&lt;/li&gt;
&lt;li&gt;路径排序算法（path ranking algorithm, PRA）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ILP: 一阶归纳学习FOIL（First Order Inductive Learner）&lt;br&gt;推理手段: 正例集合 + 反例集合 + 背景知识样例 ⟹ 目标谓词作为结论的推理规则&lt;br&gt;&lt;img data-src=&#34;/img5.png&#34;&gt;&lt;br&gt;懒得写了，看ppt吧&lt;br&gt;&lt;img data-src=&#34;/img6.png&#34;&gt;&lt;br&gt;推理规则覆盖所有正例且不覆盖任何反例的时候算法结束&lt;/p&gt;
&lt;p&gt;PRA: 路径排序算法&lt;br&gt;&lt;img data-src=&#34;/img7.png&#34;&gt;&lt;br&gt;(4)的意思是看两个实体能不能通过(3)的关系从第一个走到第二个。&lt;br&gt;后面的1表示正例，-1表示负例。&lt;/p&gt;
&lt;h2 id=&#34;概率图推理&#34;&gt;&lt;a href=&#34;#概率图推理&#34; class=&#34;headerlink&#34; title=&#34;概率图推理&#34;&gt;&lt;/a&gt;概率图推理&lt;/h2&gt;&lt;p&gt;贝叶斯网络&lt;br&gt;&lt;img data-src=&#34;/img14.png&#34;&gt;&lt;br&gt;要会算&lt;/p&gt;
&lt;p&gt;马尔科夫逻辑网络&lt;/p&gt;
&lt;h2 id=&#34;因果推理&#34;&gt;&lt;a href=&#34;#因果推理&#34; class=&#34;headerlink&#34; title=&#34;因果推理&#34;&gt;&lt;/a&gt;因果推理&lt;/h2&gt;&lt;p&gt;因果定义：变量X是变量Y的原因，当且仅当保持其它所有变量不变的情况下，改变X的值能导致Y的值发生变化。&lt;br&gt;因果效应：因变量X改变一个单位时，果变量Y的变化程度&lt;/p&gt;
&lt;p&gt;因果图是有向无环图&lt;/p&gt;
&lt;p&gt;结构因果模型：结构因果模型由两组变量集合U和V以及一组函数f组成。其中，f是根据模型中其他变量取值而给V中每一个变量赋值的函数&lt;br&gt;结构因果模型中的原因：如果变量X出现在给变量X赋值的函数中，如$Y &amp;#x3D; f(X) + \epsilon$，则X是Y的直接原因&lt;br&gt;因果图中的联合概率分布：直接看图&lt;br&gt;&lt;img data-src=&#34;/img8.png&#34;&gt;&lt;br&gt;因果图的基本结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链结构&lt;br&gt;  - &lt;img data-src=&#34;/img9.png&#34;&gt;&lt;br&gt;  - 对于变量X和Y，若X和Y之间只有一条单向的路径，变量Z是截断(intercept)该路径的集合中的任一变量，则在给定Z时，X和Y条件独立。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$&lt;br&gt;P(X, Y | Z) &amp;#x3D; P(X | Z)P(Y | Z)&lt;br&gt;$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分连结构&lt;br&gt;  - &lt;img data-src=&#34;/img10.png&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$&lt;br&gt;P(X, Y | Z) &amp;#x3D; \frac {P(X, Y, Z)}{P(Z)} &amp;#x3D; \frac {P(X | Z)P(Y | Z)P(Z)}{P(Z)} &amp;#x3D; P(X | Z)P(Y | Z)&lt;br&gt;$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;汇联结构&lt;br&gt;  - &lt;img data-src=&#34;/img11.jpg&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$&lt;br&gt;P(X, Y | Z) &amp;#x3D; \frac{P(X, Y, Z)} {P(Z)} &amp;#x3D; \frac {P(X, Y, Z)}{P(Z)} &amp;#x3D; \frac {P(X)P(Y)P(Z&amp;#x2F;X, Y)}{P(Z)} \neq P(X | Z)P(Y | Z)&lt;br&gt;$$&lt;/p&gt;
&lt;h3 id=&#34;D-分离-directional-separation-d-separation-，可用于判断任意两个节点的相关性和独立性&#34;&gt;&lt;a href=&#34;#D-分离-directional-separation-d-separation-，可用于判断任意两个节点的相关性和独立性&#34; class=&#34;headerlink&#34; title=&#34;D-分离(directional separation, d-separation)，可用于判断任意两个节点的相关性和独立性&#34;&gt;&lt;/a&gt;D-分离(directional separation, d-separation)，可用于判断任意两个节点的相关性和独立性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;限定集：已知或观察到的变量集合（给定的变量集合）&lt;/li&gt;
&lt;li&gt;路径p被限定集Z阻塞(block)当且仅当：&lt;ul&gt;
&lt;li&gt;(1) 路径p含有链结构A → B → C或分连结构A ← B → C且中间节点B在Z中，或&lt;/li&gt;
&lt;li&gt;(2) 路径p含有汇连结构A → B ← C且汇连节点B及其后代都不在Z中。&lt;/li&gt;
&lt;li&gt;若Z阻塞了节点X和节点Y之间的每一条路径，则称给定Z时，X和Y是D-分离，即给定Z时，X和Y条件独立&lt;/li&gt;
&lt;li&gt;&amp;#x3D;&amp;#x3D;链式、分连中间节点在，汇联中间节点和后代不在则D-分离&amp;#x3D;&amp;#x3D;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因果定义：变量X是变量Y的原因，当且仅当保持其它所有变量不变的情况下，改变X的值能导致Y的值发生变化。&lt;br&gt;因果效应：因变量X改变一个单位时，果变量Y的变化程度因果推理的两个关键因素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;改变因变量T&lt;/li&gt;
&lt;li&gt;保证其它变量不变&lt;br&gt;干预：干预(intervention)指的是固定(fix)系统中的变量，然后改变系统，观察其他变量的变化。&lt;br&gt;为了与X自然取值x时进行区分，在对X进行干预时，引入“do算子”(do-calculus)，记作do(X &amp;#x3D; x)。&lt;br&gt;因此，P(Y &amp;#x3D; y|X &amp;#x3D; x)表示的是当发现X &amp;#x3D; x时，Y&amp;#x3D; y的概率；而P(Y &amp;#x3D; y|do(X &amp;#x3D;x))表示的是对X进行干预，固定其值为x时，Y &amp;#x3D; y的概率。&lt;br&gt;用统计学的术语来说，P(Y &amp;#x3D; y|X &amp;#x3D; x)反映的是在取值为x的个体X上，Y的总体分布；而P(Y &amp;#x3D; y|do(X &amp;#x3D;x))反映的是如果将每一个X取值都固定为x时，Y的总体分布。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因果效应差&amp;#x2F;平均因果效应 (ACE)  懒得写了看图吧&lt;br&gt;&lt;img data-src=&#34;/img12.png&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/img13.png&#34;&gt;&lt;br&gt;计算因果效应的关键在于计算操纵概率(manipulatedprobability) $P_m$&lt;br&gt;调整公式：&lt;br&gt;$$&lt;br&gt;P(Y &amp;#x3D; y \mid do(X &amp;#x3D; x)) &amp;#x3D; \sum_z P(Y &amp;#x3D; y \mid X &amp;#x3D; x, Z &amp;#x3D; z) \cdot P(Z &amp;#x3D; z)&lt;br&gt;$$&lt;br&gt;对于Z的每一个取值z，计算X和Y的条件概率并取均值&lt;br&gt;+++info example&lt;br&gt;;;;id3 例题&lt;br&gt;假设我们研究以下变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;X：是否服药  &lt;ul&gt;
&lt;li&gt;$X &amp;#x3D; 1$：服药  &lt;/li&gt;
&lt;li&gt;$X &amp;#x3D; 0$：不服药&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Y：是否康复  &lt;ul&gt;
&lt;li&gt;$Y &amp;#x3D; 1$：康复  &lt;/li&gt;
&lt;li&gt;$Y &amp;#x3D; 0$：未康复&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Z：性别  &lt;ul&gt;
&lt;li&gt;$Z &amp;#x3D; 0$：男  &lt;/li&gt;
&lt;li&gt;$Z &amp;#x3D; 1$：女&lt;br&gt;我们知道性别会影响：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;是否选择服药（比如男性更倾向于尝试新药）&lt;/li&gt;
&lt;li&gt;康复率（比如女性可能有更强的免疫力）&lt;br&gt;因此，性别 Z 是一个混杂变量，需要在分析中进行控制。&lt;br&gt;已知：&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Z（性别）&lt;/th&gt;
&lt;th&gt;P(Z)&lt;/th&gt;
&lt;th&gt;P(Y&amp;#x3D;1 | X&amp;#x3D;1, Z)&lt;/th&gt;
&lt;th&gt;P(Y&amp;#x3D;1 | X&amp;#x3D;0, Z)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;男（0）&lt;/td&gt;
&lt;td&gt;0.6&lt;/td&gt;
&lt;td&gt;0.7&lt;/td&gt;
&lt;td&gt;0.4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;女（1）&lt;/td&gt;
&lt;td&gt;0.4&lt;/td&gt;
&lt;td&gt;0.5&lt;/td&gt;
&lt;td&gt;0.3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;我们想知道：&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;如果强制所有人都服药（即 $do(X&amp;#x3D;1)$），整体康复率是多少？&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;也就是要计算：&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P(Y&amp;#x3D;1 \mid do(X&amp;#x3D;1))&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;;;;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;;;;id3 答案&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;根据调整公式：&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$&lt;br&gt;P(Y&amp;#x3D;1 \mid do(X&amp;#x3D;1)) &amp;#x3D; \sum_z P(Y&amp;#x3D;1 \mid X&amp;#x3D;1, Z&amp;#x3D;z) \cdot P(Z&amp;#x3D;z)&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;代入数据计算&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;P(Y&amp;#x3D;1 \mid do(X&amp;#x3D;1)) &amp;#x3D; P(Y&amp;#x3D;1 \mid X&amp;#x3D;1, Z&amp;#x3D;0) \cdot P(Z&amp;#x3D;0) + P(Y&amp;#x3D;1 \mid X&amp;#x3D;1, Z&amp;#x3D;1) \cdot P(Z&amp;#x3D;1)&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;&amp;#x3D; 0.7 \times 0.6 + 0.5 \times 0.4 &amp;#x3D; 0.42 + 0.2 &amp;#x3D; 0.62&lt;br&gt;$$&lt;br&gt;+++&lt;/p&gt;
&lt;p&gt;(因果效应)给定因果图G，PA表示X的父节点集合，则X对Y的因果效应为&lt;br&gt;$$&lt;br&gt;P(Y&amp;#x3D;y \mid do(X&amp;#x3D;x)) &amp;#x3D; \sum_z P(Y&amp;#x3D;y \mid X&amp;#x3D;x, PA&amp;#x3D;z) \cdot P(PA&amp;#x3D;z)&lt;br&gt;$$&lt;br&gt;后门调整：&lt;br&gt;不写了&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/05/14/computer-science/computer-organization/ch2/</guid>
            <title>Ch2</title>
            <link>http://example.com/2025/05/14/computer-science/computer-organization/ch2/</link>
            <category>数据的表示与运算</category>
            <pubDate>Wed, 14 May 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Ch2-数据的表示和运算&#34;&gt;&lt;a href=&#34;#Ch2-数据的表示和运算&#34; class=&#34;headerlink&#34; title=&#34;Ch2 数据的表示和运算&#34;&gt;&lt;/a&gt;Ch2 数据的表示和运算&lt;/h1&gt;&lt;h2 id=&#34;2-1-进位计数制及其相互转换&#34;&gt;&lt;a href=&#34;#2-1-进位计数制及其相互转换&#34; class=&#34;headerlink&#34; title=&#34;2.1 进位计数制及其相互转换&#34;&gt;&lt;/a&gt;2.1 进位计数制及其相互转换&lt;/h2&gt;&lt;h3 id=&#34;2-1-1&#34;&gt;&lt;a href=&#34;#2-1-1&#34; class=&#34;headerlink&#34; title=&#34;2.1.1&#34;&gt;&lt;/a&gt;2.1.1&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;十进制二进制八进制十六进制转换&lt;ul&gt;
&lt;li&gt;略&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-1-2-定点数的编码表示&#34;&gt;&lt;a href=&#34;#2-1-2-定点数的编码表示&#34; class=&#34;headerlink&#34; title=&#34;2.1.2 定点数的编码表示&#34;&gt;&lt;/a&gt;2.1.2 定点数的编码表示&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;定点数一般表示定点小数和定点整数，小数是符号位.xxx，整数是符号位xxxx.0&lt;/li&gt;
&lt;li&gt;&lt;blockquote&gt;
&lt;p&gt;感觉不是什么重要的东西，浮点数表示比较重要&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;原码，反码，补码&lt;ul&gt;
&lt;li&gt;正数的原码反码补码相同&lt;/li&gt;
&lt;li&gt;原码表示的范围为 $-2^n+1 ~ 2^n-1$&lt;/li&gt;
&lt;li&gt;补码表示的范围为 $-2^n ~ 2^n-1$&lt;/li&gt;
&lt;li&gt;负数的原码是1+绝对值，反码是1+绝对值取反，补码是反码+1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;移码：用来表示浮点数的阶码，只能表示整数&lt;ul&gt;
&lt;li&gt;一般用移码表示浮点数的阶码，用补码表示定点整数&lt;br&gt;$$ [x]_移 &amp;#x3D; 2^n + x $$&lt;br&gt;移码就是在真值x前面加一个offset，比如取offset为2^7，就在补码的第8位加上1&lt;/li&gt;
&lt;li&gt;比如正数10101，移码是10010101，负数-10101的补码是11101011，所以移码是01101011&lt;/li&gt;
&lt;li&gt;移码的作用是&amp;#x3D;&amp;#x3D;保持数据原有的大小顺序&amp;#x3D;&amp;#x3D;，移码大真值大，移码小真值小，所以可以直观地进行比较&lt;br&gt;:::warning&lt;br&gt;相同位数的补码和移码表示具有相同的数据表示范围，区别只是表示方法不同&lt;br&gt;补码与移码只差一个符号位。同一个数的补码和移码表示，其数值部分相同，而符号位相反。&lt;br&gt;:::&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-1-3-整数表示&#34;&gt;&lt;a href=&#34;#2-1-3-整数表示&#34; class=&#34;headerlink&#34; title=&#34;2.1.3 整数表示&#34;&gt;&lt;/a&gt;2.1.3 整数表示&lt;/h3&gt;&lt;p&gt;略&lt;/p&gt;
&lt;h3 id=&#34;2-1-4&#34;&gt;&lt;a href=&#34;#2-1-4&#34; class=&#34;headerlink&#34; title=&#34;2.1.4&#34;&gt;&lt;/a&gt;2.1.4&lt;/h3&gt;&lt;p&gt;c中的强制转换&lt;br&gt;short转成unsigned short直接把二进制看成unsigned short，比如-1变成65535&lt;br&gt;int变成short直接截断&lt;br&gt;小字长转大字长不会改变值，如果是unsigned就会在前面补0，如果是有符号数就在前面补符号位&lt;br&gt;short转unsigned int，先对short进行符号扩展到int，再把它当做unsigned int，如果是unsigned short转int，就进行零扩展再看成int……&lt;/p&gt;
&lt;p&gt;一些题目&lt;br&gt;+++info example&lt;br&gt;;;;id3 t1&lt;br&gt;若$[x]_补 &amp;#x3D; 1,x_1x_2x_3x_4x_5x_6$,其中$x_i$取0或1，若要x&amp;gt;-32，应当满足：&lt;br&gt;C. $x_1$为1，$x_2…x_6$中至少有一位为1&lt;br&gt;1100000是-32，要比-32大所以绝对值要小，所以数值部分要大，所以$x_1$必须是1,后面随便有个1就行&lt;br&gt;;;;&lt;br&gt;;;;id3 t2&lt;br&gt;设x为正数，$[x]_补 &amp;#x3D; 1,x_1x_2x_3x_4x_5$,若要x&amp;lt;-16，应当满足：&lt;br&gt;C. $x_1$必须为0，其它任意&lt;br&gt;110000是-16，要小于-16所以数值部分绝对值要小，所以只要$x_1$为0就比-16小&lt;br&gt;;;;&lt;br&gt;;;;id3 t3&lt;br&gt;一个8位的二进制整数由2个“0”和6个“1”组成，采用补码或者移码表示，则&lt;br&gt;若采用移码表示，偏置值为127，则此整数最小为-64（偏置为127需要在补码加上1111111，&amp;#x3D;&amp;#x3D;要让数值最小，应该把1放低位&amp;#x3D;&amp;#x3D;，所以移码是00111111，补码是10111111是-64）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;：前面说过，移码大真值大，移码小真值小，所以要让数值最小把1放低位就行了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;若采用补码表示，则此整数最小为-97（10011111&amp;#x3D;-97）&lt;br&gt;;;;&lt;br&gt;;;;id3 比较大小的方法&lt;br&gt;对于无符号数，数值大的数就大&lt;br&gt;对于有符号数的原码和反码比较大小：先看正负然后看数值，反码数值转成原码再比&lt;br&gt;对于补码比较大小，正数正常比较，负数数值部分越小，绝对值越大（前面1更多的数的绝对值越小，所以11111111是-1）&lt;br&gt;;;;&lt;br&gt;+++&lt;/p&gt;
&lt;h2 id=&#34;2-2-运算方法和运算电路&#34;&gt;&lt;a href=&#34;#2-2-运算方法和运算电路&#34; class=&#34;headerlink&#34; title=&#34;2.2 运算方法和运算电路&#34;&gt;&lt;/a&gt;2.2 运算方法和运算电路&lt;/h2&gt;&lt;h3 id=&#34;2-2-1-基本运算部件&#34;&gt;&lt;a href=&#34;#2-2-1-基本运算部件&#34; class=&#34;headerlink&#34; title=&#34;2.2.1 基本运算部件&#34;&gt;&lt;/a&gt;2.2.1 基本运算部件&lt;/h3&gt;&lt;h4 id=&#34;一位全加器&#34;&gt;&lt;a href=&#34;#一位全加器&#34; class=&#34;headerlink&#34; title=&#34;一位全加器&#34;&gt;&lt;/a&gt;一位全加器&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;用真值表实现的：进位C，和S&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;A&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;B&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Cin&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Cout&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;S&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;可以用卡诺图或者直接理解&lt;br&gt;&lt;img data-src=&#34;/img2.jpg&#34;&gt;&lt;br&gt;$$&lt;br&gt;\begin{aligned}&lt;br&gt;S &amp;amp;&amp;#x3D; \overline{A} , \overline{B} , C_i + \overline{A} , B , \overline{C_i} + A , \overline{B} , \overline{C_i} + A , B , C_i \&lt;br&gt;&amp;amp;&amp;#x3D; A \oplus B \oplus C_i&lt;br&gt;\end{aligned}&lt;br&gt;$$&lt;br&gt;$$&lt;br&gt;\begin{aligned}&lt;br&gt;Co &amp;amp;&amp;#x3D; AB + A \overline{B} C_i + \overline{A} B C_i \&lt;br&gt;&amp;amp;&amp;#x3D; AB + (A \oplus B) \cdot C_i&lt;br&gt;\end{aligned}&lt;br&gt;$$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;串行进位加法器&#34;&gt;&lt;a href=&#34;#串行进位加法器&#34; class=&#34;headerlink&#34; title=&#34;串行进位加法器&#34;&gt;&lt;/a&gt;串行进位加法器&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;把n个一位全加器连起来&lt;br&gt;&lt;img data-src=&#34;/img3.png&#34;&gt;&lt;br&gt;Carry Propagation &amp;amp; Delay&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;并行进位加法器&#34;&gt;&lt;a href=&#34;#并行进位加法器&#34; class=&#34;headerlink&#34; title=&#34;并行进位加法器&#34;&gt;&lt;/a&gt;并行进位加法器&lt;/h4&gt;&lt;p&gt;对Cin进行look ahead&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/img4.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;前面提到：&lt;br&gt;$$&lt;br&gt;\begin{aligned}&lt;br&gt;Co &amp;amp;&amp;#x3D; AB + A \overline{B} C_i + \overline{A} B C_i \&lt;br&gt;   &amp;amp;&amp;#x3D; AB + (A \oplus B) \cdot C_i&lt;br&gt;\end{aligned}&lt;br&gt;$$&lt;br&gt;下一位的Cin等于上一位的Cout，所以可以进行look ahead，这里让&lt;br&gt;$$&lt;br&gt;\begin{aligned}&lt;br&gt;G_i &amp;amp;&amp;#x3D; A_iB_i&lt;br&gt;\end{aligned}&lt;br&gt;$$&lt;br&gt;$$&lt;br&gt;\begin{aligned}&lt;br&gt;P_i &amp;amp;&amp;#x3D; A_i \oplus B_i&lt;br&gt;\end{aligned}&lt;br&gt;$$&lt;br&gt;所以&lt;br&gt;$$&lt;br&gt;\begin{aligned}&lt;br&gt;C_{i+1} &amp;amp;&amp;#x3D; G_i + P_iC_i&lt;br&gt;\end{aligned}&lt;br&gt;$$&lt;br&gt;$$&lt;br&gt;\begin{aligned}&lt;br&gt;S_i &amp;amp;&amp;#x3D; P_i \oplus C_i&lt;br&gt;\end{aligned}&lt;br&gt;$$&lt;br&gt;就能得到超前进位的效果&lt;/p&gt;
&lt;h4 id=&#34;带标志加法器&#34;&gt;&lt;a href=&#34;#带标志加法器&#34; class=&#34;headerlink&#34; title=&#34;带标志加法器&#34;&gt;&lt;/a&gt;带标志加法器&lt;/h4&gt;&lt;p&gt;&lt;img data-src=&#34;/img5.jpg&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;溢出标志 $OF &amp;#x3D; C_n  \oplus C_{n-1}$，只能判断有符号数是否溢出&lt;br&gt;-两个正数加起来变成负数或者两个负数加起来变成正数，就会溢出&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;A&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;B&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;$C_{n-1}$&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;F&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;$C_n$&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;OF&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;第二行A&amp;#x3D;0, B&amp;#x3D;0, F&amp;#x3D;1，正+正&amp;#x3D;负&lt;br&gt;  第七行A&amp;#x3D;0, B&amp;#x3D;1, F&amp;#x3D;0，负+负&amp;#x3D;正&lt;br&gt;  所以OF&amp;#x3D;1，表示有溢出&lt;br&gt;  观察发现$OF &amp;#x3D; C_{n-1}  \oplus C_n$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;符号标志 $SF &amp;#x3D; F_{n-1}$，输出的最高位决定有符号数的正负&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CF&lt;/code&gt;进位&amp;#x2F;借位标志：用于判断无符号数的加减运算是否溢出&lt;ul&gt;
&lt;li&gt;$CF &amp;#x3D; Cin \oplus Cout$&lt;/li&gt;
&lt;li&gt;此处的Cin和Cout表示最开始的输入和最后的输出，还没理解&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ZF&lt;/code&gt;零标志 当且仅当所有F&amp;#x3D;0时为1，否则为0（把所有F作或非）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SF&lt;/code&gt;符号标志位,结果为负，即符号位为1时SF&amp;#x3D;1，否则为0&lt;br&gt;具体可以看这篇：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhYmJ5X19fXy9hcnRpY2xlL2RldGFpbHMvODA4MjU1NDk=&#34;&gt;https://blog.csdn.net/gabby____/article/details/80825549&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ALU&#34;&gt;&lt;a href=&#34;#ALU&#34; class=&#34;headerlink&#34; title=&#34;ALU&#34;&gt;&lt;/a&gt;ALU&lt;/h4&gt;&lt;p&gt;略&lt;/p&gt;
&lt;h3 id=&#34;2-2-2-定点数的移位运算&#34;&gt;&lt;a href=&#34;#2-2-2-定点数的移位运算&#34; class=&#34;headerlink&#34; title=&#34;2.2.2 定点数的移位运算&#34;&gt;&lt;/a&gt;2.2.2 定点数的移位运算&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;左移一位*2，右移一位&amp;#x2F;2&lt;/li&gt;
&lt;li&gt;逻辑移位：移完直接补0&lt;ul&gt;
&lt;li&gt;无符号数若高位的1移出，则发生溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;算数移位：有符号数右移时，补符号位，左移直接移，如果高位和符号位不同，则发生溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;定点数的加减运算&#34;&gt;&lt;a href=&#34;#定点数的加减运算&#34; class=&#34;headerlink&#34; title=&#34;定点数的加减运算&#34;&gt;&lt;/a&gt;定点数的加减运算&lt;/h3&gt;&lt;p&gt;补码相加减，略&lt;br&gt;主要是溢出判断：符号相同的数相加或者符号相异的数相减会发生溢出&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一位符号位（参考前面OF）&lt;/li&gt;
&lt;li&gt;双符号位（模4补码）&lt;ul&gt;
&lt;li&gt;符号位左边那一位表示正确的符号，0为正，1为负；右边那一位如果和左边的相同，如 “00”表示正且无溢出，”11”表示负且无溢出。如果右边那一位与左边那一位不一样，则表示有溢出&lt;/li&gt;
&lt;li&gt;溢出逻辑判断：若V为0则无溢出，V为1则溢出&lt;/li&gt;
&lt;li&gt;&amp;#x3D;&amp;#x3D;存储的时候，模4补码只需要一位符号位&amp;#x3D;&amp;#x3D;，因为任何一个正确的数值它的两个符号位是相同的。它只是把两个模4补码的数送往ALU进行运算的时候，把符号位同时送入ALU的双符号位中，即&amp;#x3D;&amp;#x3D;只在ALU中采用双符号位&amp;#x3D;&amp;#x3D;&lt;br&gt;$$&lt;br&gt;V &amp;#x3D; S_{s1} \oplus S_{s2}&lt;br&gt;$$&lt;br&gt;例子看这篇写的挺清楚：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1bl9ib3lfYm95X3N1bi9hcnRpY2xlL2RldGFpbHMvODc5MTcwMjA=&#34;&gt;https://blog.csdn.net/sun_boy_boy_sun/article/details/87917020&lt;/span&gt;&lt;br&gt;总之两位不同则有溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;定点数的乘除运算&#34;&gt;&lt;a href=&#34;#定点数的乘除运算&#34; class=&#34;headerlink&#34; title=&#34;定点数的乘除运算&#34;&gt;&lt;/a&gt;定点数的乘除运算&lt;/h3&gt;&lt;p&gt;略，列竖式即可&lt;/p&gt;
&lt;h3 id=&#34;浮点数的表示与运算&#34;&gt;&lt;a href=&#34;#浮点数的表示与运算&#34; class=&#34;headerlink&#34; title=&#34;浮点数的表示与运算&#34;&gt;&lt;/a&gt;浮点数的表示与运算&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;浮点数的表示格式&lt;br&gt;$$&lt;br&gt;N &amp;#x3D; (-1)^s \cdot M \cdot R^E&lt;br&gt;$$&lt;br&gt;s符号，M尾数，E阶码，R基数&lt;/li&gt;
&lt;li&gt;浮点数的表示范围&lt;br&gt;范围关于原点对称，运算结果大于最大正数时成为正上溢，小遇绝对值最大负数是成为负上溢，统称上溢。运算结果在0-最小整数之间成为正下溢，负数同理，统称下溢（原因是精度不够）&lt;/li&gt;
&lt;li&gt;浮点数的规格化&lt;br&gt;化成$1.xxxxx… \cdot 2^n$的形式&lt;/li&gt;
&lt;li&gt;IEEE754&lt;br&gt;符号，阶码，尾数&lt;br&gt;32位单精度：1 8 23，偏置为$2^7-1&amp;#x3D;127$，真值为$(-1)^s \cdot 2^{e-127} \cdot (1.M)$&lt;br&gt;单精度表示的最小值为$1 \cdot 2^{1-127} \cdot (1.000…) &amp;#x3D; 2^{-126}$，最大值为$1 \cdot 2^{254-127} \cdot (1.111…) &amp;#x3D; (2 - 2^{-23}) \cdot 2^{127}$}&lt;br&gt;64位双精度：1 11 52，偏置为$2^{10}-1&amp;#x3D;1023$，真值为$(-1)^s \cdot 2^{e-1023} \cdot (1.M)$，最大值为$1 \cdot 2^{2046-1023} \cdot (1.111…) &amp;#x3D; (2 - 2^{-52}) \cdot 2^{1023}$&lt;br&gt;阶码全为0或者全为1有特殊意义&lt;br&gt;&lt;img data-src=&#34;/f1.jpg&#34;&gt;&lt;br&gt;阶码全1尾数不全0表示无穷大&lt;br&gt;阶码全1尾数全0表示NaN&lt;br&gt;阶码全0尾数不全0表示非规格化数，隐藏位为0（精度不够表示，需要特殊处理）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;浮点数的加减运算&#34;&gt;&lt;a href=&#34;#浮点数的加减运算&#34; class=&#34;headerlink&#34; title=&#34;浮点数的加减运算&#34;&gt;&lt;/a&gt;浮点数的加减运算&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;对阶&lt;/li&gt;
&lt;li&gt;尾数相加减&lt;/li&gt;
&lt;li&gt;尾数规格化，修改阶数&lt;/li&gt;
&lt;li&gt;舍入&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;就近舍入：舍入为最近的可表示数，当结果是两个可表示数的中间时，选择结果为偶数&lt;/li&gt;
&lt;li&gt;正向舍入：朝数轴正无穷方向舍入，取右边最近的可表示数&lt;/li&gt;
&lt;li&gt;负向舍入：和正向相反&lt;/li&gt;
&lt;li&gt;截断法：直接截取所需位数，是一种趋向原点的舍入&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;溢出判断&lt;br&gt;对阶码加减时要判断是否溢出&lt;/li&gt;
&lt;/ol&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/05/13/computer-science/computer-network/ch1/</guid>
            <title>Ch1</title>
            <link>http://example.com/2025/05/13/computer-science/computer-network/ch1/</link>
            <category>计算机网络</category>
            <pubDate>Tue, 13 May 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[  ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/05/13/computer-science/computer-organization/ch1/</guid>
            <title>Ch1</title>
            <link>http://example.com/2025/05/13/computer-science/computer-organization/ch1/</link>
            <category>计算机组成</category>
            <pubDate>Tue, 13 May 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;blockquote&gt;
&lt;p&gt;计组考研复习笔记，参考资料：王道，zju数逻&amp;#x2F;计组&amp;#x2F;体系课程ppt&lt;br&gt;怕学完忘了写个笔记保留一下顺便加深印象x&lt;br&gt;王道书写得好烂、、&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;Ch1-计算机系统概述&#34;&gt;&lt;a href=&#34;#Ch1-计算机系统概述&#34; class=&#34;headerlink&#34; title=&#34;Ch1 计算机系统概述&#34;&gt;&lt;/a&gt;Ch1 计算机系统概述&lt;/h1&gt;&lt;h2 id=&#34;1-1-计算机发展历程&#34;&gt;&lt;a href=&#34;#1-1-计算机发展历程&#34; class=&#34;headerlink&#34; title=&#34;1.1 计算机发展历程&#34;&gt;&lt;/a&gt;1.1 计算机发展历程&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;四代计算机：电子管-&amp;gt;晶体管-&amp;gt;集成电路-&amp;gt;超大规模集成电路&lt;/li&gt;
&lt;li&gt;摩尔定律：集成电路上可以容纳的晶体管数目在大约每经过18个月到24个月便会增加一倍&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-2-计算机系统层次结构&#34;&gt;&lt;a href=&#34;#1-2-计算机系统层次结构&#34; class=&#34;headerlink&#34; title=&#34;1.2 计算机系统层次结构&#34;&gt;&lt;/a&gt;1.2 计算机系统层次结构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;计算机系统：硬件+软件&lt;/li&gt;
&lt;li&gt;对于某一功能，既能用软件实现又能用硬件实现，称为软、硬件在逻辑功能上是等价的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-2-2-硬件&#34;&gt;&lt;a href=&#34;#1-2-2-硬件&#34; class=&#34;headerlink&#34; title=&#34;1.2.2 硬件&#34;&gt;&lt;/a&gt;1.2.2 硬件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;冯·诺依曼机的特点：&lt;ul&gt;
&lt;li&gt;采用“存储程序”的工作方式&lt;/li&gt;
&lt;li&gt;冯·诺依曼计算机由五大部件组成：运算器、控制器、存储器、输入设备和输出设备&lt;/li&gt;
&lt;li&gt;指令和数据以同等地位存储在存储器中&lt;/li&gt;
&lt;li&gt;指令和数据均用二进制代码表示&lt;/li&gt;
&lt;li&gt;指令由操作码和地址码组成&lt;/li&gt;
&lt;li&gt;&lt;img data-src=&#34;/img1.png&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;计算机的功能部件：&lt;ul&gt;
&lt;li&gt;输入设备&lt;/li&gt;
&lt;li&gt;输出设备&lt;/li&gt;
&lt;li&gt;存储器：主存+外存&lt;ul&gt;
&lt;li&gt;CPU能直接访问的是主存&lt;/li&gt;
&lt;li&gt;&lt;img data-src=&#34;/img2.jpg&#34;&gt;&lt;/li&gt;
&lt;li&gt;MAR位10位则最多有$2^{10}$个存储单元&lt;/li&gt;
&lt;li&gt;在现代计算机中MAR和MDR存在CPU中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;运算器：进行算术运算和逻辑运算&lt;ul&gt;
&lt;li&gt;核心是ALU：通用寄存器有&amp;#x3D;&amp;#x3D;累加器(ACC)，乘商寄存器(MQ)，操作数寄存器(X)&amp;#x3D;&amp;#x3D;，变址寄存器(IX)，基址寄存器(BR)等，前三个必备&lt;/li&gt;
&lt;li&gt;程序状态寄存器(PSW)&lt;/li&gt;
&lt;li&gt;&lt;img data-src=&#34;/img3.jpg&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;控制器：由PC, IR和control unit组成&lt;ul&gt;
&lt;li&gt;: RISCV控制器&lt;/li&gt;
&lt;li&gt;&lt;img data-src=&#34;/img4.png&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CPU由运算器、控制器和cache组成&lt;/li&gt;
&lt;li&gt;总线有地址总线、数据总线、控制总线&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-2-3-软件&#34;&gt;&lt;a href=&#34;#1-2-3-软件&#34; class=&#34;headerlink&#34; title=&#34;1.2.3 软件&#34;&gt;&lt;/a&gt;1.2.3 软件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;组成：系统软件(OS, DBMS, 编译器, …)+应用软件&lt;/li&gt;
&lt;li&gt;语言：汇编语言、机器语言、高级语言&lt;ul&gt;
&lt;li&gt;汇编器：把汇编语言翻译成机器语言&lt;/li&gt;
&lt;li&gt;编译器：把高级语言翻译成汇编语言或机器语言&lt;/li&gt;
&lt;li&gt;解释器：把高级语言翻译成&amp;#x3D;&amp;#x3D;机器语言&amp;#x3D;&amp;#x3D;(比如python)&lt;br&gt;  +++info example&lt;br&gt;  ;;;id3 题目&lt;br&gt;  :chestnut:&lt;br&gt;  将高级语言源程序转换为机器级目标代码文件的程序是 []。&lt;br&gt;  A. 汇编程序&lt;br&gt;  B. 链接程序&lt;br&gt;  C. 编译程序&lt;br&gt;  D. 解释程序&lt;br&gt;  ;;;&lt;br&gt;  ;;;id3 答案&lt;br&gt;  C. 编译程序&lt;br&gt;  因为解释程序不生成目标代码，编译器可以把高级语言翻译成汇编语言或者直接翻译成机器语言&lt;br&gt;  ;;;&lt;br&gt;  +++&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-2-4-计算机系统的层次结构&#34;&gt;&lt;a href=&#34;#1-2-4-计算机系统的层次结构&#34; class=&#34;headerlink&#34; title=&#34;1.2.4 计算机系统的层次结构&#34;&gt;&lt;/a&gt;1.2.4 计算机系统的层次结构&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;看看就好&lt;/li&gt;
&lt;li&gt;&lt;img data-src=&#34;/img5.png&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-2-5-计算机系统的工作原理&#34;&gt;&lt;a href=&#34;#1-2-5-计算机系统的工作原理&#34; class=&#34;headerlink&#34; title=&#34;1.2.5 计算机系统的工作原理&#34;&gt;&lt;/a&gt;1.2.5 计算机系统的工作原理&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;程序执行前，需要把所含的指令和数据一起放入主存中&lt;/li&gt;
&lt;li&gt;五个阶段：IF-ID-EX-MEM-WB&lt;/li&gt;
&lt;li&gt;c程序怎么变成可执行文件的：直接看图&lt;ul&gt;
&lt;li&gt;&lt;img data-src=&#34;/img6.png&#34;&gt;&lt;/li&gt;
&lt;li&gt;汇编器把指令打包成可重定位目标代码文件：使用相对地址和符号引用来表示各个代码段之间的关系（代码段、数据段、符号表、重定位表…）使得代码或数据能在内存中任意位置加载或运行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;指令执行过程：后面几章会具体讲&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-3-计算机的性能指标&#34;&gt;&lt;a href=&#34;#1-3-计算机的性能指标&#34; class=&#34;headerlink&#34; title=&#34;1.3 计算机的性能指标&#34;&gt;&lt;/a&gt;1.3 计算机的性能指标&lt;/h2&gt;&lt;h3 id=&#34;1-3-1-主要性能指标&#34;&gt;&lt;a href=&#34;#1-3-1-主要性能指标&#34; class=&#34;headerlink&#34; title=&#34;1.3.1 主要性能指标&#34;&gt;&lt;/a&gt;1.3.1 主要性能指标&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;字长：一次整数运算所能处理的二进制数据的位数&lt;br&gt; :::info&lt;br&gt; 机器字长、指令字长和存储字长&lt;br&gt; :::&lt;/li&gt;
&lt;li&gt;带宽&lt;code&gt;bandwidth&lt;/code&gt;：总线一次能并行传送信息的位数&lt;/li&gt;
&lt;li&gt;主存容量&lt;/li&gt;
&lt;li&gt;运算速度&lt;ul&gt;
&lt;li&gt;吞吐量&lt;code&gt;throughput&lt;/code&gt;：一次输入数据所对应的输出数据个数&lt;/li&gt;
&lt;li&gt;响应时间&lt;code&gt;Response (Execution) time&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;主频&lt;/li&gt;
&lt;li&gt;clock cycle time( &amp;#x3D; 1&amp;#x2F;CPU frequency)&lt;/li&gt;
&lt;li&gt;MIPS: million instructions per second&lt;/li&gt;
&lt;li&gt;FLOPS: floating-point operations per second&lt;blockquote&gt;
&lt;p&gt;CPI: clock cycles per instruction(IPC: CPI的倒数)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$ \begin{aligned}&lt;br&gt;    \text{CPU execution time} &amp;amp;&amp;#x3D; \text{CPU clock cycles} \times \text{Clock cycle time} \&lt;br&gt;    &amp;amp;&amp;#x3D; \frac{\text{CPU clock cycles}}{\text{Clock rate}}&lt;br&gt;\end{aligned}$$&lt;/p&gt;
&lt;p&gt;$$\begin{aligned}&lt;br&gt;    \text{CPU clock cycles} &amp;amp;&amp;#x3D; \text{Instructions count} \times \text{Average cycles per instruction}&lt;br&gt;\end{aligned}$$&lt;/p&gt;
&lt;p&gt;$$\begin{aligned}&lt;br&gt;    \text{CPU execution time} &amp;amp;&amp;#x3D; \text{CPU clock cycles} \times \text{Clock cycle time} \&lt;br&gt;    &amp;amp;&amp;#x3D; \frac{\text{CPU clock cycles}}{\text{Clock rate}}&lt;br&gt;\end{aligned} $$&lt;/p&gt;
&lt;p&gt;$$ \begin{aligned}&lt;br&gt;     \text{performance} &amp;amp;&amp;#x3D; \frac{1}{\text{CPU execution time}}&lt;br&gt;\end{aligned}$$&lt;/p&gt;
&lt;p&gt;“Processor X is n times fast than Y” is&lt;br&gt;$$ \begin{aligned}&lt;br&gt;    \text{n} &amp;amp;&amp;#x3D; \frac{\text{CPU execution time of Y}}{\text{CPU execution time of X}}&lt;br&gt;\end{aligned}$$&lt;/p&gt;
&lt;p&gt;IPS: instructions per second&lt;br&gt;$$ \begin{aligned}&lt;br&gt;    \text{IPS} &amp;amp;&amp;#x3D; \frac{\text{CPU frequency}}{\text{CPI}}&lt;br&gt;        &amp;amp;&amp;#x3D; \frac{1}{\text{CPU clock cycles} \times \text{CPU execution time}}&lt;br&gt;\end{aligned}$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其他公式，，，用到再说吧&lt;/li&gt;
&lt;li&gt;兼容：软件或硬件的通用性&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在用于科学计算的计算机中，标志系统性能最有用的参数是浮点数运算相关的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MFLOPS 10^6&lt;/li&gt;
&lt;li&gt;GFLOPS 10^9&lt;/li&gt;
&lt;li&gt;TFLOPS 10^12&lt;/li&gt;
&lt;li&gt;PFLOPS 10^15&lt;/li&gt;
&lt;li&gt;EFLOPS 10^18&lt;/li&gt;
&lt;li&gt;ZFLOPS 10^21&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/03/30/computer-science/compile-principles/ch5/</guid>
            <title>语义分析</title>
            <link>http://example.com/2025/03/30/computer-science/compile-principles/ch5/</link>
            <category>语义分析</category>
            <pubDate>Sun, 30 Mar 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;语义分析&#34;&gt;&lt;a href=&#34;#语义分析&#34; class=&#34;headerlink&#34; title=&#34;语义分析&#34;&gt;&lt;/a&gt;语义分析&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;绑定，类型检查&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;symbol-table&#34;&gt;&lt;a href=&#34;#symbol-table&#34; class=&#34;headerlink&#34; title=&#34;symbol table&#34;&gt;&lt;/a&gt;symbol table&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Imperative style: 命令式风格&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Modify $\sigma_1$ until it becomes $\sigma_2$. &lt;/li&gt;
&lt;li&gt;While $\sigma_2$ exists, we cannot look things up in $\sigma_1$. &lt;/li&gt;
&lt;li&gt;When done with $\sigma_2$, can undo the modification to get $\sigma_1$ back again.&lt;br&gt;+++info 方法：&lt;br&gt;Hashing&lt;br&gt;插入：找到哈希值然后插入链表的表头&lt;br&gt;查找：找到哈希值然后遍历链表&lt;br&gt;pop: 找到哈希值然后把链表表头删掉  table[hash(key)] &amp;#x3D; table[hash(key)].next&lt;br&gt;+++&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Functional style: 函数式风格&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;To keep $\sigma_1$ in pristine condition while creating create $\sigma_2$ and $\sigma_3$&lt;br&gt;+++info 方法：&lt;br&gt;如果依旧用哈希，每次要复制一遍哈希表，开销太大了，不现实&lt;br&gt;&lt;img data-src=&#34;/f2.jpg&#34;&gt;&lt;br&gt;所以用persistent BST&lt;br&gt;&lt;img data-src=&#34;/f1.jpg&#34;&gt;&lt;br&gt;先遍历二叉搜索树找到要插入的位置，然后对于插入节点把它从根节点到它全都复制一遍然后插入&lt;br&gt;+++&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Tiger编译器中的符号&#34;&gt;&lt;a href=&#34;#Tiger编译器中的符号&#34; class=&#34;headerlink&#34; title=&#34;Tiger编译器中的符号&#34;&gt;&lt;/a&gt;Tiger编译器中的符号&lt;/h2&gt;&lt;p&gt;对链表进行lookup的时候每一次都要进行string compare，开销是很大的。所以使用新的数据结构将符号对象关联到一个整数上，因此对于任意给定字符串的所有不同出现，都会被转换成同一个符号对象。&lt;br&gt;Symbol的实现：通过hash函数将字符串映射到一个symbol对象上&lt;br&gt;SymbolTable的实现：beginScope()和endScope()的实现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;beginScope()：添加一个marksym&lt;/li&gt;
&lt;li&gt;endScope()：从符号表中不断pop直到marksym&lt;/li&gt;
&lt;li&gt;引入一个 辅助栈(Auxiliary stack) 来维护&lt;ul&gt;
&lt;li&gt;符号入栈时，会将binding联动地插入对应bucket的链表头&lt;/li&gt;
&lt;li&gt;弹出栈顶符号时，对应bucket的链表头也会联动地被移除&lt;/li&gt;
&lt;li&gt;beginScope: 压入一个特殊标记到辅助栈中&lt;/li&gt;
&lt;li&gt;endScope: 一直弹出符号直到弹出了一个特殊标记&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;类型检查&#34;&gt;&lt;a href=&#34;#类型检查&#34; class=&#34;headerlink&#34; title=&#34;类型检查&#34;&gt;&lt;/a&gt;类型检查&lt;/h2&gt;&lt;h3 id=&#34;哪些类型表达式是合法-非法的&#34;&gt;&lt;a href=&#34;#哪些类型表达式是合法-非法的&#34; class=&#34;headerlink&#34; title=&#34;哪些类型表达式是合法&amp;#x2F;非法的&#34;&gt;&lt;/a&gt;哪些类型表达式是合法&amp;#x2F;非法的&lt;/h3&gt;&lt;p&gt;Tiger的类型系统：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两种primitive type: int, string&lt;/li&gt;
&lt;li&gt;两种constructed type: records, arrays&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;typec → type type-id &amp;#x3D; ty&lt;ul&gt;
&lt;li&gt;这表示定义一个类型。&lt;code&gt;typec&lt;/code&gt; 是一个类型定义的开始，它由关键字 &lt;code&gt;type&lt;/code&gt;、一个类型标识符 &lt;code&gt;type-id&lt;/code&gt; 和一个等号 &lt;code&gt;=&lt;/code&gt; 后跟类型定义 &lt;code&gt;ty&lt;/code&gt; 组成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ty → type-id&lt;ul&gt;
&lt;li&gt;这表示类型 &lt;code&gt;ty&lt;/code&gt; 可以直接是一个已定义的类型标识符 &lt;code&gt;type-id&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ty → ‘{’ tyfields ‘}’&lt;ul&gt;
&lt;li&gt;这表示类型 &lt;code&gt;ty&lt;/code&gt; 可以是一个记录（record），由花括号 &lt;code&gt;&amp;#123;&amp;#125;&lt;/code&gt; 包围的一系列字段 &lt;code&gt;tyfields&lt;/code&gt; 定义。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ty → array of type-id&lt;ul&gt;
&lt;li&gt;这表示类型 &lt;code&gt;ty&lt;/code&gt; 可以是一个数组，由关键字 &lt;code&gt;array of&lt;/code&gt; 后跟一个类型标识符 &lt;code&gt;type-id&lt;/code&gt; 定义。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;tyfields → ε&lt;ul&gt;
&lt;li&gt;这表示字段列表 &lt;code&gt;tyfields&lt;/code&gt; 可以为空（ε 表示空串）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;tyfields → id: type-id {, id:type-id}&lt;ul&gt;
&lt;li&gt;这表示字段列表 &lt;code&gt;tyfields&lt;/code&gt; 由一个或多个字段组成，每个字段由一个标识符 &lt;code&gt;id&lt;/code&gt; 和冒号 &lt;code&gt;:&lt;/code&gt; 后跟一个类型标识符 &lt;code&gt;type-id&lt;/code&gt; 定义，多个字段之间用逗号 &lt;code&gt;,&lt;/code&gt; 分隔。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;let type a = &amp;#123;x: int; y: int&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    type b = a&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    var i : a := ...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    var j : b := ...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;in i := j&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;


&lt;h3 id=&#34;类型等价&#34;&gt;&lt;a href=&#34;#类型等价&#34; class=&#34;headerlink&#34; title=&#34;类型等价&#34;&gt;&lt;/a&gt;类型等价&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Name equivalence (NE): 必须声明是同一个类型才是同一类型&lt;/li&gt;
&lt;li&gt;Structure equivalence (SE): 如果两个类型的结构完全相同（即它们由相同的构造器以相同的顺序组成），那么它们就被认为是等价的，即使它们的名字不同&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;type A = &amp;#123;x: int; y: int&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;type B = &amp;#123;x: int; y: int&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Tiger用的是NE&lt;br&gt;在Tiger编程语言中，存在两个独立的命名空间：一个用于类型（Types），另一个用于函数和变量（Functions and Variables）。所以类型和函数&amp;#x2F;变量可以存在相同的名字，但是函数和变量不能存在相同的名字。&lt;br&gt;所以需要两个env&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Type env&lt;ul&gt;
&lt;li&gt;symbol -&amp;gt; Ty_ty&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Value env&lt;ul&gt;
&lt;li&gt;对于变量，symbol -&amp;gt; Ty_ty&lt;/li&gt;
&lt;li&gt;对于函数，symbol -&amp;gt; struct{Ty_tyList formals, Ty_ty results}&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;类型检查的rule&#34;&gt;&lt;a href=&#34;#类型检查的rule&#34; class=&#34;headerlink&#34; title=&#34;类型检查的rule&#34;&gt;&lt;/a&gt;类型检查的rule&lt;/h3&gt;&lt;p&gt;类型检查分为两部分:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Type-checking expressions: 对于每个表达式，根据当前的Type和Value环境来确定其类型，并检查是否符合语言的类型规则&lt;/li&gt;
&lt;li&gt;Type-checking declarations: 在Tiger语言中声明只可能在let语句中出现&lt;br&gt;好像就是讲了transExp, transDec, transVar，AST递归检查每个节点的类型然后一层一层往上传再检查&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/03/29/computer-science/compile-principles/ch4/</guid>
            <title>抽象语法</title>
            <link>http://example.com/2025/03/29/computer-science/compile-principles/ch4/</link>
            <category>抽象语法</category>
            <pubDate>Sat, 29 Mar 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[  ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/03/23/computer-science/compile-principles/ch3/</guid>
            <title>语法分析</title>
            <link>http://example.com/2025/03/23/computer-science/compile-principles/ch3/</link>
            <category>语法分析</category>
            <pubDate>Sun, 23 Mar 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;语法分析&#34;&gt;&lt;a href=&#34;#语法分析&#34; class=&#34;headerlink&#34; title=&#34;语法分析&#34;&gt;&lt;/a&gt;语法分析&lt;/h1&gt;&lt;h2 id=&#34;CFG&#34;&gt;&lt;a href=&#34;#CFG&#34; class=&#34;headerlink&#34; title=&#34;CFG&#34;&gt;&lt;/a&gt;CFG&lt;/h2&gt;&lt;p&gt;见计算理论&lt;br&gt;Parse tree&lt;/p&gt;
&lt;h3 id=&#34;Ambiguous-grammars&#34;&gt;&lt;a href=&#34;#Ambiguous-grammars&#34; class=&#34;headerlink&#34; title=&#34;Ambiguous grammars&#34;&gt;&lt;/a&gt;Ambiguous grammars&lt;/h3&gt;&lt;h2 id&gt;&lt;a href=&#34;#&#34; class=&#34;headerlink&#34; title&gt;&lt;/a&gt;&lt;/h2&gt; ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/03/22/computer-science/compile-principles/ch2/</guid>
            <title>词法分析</title>
            <link>http://example.com/2025/03/22/computer-science/compile-principles/ch2/</link>
            <category>词法分析</category>
            <pubDate>Sat, 22 Mar 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Ch2-词法分析&#34;&gt;&lt;a href=&#34;#Ch2-词法分析&#34; class=&#34;headerlink&#34; title=&#34;Ch2 词法分析&#34;&gt;&lt;/a&gt;Ch2 词法分析&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;把input分解成一个个token&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;Regular-Expression&#34;&gt;&lt;a href=&#34;#Regular-Expression&#34; class=&#34;headerlink&#34; title=&#34;Regular Expression&#34;&gt;&lt;/a&gt;Regular Expression&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Language: a set of strings&lt;/li&gt;
&lt;li&gt;String: a finite sequence of characters&lt;blockquote&gt;
&lt;p&gt;Regular Experssion Notations:&lt;br&gt;&lt;img data-src=&#34;/image-1.png&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;:::info&lt;br&gt;DFA, NFA相关 见计算理论&lt;br&gt;:::&lt;/p&gt;
&lt;h2 id=&#34;RE转NFA&#34;&gt;&lt;a href=&#34;#RE转NFA&#34; class=&#34;headerlink&#34; title=&#34;RE转NFA&#34;&gt;&lt;/a&gt;RE转NFA&lt;/h2&gt;&lt;p&gt;:::info 方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;画出初始态和终态&lt;/li&gt;
&lt;li&gt;分裂规则：&lt;br&gt;&lt;img data-src=&#34;/image-2.jpg&#34;&gt;&lt;br&gt;:::&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;NFA转DFA&#34;&gt;&lt;a href=&#34;#NFA转DFA&#34; class=&#34;headerlink&#34; title=&#34;NFA转DFA&#34;&gt;&lt;/a&gt;NFA转DFA&lt;/h2&gt;&lt;p&gt;从初始状态的闭包开始，每次根据\epsilon和当前状态的闭包，得到下一个状态的闭包，直到得到终态的闭包。&lt;/p&gt;
&lt;p&gt;+++info example&lt;br&gt;;;;id3 题目&lt;br&gt;:chestnut:&lt;br&gt;把这个NFA转成等价的DFA&lt;br&gt;&lt;img data-src=&#34;/image-3.png&#34;&gt;&lt;br&gt;;;;&lt;br&gt;;;;id3 答案&lt;br&gt;初态的闭包是1、2、6，1、2、6经过a可以转移到3、7，因为有\epsilon转移，所以3、7的闭包是3、4、7、8，同理3、4、7、8经过b可以到5、8，由于8是终态，把所有包含8的圆圈画成终态的环。&lt;br&gt;&lt;img data-src=&#34;/image-4.png&#34;&gt;&lt;br&gt;;;;&lt;br&gt;+++&lt;/p&gt;
&lt;h2 id=&#34;最小化DFA&#34;&gt;&lt;a href=&#34;#最小化DFA&#34; class=&#34;headerlink&#34; title=&#34;最小化DFA&#34;&gt;&lt;/a&gt;最小化DFA&lt;/h2&gt;&lt;p&gt;含义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;没有多余状态：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;从这个状态没有通路到达终态&lt;/li&gt;
&lt;li&gt;从开始状态出发，任何输入串也不能到达的那个状态&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;没有两个状态相互等价&lt;br&gt;:::info 方法：&lt;/li&gt;
&lt;li&gt;多余状态直接删除&lt;br&gt;&lt;img data-src=&#34;/image-5.png&#34;&gt;&lt;/li&gt;
&lt;li&gt;合并等价状态&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;将状态分为终态和非终态两个集合&lt;/li&gt;
&lt;li&gt;遍历每个集合，如果经过转换到达的状态都在当前集合里，则不用分，否则划分子集，直到划分不了为止&lt;/li&gt;
&lt;li&gt;:chestnut: 例子&lt;/li&gt;
&lt;li&gt;&lt;img data-src=&#34;/image-6.png&#34;&gt;&lt;br&gt;:::&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/03/21/computer-science/compile-principles/ch1/</guid>
            <title>Introduction</title>
            <link>http://example.com/2025/03/21/computer-science/compile-principles/ch1/</link>
            <category>编译原理</category>
            <pubDate>Fri, 21 Mar 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;blockquote&gt;
&lt;p&gt;ZJU 2025春夏编译原理 学习笔记&lt;/p&gt;
&lt;p&gt;主要基于虎书（&lt;em&gt;Modern Compiler Implementation in C&lt;/em&gt;, Andrew W. Appel）和好多老师的ppt（ldm, yps），还有lzx的智云&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;CH1-Introduction&#34;&gt;&lt;a href=&#34;#CH1-Introduction&#34; class=&#34;headerlink&#34; title=&#34;CH1 Introduction&#34;&gt;&lt;/a&gt;CH1 Introduction&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Two Important Concepts&lt;ul&gt;
&lt;li&gt;Phases（阶段）&lt;/li&gt;
&lt;li&gt;Interfaces（接口）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方框里的是phase，中间的是interface&lt;br&gt;&lt;img data-src=&#34;/image.png&#34;&gt;&lt;br&gt;各个阶段的描述&lt;br&gt;&lt;img data-src=&#34;/image-1.png&#34;&gt;&lt;img data-src=&#34;/image-2.png&#34;&gt;&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
