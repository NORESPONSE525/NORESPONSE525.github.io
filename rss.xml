<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title></title>
        <link>http://example.com</link>
        <description></description>
        <language>en</language>
        <pubDate>Sun, 15 Jun 2025 00:00:00 +0800</pubDate>
        <lastBuildDate>Sun, 15 Jun 2025 00:00:00 +0800</lastBuildDate>
        <category>人工智能</category>
        <category>�˹�����</category>
        <category>编译原理</category>
        <category>词法分析</category>
        <category>抽象语法</category>
        <category>语义分析</category>
        <category>语法分析</category>
        <category>计算机组成</category>
        <category>数据的表示与运算</category>
        <category>计算机网络</category>
        <item>
            <guid isPermalink="true">http://example.com/2025/06/15/AI/week8-9/</guid>
            <title>Week8-9</title>
            <link>http://example.com/2025/06/15/AI/week8-9/</link>
            <category>�˹�����</category>
            <pubDate>Sun, 15 Jun 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;K-Means&#34;&gt;&lt;a href=&#34;#K-Means&#34; class=&#34;headerlink&#34; title=&#34;K-Means&#34;&gt;&lt;/a&gt;K-Means&lt;/h1&gt;&lt;p&gt;������������ν�n���������������ƶȴ�С�����Ƿֱ���ൽk�����ϣ�ʹ��ÿ�����ݽ�����һ�����༯�ϡ�&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;��ʼ�����ģ����ѡ��k�����ݵ���Ϊ��ʼ����$c_1, c_2, …, c_k$��&lt;/li&gt;
&lt;li&gt;�������ݵ㣺����ÿ�����ݵ�$x_i$�����������������ĵľ��룬��������䵽����������������ڵĴ���&lt;/li&gt;
&lt;li&gt;�������ģ�����ÿ���أ�����ô����������ݵ��ƽ��ֵ������ƽ��ֵ��Ϊ�µ����ġ�&lt;/li&gt;
&lt;li&gt;�������̣��ظ�ִ�з���͸��²��裬ֱ�����Ĳ��ٷ����仯��ﵽԤ���������������&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;���ɷַ���-PCA&#34;&gt;&lt;a href=&#34;#���ɷַ���-PCA&#34; class=&#34;headerlink&#34; title=&#34;���ɷַ���(PCA)&#34;&gt;&lt;/a&gt;���ɷַ���(PCA)&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;���룺n��dά�������������ɵľ���$\mathbf{X}$����ά���ά��l&lt;/li&gt;
&lt;li&gt;�����ӳ�����$\mathbf{W} &amp;#x3D; {\mathbf{w}_1, \mathbf{w}_2, …, \mathbf{w}_l}$&lt;br&gt;�㷨���裺&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;����ÿ����������$\mathbf{x}_i$�������Ļ�������&lt;br&gt;$$&lt;br&gt;\mathbf{x}_i’ &amp;#x3D; \mathbf{x}&lt;em&gt;i - \mu, \quad \mu &amp;#x3D; \frac{1}{n}\sum&lt;/em&gt;{j&amp;#x3D;1}^{n} \mathbf{x}_j&lt;br&gt;$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;����ԭʼ�������ݵ�Э�������&lt;br&gt;$$&lt;br&gt;\Sigma &amp;#x3D; \frac{1}{n-1} \mathbf{X}^T \mathbf{X}&lt;br&gt;$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;��Э�������$\Sigma$��������ֵ�ֽ⣬����������������ֵ��С����$\lambda_1 \geq \lambda_2 \geq \cdots \geq \lambda_d$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ȡǰ$l$���������������Ӧ��������$\mathbf{w}_1, \mathbf{w}_2, …, \mathbf{w}_l$���ӳ�����$\mathbf{W}$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;��ÿ����������$\mathbf{x}&lt;em&gt;i$�������·�����ά��&lt;br&gt;$$&lt;br&gt;(\mathbf{x}&lt;em&gt;i)&lt;/em&gt;{1 \times d} (\mathbf{W})&lt;/em&gt;{d \times l} &amp;#x3D; 1 \times l&lt;br&gt;$$&lt;br&gt;���֣�&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ά��&lt;/th&gt;
&lt;th&gt;PCA&lt;/th&gt;
&lt;th&gt;LDA&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;����&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;�޼ල&lt;/td&gt;
&lt;td&gt;�мල&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Ŀ��&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;��󻯷��������Ҫ�ֲ���Ϣ&lt;/td&gt;
&lt;td&gt;��������룬��С�����ھ���&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;�Ƿ�ʹ�������Ϣ&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;? ��ʹ��&lt;/td&gt;
&lt;td&gt;? ʹ��&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;��������&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;����ѹ�������ӻ���ȥ��&lt;/td&gt;
&lt;td&gt;���������������ȡ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;��ά��ά������&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;�����⣬��һ��С��ԭά��&lt;/td&gt;
&lt;td&gt;��ཱུ�� $k-1$ ά��$k$ ���������&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;��ѧ����&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Э������������ֵ�ֽ�&lt;/td&gt;
&lt;td&gt;���&amp;#x2F;����ɢ�Ⱦ���Ĺ�������ֵ�ֽ�&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;������ά������&lt;ul&gt;
&lt;li&gt;�Ǹ�����ֽ� ��non-negative matrix factorization, NMF��&lt;/li&gt;
&lt;li&gt;��ά�߶ȷ���Metric multidimensional scaling, MDS��&lt;/li&gt;
&lt;li&gt;�ֲ�����Ƕ�루Locally Linear Embedding��LLE��&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;������������&#34;&gt;&lt;a href=&#34;#������������&#34; class=&#34;headerlink&#34; title=&#34;������������&#34;&gt;&lt;/a&gt;������������&lt;/h1&gt;&lt;p&gt;����ʱ��ÿ������ͼ��ת����������&lt;br&gt;&lt;img data-src=&#34;/f1.jpg&#34;&gt;&lt;br&gt;�㷨����&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;���룺$n$��1024ά�����������������ɵľ���$\mathbf{X}$����ά���ά��$l$&lt;/li&gt;
&lt;li&gt;�����ӳ�����$\mathbf{W} &amp;#x3D; {\mathbf{w}_1, \mathbf{w}_2, …, \mathbf{w}_l}$������ÿ��$\mathbf{w}_j (1 \leq j \leq l)$��һ������������&lt;br&gt;�㷨����&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;���Ļ�������&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;��ÿ��������������$x_i$�������Ļ�������&lt;br&gt;$$&lt;br&gt;x_i’ &amp;#x3D; x_i - \mu, \quad \mu &amp;#x3D; \frac{1}{n}\sum_{j&amp;#x3D;1}^{n} x_j&lt;br&gt;$$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;����Э�������&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;����ԭʼ�����������ݵ�Э�������&lt;br&gt;$$&lt;br&gt;\Sigma &amp;#x3D; \frac{1}{n-1} \mathbf{X}^T \mathbf{X}&lt;br&gt;$$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;����ֵ�ֽ⣺&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;��Э�������$\Sigma$��������ֵ�ֽ⣬���������������Ӵ�С����&lt;br&gt;$$&lt;br&gt;\lambda_1 \geq \lambda_2 \geq \cdots \geq \lambda_d&lt;br&gt;$$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;����ӳ�����&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ȡǰ$l$���������������Ӧ��������$\mathbf{w}_1, \mathbf{w}_2, …, \mathbf{w}_l$���ӳ�����$\mathbf{W}$��&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;���ݽ�ά��&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;��ÿ������ͼ��$x_i$�������·�����ά��&lt;br&gt;$$&lt;br&gt;(\mathbf{x}&lt;em&gt;i)&lt;/em&gt;{1 \times d} (\mathbf{W})_{d \times l} &amp;#x3D; 1 \times l&lt;br&gt;$$&lt;br&gt;����ʵ�õ���pca�����һ�����������ʱ���32*32��ͼ̯����1024*1�����������ѣ�&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;DZ�����������Latent-Semantic-Analysis-LSA��&#34;&gt;&lt;a href=&#34;#DZ�����������Latent-Semantic-Analysis-LSA��&#34; class=&#34;headerlink&#34; title=&#34;Ǳ�����������Latent Semantic Analysis, LSA��&#34;&gt;&lt;/a&gt;Ǳ�����������Latent Semantic Analysis, LSA��&lt;/h1&gt;&lt;p&gt;����&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;��������-�ĵ�����&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;����һ������-�ĵ�����$A$������ÿ��Ԫ��$a_{ij}$��ʾ��$i$�������ڵ�$j$���ĵ��е�Ƶ�ʣ�ͨ��ʹ�ô�Ƶ-���ĵ�Ƶ��TF-IDF���м�Ȩ����&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;����ֵ�ֽ⣨SVD����&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;�Ե���-�ĵ�����$A$��������ֵ�ֽ⣬��$A &amp;#x3D; U \Sigma V^T$������$U$��$V$�ֱ���������������������������ɵľ���$\Sigma$�ǶԽǾ�����Խ����ϵ�Ԫ����$A$������ֵ�����������У���&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ѡ��ǰ$k$���������ֵ����Ӧ������������&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ѡȡǰ$k$����������ֵ�����Ӧ�������������γɵ��ȱƽ�����$A_k &amp;#x3D; U_k \Sigma_k V_k^T$������$k$��ѡ��ȡ���ڱ�������ԭʼ��Ϣ����ͨ�������ۻ�����׼�����ȷ����&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;�ؽ������ھ������ϵ��&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ʹ��$A_k$����ԭʼ����$A$�����Լ������������ĵ�֮������ƶȣ���Ƥ��ѷ���ϵ�������Ӷ������ĵ�-�ĵ�֮��Ĺ�����ϵ��&lt;/li&gt;
&lt;li&gt;ͬ���أ�Ҳ��������̽������-���ʡ�����-�ĵ����������ϵ��&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;��������㷨��Expectation-Maximization-Algorithm-EM��&#34;&gt;&lt;a href=&#34;#��������㷨��Expectation-Maximization-Algorithm-EM��&#34; class=&#34;headerlink&#34; title=&#34;��������㷨��Expectation-Maximization Algorithm, EM��&#34;&gt;&lt;/a&gt;��������㷨��Expectation-Maximization Algorithm, EM��&lt;/h1&gt;&lt;p&gt;EM�㷨��һ�ֵ�����������Ҫ���ں����������ĸ���ģ�Ͳ����������⡣����Ϊ&amp;#x3D;&amp;#x3D;E������������&amp;#x3D;&amp;#x3D;��&amp;#x3D;&amp;#x3D;M������󻯣�&amp;#x3D;&amp;#x3D;��ͨ��������ʽ�ƽ�ģ�Ͳ����������Ȼ����ֵ��&lt;/p&gt;
&lt;p&gt;����&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;��ʼ��ģ�Ͳ�����&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;����Ϊģ�Ͳ����趨��ʼֵ�������˹���ģ���еľ�ֵ������ȣ���&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;E����Expectation Step��������������&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;���ڵ�ǰ��ģ�Ͳ����������������ĺ�����ʷֲ�������ÿһ������$x_i$�Ϳ��ܵ�������$z_i$������$p(z_i|x_i, \theta)$������$\theta$��ʾ��ǰ��ģ�Ͳ�����&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;M����Maximization Step���������Ȼ�����͸���ģ�Ͳ���&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;���ݹ۲�����$x_i$��������$z_i$�ĺ�����ʷֲ������¹���ģ�Ͳ���$\theta$��������������ݵĶ�����Ȼ����$\log p(x,z|\theta)$��������&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;�ظ�E����M����&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;�����ظ�ִ��E����M����ֱ��ģ�Ͳ����������ߴﵽԤ���ĵ�������Ϊֹ��&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;�����û���������Ҷ�����˵&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/06/12/AI/week6-7/</guid>
            <title>Week6-7</title>
            <link>http://example.com/2025/06/12/AI/week6-7/</link>
            <category>人工智能</category>
            <pubDate>Thu, 12 Jun 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Ch4-机器学习&#34;&gt;&lt;a href=&#34;#Ch4-机器学习&#34; class=&#34;headerlink&#34; title=&#34;Ch4 机器学习&#34;&gt;&lt;/a&gt;Ch4 机器学习&lt;/h1&gt;&lt;h2 id=&#34;监督学习&#34;&gt;&lt;a href=&#34;#监督学习&#34; class=&#34;headerlink&#34; title=&#34;监督学习&#34;&gt;&lt;/a&gt;监督学习&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;标注数据&lt;/li&gt;
&lt;li&gt;学习模型&lt;/li&gt;
&lt;li&gt;损失函数&lt;br&gt;典型的损失函数&lt;br&gt;&lt;img data-src=&#34;/figure2.png&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;经验风险(empirical risk )&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;训练集中数据产生的损失。&lt;/li&gt;
&lt;li&gt;经验风险越小说明学习模型对训练数据拟合程度越好。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;期望风险(expected risk):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当测试集中存在无穷多数据时产生的损失。&lt;/li&gt;
&lt;li&gt;期望风险越小，学习所得模型越好。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;经验风险最小化&lt;/p&gt;
&lt;p&gt;$$\min_{f \in \Phi} \frac{1}{n} \sum_{i&amp;#x3D;1}^{n} Loss(y_i, f(x_i))$$&lt;/p&gt;
&lt;p&gt;期望风险最小化&lt;/p&gt;
&lt;p&gt;$$\min_{f \in \Phi} \int_{x \times y} Loss(y, f(x)) P(x, y) dx dy$$&lt;/p&gt;
&lt;p&gt;模型泛化能力与经验风险、期望风险的关系&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;经验风险小（训练集上表现好）&lt;/th&gt;
&lt;th&gt;期望风险小（测试集上表现好）&lt;/th&gt;
&lt;th&gt;泛化能力强&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;经验风险小（训练集上表现好）&lt;/td&gt;
&lt;td&gt;期望风险大（测试集上表现不好）&lt;/td&gt;
&lt;td&gt;过学习（模型过于复杂）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;经验风险大（训练集上表现不好）&lt;/td&gt;
&lt;td&gt;期望风险大（测试集上表现不好）&lt;/td&gt;
&lt;td&gt;欠学习&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;经验风险大（训练集上表现不好）&lt;/td&gt;
&lt;td&gt;期望风险小（测试集上表现好）&lt;/td&gt;
&lt;td&gt;“神仙算法”或“黄粱美梦”&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;结构风险最小化 (structural risk minimization)&lt;/p&gt;
&lt;p&gt;为了防止过拟合，在经验风险上加上表示模型复杂度的正则化项 (regularizer) 或惩罚项 (penalty term):&lt;/p&gt;
&lt;p&gt;$$\min_{f \in \Phi} \frac{1}{n} \sum_{i&amp;#x3D;1}^{n} Loss(y_i, f(x_i)) + \lambda J(f)$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;经验风险: $\frac{1}{n} \sum_{i&amp;#x3D;1}^{n} Loss(y_i, f(x_i))$&lt;/li&gt;
&lt;li&gt;模型复杂度: $\lambda J(f)$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;监督学习方法又可以分为 生成方法 (generative approach) 和 判别方法(discriminative approach)。所学到的模型分别称为生成模型(generative model)和判别模型(discriminative model)&lt;br&gt;&lt;img data-src=&#34;/figure1.png&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;回归分析&#34;&gt;&lt;a href=&#34;#回归分析&#34; class=&#34;headerlink&#34; title=&#34;回归分析&#34;&gt;&lt;/a&gt;回归分析&lt;/h1&gt;&lt;h2 id=&#34;线性回归&#34;&gt;&lt;a href=&#34;#线性回归&#34; class=&#34;headerlink&#34; title=&#34;线性回归&#34;&gt;&lt;/a&gt;线性回归&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一元线性回归&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$y_i &amp;#x3D; ax_i + b \quad (1 \leq i \leq n)$$&lt;/p&gt;
&lt;p&gt;$$a &amp;#x3D; \frac{\sum_{i&amp;#x3D;1}^{n} x_i y_i - n \bar{x} \bar{y}}{\sum_{i&amp;#x3D;1}^{n} x_i^2 - n \bar{x}^2}$$&lt;/p&gt;
&lt;p&gt;$$b &amp;#x3D; \bar{y} - a \bar{x}$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;多元线性回归&lt;br&gt;$$f(x_i) &amp;#x3D; a_0 + \sum_{j&amp;#x3D;1}^{D} a_j x_{i,j} &amp;#x3D; a_0 + \mathbf{a}^T \mathbf{x}_i$$&lt;br&gt;a是要求的参数，x是输入的数据，f是预测值。&lt;br&gt;为了方便，使用矩阵来表示所有的训练数据和数据标签。&lt;br&gt;$$X &amp;#x3D; [x_1, …, x_m], \quad y &amp;#x3D; [y_1, …, y_m]$$&lt;br&gt;最小化均方误差得到：&lt;br&gt;$$a &amp;#x3D; (XX^T)^{-1}X^Ty$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;逻辑斯蒂回归&amp;#x2F;对数几率回归&lt;br&gt;线性回归一个明显的问题是对离群点导致模型建模不稳定，使结果有偏，为了缓解这个问题（特别是在二分类场景中）带来的影响，可考虑逻辑斯蒂回归&lt;br&gt;逻辑斯蒂回归就是在回归模型中引入 sigmoid函数的一种非线性回归模型&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;逻辑斯蒂回归-Logistic-Regression&#34;&gt;&lt;a href=&#34;#逻辑斯蒂回归-Logistic-Regression&#34; class=&#34;headerlink&#34; title=&#34;逻辑斯蒂回归 (Logistic Regression)&#34;&gt;&lt;/a&gt;逻辑斯蒂回归 (Logistic Regression)&lt;/h2&gt;&lt;p&gt;逻辑斯蒂回归（logistic regression）就是在回归模型中引入 sigmoid 函数的一种非线性回归模型。Logistic 回归模型可如下表示：&lt;/p&gt;
&lt;p&gt;$$ y &amp;#x3D; \frac{1}{1 + e^{-z}} &amp;#x3D; \frac{1}{1 + e^{-(w^T x + b)}} $$&lt;br&gt;其中 $y \in (0, 1)$，$z &amp;#x3D; w^T x + b$。&lt;br&gt;这里 $\frac{1}{1 + e^{-z}}$ 是 sigmoid 函数，$x \in \mathbb{R}^d$ 是输入数据，$w \in \mathbb{R}^d$ 和 $b \in \mathbb{R}$ 是回归函数的参数。&lt;/p&gt;
&lt;p&gt;逻辑斯蒂回归多用于&amp;#x3D;&amp;#x3D;二分类&amp;#x3D;&amp;#x3D;问题&lt;br&gt;Sigmoid 函数将任意实数映射到区间(0,1)，这正好符合“概率”的取值范围，所以函数的输出y可以被解释为输入数据x属于正例的概率&lt;br&gt;因此我们可以将输出 y 解释为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在给定输入特征 x 的条件下，该样本属于正类（例如类别 1）的概率。&lt;br&gt;即：&lt;br&gt;$$&lt;br&gt;y &amp;#x3D; P(y &amp;#x3D; 1 \mid x)&lt;br&gt;$$&lt;br&gt;如果 $P(y&amp;#x3D;1|x)$ 表示给定输入 $x$ 属于正类的概率，则 $1 - P(y&amp;#x3D;1|x)$ 表示属于负类的概率。&lt;br&gt;$\frac{P(y&amp;#x3D;1|x)}{1 - P(y&amp;#x3D;1|x)}$ 就是正类相对于负类的优势比。所以&amp;gt;1就归为正类，反之就是负类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;$$&lt;br&gt;\log \frac{P(y&amp;#x3D;1|x)}{P(y&amp;#x3D;0|x)} &amp;#x3D; {w^T x + b} &amp;gt; \log{1} &amp;#x3D; 0&lt;br&gt;$$&lt;br&gt;从这里可以看出，logistic回归本质上是一个线性模型。在预测时，可以计算线性函数$w^T x + b$取值是否大于0来判断输入数据x的类别归属&lt;/p&gt;
&lt;p&gt;为了找到最优参数w和b，我们使用最大似然估计，假设每个样本独立同分布，则&lt;br&gt;……&lt;br&gt;公式懒得敲了，&lt;/p&gt;
&lt;p&gt;为什么基于相关性的方法可能会导致模型的不可解释性和不稳定性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因果特征和非因果特征&lt;/li&gt;
&lt;li&gt;Making V⊥Y: 最终目标是让非因果特征 V 与输出 Y 独立，即消除虚假相关性，使得模型更加稳定和可解释&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;决策树&#34;&gt;&lt;a href=&#34;#决策树&#34; class=&#34;headerlink&#34; title=&#34;决策树&#34;&gt;&lt;/a&gt;决策树&lt;/h1&gt;&lt;p&gt;决策树是一种通过树形结构来进行分类的方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信息熵（entropy）是度量样本集合纯度最常用的一种指标&lt;br&gt;假设有一个K个信息（类别），其组成了集合样本D，记第k个信息（类别）发生的概率为$p_k (1 \leq k \leq K)$。如下定义这K个信息的信息熵：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$Ent(D) &amp;#x3D; -\sum_{k&amp;#x3D;1}^{K} p_k \log_2 p_k$$&lt;/p&gt;
&lt;p&gt;&amp;#x3D;&amp;#x3D;$Ent(D)$值越小，表示D包含的信息越确定，也称D的纯度越高。&amp;#x3D;&amp;#x3D;所有$p_k$累加起来的和为1。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信息增益:衡量使用某个属性进行划分后，数据集不确定性减少的程度&lt;br&gt;得到信息熵后可以进一步计算信息增益：&lt;br&gt;$$Gain(D, A) &amp;#x3D; Ent(D) - \sum_{i&amp;#x3D;1}^{n} \frac{|D_i|}{|D|} Ent(D_i)$$&lt;br&gt;&lt;img data-src=&#34;/f3.png&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/f4.png&#34;&gt;&lt;br&gt;ID3决策树学习算法[Quinlan, 1986]以信息增益为准则来选择划分属性&lt;br&gt;目标：通过不断划分，使得每个子集尽可能“纯净”，即子集内的样本属于同一类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;信息熵（和上面的一样的）&lt;br&gt;$$&lt;br&gt;info &amp;#x3D; -\sum_{i&amp;#x3D;1}^{n} \frac{|D_i|}{|D|} \log_2 \frac{|D_i|}{|D|}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;增益率（Gain-ratio）：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;Gain-ratio &amp;#x3D; \frac{Gain(D, A)}{info}&lt;br&gt;$$&lt;br&gt;存在的问题：增益率准则对可取数目较少的属性有所偏好&lt;/p&gt;
&lt;p&gt;另一种计算更简的度量指标是如下的 Gini 指数（基尼指数）：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;Gini(D) &amp;#x3D; 1 - \sum_{k&amp;#x3D;1}^{K} p_k^2&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;相对于信息熵的计算 $E(D) &amp;#x3D; -\sum_{k&amp;#x3D;1}^{K} p_k \log_2 p_k$，不用计算对数 log，计算更为简易。&lt;/p&gt;
&lt;h2 id=&#34;连续属性离散化&#34;&gt;&lt;a href=&#34;#连续属性离散化&#34; class=&#34;headerlink&#34; title=&#34;连续属性离散化&#34;&gt;&lt;/a&gt;连续属性离散化&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;确定连续属性的取值范围，确定划分点集合&lt;br&gt;考虑包含 n-1 个元素的候选划分点集合：&lt;br&gt;$$&lt;br&gt;T_a &amp;#x3D; \left{ \frac{a^i + a^{i+1}}{2} ,\middle|, 1 \leq i \leq n - 1 \right}&lt;br&gt;$$&lt;br&gt;这里的每个候选划分点是相邻两个取值的中点，即区间 $[a^i, a^{i+1})$ 的中位点 $\frac{a^i + a^{i+1}}{2}$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;计算信息增益&lt;br&gt;$$&lt;br&gt;\text{Gain}(D, a, t) &amp;#x3D; \text{Ent}(D) - \sum_{\lambda \in {-, +}} \frac{|D_t^\lambda|}{|D|} \cdot \text{Ent}(D_t^\lambda)&lt;br&gt;$$&lt;br&gt;计算每个划分点的信息增益率，选择信息增益最大的划分点&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;+++info example&lt;br&gt;;;;id3 example&lt;br&gt;给定数据点及其对应的类别标签如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$a_1 &amp;#x3D; 1$ -&amp;gt; 类别为 0&lt;/li&gt;
&lt;li&gt;$a_2 &amp;#x3D; 3$ -&amp;gt; 类别为 1&lt;/li&gt;
&lt;li&gt;$a_3 &amp;#x3D; 5$ -&amp;gt; 类别为 0&lt;/li&gt;
&lt;li&gt;$a_4 &amp;#x3D; 7$ -&amp;gt; 类别为 1&lt;/li&gt;
&lt;li&gt;$a_5 &amp;#x3D; 9$ -&amp;gt; 类别为 0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，我们的数据集 $D$ 是 ${1, 3, 5, 7, 9}$，对应的类别标签分别为 ${0, 1, 0, 1, 0}$。&lt;/p&gt;
&lt;p&gt;第一步：计算原始数据集的信息熵&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;Ent(D) &amp;#x3D; -\left( p_0 \log_2 p_0 + p_1 \log_2 p_1 \right)&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;其中，$p_0 &amp;#x3D; \frac{3}{5}$，$p_1 &amp;#x3D; \frac{2}{5}$，则：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;Ent(D) &amp;#x3D; -\left( \frac{3}{5} \log_2 \frac{3}{5} + \frac{2}{5} \log_2 \frac{2}{5} \right) \approx 0.971&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;第二步：确定候选划分点集合&lt;/p&gt;
&lt;p&gt;根据公式 $T_a &amp;#x3D; \left{ \frac{a^i + a^{i+1}}{2} ,\middle|, 1 \leq i \leq n - 1 \right}$，我们得到候选划分点集合：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;T_a &amp;#x3D; {2, 4, 6, 8}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;第三步：计算每个候选划分点的信息增益&lt;/p&gt;
&lt;p&gt;以划分点 $t &amp;#x3D; 4$ 为例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$D_t^{-} &amp;#x3D; {1, 3}$，类别为 ${0, 1}$&lt;/li&gt;
&lt;li&gt;$D_t^{+} &amp;#x3D; {5, 7, 9}$，类别为 ${0, 1, 0}$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;计算这两个子集的熵：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$$Ent(D_t^{-}) &amp;#x3D; -\left( \frac{1}{2} \log_2 \frac{1}{2} + \frac{1}{2} \log_2 \frac{1}{2} \right) &amp;#x3D; 1$$&lt;/li&gt;
&lt;li&gt;$$Ent(D_t^{+}) &amp;#x3D; -\left( \frac{2}{3} \log_2 \frac{2}{3} + \frac{1}{3} \log_2 \frac{1}{3} \right) \approx 0.918$$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;计算信息增益：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;Gain(D, a, t&amp;#x3D;4) &amp;#x3D; Ent(D) - \left( \frac{|D_t^{-}|}{|D|} \cdot Ent(D_t^{-}) + \frac{|D_t^{+}|}{|D|} \cdot Ent(D_t^{+}) \right)&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;代入数值：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;Gain(D, a, t&amp;#x3D;4) &amp;#x3D; 0.971 - \left( \frac{2}{5} \cdot 1 + \frac{3}{5} \cdot 0.918 \right) \approx 0.029&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;重复上述过程，对所有划分点 $t &amp;#x3D; 2, 4, 6, 8$ 进行类似计算，并选择使 $Gain(D, a, t)$ 最大的那个作为最优划分点。&lt;br&gt;;;;&lt;br&gt;+++&lt;/p&gt;
&lt;h1 id=&#34;线性区别分析-LDA-FDA&#34;&gt;&lt;a href=&#34;#线性区别分析-LDA-FDA&#34; class=&#34;headerlink&#34; title=&#34;线性区别分析 (LDA&amp;#x2F;FDA)&#34;&gt;&lt;/a&gt;线性区别分析 (LDA&amp;#x2F;FDA)&lt;/h1&gt;&lt;p&gt;线性判别分析(linear discriminant analysis， LDA)是一种基于监督学习的降维方法，也称为Fisher线性判别分析(fisher’s discriminant analysis，FDA),对于一组具有标签信息的高维数据样本，LDA利用其类别信息，将其线性投影到一个低维空间上，在低维空间中同一类别样本尽可能靠近，不同类别样本尽可能彼此远离。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算数据样本集中每个类别样本的均值&lt;/li&gt;
&lt;li&gt;计算类内散度矩阵$S_w$和类间散度矩阵$S_b$&lt;/li&gt;
&lt;li&gt;根据$S_w^{-1}S_bW&amp;#x3D;\lambda W$来求解$S_w^{-1}S_b$所对应前$r$个最大特征值所对应特征向量$(w_1,w_2,…,w_r)$，构成矩阵W&lt;/li&gt;
&lt;li&gt;通过矩阵$W$将每个样本映射到低维空间，实现特征降维。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体不想看，考到就给了&lt;/p&gt;
&lt;h1 id=&#34;Ada-Boosting&#34;&gt;&lt;a href=&#34;#Ada-Boosting&#34; class=&#34;headerlink&#34; title=&#34;Ada Boosting&#34;&gt;&lt;/a&gt;Ada Boosting&lt;/h1&gt;&lt;p&gt;。。看不懂懒得看&lt;/p&gt;
&lt;h1 id=&#34;支持向量机&#34;&gt;&lt;a href=&#34;#支持向量机&#34; class=&#34;headerlink&#34; title=&#34;支持向量机&#34;&gt;&lt;/a&gt;支持向量机&lt;/h1&gt;&lt;h1 id=&#34;生成学习模型&#34;&gt;&lt;a href=&#34;#生成学习模型&#34; class=&#34;headerlink&#34; title=&#34;生成学习模型&#34;&gt;&lt;/a&gt;生成学习模型&lt;/h1&gt; ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/06/11/AI/week4-5/</guid>
            <title>Week4-5</title>
            <link>http://example.com/2025/06/11/AI/week4-5/</link>
            <category>人工智能</category>
            <pubDate>Wed, 11 Jun 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;#Ch3 搜索算法&lt;/p&gt;
&lt;h2 id=&#34;无信息搜索&#34;&gt;&lt;a href=&#34;#无信息搜索&#34; class=&#34;headerlink&#34; title=&#34;无信息搜索&#34;&gt;&lt;/a&gt;无信息搜索&lt;/h2&gt;&lt;p&gt;BFS DFS 略&lt;/p&gt;
&lt;h2 id=&#34;启发式搜索&#34;&gt;&lt;a href=&#34;#启发式搜索&#34; class=&#34;headerlink&#34; title=&#34;启发式搜索&#34;&gt;&lt;/a&gt;启发式搜索&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;贪婪优先搜索&lt;ul&gt;
&lt;li&gt;每次取最短的；缺点：不一定是最优的&lt;/li&gt;
&lt;li&gt;时间和空间复杂度均为 $O(b_m)$，b是搜索树分支因子，m是最大深度&lt;br&gt;&lt;img data-src=&#34;/figure1.png&#34;&gt;&lt;br&gt;:::info&lt;br&gt;每次取当前节点的下一个节点到终点中直线距离最短的&lt;br&gt;:::&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A*算法&lt;ul&gt;
&lt;li&gt;评价函数：f(n) &amp;#x3D; g(n) + h(n)&lt;/li&gt;
&lt;li&gt;代价函数 g(n) 表示从起始结点到结点n的开销代价值&lt;/li&gt;
&lt;li&gt;启发函数 h(n) 表示从结点n到目标结点路径中所估算的最小开销代价值。&lt;/li&gt;
&lt;li&gt;评价函数 f(n) 可视为经过结点n、具有最小开销代价值的路径。&lt;ul&gt;
&lt;li&gt;在最短路径问题中，g(?)为当前选择的路径的实际距离，即从上一个节点到下一个节点的实际距离，?(?)为下一个节点到目标城市的直线距离。每一次搜索，下一个节点选择与此刻城市连接的所有节点中，g(?)+?(?)最小的城市节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;:::info&lt;br&gt;取（当前节点到下一节点的距离+下一节点到目标城市的距离）最短的&lt;br&gt;:::&lt;br&gt;A*算法的完备性和最优性取决于搜索问题和启发函数的性质&lt;br&gt;一个良好的启发函数需要满足:可容性（admissible）;一致性（consistency）&lt;br&gt;如果启发函数是可容的，那么树搜索的A*算法满足最优性(最优性:搜索算法是否能保证找到的第一个解是最优解)&lt;br&gt;满足一致性条件的启发函数一定满足可容性条件，反之不一定&lt;/p&gt;
&lt;h2 id=&#34;对抗搜索&#34;&gt;&lt;a href=&#34;#对抗搜索&#34; class=&#34;headerlink&#34; title=&#34;对抗搜索&#34;&gt;&lt;/a&gt;对抗搜索&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;最小最大搜索（minimax）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最小最大搜索是一个在你和对手轮流行动的情况下，为你自己寻找最优策略的算法。&lt;/li&gt;
&lt;li&gt;算法：略&lt;/li&gt;
&lt;li&gt;时间复杂度：$O(b^m)$&lt;/li&gt;
&lt;li&gt;空间复杂度：$O(bm)$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\alpha-\beta剪枝&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Minimax 会穷举整个博弈树，但我们可以用剪枝技巧跳过一些无用分支，让它跑得更快&lt;/li&gt;
&lt;li&gt;max层的下界取下一层（上界）里面最大的；min层的上界取下一层（下界）里面最小的&lt;br&gt;懒得写直接看例子：&lt;br&gt;&lt;img data-src=&#34;/figure2.png&#34;&gt;&lt;br&gt; Alpha-Beta 剪枝算法什么时候扩展的结点数量最少？&lt;/li&gt;
&lt;li&gt;每一层最左端结点的所有孩子结点均被访问，其他节点仅有最左端孩子结点被访问、其他孩子结点被剪枝。&lt;br&gt; 如果一个节点导致了其兄弟节点被剪枝，可知其孩子节点必然被扩展。&lt;/li&gt;
&lt;li&gt;最优效率下时间复杂度：$O(b^{m&amp;#x2F;2})$  (或者m+1);最差的就是完全没剪枝和minimax一样&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;蒙特卡洛树搜索&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择(UCB)、扩展(随机)、模拟(随机)、反向传播&lt;/li&gt;
&lt;li&gt;悔值函数&lt;br&gt;:::info&lt;br&gt;没完全懂，后面再回来研究&lt;br&gt;:::&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/05/20/AI/week1/</guid>
            <title>Week1</title>
            <link>http://example.com/2025/05/20/AI/week1/</link>
            <category>人工智能</category>
            <pubDate>Tue, 20 May 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;blockquote&gt;
&lt;p&gt;2025-2026春夏人工智能课程笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;Ch1-绪论&#34;&gt;&lt;a href=&#34;#Ch1-绪论&#34; class=&#34;headerlink&#34; title=&#34;Ch1 绪论&#34;&gt;&lt;/a&gt;Ch1 绪论&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;人工智能求解：&lt;ul&gt;
&lt;li&gt;以符号主义为核心的逻辑推理：将概念（如命题等）符号化，从若干判断（前提）出发得到新判断（结论）&lt;/li&gt;
&lt;li&gt;以问题求解为核心的探寻搜索:探寻搜索依据已有信息来寻找满足约束条件的待求解问题的答案&lt;/li&gt;
&lt;li&gt;以数据驱动为核心的机器学习:从数据中发现数据所承载语义（如概念）的内在模式&lt;/li&gt;
&lt;li&gt;以行为主义为核心的强化学习:根据环境所提供的奖罚反馈来学习所处状态可施加的最佳行动，在“探索（未知空间）-利用（已有经验）（exploration vs. exploitation）”之间寻找平衡，完成某个序列化任务，具备自我学习能力&lt;/li&gt;
&lt;li&gt;以博弈对抗为核心的群体智能:从“数据拟合”优化解的求取向“均衡解”的求取迈进&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/05/20/AI/week2-3/</guid>
            <title>Week2-3</title>
            <link>http://example.com/2025/05/20/AI/week2-3/</link>
            <category>人工智能</category>
            <pubDate>Tue, 20 May 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Ch2-知识表达与推理&#34;&gt;&lt;a href=&#34;#Ch2-知识表达与推理&#34; class=&#34;headerlink&#34; title=&#34;Ch2 知识表达与推理&#34;&gt;&lt;/a&gt;Ch2 知识表达与推理&lt;/h1&gt;&lt;h2 id=&#34;命题逻辑&#34;&gt;&lt;a href=&#34;#命题逻辑&#34; class=&#34;headerlink&#34; title=&#34;命题逻辑&#34;&gt;&lt;/a&gt;命题逻辑&lt;/h2&gt;&lt;p&gt;&lt;img data-src=&#34;/img1.png&#34;&gt;&lt;br&gt;真值表：&lt;br&gt;&lt;img data-src=&#34;/img2.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“条件”命题联结词中前提为假时命题结论永远为真，bi-conditional只有两个都是true或者都是false才是true&lt;br&gt;逻辑等价：给定命题p和命题q，如果&amp;#x3D;&amp;#x3D;p和q在所有情况下都具有同样真假结果&amp;#x3D;&amp;#x3D;，那么p和q在逻辑上等价，一般用 $\equiv$ 来表示，即p $\equiv$ q。&lt;br&gt;判断逻辑等价：画真值表&lt;br&gt;逻辑等价式：&lt;br&gt;&lt;img data-src=&#34;/img3.jpg&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/img4.png&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;normal form&lt;ul&gt;
&lt;li&gt;有限个简单合取式构成的析取式称为析取(or)范式&lt;/li&gt;
&lt;li&gt;由有限个简单析取式构成的合取式称为合取(and)范式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;谓词逻辑&#34;&gt;&lt;a href=&#34;#谓词逻辑&#34; class=&#34;headerlink&#34; title=&#34;谓词逻辑&#34;&gt;&lt;/a&gt;谓词逻辑&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;全称量词与存在量词&lt;/li&gt;
&lt;li&gt;约束变元、自由变元&lt;br&gt;:::info&lt;br&gt;在约束变元相同的情况下，量词的运算满足分配律：全称量词对析取没有分配律、存在量词对合取没有分配律&lt;br&gt;:::&lt;br&gt;$$\begin{aligned}&lt;br&gt;(\forall x)(A(x) \lor B(x)) \equiv (\forall x)A(x) \lor (\forall x)B(x) 不成立&lt;br&gt;\end{aligned}$$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$\begin{aligned}&lt;br&gt;(\forall x)(A(x) \land B(x)) \equiv (\forall x)A(x) \land (\forall x)B(x) 成立&lt;br&gt;\end{aligned}$$&lt;/p&gt;
&lt;p&gt;$$\begin{aligned}&lt;br&gt;(\exists x)(A(x) \lor B(x)) \equiv (\exists x)A(x) \lor (\exists x)B(x) 成立&lt;br&gt;\end{aligned}$$&lt;/p&gt;
&lt;p&gt;$$\begin{aligned}&lt;br&gt;(\exists x)(A(x) \land B(x)) \equiv (\exists x)A(x) \land (\exists x)B(x) 不成立&lt;br&gt;\end{aligned}$$&lt;br&gt;:::info&lt;br&gt;当公式中存在多个量词时，若多个量词都是全称量词或者都是存在量词，则量词的位置可以互换；若多个量词中既有全称量词又有存在量词，则量词的位置不可以随意互换&lt;br&gt;:::&lt;br&gt;$$\begin{aligned}&lt;br&gt;(\forall x)(\forall y)A(x, y) \equiv (\forall y)(\forall x)A(x, y)&lt;br&gt;\end{aligned}$$&lt;/p&gt;
&lt;p&gt;$$\begin{aligned}&lt;br&gt;(\exists x)(\exists y)A(x, y) \equiv (\exists y)(\exists x)A(x, y)&lt;br&gt;\end{aligned}$$&lt;/p&gt;
&lt;p&gt;$$\begin{aligned}&lt;br&gt;(\forall x)(\forall y)A(x, y) \equiv (\exists y)(\forall x)A(x, y)&lt;br&gt;\end{aligned}$$&lt;/p&gt;
&lt;p&gt;$$\begin{aligned}&lt;br&gt;(\forall x)(\forall y)A(x, y) \equiv (\exists x)(\forall y)A(x, y)&lt;br&gt;\end{aligned}$$&lt;/p&gt;
&lt;p&gt;$$\begin{aligned}&lt;br&gt;(\exists y)(\forall x)A(x, y) \equiv (\forall x)(\exists y)A(x, y)&lt;br&gt;\end{aligned}$$&lt;/p&gt;
&lt;p&gt;$$\begin{aligned}&lt;br&gt;(\exists x)(\forall y)A(x, y) \equiv (\forall y)(\exists x)A(x, y)&lt;br&gt;\end{aligned}$$&lt;/p&gt;
&lt;p&gt;$$\begin{aligned}&lt;br&gt;(\forall x)(\exists y)A(x, y) \equiv (\exists y)(\exists x)A(x, y)&lt;br&gt;\end{aligned}$$&lt;/p&gt;
&lt;p&gt;$$\begin{aligned}&lt;br&gt;(\forall y)(\exists x)A(x, y) \equiv (\exists x)(\exists y)A(x, y)&lt;br&gt;\end{aligned}$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用谓词逻辑进行推理&lt;ul&gt;
&lt;li&gt;全称量词消去： $(\forall x) A(x) \equiv A(y)$&lt;/li&gt;
&lt;li&gt;全称量词引入： $A(y) \equiv (\forall x) A(x)$&lt;/li&gt;
&lt;li&gt;存在量词消去： $(\exists x) A(x) \equiv A(c)$&lt;/li&gt;
&lt;li&gt;存在量词引入： $A(c) \equiv (\exists x) A(x)$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;知识图谱推理&#34;&gt;&lt;a href=&#34;#知识图谱推理&#34; class=&#34;headerlink&#34; title=&#34;知识图谱推理&#34;&gt;&lt;/a&gt;知识图谱推理&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;知识图谱可视为包含多种关系的图。在图中，每个节点是一个实体（如人名、地名、事件和活动等），任意两个节点之间的边表示这两个节点之间存在的关系。&lt;/li&gt;
&lt;li&gt;可将知识图谱中任意两个相连节点及其连接边表示成一个三元组（triplet）,即 (left_node, relation, right_node)&lt;br&gt;两类代表性方法：&lt;/li&gt;
&lt;li&gt;归纳逻辑程序设计 (inductive logic programming，ILP)算法&lt;/li&gt;
&lt;li&gt;路径排序算法（path ranking algorithm, PRA）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ILP: 一阶归纳学习FOIL（First Order Inductive Learner）&lt;br&gt;推理手段: 正例集合 + 反例集合 + 背景知识样例 ⟹ 目标谓词作为结论的推理规则&lt;br&gt;&lt;img data-src=&#34;/img5.png&#34;&gt;&lt;br&gt;懒得写了，看ppt吧&lt;br&gt;&lt;img data-src=&#34;/img6.png&#34;&gt;&lt;br&gt;推理规则覆盖所有正例且不覆盖任何反例的时候算法结束&lt;/p&gt;
&lt;p&gt;PRA: 路径排序算法&lt;br&gt;&lt;img data-src=&#34;/img7.png&#34;&gt;&lt;br&gt;(4)的意思是看两个实体能不能通过(3)的关系从第一个走到第二个。&lt;br&gt;后面的1表示正例，-1表示负例。&lt;/p&gt;
&lt;h2 id=&#34;概率图推理&#34;&gt;&lt;a href=&#34;#概率图推理&#34; class=&#34;headerlink&#34; title=&#34;概率图推理&#34;&gt;&lt;/a&gt;概率图推理&lt;/h2&gt;&lt;p&gt;贝叶斯网络&lt;br&gt;马尔科夫逻辑网络&lt;/p&gt;
&lt;h2 id=&#34;因果推理&#34;&gt;&lt;a href=&#34;#因果推理&#34; class=&#34;headerlink&#34; title=&#34;因果推理&#34;&gt;&lt;/a&gt;因果推理&lt;/h2&gt;&lt;p&gt;因果定义：变量X是变量Y的原因，当且仅当保持其它所有变量不变的情况下，改变X的值能导致Y的值发生变化。&lt;br&gt;因果效应：因变量X改变一个单位时，果变量Y的变化程度&lt;/p&gt;
&lt;p&gt;因果图是有向无环图&lt;/p&gt;
&lt;p&gt;结构因果模型：结构因果模型由两组变量集合U和V以及一组函数f组成。其中，f是根据模型中其他变量取值而给V中每一个变量赋值的函数&lt;br&gt;结构因果模型中的原因：如果变量X出现在给变量X赋值的函数中，如$Y &amp;#x3D; f(X) + \epsilon$，则X是Y的直接原因&lt;br&gt;因果图中的联合概率分布：直接看图&lt;br&gt;&lt;img data-src=&#34;/img8.png&#34;&gt;&lt;br&gt;因果图的基本结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链结构&lt;br&gt;  - &lt;img data-src=&#34;/img9.png&#34;&gt;&lt;br&gt;  - 对于变量X和Y，若X和Y之间只有一条单向的路径，变量Z是截断(intercept)该路径的集合中的任一变量，则在给定Z时，X和Y条件独立。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$&lt;br&gt;P(X, Y | Z) &amp;#x3D; P(X | Z)P(Y | Z)&lt;br&gt;$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分连结构&lt;br&gt;  - &lt;img data-src=&#34;/img10.png&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$&lt;br&gt;P(X, Y | Z) &amp;#x3D; \frac {P(X, Y, Z)}{P(Z)} &amp;#x3D; \frac {P(X | Z)P(Y | Z)P(Z)}{P(Z)} &amp;#x3D; P(X | Z)P(Y | Z)&lt;br&gt;$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;汇联结构&lt;br&gt;  - &lt;img data-src=&#34;/img11.png&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$&lt;br&gt;P(X, Y | Z) &amp;#x3D; \frac{P(X, Y, Z)} {P(Z)} &amp;#x3D; \frac {P(X, Y, Z)}{P(Z)} &amp;#x3D; \frac {P(X)P(Y)P(Z&amp;#x2F;X, Y)}{P(Z)} \neq P(X | Z)P(Y | Z)&lt;br&gt;$$&lt;/p&gt;
&lt;h3 id=&#34;D-分离-directional-separation-d-separation-，可用于判断任意两个节点的相关性和独立性&#34;&gt;&lt;a href=&#34;#D-分离-directional-separation-d-separation-，可用于判断任意两个节点的相关性和独立性&#34; class=&#34;headerlink&#34; title=&#34;D-分离(directional separation, d-separation)，可用于判断任意两个节点的相关性和独立性&#34;&gt;&lt;/a&gt;D-分离(directional separation, d-separation)，可用于判断任意两个节点的相关性和独立性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;限定集：已知或观察到的变量集合（给定的变量集合）&lt;/li&gt;
&lt;li&gt;路径p被限定集Z阻塞(block)当且仅当：&lt;ul&gt;
&lt;li&gt;(1) 路径p含有链结构A → B → C或分连结构A ← B → C且中间节点B在Z中，或&lt;/li&gt;
&lt;li&gt;(2) 路径p含有汇连结构A → B ← C且汇连节点B及其后代都不在Z中。&lt;/li&gt;
&lt;li&gt;若Z阻塞了节点X和节点Y之间的每一条路径，则称给定Z时，X和Y是D-分离，即给定Z时，X和Y条件独立&lt;/li&gt;
&lt;li&gt;&amp;#x3D;&amp;#x3D;链式、分连中间节点在，汇联中间节点和后代不在则D-分离&amp;#x3D;&amp;#x3D;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因果定义：变量X是变量Y的原因，当且仅当保持其它所有变量不变的情况下，改变X的值能导致Y的值发生变化。&lt;br&gt;因果效应：因变量X改变一个单位时，果变量Y的变化程度因果推理的两个关键因素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;改变因变量T&lt;/li&gt;
&lt;li&gt;保证其它变量不变&lt;br&gt;干预：干预(intervention)指的是固定(fix)系统中的变量，然后改变系统，观察其他变量的变化。&lt;br&gt;为了与X自然取值x时进行区分，在对X进行干预时，引入“do算子”(do-calculus)，记作do(X &amp;#x3D; x)。&lt;br&gt;因此，P(Y &amp;#x3D; y|X &amp;#x3D; x)表示的是当发现X &amp;#x3D; x时，Y&amp;#x3D; y的概率；而P(Y &amp;#x3D; y|do(X &amp;#x3D;x))表示的是对X进行干预，固定其值为x时，Y &amp;#x3D; y的概率。&lt;br&gt;用统计学的术语来说，P(Y &amp;#x3D; y|X &amp;#x3D; x)反映的是在取值为x的个体X上，Y的总体分布；而P(Y &amp;#x3D; y|do(X &amp;#x3D;x))反映的是如果将每一个X取值都固定为x时，Y的总体分布。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因果效应差&amp;#x2F;平均因果效应 (ACE)  懒得写了看图吧&lt;br&gt;&lt;img data-src=&#34;/img12.png&#34;&gt;&lt;br&gt;&lt;img data-src=&#34;/img13.png&#34;&gt;&lt;br&gt;计算因果效应的关键在于计算操纵概率(manipulatedprobability) $P_m$&lt;br&gt;调整公式：&lt;br&gt;$$&lt;br&gt;P(Y &amp;#x3D; y \mid do(X &amp;#x3D; x)) &amp;#x3D; \sum_z P(Y &amp;#x3D; y \mid X &amp;#x3D; x, Z &amp;#x3D; z) \cdot P(Z &amp;#x3D; z)&lt;br&gt;$$&lt;br&gt;对于Z的每一个取值z，计算X和Y的条件概率并取均值&lt;br&gt;+++info example&lt;br&gt;;;;id3 例题&lt;br&gt;假设我们研究以下变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;X：是否服药  &lt;ul&gt;
&lt;li&gt;$X &amp;#x3D; 1$：服药  &lt;/li&gt;
&lt;li&gt;$X &amp;#x3D; 0$：不服药&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Y：是否康复  &lt;ul&gt;
&lt;li&gt;$Y &amp;#x3D; 1$：康复  &lt;/li&gt;
&lt;li&gt;$Y &amp;#x3D; 0$：未康复&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Z：性别  &lt;ul&gt;
&lt;li&gt;$Z &amp;#x3D; 0$：男  &lt;/li&gt;
&lt;li&gt;$Z &amp;#x3D; 1$：女&lt;br&gt;我们知道性别会影响：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;是否选择服药（比如男性更倾向于尝试新药）&lt;/li&gt;
&lt;li&gt;康复率（比如女性可能有更强的免疫力）&lt;br&gt;因此，性别 Z 是一个混杂变量，需要在分析中进行控制。&lt;br&gt;已知：&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Z（性别）&lt;/th&gt;
&lt;th&gt;P(Z)&lt;/th&gt;
&lt;th&gt;P(Y&amp;#x3D;1 | X&amp;#x3D;1, Z)&lt;/th&gt;
&lt;th&gt;P(Y&amp;#x3D;1 | X&amp;#x3D;0, Z)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;男（0）&lt;/td&gt;
&lt;td&gt;0.6&lt;/td&gt;
&lt;td&gt;0.7&lt;/td&gt;
&lt;td&gt;0.4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;女（1）&lt;/td&gt;
&lt;td&gt;0.4&lt;/td&gt;
&lt;td&gt;0.5&lt;/td&gt;
&lt;td&gt;0.3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;我们想知道：&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;如果强制所有人都服药（即 $do(X&amp;#x3D;1)$），整体康复率是多少？&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;也就是要计算：&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P(Y&amp;#x3D;1 \mid do(X&amp;#x3D;1))&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;;;;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;;;;id3 答案&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;根据调整公式：&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$&lt;br&gt;P(Y&amp;#x3D;1 \mid do(X&amp;#x3D;1)) &amp;#x3D; \sum_z P(Y&amp;#x3D;1 \mid X&amp;#x3D;1, Z&amp;#x3D;z) \cdot P(Z&amp;#x3D;z)&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;代入数据计算&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;P(Y&amp;#x3D;1 \mid do(X&amp;#x3D;1)) &amp;#x3D; P(Y&amp;#x3D;1 \mid X&amp;#x3D;1, Z&amp;#x3D;0) \cdot P(Z&amp;#x3D;0) + P(Y&amp;#x3D;1 \mid X&amp;#x3D;1, Z&amp;#x3D;1) \cdot P(Z&amp;#x3D;1)&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;&amp;#x3D; 0.7 \times 0.6 + 0.5 \times 0.4 &amp;#x3D; 0.42 + 0.2 &amp;#x3D; 0.62&lt;br&gt;$$&lt;br&gt;+++&lt;/p&gt;
&lt;p&gt;(因果效应)给定因果图G，PA表示X的父节点集合，则X对Y的因果效应为&lt;br&gt;$$&lt;br&gt;P(Y&amp;#x3D;y \mid do(X&amp;#x3D;x)) &amp;#x3D; \sum_z P(Y&amp;#x3D;y \mid X&amp;#x3D;x, PA&amp;#x3D;z) \cdot P(PA&amp;#x3D;z)&lt;br&gt;$$&lt;br&gt;后门调整：&lt;br&gt;不写了&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/05/14/computer-science/computer-organization/ch2/</guid>
            <title>Ch2</title>
            <link>http://example.com/2025/05/14/computer-science/computer-organization/ch2/</link>
            <category>数据的表示与运算</category>
            <pubDate>Wed, 14 May 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Ch2-数据的表示和运算&#34;&gt;&lt;a href=&#34;#Ch2-数据的表示和运算&#34; class=&#34;headerlink&#34; title=&#34;Ch2 数据的表示和运算&#34;&gt;&lt;/a&gt;Ch2 数据的表示和运算&lt;/h1&gt;&lt;h2 id=&#34;2-1-进位计数制及其相互转换&#34;&gt;&lt;a href=&#34;#2-1-进位计数制及其相互转换&#34; class=&#34;headerlink&#34; title=&#34;2.1 进位计数制及其相互转换&#34;&gt;&lt;/a&gt;2.1 进位计数制及其相互转换&lt;/h2&gt;&lt;h3 id=&#34;2-1-1&#34;&gt;&lt;a href=&#34;#2-1-1&#34; class=&#34;headerlink&#34; title=&#34;2.1.1&#34;&gt;&lt;/a&gt;2.1.1&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;十进制二进制八进制十六进制转换&lt;ul&gt;
&lt;li&gt;略&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-1-2-定点数的编码表示&#34;&gt;&lt;a href=&#34;#2-1-2-定点数的编码表示&#34; class=&#34;headerlink&#34; title=&#34;2.1.2 定点数的编码表示&#34;&gt;&lt;/a&gt;2.1.2 定点数的编码表示&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;定点百世一般表示定点小数和定点整数，小数是符号位.xxx，整数是符号位xxxx.0&lt;/li&gt;
&lt;li&gt;&lt;blockquote&gt;
&lt;p&gt;感觉不是什么重要的东西，浮点数表示比较重要&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;原码，反码，补码&lt;ul&gt;
&lt;li&gt;正数的原码反码补码相同&lt;/li&gt;
&lt;li&gt;原码表示的范围为 $-2^n+1 ~ 2^n-1$&lt;/li&gt;
&lt;li&gt;补码表示的范围为 $-2^n ~ 2^n-1$&lt;/li&gt;
&lt;li&gt;负数的原码是1+绝对值，反码是1+绝对值取反，补码是反码+1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;移码：用来表示浮点数的阶码，只能表示整数&lt;ul&gt;
&lt;li&gt;一般用移码表示浮点数的阶码，用补码表示定点整数&lt;br&gt;$$ [x]_移 &amp;#x3D; 2^n + x $$&lt;br&gt;移码就是在真值x前面加一个offset，比如取offset为2^7，就在补码的第8位加上1&lt;/li&gt;
&lt;li&gt;比如正数10101，移码是10010101，负数-10101的补码是11101011，所以移码是01101011&lt;/li&gt;
&lt;li&gt;移码的作用是&amp;#x3D;&amp;#x3D;保持数据原有的大小顺序&amp;#x3D;&amp;#x3D;，移码大真值大，移码小真值小，所以可以直观地进行比较&lt;br&gt;:::warning&lt;br&gt;相同位数的补码和移码表示具有相同的数据表示范围，区别只是表示方法不同&lt;br&gt;补码与移码只差一个符号位。同一个数的补码和移码表示，其数值部分相同，而符号位相反。&lt;br&gt;:::&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-1-3-整数表示&#34;&gt;&lt;a href=&#34;#2-1-3-整数表示&#34; class=&#34;headerlink&#34; title=&#34;2.1.3 整数表示&#34;&gt;&lt;/a&gt;2.1.3 整数表示&lt;/h3&gt;&lt;p&gt;略&lt;/p&gt;
&lt;h3 id=&#34;2-1-4&#34;&gt;&lt;a href=&#34;#2-1-4&#34; class=&#34;headerlink&#34; title=&#34;2.1.4&#34;&gt;&lt;/a&gt;2.1.4&lt;/h3&gt;&lt;p&gt;c中的强制转换&lt;br&gt;short转成unsigned short直接把二进制看成unsigned short，比如-1变成65535&lt;br&gt;int变成short直接截断&lt;br&gt;小字长转大字长不会改变值，如果是unsigned就会在前面补0，如果是有符号数就在前面补符号位&lt;br&gt;short转unsigned int，先对short进行符号扩展到int，再把它当做unsigned int，如果是unsigned short转int，就进行零扩展再看成int……&lt;/p&gt;
&lt;p&gt;一些题目&lt;br&gt;+++info example&lt;br&gt;;;;id3 t1&lt;br&gt;若$[x]_补 &amp;#x3D; 1,x_1x_2x_3x_4x_5x_6$,其中$x_i$取0或1，若要x&amp;gt;-32，应当满足：&lt;br&gt;C. $x_1$为1，$x_2…x_6$中至少有一位为1&lt;br&gt;1100000是-32，要比-32大所以绝对值要小，所以数值部分要大，所以$x_1$必须是1,后面随便有个1就行&lt;br&gt;;;;&lt;br&gt;;;;id3 t2&lt;br&gt;设x为正数，$[x]_补 &amp;#x3D; 1,x_1x_2x_3x_4x_5$,若要x&amp;lt;-16，应当满足：&lt;br&gt;C. $x_1$必须为0，其它任意&lt;br&gt;110000是-16，要小于-16所以数值部分绝对值要小，所以只要$x_1$为0就比-16小&lt;br&gt;;;;&lt;br&gt;;;;id3 t3&lt;br&gt;一个8位的二进制整数由2个“0”和6个“1”组成，采用补码或者移码表示，则&lt;br&gt;若采用移码表示，偏置值为127，则此整数最小为-64（偏置为127需要在补码加上1111111，&amp;#x3D;&amp;#x3D;要让数值最小，应该把1放低位&amp;#x3D;&amp;#x3D;，所以移码是00111111，补码是10111111是-64）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;：前面说过，移码大真值大，移码小真值小，所以要让数值最小把1放低位就行了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;若采用补码表示，则此整数最小为-97（10011111&amp;#x3D;-97）&lt;br&gt;;;;&lt;br&gt;;;;id3 比较大小的方法&lt;br&gt;对于无符号数，数值大的数就大&lt;br&gt;对于有符号数的原码和反码比较大小：先看正负然后看数值，反码数值转成原码再比&lt;br&gt;对于补码比较大小，正数正常比较，负数数值部分越小，绝对值越大（前面1更多的数的绝对值越小，所以11111111是-1）&lt;br&gt;;;;&lt;br&gt;+++&lt;/p&gt;
&lt;h2 id=&#34;2-2-运算方法和运算电路&#34;&gt;&lt;a href=&#34;#2-2-运算方法和运算电路&#34; class=&#34;headerlink&#34; title=&#34;2.2 运算方法和运算电路&#34;&gt;&lt;/a&gt;2.2 运算方法和运算电路&lt;/h2&gt;&lt;h3 id=&#34;2-2-1-基本运算部件&#34;&gt;&lt;a href=&#34;#2-2-1-基本运算部件&#34; class=&#34;headerlink&#34; title=&#34;2.2.1 基本运算部件&#34;&gt;&lt;/a&gt;2.2.1 基本运算部件&lt;/h3&gt;&lt;h4 id=&#34;一位全加器&#34;&gt;&lt;a href=&#34;#一位全加器&#34; class=&#34;headerlink&#34; title=&#34;一位全加器&#34;&gt;&lt;/a&gt;一位全加器&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;用真值表实现的：进位C，和S&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;A&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;B&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Cin&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Cout&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;S&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;可以用卡诺图或者直接理解(王道不写还好我本来就会，差点忘了。。。)&lt;br&gt;&lt;img data-src=&#34;/img2.jpg&#34;&gt;&lt;br&gt;$$&lt;br&gt;\begin{aligned}&lt;br&gt;S &amp;amp;&amp;#x3D; \overline{A} , \overline{B} , C_i + \overline{A} , B , \overline{C_i} + A , \overline{B} , \overline{C_i} + A , B , C_i \&lt;br&gt;&amp;amp;&amp;#x3D; A \oplus B \oplus C_i&lt;br&gt;\end{aligned}&lt;br&gt;$$&lt;br&gt;$$&lt;br&gt;\begin{aligned}&lt;br&gt;Co &amp;amp;&amp;#x3D; AB + A \overline{B} C_i + \overline{A} B C_i \&lt;br&gt;&amp;amp;&amp;#x3D; AB + (A \oplus B) \cdot C_i&lt;br&gt;\end{aligned}&lt;br&gt;$$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;串行进位加法器&#34;&gt;&lt;a href=&#34;#串行进位加法器&#34; class=&#34;headerlink&#34; title=&#34;串行进位加法器&#34;&gt;&lt;/a&gt;串行进位加法器&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;把n个一位全加器连起来&lt;br&gt;&lt;img data-src=&#34;/img3.png&#34;&gt;&lt;br&gt;Carry Propagation &amp;amp; Delay&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;并行进位加法器&#34;&gt;&lt;a href=&#34;#并行进位加法器&#34; class=&#34;headerlink&#34; title=&#34;并行进位加法器&#34;&gt;&lt;/a&gt;并行进位加法器&lt;/h4&gt;&lt;p&gt;对Cin进行look ahead&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/img4.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;前面提到：&lt;br&gt;$$&lt;br&gt;\begin{aligned}&lt;br&gt;Co &amp;amp;&amp;#x3D; AB + A \overline{B} C_i + \overline{A} B C_i \&lt;br&gt;   &amp;amp;&amp;#x3D; AB + (A \oplus B) \cdot C_i&lt;br&gt;\end{aligned}&lt;br&gt;$$&lt;br&gt;下一位的Cin等于上一位的Cout，所以可以进行look ahead，这里让&lt;br&gt;$$&lt;br&gt;\begin{aligned}&lt;br&gt;G_i &amp;amp;&amp;#x3D; A_iB_i&lt;br&gt;\end{aligned}&lt;br&gt;$$&lt;br&gt;$$&lt;br&gt;\begin{aligned}&lt;br&gt;P_i &amp;amp;&amp;#x3D; A_i \oplus B_i&lt;br&gt;\end{aligned}&lt;br&gt;$$&lt;br&gt;所以&lt;br&gt;$$&lt;br&gt;\begin{aligned}&lt;br&gt;C_{i+1} &amp;amp;&amp;#x3D; G_i + P_iC_i&lt;br&gt;\end{aligned}&lt;br&gt;$$&lt;br&gt;$$&lt;br&gt;\begin{aligned}&lt;br&gt;S_i &amp;amp;&amp;#x3D; P_i \oplus C_i&lt;br&gt;\end{aligned}&lt;br&gt;$$&lt;br&gt;就能得到超前进位的效果&lt;/p&gt;
&lt;h4 id=&#34;带标志加法器&#34;&gt;&lt;a href=&#34;#带标志加法器&#34; class=&#34;headerlink&#34; title=&#34;带标志加法器&#34;&gt;&lt;/a&gt;带标志加法器&lt;/h4&gt;&lt;p&gt;&lt;img data-src=&#34;/img5.jpg&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;溢出标志 $OF &amp;#x3D; C_n  \oplus C_{n-1}$，只能判断有符号数是否溢出&lt;br&gt;-两个正数加起来变成负数或者两个负数加起来变成正数，就会溢出&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;A&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;B&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;$C_{n-1}$&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;F&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;$C_n$&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;OF&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;第二行A&amp;#x3D;0, B&amp;#x3D;0, F&amp;#x3D;1，正+正&amp;#x3D;负&lt;br&gt;  第七行A&amp;#x3D;0, B&amp;#x3D;1, F&amp;#x3D;0，负+负&amp;#x3D;正&lt;br&gt;  所以OF&amp;#x3D;1，表示有溢出&lt;br&gt;  观察发现$OF &amp;#x3D; C_{n-1}  \oplus C_n$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;符号标志 $SF &amp;#x3D; F_{n-1}$，输出的最高位决定有符号数的正负&lt;/li&gt;
&lt;li&gt;进位&amp;#x2F;借位标志：用于判断无符号数的加减运算是否溢出&lt;ul&gt;
&lt;li&gt;$CF &amp;#x3D; Cin \oplus Cout$&lt;/li&gt;
&lt;li&gt;此处的Cin和Cout表示最开始的输入和最后的输出，还没理解&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;零标志 当且仅当所有F&amp;#x3D;0时为1，否则为0（把所有F作或非）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ALU&#34;&gt;&lt;a href=&#34;#ALU&#34; class=&#34;headerlink&#34; title=&#34;ALU&#34;&gt;&lt;/a&gt;ALU&lt;/h4&gt;&lt;p&gt;略&lt;/p&gt;
&lt;h3 id=&#34;2-2-2-定点数的移位运算&#34;&gt;&lt;a href=&#34;#2-2-2-定点数的移位运算&#34; class=&#34;headerlink&#34; title=&#34;2.2.2 定点数的移位运算&#34;&gt;&lt;/a&gt;2.2.2 定点数的移位运算&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;左移一位*2，右移一位&amp;#x2F;2&lt;/li&gt;
&lt;li&gt;逻辑移位：移完直接补0&lt;ul&gt;
&lt;li&gt;无符号数若高位的1移出，则发生溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;算数移位：有符号数右移时，补符号位，左移如果高位和符号位不同，则发生溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;定点数的加减运算&#34;&gt;&lt;a href=&#34;#定点数的加减运算&#34; class=&#34;headerlink&#34; title=&#34;定点数的加减运算&#34;&gt;&lt;/a&gt;定点数的加减运算&lt;/h3&gt;&lt;p&gt;补码相加减，略&lt;br&gt;主要是溢出判断：符号相同的数相加或者符号相异的数相减会发生溢出&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一位符号位（参考前面OF）&lt;/li&gt;
&lt;li&gt;双符号位（模4补码）&lt;ul&gt;
&lt;li&gt;符号位左边那一位表示正确的符号，0为正，1为负；右边那一位如果和左边的相同，如 “00”表示正且无溢出，”11”表示负且无溢出。如果右边那一位与左边那一位不一样，则表示有溢出&lt;/li&gt;
&lt;li&gt;溢出逻辑判断：若V为0则无溢出，V为1则溢出&lt;br&gt;$$&lt;br&gt;V &amp;#x3D; S_{s1} \oplus S_{s2}&lt;br&gt;$$&lt;br&gt;例子看这篇写的挺清楚：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1bl9ib3lfYm95X3N1bi9hcnRpY2xlL2RldGFpbHMvODc5MTcwMjA=&#34;&gt;https://blog.csdn.net/sun_boy_boy_sun/article/details/87917020&lt;/span&gt;&lt;br&gt;总之两位不同则有溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;定点数的乘除运算&#34;&gt;&lt;a href=&#34;#定点数的乘除运算&#34; class=&#34;headerlink&#34; title=&#34;定点数的乘除运算&#34;&gt;&lt;/a&gt;定点数的乘除运算&lt;/h3&gt;&lt;p&gt;略，列竖式即可&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/05/13/computer-science/computer-organization/ch1/</guid>
            <title>Ch1</title>
            <link>http://example.com/2025/05/13/computer-science/computer-organization/ch1/</link>
            <category>计算机组成</category>
            <pubDate>Tue, 13 May 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;blockquote&gt;
&lt;p&gt;王道计组考研复习笔记&lt;br&gt;怕学完忘了写个笔记保留一下顺便加深印象x&lt;br&gt;王道书写得好烂、、&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;Ch1-计算机系统概述&#34;&gt;&lt;a href=&#34;#Ch1-计算机系统概述&#34; class=&#34;headerlink&#34; title=&#34;Ch1 计算机系统概述&#34;&gt;&lt;/a&gt;Ch1 计算机系统概述&lt;/h1&gt;&lt;h2 id=&#34;1-1-计算机发展历程&#34;&gt;&lt;a href=&#34;#1-1-计算机发展历程&#34; class=&#34;headerlink&#34; title=&#34;1.1 计算机发展历程&#34;&gt;&lt;/a&gt;1.1 计算机发展历程&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;四代计算机：电子管-&amp;gt;晶体管-&amp;gt;集成电路-&amp;gt;超大规模集成电路&lt;/li&gt;
&lt;li&gt;摩尔定律：集成电路上可以容纳的晶体管数目在大约每经过18个月到24个月便会增加一倍&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-2-计算机系统层次结构&#34;&gt;&lt;a href=&#34;#1-2-计算机系统层次结构&#34; class=&#34;headerlink&#34; title=&#34;1.2 计算机系统层次结构&#34;&gt;&lt;/a&gt;1.2 计算机系统层次结构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;计算机系统：硬件+软件&lt;/li&gt;
&lt;li&gt;对于某一功能，既能用软件实现又能用硬件实现，称为软、硬件在逻辑功能上是等价的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-2-2-硬件&#34;&gt;&lt;a href=&#34;#1-2-2-硬件&#34; class=&#34;headerlink&#34; title=&#34;1.2.2 硬件&#34;&gt;&lt;/a&gt;1.2.2 硬件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;冯·诺依曼机的特点：&lt;ul&gt;
&lt;li&gt;采用“存储程序”的工作方式&lt;/li&gt;
&lt;li&gt;冯·诺依曼计算机由五大部件组成：运算器、控制器、存储器、输入设备和输出设备&lt;/li&gt;
&lt;li&gt;指令和数据以同等地位存储在存储器中&lt;/li&gt;
&lt;li&gt;指令和数据均用二进制代码表示&lt;/li&gt;
&lt;li&gt;指令由操作码和地址码组成&lt;/li&gt;
&lt;li&gt;&lt;img data-src=&#34;/img1.png&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;计算机的功能部件：&lt;ul&gt;
&lt;li&gt;输入设备&lt;/li&gt;
&lt;li&gt;输出设备&lt;/li&gt;
&lt;li&gt;存储器：主存+外存&lt;ul&gt;
&lt;li&gt;CPU能直接访问的是主存&lt;/li&gt;
&lt;li&gt;&lt;img data-src=&#34;/img2.jpg&#34;&gt;&lt;/li&gt;
&lt;li&gt;MAR位10位则最多有$2^{10}$个存储单元&lt;/li&gt;
&lt;li&gt;在现代计算机中MAR和MDR存在CPU中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;运算器：进行算术运算和逻辑运算&lt;ul&gt;
&lt;li&gt;核心是ALU：通用寄存器有&amp;#x3D;&amp;#x3D;累加器(ACC)，乘商寄存器(MQ)，操作数寄存器(X)&amp;#x3D;&amp;#x3D;，变址寄存器(IX)，基址寄存器(BR)等，前三个必备&lt;/li&gt;
&lt;li&gt;程序状态寄存器(PSW)&lt;/li&gt;
&lt;li&gt;&lt;img data-src=&#34;/img3.jpg&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;控制器：由PC, IR和control unit组成&lt;ul&gt;
&lt;li&gt;: RISCV控制器&lt;/li&gt;
&lt;li&gt;&lt;img data-src=&#34;/img4.png&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CPU由运算器、控制器和cache组成&lt;/li&gt;
&lt;li&gt;总线有地址总线、数据总线、控制总线&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-2-3-软件&#34;&gt;&lt;a href=&#34;#1-2-3-软件&#34; class=&#34;headerlink&#34; title=&#34;1.2.3 软件&#34;&gt;&lt;/a&gt;1.2.3 软件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;组成：系统软件(OS, DBMS, 编译器, …)+应用软件&lt;/li&gt;
&lt;li&gt;语言：汇编语言、机器语言、高级语言&lt;ul&gt;
&lt;li&gt;汇编器：把汇编语言翻译成机器语言&lt;/li&gt;
&lt;li&gt;编译器：把高级语言翻译成汇编语言或机器语言&lt;/li&gt;
&lt;li&gt;解释器：把高级语言翻译成&amp;#x3D;&amp;#x3D;机器语言&amp;#x3D;&amp;#x3D;(比如python)&lt;br&gt;  +++info example&lt;br&gt;  ;;;id3 题目&lt;br&gt;  :chestnut:&lt;br&gt;  将高级语言源程序转换为机器级目标代码文件的程序是 []。&lt;br&gt;  A. 汇编程序&lt;br&gt;  B. 链接程序&lt;br&gt;  C. 编译程序&lt;br&gt;  D. 解释程序&lt;br&gt;  ;;;&lt;br&gt;  ;;;id3 答案&lt;br&gt;  C. 编译程序&lt;br&gt;  因为解释程序不生成目标代码，编译器可以把高级语言翻译成汇编语言或者直接翻译成机器语言&lt;br&gt;  ;;;&lt;br&gt;  +++&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-2-4-计算机系统的层次结构&#34;&gt;&lt;a href=&#34;#1-2-4-计算机系统的层次结构&#34; class=&#34;headerlink&#34; title=&#34;1.2.4 计算机系统的层次结构&#34;&gt;&lt;/a&gt;1.2.4 计算机系统的层次结构&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;看看就好&lt;/li&gt;
&lt;li&gt;&lt;img data-src=&#34;/img5.png&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-2-5-计算机系统的工作原理&#34;&gt;&lt;a href=&#34;#1-2-5-计算机系统的工作原理&#34; class=&#34;headerlink&#34; title=&#34;1.2.5 计算机系统的工作原理&#34;&gt;&lt;/a&gt;1.2.5 计算机系统的工作原理&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;程序执行前，需要把所含的指令和数据一起放入主存中&lt;/li&gt;
&lt;li&gt;五个阶段：IF-ID-EX-MEM-WB&lt;/li&gt;
&lt;li&gt;c程序怎么变成可执行文件的：直接看图&lt;ul&gt;
&lt;li&gt;&lt;img data-src=&#34;/img6.png&#34;&gt;&lt;/li&gt;
&lt;li&gt;汇编器把指令打包成可重定位目标代码文件：使用相对地址和符号引用来表示各个代码段之间的关系（代码段、数据段、符号表、重定位表…）使得代码或数据能在内存中任意位置加载或运行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;指令执行过程：后面几章会具体讲&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-3-计算机的性能指标&#34;&gt;&lt;a href=&#34;#1-3-计算机的性能指标&#34; class=&#34;headerlink&#34; title=&#34;1.3 计算机的性能指标&#34;&gt;&lt;/a&gt;1.3 计算机的性能指标&lt;/h2&gt;&lt;h3 id=&#34;1-3-1-主要性能指标&#34;&gt;&lt;a href=&#34;#1-3-1-主要性能指标&#34; class=&#34;headerlink&#34; title=&#34;1.3.1 主要性能指标&#34;&gt;&lt;/a&gt;1.3.1 主要性能指标&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;字长：一次整数运算所能处理的二进制数据的位数&lt;br&gt; :::info&lt;br&gt; 机器字长、指令字长和存储字长&lt;br&gt; :::&lt;/li&gt;
&lt;li&gt;带宽&lt;code&gt;bandwidth&lt;/code&gt;：总线一次能并行传送信息的位数&lt;/li&gt;
&lt;li&gt;主存容量&lt;/li&gt;
&lt;li&gt;运算速度&lt;ul&gt;
&lt;li&gt;吞吐量&lt;code&gt;throughput&lt;/code&gt;：一次输入数据所对应的输出数据个数&lt;/li&gt;
&lt;li&gt;响应时间&lt;code&gt;Response (Execution) time&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;主频&lt;/li&gt;
&lt;li&gt;clock cycle time( &amp;#x3D; 1&amp;#x2F;CPU frequency)&lt;/li&gt;
&lt;li&gt;MIPS: million instructions per second&lt;/li&gt;
&lt;li&gt;FLOPS: floating-point operations per second&lt;blockquote&gt;
&lt;p&gt;CPI: clock cycles per instruction(IPC: CPI的倒数)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$ \begin{aligned}&lt;br&gt;    \text{CPU execution time} &amp;amp;&amp;#x3D; \text{CPU clock cycles} \times \text{Clock cycle time} \&lt;br&gt;    &amp;amp;&amp;#x3D; \frac{\text{CPU clock cycles}}{\text{Clock rate}}&lt;br&gt;\end{aligned}$$&lt;/p&gt;
&lt;p&gt;$$\begin{aligned}&lt;br&gt;    \text{CPU clock cycles} &amp;amp;&amp;#x3D; \text{Instructions count} \times \text{Average cycles per instruction}&lt;br&gt;\end{aligned}$$&lt;/p&gt;
&lt;p&gt;$$\begin{aligned}&lt;br&gt;    \text{CPU execution time} &amp;amp;&amp;#x3D; \text{CPU clock cycles} \times \text{Clock cycle time} \&lt;br&gt;    &amp;amp;&amp;#x3D; \frac{\text{CPU clock cycles}}{\text{Clock rate}}&lt;br&gt;\end{aligned} $$&lt;/p&gt;
&lt;p&gt;$$ \begin{aligned}&lt;br&gt;     \text{performance} &amp;amp;&amp;#x3D; \frac{1}{\text{CPU execution time}}&lt;br&gt;\end{aligned}$$&lt;/p&gt;
&lt;p&gt;“Processor X is n times fast than Y” is&lt;br&gt;$$ \begin{aligned}&lt;br&gt;    \text{n} &amp;amp;&amp;#x3D; \frac{\text{CPU execution time of Y}}{\text{CPU execution time of X}}&lt;br&gt;\end{aligned}$$&lt;/p&gt;
&lt;p&gt;IPS: instructions per second&lt;br&gt;$$ \begin{aligned}&lt;br&gt;    \text{IPS} &amp;amp;&amp;#x3D; \frac{\text{CPU frequency}}{\text{CPI}}&lt;br&gt;        &amp;amp;&amp;#x3D; \frac{1}{\text{CPU clock cycles} \times \text{CPU execution time}}&lt;br&gt;\end{aligned}$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其他公式，，，用到再说吧&lt;/li&gt;
&lt;li&gt;兼容：软件或硬件的通用性&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在用于科学计算的计算机中，标志系统性能最有用的参数是浮点数运算相关的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MFLOPS 10^6&lt;/li&gt;
&lt;li&gt;GFLOPS 10^9&lt;/li&gt;
&lt;li&gt;TFLOPS 10^12&lt;/li&gt;
&lt;li&gt;PFLOPS 10^15&lt;/li&gt;
&lt;li&gt;EFLOPS 10^18&lt;/li&gt;
&lt;li&gt;ZFLOPS 10^21&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/05/13/computer-science/computer-network/ch1/</guid>
            <title>Ch1</title>
            <link>http://example.com/2025/05/13/computer-science/computer-network/ch1/</link>
            <category>计算机网络</category>
            <pubDate>Tue, 13 May 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[  ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/03/29/computer-science/compile-principles/ch4/</guid>
            <title>Ch4</title>
            <link>http://example.com/2025/03/29/computer-science/compile-principles/ch4/</link>
            <category>抽象语法</category>
            <pubDate>Sat, 29 Mar 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[  ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/03/23/computer-science/compile-principles/ch3/</guid>
            <title>Ch3</title>
            <link>http://example.com/2025/03/23/computer-science/compile-principles/ch3/</link>
            <category>语法分析</category>
            <pubDate>Sun, 23 Mar 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;语法分析&#34;&gt;&lt;a href=&#34;#语法分析&#34; class=&#34;headerlink&#34; title=&#34;语法分析&#34;&gt;&lt;/a&gt;语法分析&lt;/h1&gt;&lt;h2 id=&#34;CFG&#34;&gt;&lt;a href=&#34;#CFG&#34; class=&#34;headerlink&#34; title=&#34;CFG&#34;&gt;&lt;/a&gt;CFG&lt;/h2&gt;&lt;p&gt;见计算理论&lt;br&gt;Parse tree&lt;/p&gt;
&lt;h3 id=&#34;Ambiguous-grammars&#34;&gt;&lt;a href=&#34;#Ambiguous-grammars&#34; class=&#34;headerlink&#34; title=&#34;Ambiguous grammars&#34;&gt;&lt;/a&gt;Ambiguous grammars&lt;/h3&gt;&lt;h2 id&gt;&lt;a href=&#34;#&#34; class=&#34;headerlink&#34; title&gt;&lt;/a&gt;&lt;/h2&gt; ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/03/22/computer-science/compile-principles/ch2/</guid>
            <title>Ch2</title>
            <link>http://example.com/2025/03/22/computer-science/compile-principles/ch2/</link>
            <category>词法分析</category>
            <pubDate>Sat, 22 Mar 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Ch2-词法分析&#34;&gt;&lt;a href=&#34;#Ch2-词法分析&#34; class=&#34;headerlink&#34; title=&#34;Ch2 词法分析&#34;&gt;&lt;/a&gt;Ch2 词法分析&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;把input分解成一个个token&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;Regular-Expression&#34;&gt;&lt;a href=&#34;#Regular-Expression&#34; class=&#34;headerlink&#34; title=&#34;Regular Expression&#34;&gt;&lt;/a&gt;Regular Expression&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Language: a set of strings&lt;/li&gt;
&lt;li&gt;String: a finite sequence of characters&lt;blockquote&gt;
&lt;p&gt;Regular Experssion Notations:&lt;br&gt;&lt;img data-src=&#34;/image-1.png&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;:::info&lt;br&gt;DFA, NFA相关 见计算理论&lt;br&gt;:::&lt;/p&gt;
&lt;h2 id=&#34;RE转NFA&#34;&gt;&lt;a href=&#34;#RE转NFA&#34; class=&#34;headerlink&#34; title=&#34;RE转NFA&#34;&gt;&lt;/a&gt;RE转NFA&lt;/h2&gt;&lt;p&gt;:::info 方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;画出初始态和终态&lt;/li&gt;
&lt;li&gt;分裂规则：&lt;br&gt;&lt;img data-src=&#34;/image-2.jpg&#34;&gt;&lt;br&gt;:::&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;NFA转DFA&#34;&gt;&lt;a href=&#34;#NFA转DFA&#34; class=&#34;headerlink&#34; title=&#34;NFA转DFA&#34;&gt;&lt;/a&gt;NFA转DFA&lt;/h2&gt;&lt;p&gt;从初始状态的闭包开始，每次根据\epsilon和当前状态的闭包，得到下一个状态的闭包，直到得到终态的闭包。&lt;/p&gt;
&lt;p&gt;+++info example&lt;br&gt;;;;id3 题目&lt;br&gt;:chestnut:&lt;br&gt;把这个NFA转成等价的DFA&lt;br&gt;&lt;img data-src=&#34;/image-3.png&#34;&gt;&lt;br&gt;;;;&lt;br&gt;;;;id3 答案&lt;br&gt;初态的闭包是1、2、6，1、2、6经过a可以转移到3、7，因为有\epsilon转移，所以3、7的闭包是3、4、7、8，同理3、4、7、8经过b可以到5、8，由于8是终态，把所有包含8的圆圈画成终态的环。&lt;br&gt;&lt;img data-src=&#34;/image-4.png&#34;&gt;&lt;br&gt;;;;&lt;br&gt;+++&lt;/p&gt;
&lt;h2 id=&#34;最小化DFA&#34;&gt;&lt;a href=&#34;#最小化DFA&#34; class=&#34;headerlink&#34; title=&#34;最小化DFA&#34;&gt;&lt;/a&gt;最小化DFA&lt;/h2&gt;&lt;p&gt;含义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;没有多余状态：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;从这个状态没有通路到达终态&lt;/li&gt;
&lt;li&gt;从开始状态出发，任何输入串也不能到达的那个状态&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;没有两个状态相互等价&lt;br&gt;:::info 方法：&lt;/li&gt;
&lt;li&gt;多余状态直接删除&lt;br&gt;&lt;img data-src=&#34;/image-5.png&#34;&gt;&lt;/li&gt;
&lt;li&gt;合并等价状态&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;将状态分为终态和非终态两个集合&lt;/li&gt;
&lt;li&gt;遍历每个集合，如果经过转换到达的状态都在当前集合里，则不用分，否则划分子集，直到划分不了为止&lt;/li&gt;
&lt;li&gt;:chestnut: 例子&lt;/li&gt;
&lt;li&gt;&lt;img data-src=&#34;/image-6.png&#34;&gt;&lt;br&gt;:::&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/03/21/computer-science/compile-principles/ch1/</guid>
            <title>Ch1</title>
            <link>http://example.com/2025/03/21/computer-science/compile-principles/ch1/</link>
            <category>编译原理</category>
            <pubDate>Fri, 21 Mar 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;blockquote&gt;
&lt;p&gt;ZJU 2025春夏编译原理 学习笔记&lt;/p&gt;
&lt;p&gt;主要基于虎书（&lt;em&gt;Modern Compiler Implementation in C&lt;/em&gt;, Andrew W. Appel）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;CH1-Introduction&#34;&gt;&lt;a href=&#34;#CH1-Introduction&#34; class=&#34;headerlink&#34; title=&#34;CH1 Introduction&#34;&gt;&lt;/a&gt;CH1 Introduction&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Two Important Concepts&lt;ul&gt;
&lt;li&gt;Phases（阶段）&lt;/li&gt;
&lt;li&gt;Interfaces（接口）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方框里的是phase，中间的是interface&lt;br&gt;&lt;img data-src=&#34;/image.png&#34;&gt;&lt;br&gt;各个阶段的描述&lt;br&gt;&lt;img data-src=&#34;/image-1.png&#34;&gt;&lt;img data-src=&#34;/image-2.png&#34;&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/03/21/computer-science/compile-principles/ch5/</guid>
            <title>Ch5</title>
            <link>http://example.com/2025/03/21/computer-science/compile-principles/ch5/</link>
            <category>语义分析</category>
            <pubDate>Fri, 21 Mar 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;语义分析&#34;&gt;&lt;a href=&#34;#语义分析&#34; class=&#34;headerlink&#34; title=&#34;语义分析&#34;&gt;&lt;/a&gt;语义分析&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;绑定，类型检查&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;symbol-table&#34;&gt;&lt;a href=&#34;#symbol-table&#34; class=&#34;headerlink&#34; title=&#34;symbol table&#34;&gt;&lt;/a&gt;symbol table&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Functional style: 函数式风格&lt;ul&gt;
&lt;li&gt;To keep $\sigma_1$ in pristine condition while creating create $\sigma_2$ and $\sigma_3$&lt;br&gt;:::info 方法：&lt;br&gt;persistent BST&lt;br&gt;:::&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Imperative style: 命令式风格&lt;ul&gt;
&lt;li&gt;Modify $\sigma_1$ until it becomes $\sigma_2$. &lt;/li&gt;
&lt;li&gt;While $\sigma_2$ exists, we cannot look things up in $\sigma_1$. &lt;/li&gt;
&lt;li&gt;When done with $\sigma_2$, can undo the modification to get $\sigma_1$ back again.&lt;br&gt;:::info 方法：&lt;br&gt;Hashing&lt;br&gt;:::&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
    </channel>
</rss>
